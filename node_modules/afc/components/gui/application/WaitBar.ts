namespace AFC.gui {
    const _control = Symbol();

    export function parseOptions<T = any>(value: string, defaultOptions: T): Partial<T> {
        let matches: IterableIterator<RegExpMatchArray> = value?.matchAll(/([^:;]+):([^:;]+)(?:;|$)/g),
            options: { [key: string]: any };

        if (matches) {
            options = {};
            for (let [, key, value] of matches) {
                try {
                    if (defaultOptions.hasOwnProperty(key = key.trim())) {
                        options[key] = AFC.Tools.Data.isString((<any>defaultOptions)[key]) ? value.trim() : JSON.parse(value);
                    }
                } catch (e) {
                }
            }
            return <Partial<T>>options;
        }
    }

    export class AfcGuiWaitBar extends AfcGuiElement {
        /** @internal */
        protected [_control]: AFC.Controls.WaitBar;
        public readonly adapter: AFC.Globals.WaitAdapter;

        constructor() {
            super();
            this.adapter = new AFC.Globals.WaitAdapter({
                waitBar: this[_control] = new AFC.Controls.WaitBar(this)
            });
        }
        
        protected override _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void {
            let options = this.id && this[_control].options;
            if (options) {
                savedInstanceState.putValue(`${this.id}|options`, options);
            }            
        }

        protected override _onRestoreViewState(context: Application.Context, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void {
            let options = (this.id && savedInstanceState?.getValue(`${this.id}|options`)) || parseOptions(this.getAttribute('options'), Controls.WaitBar.defaultOptions);
            
            options && this.setOptions(options);
            this.adapter.register();
        }
        
        public setOptions(options: Partial<Controls.ISpinnerAnimationOptions>): void {
            this[_control].options = options;
        }

        public disconnectedCallback(): void {
            this.adapter.unregister();
        }
    }

    export class AfcGuiProgressBar extends AfcGuiElement {
        /** @internal */
        protected [_control]: AFC.Controls.ProgressBar;
        public readonly adapter: AFC.Globals.WaitAdapter;

        constructor() {
            super();
            this.adapter = new AFC.Globals.WaitAdapter({
                progressBar: this[_control] = new AFC.Controls.ProgressBar(this)
            });
        }

        public connectedCallback(): void {
            this.adapter.dummyEnabled = this.getAttribute("enable-dummy") !== null;
            this.adapter.register();
        }
        
        public disconnectedCallback(): void {
            this.adapter.unregister();
        }
    }
    
    registerElement("afc-gui-wait-bar", AfcGuiWaitBar);
    registerElement("afc-gui-progress-bar", AfcGuiProgressBar);
}