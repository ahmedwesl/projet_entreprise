/**
 * Created by jean.rennes on 14/05/2019.
 */
///<reference path="../Globals.ts" /> 

namespace AFC.gui {
    function _computeValue(control: AfcRatingControl, value: number): number {
        let ratio = control.allowHalf ? 2 : 1;
        return Math.ceil(ratio * value) / ratio;
    }

    function _setWidth(control: AfcRatingControl, child: HTMLElement, value: number): void {
        child.style.width = value ? `${Math.min(value, control.maxValue) * 100 / control.maxValue}%` : '0';
    }

    function _setValue(control: AfcRatingControl, value: number, highlight?: number): void {
        let child0 = <HTMLElement>control.children[0];

        if (child0) {
            let child1 = <HTMLElement>child0.children[0],
                child2 = <HTMLElement>child0.children[1],
                child3 = <HTMLElement>child0.children[2],
                value1 = 0,
                value2 = 0,
                value3 = 0;

            if (highlight !== void 0) {
                if (highlight > value) {
                    value3 = value;
                    value1 = highlight;
                }
                else if (highlight < value) {
                    value3 = highlight;
                    value2 = value;
                }
                else {
                    value2 = value;
                }
            } else {
                value3 = value;
            }
            _setWidth(control, child1, value1);
            _setWidth(control, child2, value2);
            _setWidth(control, child3, value3);
        }
    }

    function _getValue(control: AfcRatingControl, event: MouseEvent) {
        let query = $(control),
            width = query.children('div').width();
        return (event.pageX - query.offset().left) * control.maxValue / width;
    }

    const _value = Symbol(),
          _maxValue = Symbol(),
          _allowHalf = Symbol(),
          _timeout = Symbol(),
          _disabled = Symbol(),
          _generate = Symbol();
          
          
    export class AfcRatingControl extends AfcGuiElement {
        /** @internal */
        private [_value]: number;
        /** @internal */
        private [_maxValue]: number;
        /** @internal */
        private [_allowHalf]: boolean;
        /** @internal */
        private [_disabled]: boolean;
        /** @internal */
        private [_timeout]: number;

        public static observedAttributes = AfcGuiElement.observedAttributes.concat(['value', 'max-value', 'allow-half', 'disabled']);
        
        /** @internal */
        private [_generate](): void {
            (this[_timeout] !== void 0) || (this[_timeout] = setTimeout(() => {
                let query = $(this),
                    maxValue = this.maxValue,
                    control0 = document.createElement('div'),
                    control1 = document.createElement('div');

                query.empty();
                control0.appendChild(document.createTextNode(String.fromCharCode(0x2606).repeat(maxValue)));
                control1.appendChild(document.createTextNode(String.fromCharCode(0x2605).repeat(maxValue)));
                this.appendChild(control0);
                control0.appendChild(control0.cloneNode(true));
                control0.appendChild(control1);
                control0.appendChild(control1.cloneNode(true));
                _setValue(this, this.value);
                delete this[_timeout];
            }, 0));
        }
             
        constructor() {
            super();
            this[_value] = 0;
            this[_maxValue] = 3;
            this[_allowHalf] = false;
            this.addEventListener('pointerup', (event: PointerEvent) => {
                if (!this[_disabled]) {
                    let value = _computeValue(this, _getValue(this, event));

                    this.value = value === this.value ? 0 : value;
                    _setValue(this, this.value, value);
                    gui._dispatchEvent(this, 'change', {detail: this.value});
                }
            }, true);
            this.addEventListener('pointermove', (event: PointerEvent) => this[_disabled] || _setValue(this, this.value, _computeValue(this, _getValue(this, event))));
            this.addEventListener('pointerleave', (/*event: PointerEvent*/) => this[_disabled] || _setValue(this, this.value));
            this[_generate]();
        }

        protected override _onRestoreViewState(activity: Application.RestActivity, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void {
            const id = savedInstanceState && this.id;
            if (id) {
                this.value = savedInstanceState.getValue(id);
            }
        }
        
        protected override _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void {
            const id = this.id;
            id && savedInstanceState.putValue(id, this.value);
            super._onSaveInstanceState(context, savedInstanceState);
        }
                
        public get value(): number {
            return this[_value];
        }
        
        public set value(value: number) {
            if ((value = _computeValue(this, value)) !== this[_value]) {
                _setValue(this, this[_value] = value);
            }
        }

        public get maxValue(): number {
            return this[_maxValue];
        }
        
        public set maxValue(value: number) {
            if ((this[_maxValue] !== value)) {
                this[_maxValue] = Math.max(1, value);
                this[_generate]();
            }
        }

        public get allowHalf(): boolean {
            return this[_allowHalf];
        }
        
        public set allowHalf(value: boolean) {
            let v = !value;
            (this[_allowHalf] === v) && !(this[_allowHalf] = !v) && (this.value = this[_value]);
        }
        
        public get disabled(): boolean {
            return this[_disabled];
        }
        
        public set disabled(value: boolean) {
            (this[_disabled] = !!value) && _setValue(this, this[_value]);
        }
        
        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            let value: number;
            
            switch(attrName) {
                case 'value':
                    isFinite(value = parseFloat(newVal)) && (this.value = value);
                    break;
                case 'max-value':
                    isFinite(value = parseFloat(newVal)) && (this.maxValue = value);
                    break;
                case 'allow-half':
                    this.allowHalf = newVal !== null;
                    break;
                case 'disabled':
                    this.disabled = newVal !== null;
                    break;
                default:
                    super.attributeChangedCallback(attrName, oldVal, newVal);
                    break;
            }
        }
    }

    registerElement("afc-gui-rating-control", AfcRatingControl);
}