/**
 * Created by jean.rennes on 18/01/2017.
 */
///<reference path="../../models/globals/Global.ts" />
///<reference path="../Globals.ts" />
///<reference path="../../helpers/Data.ts" />

namespace AFC.gui {
    export interface IEventLayerInfo<K extends Globals.DrawableLayerType = Globals.DrawableLayerType, M extends Globals.IMapLayerModel<K> = Globals.IMapLayerModel<K>> extends Globals.IEventLayerInfo<K> {
        readonly provider: ILayerProviderElement<M>;
    }
    
    export type IMapEventHandlers = {
        [K in keyof Globals.IMapEventHandlers]: Parameters<Globals.IMapEventHandlers[K]>[0] extends L.LeafletMouseEvent ?
            (latLng: L.LatLng, info: IEventLayerInfo, event: Parameters<Globals.IMapEventHandlers[K]>[0])=> boolean:
            (event: Parameters<Globals.IMapEventHandlers[K]>[0], info: IEventLayerInfo)=> boolean;
    }

    export interface ILayer<T extends Globals.IMapLayerModel = Globals.IMapLayerModel> {
        readonly id: string;
        readonly layerModel: T | null;
    }
    
    export interface IBaseLayerProvider<T extends Globals.IMapLayerModel = Globals.IMapLayerModel> {
        readonly name: string;
        readonly filterable?: boolean;
        getLayer(): Promise<Readonly<ILayer<T>>>;
    }
    
    export interface ILayerProvider<T extends Globals.IMapLayerModel = Globals.IMapLayerModel> extends IBaseLayerProvider<T>, Data.IFilterable<Globals.IMapLayerModelData> {
        readonly filterable: true;
        refresh(): void;
    };
      
    export interface ILayerProviderInfo {
        grayLevelsEnabled?: boolean;
        grayLevelsRaster?: boolean;   // simplification of existing mecanism: flags which indicate if gray levels of raster layer is enabled, to be removed someday ?
        provider: Globals.IRasterProvider;
    }
    
    export interface ILayerProviderElement<T extends Globals.IMapLayerModel = Globals.IMapLayerModel> extends HTMLElement {
        readonly handlers?: gui.IMapEventHandlers;
        readonly getBbox?: ()=> Promise<Tools.Geometry.Rectangle>;
        getCount(): number;
        getLayerProvider(indice: number): IBaseLayerProvider<T>;
        getInfo(): Promise<Readonly<ILayerProviderInfo>>;
    }
          
    export type ILayerSavedState = Partial<Pick<MapLayerProvider, 'hidden' | 'filter' | 'options' | 'clusteringMaxZoom' | 'clustering' | 'minZ'>>;
        
    export type IMapLayerProviderFilter = (row: ReadonlyArray<any>, dataModel: Globals.IMapLayerModelData) => boolean;
    
    interface IMapLayerProviderDescriptor {
        readonly name: string;
    }
    
    const _configuration = Symbol(),
        _dataModel = Symbol();
    
    export abstract class MapLayerProvider<T extends Globals.IMapLayerModel = Globals.IMapLayerModel, D extends IMapLayerProviderDescriptor = IMapLayerProviderDescriptor> extends Tools.EventSink implements ILayerProvider<T> {
        protected _sequence: Symbol;
        protected _layerModel: T;
        protected readonly [_configuration]: ILayerSavedState;
        public readonly id: string;
        public readonly descriptor: D;
        public readonly filterable: true;
        public abstract type: Globals.LayerType;
        
        
        constructor(id: string, descriptor: D, configuration?: ILayerSavedState) {
            super();
            this.id = id;
            this.descriptor = descriptor;
            this.filterable = true;
            this[_configuration] = configuration || {};
        }
        
        protected abstract _getLayerModel(): Promise<T>;
        
        public get name(): string {
            return this.descriptor.name;
        }
        
        public set hidden(value: boolean) {
            this[_configuration].hidden = value;
            this._layerModel && (this._layerModel.hidden = value);
        }

        public get hidden(): boolean {
            return this[_configuration].hidden ?? this._layerModel?.hidden;
        }
                
        public set clusteringMaxZoom(value: number) {
            this[_configuration].clusteringMaxZoom = value;
            this._layerModel && (this._layerModel.clusteringMaxZoom = value);
        }

        public get clusteringMaxZoom(): number {
            return this[_configuration].clusteringMaxZoom ?? this._layerModel?.clusteringMaxZoom;
        }
                
        public set clustering(value: boolean) {
            this[_configuration].clustering = value;
            this._layerModel && (this._layerModel.clustering = value);
        }

        public get clustering(): boolean {
            return this[_configuration].clustering ?? this._layerModel?.clustering;
        }

        public set filter(value: IMapLayerProviderFilter) {
            this[_configuration].filter = value;
            this._layerModel && (this._layerModel.data.filter = value);
        }
        
        public get filter(): IMapLayerProviderFilter {
            return this[_configuration].filter;
        }
        
        public set options(value: Globals.GeoJSONOptionOverrides) {
            this[_configuration].options = value;
            this._layerModel && (this._layerModel.options = value);
        }
        
        public get options(): Globals.GeoJSONOptionOverrides {
            return this[_configuration].options ?? this._layerModel?.options;
        }
                
        public set minZ(value: number) {
            this[_configuration].minZ = value;
            this._layerModel && (this._layerModel.minZ = value);
        }
        
        public get minZ(): number {
            return this[_configuration].minZ ?? this._layerModel?.minZ;
        }
                
        public refresh(): void {
            let filter = this.filter;
            this.filter = null;
            this.filter = filter;
        }
        
        public async getLayer(): Promise<Readonly<ILayer<T>>> {
            let layerModel = this._layerModel;

            if (layerModel === void 0) {
                layerModel = await new Promise(async (resolve, reject) => {
                    let sequence = this._sequence;
                    
                    this.notify(Tools.EventType.UserEvent, () => sequence === this._sequence ? resolve(this._layerModel):reject());
                    if (!sequence) {
                        sequence = this._sequence = Symbol();
                            
                        if (Globals.isVectorLayer(this)) {
                            let layerModel: T = this._layerModel = await this._getLayerModel();
                            layerModel.hidden = this.hidden;
                            layerModel.clustering = this.clustering;
                            layerModel.clusteringMaxZoom = this.clusteringMaxZoom;
                            layerModel.data.filter = this.filter;
                            layerModel.options = this.options;
                            layerModel.minZ = this.minZ;
                        } else {
                            this._layerModel = null;
                        }
                        this.fireEvent(Tools.EventType.UserEvent);
                    }
                });
            }
            return { id: this.id, layerModel: layerModel };
        }
    }
    
    abstract class GlobalLayerProvider<T extends Globals.IMapLayerModel> extends MapLayerProvider<T, Globals.MapLayerDescriptor> {
        constructor(descriptor: Globals.MapLayerDescriptor, configuration?: ILayerSavedState) {
            super(descriptor.id, descriptor, configuration);
        }
        
        public override get type(): Globals.LayerType {
            return this.descriptor.type;
        }
        
        public async getDrawingInfo<D extends Globals.IMapLayerMetaData = Globals.IMapLayerMetaData>(): Promise<Globals.IMapLayerDrawingInfo<D>> {
            let descriptor = this.descriptor,
                [map, layer, thematics] = await Promise.all([descriptor.mapView.getMetadata(), descriptor.getMetadata<D>(), this.getLegendData()]);;
            return {
                descriptor: descriptor,
                map: map,
                layer: layer,
                thematics: thematics
            };
        }
        
        public async getLegendData(): Promise<Globals.ILayerLegendData> {
            return this.descriptor.getLegendData();
        }        
    }
    
    type ITileLayerProviderData = AFC.Globals.TileVectorModel<AFC.Globals.DrawableLayerType, AFC.Globals.ITileLayerProviderImpl<AFC.Globals.DrawableLayerType>>;
    
    export class TileLayerProvider extends GlobalLayerProvider<Globals.IMapLayerTiledModelImpl> {
        constructor(descriptor: Globals.MapLayerDescriptor, configuration: ILayerSavedState, dataModel?: ITileLayerProviderData) {
            super(descriptor, configuration);
            this[_dataModel] = dataModel;
        }
        
        protected override async _getLayerModel(): Promise<Globals.IMapLayerTiledModelImpl> {
            let drawingInfo: Readonly<Globals.IMapLayerDrawingInfo<Globals.IMapVectorLayerMetaData>> = await this.getDrawingInfo();
            return Globals.mapLayerTiledModel(this.descriptor, drawingInfo.layer, drawingInfo.thematics, this[_dataModel]);
        }
        
        /** @internal */
        private [_dataModel]: ITileLayerProviderData;        
    }
        
    export class StaticLayerProvider extends GlobalLayerProvider<Globals.IMapLayerStaticModel> {
        constructor(descriptor: Globals.MapLayerDescriptor, configuration: ILayerSavedState, dataModel?: Data.IRowCollection & Data.IKeyProvider) {
            super(descriptor, configuration);
            this[_dataModel] = dataModel;
        }
        
        protected override async _getLayerModel(): Promise<Globals.IMapLayerStaticModel> {
            let descriptor = this.descriptor,
                drawingInfo = await this.getDrawingInfo<Globals.IMapVectorLayerMetaData>(),
                dataModel = this[_dataModel] || (await descriptor.getContent()).table;
            return new Globals.MapLayerStaticModel(drawingInfo.layer, dataModel, drawingInfo.thematics);
        }
        
        /** @internal */
        private [_dataModel]: Data.IRowCollection & Data.IKeyProvider;        
    }
    
    export function getProviderInfoFromMapMetadata(metadata: Readonly<Globals.IMapViewMetadata>): Promise<ILayerProviderInfo> {
        let raster = metadata && metadata.layers.find(layer => layer.type === Globals.LayerType.raster);
        return raster && raster.getMetadata<Globals.IMapRasterLayerMetaData>().then(metadata => metadata && {
            grayLevelsEnabled: metadata.grayLevels,
            grayLevelsRaster: metadata.grayLevels,
            provider: metadata.provider
        });
    }

    export const enum LayerDataMode {
        none = 0,
        static,
        tiled 
    }
    const LayerDataModeLookup: {[key: string]: LayerDataMode} = {
        none: LayerDataMode.none,
        static: LayerDataMode.static,
        tiled: LayerDataMode.tiled 
    };

    const _rest = Symbol(),
        _sequence = Symbol(),
        _layerProvider = Symbol(),
        _onDirty = Symbol(),
        _state = Symbol(),
        _bindTo = Symbol();

    interface ISavedState {
        mapView: string;
        name: string;
        mode: LayerDataMode;
        model: ITileLayerProviderData | (Data.IRowCollection & Data.IKeyProvider);
        layer: ILayerSavedState;
    }

    export class AfcGuiLayer extends AfcGuiElement implements ILayerProviderElement {
        /** @internal */
        private [_rest]: Rest.RestModel;
        /** @internal */
        private [_sequence]: Symbol;
        /** @internal */
        private [_layerProvider]?: GlobalLayerProvider<Globals.IMapLayerModel>;
        /** @internal */
        private [_dataModel]: Data.IRowCollection & Data.IKeyProvider;
        /** @internal */
        private [_state]: Partial<ISavedState> = {mode: LayerDataMode.none, layer: {}};
        
        public static observedAttributes = AfcGuiElement.observedAttributes.concat(['template', 'filter', 'no-clustering', 'clustering-max-zoom', 'mode']);
        public handlers: gui.IMapEventHandlers;

        /** @internal */
        private [_onDirty](/*event: Tools.IEvent*/): void {
            _dispatchEvent(this, 'layersChange');
        }

        /** @internal */
        private async [_bindTo](): Promise<void> {
            let rest: Rest.RestModel = this[_rest],
                layerProvider = this[_layerProvider],
                dataModel: Data.IRowCollection & Data.IKeyProvider,
                sequence = this[_sequence] = Symbol();
            
            delete this[_layerProvider];
            if (rest && (this.mode !== LayerDataMode.none || (dataModel = this[_dataModel]))) {
                let state = this[_state],
                    mapView: Globals.MapViewDescriptor = Tools.findByIdOrName<Globals.MapViewDescriptor>(state.mapView, await rest.globals.getMapViews()),
                    mapViewMetadata: Readonly<Globals.IMapViewMetadata> = mapView && await mapView.getMetadata(),
                    descriptor = mapViewMetadata && Tools.findByIdOrName<Globals.MapLayerDescriptor>(state.name, mapViewMetadata.layers);

                if (descriptor) {
                    this[_layerProvider] = this.mode === LayerDataMode.tiled ?
                        new TileLayerProvider(descriptor, state.layer):
                        new StaticLayerProvider(descriptor, state.layer, dataModel);
                }
            }
            layerProvider !== this[_layerProvider] && sequence === this[_sequence] && this[_onDirty]();
        }

        protected override _setHide(bHide: boolean): void {
            this._setMute(bHide);
            this[_state].layer.hidden = bHide;
            if (this[_layerProvider]) {
                this[_layerProvider].hidden = bHide;
            }
        }
        
        protected override _onRestoreViewState(activity: Application.RestActivity, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void {
            if (activity.getRestModel) {
                let state = this.id && savedInstanceState && savedInstanceState.getValue<{state: Partial<ISavedState>, provider: GlobalLayerProvider<Globals.IMapLayerModel>}>(this.id);
                
                if (state) {
                    this[_state] = state.state;
                    this[_layerProvider] = state.provider;
                }
                this[_rest] = activity.getRestModel();
                this[_layerProvider] || this[_bindTo]();
            }
        }

        protected override _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void {
            savedInstanceState.putValue(this.id, { state: this[_state], provider: this[_layerProvider]});
            super._onSaveInstanceState(context, savedInstanceState);
        }
        
        public set template(value: string) {
            let arg: { dbName: string; name: string; } = AFC.Tools.Data.splitSQLName(value),
                mapView: string = arg.dbName, name: string = mapView && arg.name,
                configuration = this[_state];
            
            if ((configuration.mapView !== mapView) || (configuration.name !== name)) {
                configuration.mapView = mapView;
                configuration.name = name;
                this[_bindTo]();
            }
        }
        
        public set mode(value: LayerDataMode) {
            this[_state].mode = value || LayerDataMode.none;
            this[_bindTo]();
        }
        
        public get mode(): LayerDataMode {
            return this[_state].mode;
        }
        
        public set dataModel(value: Data.IRowCollection & Data.IKeyProvider) {
            this[_dataModel] = value;
            this.mode = LayerDataMode.none;
        }
        
        public get dataModel(): Data.IRowCollection & Data.IKeyProvider {
            return this[_dataModel];
        }
        
        public set noClustering(value: boolean) {
            (this[_layerProvider] || this[_state].layer).clustering = !value;
        }
        
        public set clusteringMaxZoom(value: number) {
            (this[_layerProvider] || this[_state].layer).clusteringMaxZoom = value;
        }
        
        public set filter(value: (row: ReadonlyArray<any>, dataModel: Globals.IMapLayerModelData)=> boolean) {
            (this[_layerProvider] || this[_state].layer).filter = value;
        }

        public get filter(): (row: ReadonlyArray<any>, dataModel: Globals.IMapLayerModelData)=> boolean {
            return this[_state].layer.filter;
        }
        
        public set minZ(value: number) {
            (this[_layerProvider] || this[_state].layer).minZ = value;
        }
        
        public getCount(): number {
            return this[_layerProvider] ? 1 : 0;
        }
        
        public getLayerProvider(indice: number): ILayerProvider  {
            if (indice < this.getCount())
                return this[_layerProvider];
        }
        
        public async getInfo(): Promise<Readonly<ILayerProviderInfo>> {
            let drawingInfo = await this[_layerProvider]?.getDrawingInfo();
            return drawingInfo && getProviderInfoFromMapMetadata(drawingInfo.map);
        }
        
        public async getBbox(): Promise<Tools.Geometry.Rectangle> {
            let layer = this.mode !== LayerDataMode.tiled && this[_layerProvider] && <ILayer<Globals.IMapLayerStaticModel>>await this[_layerProvider].getLayer(),
                layerModel = layer && layer.layerModel,
                geoJSON = layerModel && layerModel.geoJSON;
            return geoJSON && (<Tools.Geometry.Rectangle>geoJSON.bbox || Tools.Geometry.getBoundRect(geoJSON));
        }
        
        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            switch(attrName) {
            case 'template':
                this.template = newVal;
                break;
            case 'filter':
                this.filter = StringToFunction(newVal);
                break;
            case 'no-clustering':
                this.noClustering = newVal !== null;
                break;
            case 'clustering-max-zoom':
                let value = parseInt(newVal);
                this.clusteringMaxZoom = isNaN(value) ? void 0 : value;
                break;
            case 'mode':
                this.mode = LayerDataModeLookup[newVal] || LayerDataMode.none;
                break;
            default:
                super.attributeChangedCallback(attrName, oldVal, newVal);
                break;
            }
        }
        
        public refresh(): void {
            this[_layerProvider]?.refresh();
        }        
    }
    
    function _createMap(mapHolder: AfcGuiMapHolder): L.Map {
        let control: L.Map;

        control = L.map(mapHolder, { zoomControl: false, attributionControl: false }).setView(mapHolder.center, mapHolder.scale);// Leaflet object
        L.control.scale({position: 'bottomright', imperial: false}).addTo(control);
/*
        // needs something better to decide if the control is shown or not !
        L.control.zoom({position: 'bottomright'}).addTo(control);
*/            
        return control;
    }

    export interface ILayerInfo {
        layer: Globals.IMapLayerModel;
        provider: ILayerProviderElement;
    }

    interface ILayerInfoEx extends ILayerInfo {
        id: string;
        pos: number;
        loc: number;
        container: number;
        handlers?: gui.IMapEventHandlers;
        dataReader?: (row: any[], indice: number)=> string;
        filterable?: Data.IFilterable;
    }

    function _compare(a: ILayerInfoEx, b: ILayerInfoEx): number {
        return (a.layer.type - b.layer.type) || (a.container - b.container) || (a.loc - b.loc);
    }

    class MapLegends extends Tools.EventSink implements Globals.ILegendsProvider {
        protected _control: L.Map;
        protected _infos: ILayerInfoEx[];
        protected _model: Globals.MapModel;
        protected _filterables: {[key: string]: Mutable<Controls.IFilterableLegendInfo>;};
        protected _legends: Controls.IFilterableLegendInfo[];
        
        constructor(control: L.Map) {
            super();
            (this._control = control).on('zoom', this._refresh, this);
        }
        
        protected _refresh(): void {
            this._update() && this.fireEvent(Tools.EventType.Dirty);
        }
        
        protected _update(): boolean {
            let hasChanged: boolean = !this._legends,
                legends: Controls.IFilterableLegendInfo[] = [];
            
            if (this._infos) {
                let zoom: number = this._control.getZoom();

                this._infos.forEach(info => {
                    let layer: Globals.IMapLayerModel = info.layer;
                    if (((layer.minZ === void 0) || (layer.minZ <= zoom)) && ((layer.maxZ === void 0) || (layer.maxZ >= zoom))) {
                        let legend: Mutable<Controls.IFilterableLegendInfo>;

                        if ((this._filterables || (this._filterables = {})).hasOwnProperty(info.id))
                            legend = this._filterables[info.id];
                        else {
                            legend = this._filterables[info.id] = <Mutable<Controls.IFilterableLegendInfo>>Globals.MapModel.getLegendInfo(info.layer);
                            if (legend) {
                                if (info.filterable) {
                                    legend.id = info.id;
                                    legend.filterable = info.filterable;
                                }
                            }
                        }
                        hasChanged = hasChanged || (this._legends[legends.length] !== legend);
                        legend && legends.push(legend);
                    }
                });
            } else {
                hasChanged = !!(this._legends && this._legends.length);
            }
            this._legends = legends;
            return hasChanged;
        }
        
        public get legends(): ReadonlyArray<Controls.IFilterableLegendInfo> {
            return this._legends || [];
        }
        
        public setLayers(model: Globals.MapModel, infos?: ILayerInfoEx[]): void {
            this._model = model;
            this._infos = infos;
            delete this._filterables;            
            delete this._legends;
            this._update();
            this.fireEvent(Tools.EventType.Dirty);
        }
    }
    
    const _rasterProvider = Symbol(),
        _rasterLayer = Symbol(),
        _defaultProvider: Globals.IRasterProvider = {
             name: 'default',
             host: '{s}.tile.openstreetmap.org',
             path: '{z}/{x}/{y}.png'
        };

    function _onMapComplete(holder: AfcGuiMapHolder, model: Globals.MapModel, adapter: Globals.MapAdapter, infos: ILayerInfoEx[], legends: MapLegends, info: ILayerProviderInfo): void {
        model.clearLayers();
        if (infos) {
            infos.sort(_compare);
            infos.forEach((info: ILayerInfoEx, indice: number) => {
                info.pos = indice;
                model.addLayer(info.layer);
            });
        }
        legends.setLayers(model, infos);
        (<MapEventHandlers>adapter.handlers).layers = infos || [];
        
        let control = holder.control,
            pane = control.getPane('tilePane'),
            grayLevelsRaster: number = 0,
            provider: Globals.IRasterProvider,
            oldProvider = holder[_rasterProvider],
            layer: L.Layer;
            
        if (info) {
            grayLevelsRaster = info.grayLevelsRaster ? 1 : 0;
            provider = info.provider;
        }
        if (!oldProvider || (provider && (oldProvider.name !== provider.name))) {
            holder[_rasterProvider] = provider || (provider = _defaultProvider);
            holder[_rasterLayer] && control.removeLayer(holder[_rasterLayer]);
            if (provider.external) {
                if (provider.name == 'Google Maps') {
                    layer = L.Google && new L.Google('ROADMAP');
                }
            } else {
                layer = L.tileLayer(Tools.StringTools.buildUrl(provider.host, provider.path, provider.secure, provider.port), provider.subdomains && {subdomains: <string[]>provider.subdomains});
            }
            layer && control.addLayer(holder[_rasterLayer] = layer);
        }
        $(pane).css('filter', `grayscale(${grayLevelsRaster})`);
    }

    export function generateTooltips(info: Globals.IEventLayerInfo, dataReader?: (row: ReadonlyArray<any>, indice: number) => string): string {
        let tooltips = info?.model.tooltips,
            dataModel: Globals.IMapLayerModelData,
            row: ReadonlyArray<any>;
            
        return (tooltips && 
            (dataModel = info.model.data) && 
            (row = info.feature.feature?.properties?.data) && 
            tooltips.reduce((acc, tooltip) => {
                let i = tooltip.id ? dataModel.columns.findIndex(column => column.dataId === tooltip.id) : -1,
                    column,
                    text;

                if (i === -1)
                    i = dataModel.columnIndex[tooltip.name];
                if (column = dataModel.columns[i]) {
                    let formatHelper = new AFC.Tools.StringTools.FormatString(tooltip.format === void 0 ? '' : tooltip.format, column.type);
                    
                    if ((row[i] !== null) && (!dataReader || ((text = dataReader(row, i)) === void 0)))
                        text = formatHelper.getFormated(row[i]);
                    else
                        text = formatHelper.getFormated(void 0);
                    acc += `<tr><td class="mapTooltipColumn">${tooltip.name}</td><td class="${formatHelper.isNumeric() ? 'mapTooltipNumericValue' : 'mapTooltipValue'}">${text}</td></tr>`;
                }
                return acc;
            }, '')) || '';
    }

    class MapEventHandlers implements Globals.IMapEventHandlers {
        public layers: ILayerInfoEx[];
        protected _current: Globals.IEventLayerInfo;
        protected _adapter: Globals.MapAdapter;
        protected _holder: AfcGuiMapHolder;

        constructor(holder: AfcGuiMapHolder, layers: ILayerInfoEx[], adapter: Globals.MapAdapter) {
            this._holder = holder;
            this.layers = layers;
            this._adapter = adapter;
        }

        protected _reset(): void {
            if (this._current) {
                let polygon: L.Polygon<Globals.IGeoJsonProperties> = <L.Polygon<Globals.IGeoJsonProperties>>this._current.feature;
                let layer = this._adapter.layers[this._current.index];
                
                if (layer.featureGroup === this._current.featureGroup) {
                    let refStyle: L.PathOptions = (<L.StyleFunction<Globals.IGeoJsonProperties>>layer.options.style)(polygon.feature);

                    polygon.setStyle(refStyle);
                }
                delete this._current;
            }
        }
        
        public click(event: L.LeafletMouseEvent, info: Globals.IEventLayerInfo): void {
            let latLng = event.latlng;
            let globalHandlers: IMapEventHandlers = this._holder.handlers;
            let handlers: IMapEventHandlers;
            let param: IEventLayerInfo;
            let layer: ILayerInfoEx;

            if (info) {
                layer = this.layers[info.index];
                handlers = layer.handlers;
                param = {
                    model: info.model,
                    options: info.options,
                    featureGroup: info.featureGroup,
                    feature: info.feature,
                    index: layer.pos,
                    provider: layer.provider
                };
            }
            
            if (!globalHandlers || !globalHandlers.click || globalHandlers.click.call(globalHandlers, latLng, param, event)) {
                if (!handlers || !handlers.click || handlers.click.call(handlers, latLng, param, event)) {
                    let model = info?.model,
                        selectable = model ? model.selectable : true,
                        pin;
                        
                    if (selectable) {
                        pin = this._holder.highlight(model && {model: model, keys: [model.data.getKeyFromRow(info.feature.feature.properties.data)]});
                        if (this._holder.dispatchEvent(new CustomEvent('mapEvent', {detail: {kind: 'click', latlng: latLng, param: param, pin: pin}, cancelable: true}))) {
                            let s: string = generateTooltips(param, layer && layer.dataReader);

                            s && this._adapter.control.openPopup(`<table class="mapTooltipPopup">${s}</table>`, latLng);
                        }
                        L.DomEvent.stopPropagation(event);
                    }
                }
            }
        }

        public mouseDefaultHandler(event: L.LeafletMouseEvent, mouseEventType: keyof IMapEventHandlers, info: Globals.IEventLayerInfo): boolean {
            let latLng = event.latlng;
            let globalHandlers: IMapEventHandlers = this._holder.handlers;
            let handlers: IMapEventHandlers;
            let param: IEventLayerInfo;
            let layer: ILayerInfoEx;

            if (info) {
                layer = this.layers[info.index];
                handlers = layer.handlers;
                param = {
                    model: info.model,
                    options: info.options,
                    featureGroup: info.featureGroup,
                    feature: info.feature,
                    index: layer.pos,
                    provider: layer.provider
                };
            }
            
            if (!globalHandlers || !globalHandlers[ mouseEventType ] || globalHandlers[ mouseEventType ].call(globalHandlers, latLng, param, event)) {
                return handlers && handlers[ mouseEventType ] && handlers[ mouseEventType ].call(handlers, latLng, param, event);
            }
        }

        public mousedown(event: L.LeafletMouseEvent, info: Globals.IEventLayerInfo): void {
            this.mouseDefaultHandler(event, "mousedown", info);
        }
        
        public mouseup(event: L.LeafletMouseEvent, info: Globals.IEventLayerInfo): void {
            this.mouseDefaultHandler(event, "mouseup", info);
        }
        
        public mouseover(event: L.LeafletMouseEvent, info: Globals.IEventLayerInfo): void {
            if (info) {
                let latLng = event.latlng;
                let param: IEventLayerInfo;
                let layer: ILayerInfoEx = this.layers[info.index];
                let globalHandlers: IMapEventHandlers = this._holder.handlers;
                let handlers: IMapEventHandlers = layer.handlers;
                
                param = {
                    model: info.model,
                    options: info.options,
                    featureGroup: info.featureGroup,
                    feature: info.feature,
                    index: layer.loc,
                    provider: layer.provider
                };

                if (!globalHandlers || !globalHandlers.mouseover || globalHandlers.mouseover.call(globalHandlers, latLng, param, event)) {
                    if (!handlers || !handlers.mouseover || handlers.mouseover.call(handlers, latLng, param, event)) {
                        if (this._holder.dispatchEvent(new CustomEvent('mapEvent', {detail: {kind: 'over', latlng: latLng, param: param}, cancelable: true}))) {
                            let polygon: L.Polygon<Globals.IGeoJsonProperties>;

                            this._reset();
                            if (info && (polygon = <L.Polygon<Globals.IGeoJsonProperties>> info.feature) && polygon.setStyle && info.options && info.options.style && polygon.feature && (info.model.tooltips || info.model.selectable)) {
                                let style = $.extend({}, (<L.StyleFunction<Globals.IGeoJsonProperties>>info.options.style)(polygon.feature));
                                let opacity: number = style.fillOpacity;
                                style.fillOpacity = opacity >= 0.5 ? opacity / 2 : opacity * 2;
                                polygon.setStyle(style);
                                this._current = info;
                            }
                        }
                    }
                }
            }
        }

        public mouseout(event: L.LeafletMouseEvent, info: Globals.IEventLayerInfo): void {
            if (info) {
                let latLng = event.latlng;
                let param: IEventLayerInfo;
                let layer: ILayerInfoEx = this.layers[info.index];
                let handlers: IMapEventHandlers = layer.handlers;
                
                param = {
                    model: info.model,
                    options: info.options,
                    featureGroup: info.featureGroup,
                    feature: info.feature,
                    index: layer.loc,
                    provider: layer.provider
                };
                
                if (!handlers || !handlers.mouseout || handlers.mouseout.call(handlers, latLng, param, event)) {
                    if (this._holder.dispatchEvent(new CustomEvent('mapEvent', {detail: {kind: 'out', latlng: latLng, param: param}, cancelable: true}))) {
                        this._reset();
                    }
                }
            }
        }
                
        public animationend(event: L.LeafletEvent, info: Globals.IEventLayerInfo): void {
            let globalHandlers: IMapEventHandlers = this._holder.handlers;
            let handlers: IMapEventHandlers;
            let param: IEventLayerInfo;
            let layer: ILayerInfoEx;

            if (info) {
                layer = this.layers[info.index];
                handlers = layer.handlers;
                param = {
                    model: info.model,
                    options: info.options,
                    featureGroup: info.featureGroup,
                    feature: info.feature,
                    index: layer.pos,
                    provider: layer.provider
                };
            }
                                    
            if (!globalHandlers || !globalHandlers.animationend || globalHandlers.animationend.call(globalHandlers, event, param)) {
                if (handlers && handlers.animationend)
                    handlers.animationend.call(handlers, event, param);
            }
        }
        
        public release() {
            delete this._current;
        }
    };
    

    function _refreshLayer(holder: AfcGuiMapHolder, model: Globals.MapModel, adapter: Globals.MapAdapter, legends: MapLegends) {
        let infos: ILayerInfoEx[];
        let sequence: number = ++holder[_sequence];
        let providerInfo: ILayerProviderInfo;
        let promises0: Promise<Readonly<ILayerProviderInfo>>[] = [],
            promises1: Promise<any>[] = [];
        
        jQuery<HTMLElement>(holder).children().each(function(this: ILayerProviderElement, container: number) {
            if (this.getCount && this.getLayerProvider) {
                let count: number = this.getCount();

                promises0.push(this.getInfo());
                if (count) {
                    for (let i: number = 0; i < count; ++i) {
                        let layerProvider: IBaseLayerProvider = this.getLayerProvider(i);
                        promises1.push(layerProvider.getLayer().then((layer: ILayer) => {
                            let layerModel = layer?.layerModel;
                            if (layerModel) {
                                let info: ILayerInfoEx = {
                                        id: layer.id,
                                        pos: (infos || (infos = [])).length,
                                        loc: i,
                                        layer: layerModel,
                                        container: container,
                                        provider: this
                                    };
                                this.handlers && (info.handlers = this.handlers);
                                if (layerProvider.filterable && layerModel.legend && layerModel.type === Globals.LayerType.symbol) {
                                    info.filterable = <ILayerProvider>layerProvider;
                                }
                                infos.push(info);
                            }
                        }));
                    }
                }
            }
        });
        promises1.push(Promise.all(promises0).then((providerInfos: Readonly<ILayerProviderInfo>[]) => {
            if (providerInfos.length) {
                let provider: Globals.IRasterProvider,
                    grayLevelsRaster: boolean;
                providerInfos.some(providerInfo => {
                    if (providerInfo) {
                        provider = provider || providerInfo.provider;
                        grayLevelsRaster = grayLevelsRaster || providerInfo.grayLevelsRaster;
                    }
                    return provider && grayLevelsRaster;
                });
                providerInfo = {
                    provider: provider,
                    grayLevelsRaster: grayLevelsRaster,
                    grayLevelsEnabled: true
                };
            }
        }));
        Promise.all(promises1).then(() => (sequence === holder[_sequence]) && _onMapComplete(holder, model, adapter, infos, legends, providerInfo));
    }

    export interface IMapButtonOptions {
        text: string;
        iconUrl: string;
        toggle: boolean;
        hideText: boolean;
        maxWidth: string;
    }

    const _smartZoom = Symbol(),
         _buttons = Symbol(),
         _center = Symbol(),
         _scale = Symbol(),
         _selection = Symbol(),
         _mapHolder = 'AFC-GUI-MAP-HOLDER',
         _reattach = (button: AfcGuiMapButton) => {
             button[_sequence] || (button[_sequence] = setTimeout(() => {
                button.disconnectedCallback();
                button.connectedCallback();
                delete button[_sequence];
             }, 0));
         },
         _converter: {[key in keyof IMapButtonOptions]?: (s: string)=> IMapButtonOptions[key]; } = {
             toggle: Tools.Data.toBoolean,
             hideText: Tools.Data.toBoolean
         },
         _hideButton = (button: L.Control.Button, hide: boolean) => {
             if (button) {
                 let container = button.getContainer();
                 hide ? $(container).hide() : $(container).show();
             }
         };

    export class AfcGuiMapButton extends HTMLElement {
        protected _name: string;
        protected _options: L.ButtonOptions;
        protected _position: L.ControlPosition;
        protected _hidden: boolean;
        protected _button: L.Control.Button;
        /** @internal */
        public [_sequence]: number;
        public static readonly observedAttributes = ['name', 'options', 'position', 'onbuttonclick', 'hidden'];
        public static defaultSize: string;
        public onButtonClick: (event: L.LeafletEvent) => any;

        constructor() {
            super();
            this.options = {};
            this._hidden = false;
        }

        public set name(value: string) {
            if (this._name !== value) {
                this._name = value;
                _reattach(this);
            }
        }

        public get name(): string {
            return this._name; 
        }
        
        public set position(value: L.ControlPosition) {
            if (this._position !== value) {
                this._position = value;
                _reattach(this);
            }
        }

        public get position(): L.ControlPosition {
            return this._position; 
        }
        
        public get hidden(): boolean {
            return this._hidden;
        }

        public set hidden(value: boolean) {
            let show = !value;
            if (show === this._hidden) {
                _hideButton(this._button, this._hidden = !show);
            }
        }
        
        public set options(value: Partial<IMapButtonOptions>) {
            this._options = {
                text: value.text,
                iconUrl: value.iconUrl,
                onClick: (event: L.LeafletEvent)=> this.onButtonClick && this.onButtonClick(event),
                toggle: value.toggle,
                hideText: value.hideText,
                maxWidth: value.maxWidth || AfcGuiMapButton.defaultSize
            };
            _reattach(this);
        }

        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            switch (attrName) {
                case 'name':
                    this.name = newVal;
                    break;
                case 'options':
                    this.options = StringToObject(newVal, _converter);
                    break;
                case 'position':
                    this.position = <L.ControlPosition>newVal;
                    break;
                case 'onbuttonclick':
                    this.onButtonClick = StringToFunction(`function() {${newVal}}`).bind(this);
                    break;
                case 'hidden':
                    this.hidden = (newVal !== null);
                    break;                    
            }
        }

        public connectedCallback(): void {
            let parent: AfcGuiMapHolder = <AfcGuiMapHolder>this.parentNode;
            if (parent && parent.tagName === _mapHolder) {
                this._button = parent.addButton(this._options, this._name, this._position, this._hidden);
            }
        }

        public disconnectedCallback(): void {
            if (this._button) {
                let parent: AfcGuiMapHolder = <AfcGuiMapHolder>this.parentNode;
                if (parent && parent.tagName === _mapHolder) {
                    parent.removeButton(this._button);
                }
                delete this._button;
            }
        }
    }
         
    const _getZoomPromise = (control: L.Map): Promise<L.LeafletEvent> => new Promise<L.LeafletEvent>(resolve => control.once('zoomend moveend', resolve));

    export function autoZoom(map: AfcGuiMapHolder): void {
        map.addEventListener('dataReady', (event: CustomEvent<Globals.ILayerDescriptor[]>) => {
            const map = <AfcGuiMapHolder>event.target;
            map.smartZoom();
        }, {once: true});
    }
    
    const _disableSmartZoom = 'disable-smart-zoom';

    export class AfcGuiMapHolder extends AfcGuiElement implements ILegendsProviderHolder {
        /** @internal */
        public [_rasterProvider]: Globals.IRasterProvider;
        /** @internal */
        public [_rasterLayer]: L.Layer;
        /** @internal */
        protected [_center]: L.LatLng;
        /** @internal */
        protected [_scale]: number;
        /** @internal */
        protected [_selection]: {
            group: Globals.FeatureGroup;
            keys: ReadonlyArray<any>[];
        };
        protected _adapter: Globals.MapAdapter;
        /** @internal */
        protected [_buttons]: {
            [key: string]: L.Control.Button;
            [_smartZoom]?: L.Control.Button;
        };
        /** @internal */
        public [_sequence]: number;
        
        public handlers: gui.IMapEventHandlers;
        public readonly model: Globals.MapModel;
        public readonly control: L.Map;
        public readonly legends: MapLegends;
        public static readonly observedAttributes = AfcGuiElement.observedAttributes.concat([_disableSmartZoom]);
        public static readonly Button = AfcGuiMapButton;
        
        protected _setHide(bHide: boolean): void {
            this._setMute(bHide);
            !bHide && this.refresh();
        }

        protected _setMute(bMute: boolean): void {
            Tools.AdapterBase.disable(this._adapter, bMute);
            super._setMute(bMute);
        }

        constructor() {
            super();
            let map = _createMap(this);
            
            this[_sequence] = 0;
            this.legends = new MapLegends(map);
            this._adapter = new Globals.MapAdapter(this.control = map);
            this._adapter.bindTo(this.model = new Globals.MapModel());
            this._adapter.handlers = new MapEventHandlers(this, [], this._adapter);
            this._adapter.onComplete = (layers: Globals.ILayerDescriptor[]) => _dispatchEvent(this, 'dataReady', {detail: layers});
            this.addEventListener('layersChange', (/*e: CustomEvent*/) => {
                delete this[_selection];
                (<MapEventHandlers> this._adapter.handlers).release();
                this._adapter.clearMap();
                this.legends && this.legends.setLayers(this.model);
                this.model.notify(Tools.EventType.Ready, ()=> _refreshLayer(this, this.model, this._adapter, this.legends));
                this.model.fireEvent(Tools.EventType.Ready);
            });
            this[_buttons] = {};
            this.disableSmartZoom = this.getAttribute(_disableSmartZoom) !== null;
        }

        public get adapter(): Globals.MapAdapter {
            return this._adapter;
        }

        public set center(value: L.LatLng)  {
            this[_center] = value;
        }

        public get center(): L.LatLng {
            return this[_center] || L.latLng(46.75, 2.45);
        }

        public set scale(value: number)  {
            this[_scale] = value;
        }

        public get scale(): number {
            return this[_scale] || 6;
        }

        public get providers(): ILayerInfo[] {
            let handlers: MapEventHandlers = <MapEventHandlers>this._adapter.handlers;
            if (handlers instanceof MapEventHandlers) {
                return handlers.layers;
            }
        }
        
        protected _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void {
            super._onSaveInstanceState(context, savedInstanceState);
             this.id && savedInstanceState.putValue(this.id, {
                currentCenter: this.control.getCenter(),
                currentScale: this.control.getZoom(),
                center: this.center,
                scale: this.scale
            });
        }

        protected _onRestoreViewState(context: Application.Context, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void {
            let value: {
                currentCenter: L.LatLng;
                currentScale: number;
                center: L.LatLng;
                scale: number;
            };
            
            super._onRestoreViewState(context, fragmentManager, savedInstanceState);
            if (savedInstanceState && this.id && (value = savedInstanceState.getValue(this.id))) {
                this.control.setView(value.currentCenter, value.currentScale);
                value.center && (this[_center] = value.center);
                (value.scale !== void 0) && (this[_scale] = value.scale);
            }
        }
        
        public set disableSmartZoom(value: boolean) {
            value ? 
                this._removeButton(<any>_smartZoom):
                this.addButton({
                    iconUrl: 'css/images/smartzoom.png',
                    onClick: this.smartZoom.bind(this)
                }, <any>_smartZoom);
        }
        
        public get disableSmartZoom(): boolean {
            return !this[_buttons][_smartZoom];
        }
        
        public get layers(): ReadonlyArray<Globals.ILayerDescriptor> {
            return this._adapter.layers || [];
        }
        
        public get selection() {
            return this[_selection];
        }
        
        public get buttons() {
            return this[_buttons];
        }
        
        public setView(center: L.LatLngExpression, zoom?: number, options?: L.ZoomPanOptions): Promise<L.LeafletEvent> {
            let promise = _getZoomPromise(this.control);
            this.control.setView(center, zoom, options);
            return promise;
        }
        
        public fitBounds(bounds: L.LatLngBoundsExpression): Promise<L.LeafletEvent> {
            let promise = _getZoomPromise(this.control);
            this.control.fitBounds(bounds);
            return promise;
        }
        
        public async smartZoom(): Promise<L.LeafletEvent> {
            let symbolBounds: L.LatLngBounds,
                bboxes = await Promise.all(this.providers?.reduce((acc: Promise<Tools.Geometry.Rectangle>[], layerInfo: ILayerInfo) => {
                    let provider = layerInfo.provider;
                    !provider.hidden && provider.getBbox && acc.push(provider.getBbox());
                    return acc;
                }, [])),
                bbox: Tools.Geometry.Rectangle = bboxes.length && bboxes.reduce((acc: Tools.Geometry.Rectangle, bbox: Tools.Geometry.Rectangle) => bbox && acc ? (Tools.Geometry.inflateRectWithRect(acc, bbox), acc) : acc || bbox),
                bounds: L.LatLngBounds = bbox && L.latLngBounds([bbox[1], bbox[0]], [bbox[3], bbox[2]]);
            
            bounds || this.model.layers.forEach((layer: Globals.IMapLayerStaticModel)=>{
                let geoJSON: GeoJSON.GeoJsonObject = layer.geoJSON;
                let bbox: any[];
                let latlngs: L.LatLngBoundsLiteral;
 
                if (geoJSON  && (bbox = geoJSON.bbox)) {
                    latlngs = [[bbox[1], bbox[0]],[bbox[3], bbox[2]]];
                    if (layer.type !== Globals.LayerType.symbol) {
                        bounds ? bounds.extend(latlngs) : bounds = L.latLngBounds(latlngs);
                    } else {
                        symbolBounds ? symbolBounds.extend(latlngs) : symbolBounds = L.latLngBounds(latlngs);
                    }
                }
            });
            return bounds || (bounds = symbolBounds) ? this.fitBounds(bounds) : this.setView(this.center, this.scale);
        }

        public addButton(options: Partial<L.ButtonOptions>, key?: string, position: L.ControlPosition = 'topright', hidden?: boolean): L.Control.Button {
            let button: L.Control.Button = new L.Control.Button($.extend({
                    text: '',
                    hideText: true,
                    toogle: false,
                    maxWidth: AfcGuiMapButton.defaultSize
                }, options));
            button.options = {
                position: position
            };
            key && this._removeButton(key);
            _hideButton(button, hidden);
            this.control.addControl(this[_buttons][key||<any>Symbol()] = button);
            return button;
        }
        
        protected _removeButton(key: string): boolean {
            let button: L.Control.Button = this[_buttons][key];
            if (button) {
                delete this[_buttons][key];
                this.control.removeControl(button);
                return true;
            }
        }
        
        public removeButton(button: L.Control.Button): void {
            for (let key in this[_buttons]) {
                if (this[_buttons][key] === button) {
                    this._removeButton(key);
                    return;
                }
            }
        }

        public refresh(): void {
            this._adapter.refresh();
        }
        
        public connectedCallback(): void {
            let attribute: string = this.getAttribute('center'), scale;

            if (attribute) {
                let aTmp: string[] = attribute.split(',');
                let lat: number, lng: number;

                if (aTmp.length === 2) {
                    lng = parseFloat(aTmp[0]);
                    lat = parseFloat(aTmp[1]);
                    if (!isNaN(lng)&&!isNaN(lat)) {
                        this[_center] = L.latLng(lat, lng);
                    }
                }
            }
            attribute = this.getAttribute('scale');
            if (attribute && !isNaN(scale = parseInt(attribute))) {
                this[_scale] = scale;
            }
                 
            this.control.invalidateSize(false);
            _dispatchEvent(this, 'layersChange');
        }
        
        public disconnectedCallback(): void {
            this.model.clearLayers();
        }

        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            attrName === _disableSmartZoom ? this.disableSmartZoom = (newVal !== null): super.attributeChangedCallback(attrName, oldVal, newVal);
        }
        
        protected override _resize(screenRect: Partial<IScreenRect>): void {
            super._resize(screenRect);
            this.control.invalidateSize(false);
        }
        
        public highlight(selection?: {model: Globals.IMapLayerModel, keys: ReadonlyArray<any>[]}): boolean {
            let layers = this._adapter.layers,
                layer = layers && selection && layers.find(layer => layer.model === selection.model),
                old = this[_selection],
                ret: boolean,
                same: boolean = layer && old && (old.group === layer.featureGroup);
                
            if (same && !AFC.Tools.arrayCompare(old.keys, selection.keys))
                return true;    // already highlighted

            delete this[_selection];
            if (layer) {
                layer.featureGroup.highlight(selection.keys);
                this[_selection] = {
                    group: layer.featureGroup,
                    keys: selection.keys
                };
                ret = true;
            }
            !same && old?.group.highlight();
            return ret;
        }
    }
    
    const   _holder = Symbol(),
            _onMapEventHandler = Symbol(),
            _onMapEvent = Symbol();
    
    class TooltipPin {
        public readonly tooltip: AfcGuiLayerTooltip;
        constructor(tooltip: AfcGuiLayerTooltip) {
            let pin = document.createElement('div');

            this.tooltip = tooltip;
            pin.classList.add("mapTooltipPopupHeader");
            tooltip.appendChild(pin).addEventListener('click', this.onClick.bind(this));
        }
        
        public onClick(event: MouseEvent): void {
            this.tooltip.hideTT(true);
            event.stopPropagation();
        }
    }
           
    export class AfcGuiLayerTooltip extends AfcGuiElement {
        protected _hidden: boolean;
        private _pinned: TooltipPin;
        private _ttIsEmpty: boolean;
        private _ttFeatureId: string;
        /** @internal */
        private [_holder]: AfcGuiMapHolder;
        /** @internal */
        private [_onMapEventHandler]: (event: CustomEvent) => void;
        public static observedAttributes = AfcGuiElement.observedAttributes.concat(['for']);
                        
        protected _setHide(bHide: boolean): void {
            super._setHide(bHide || this._hidden);
        }
        
        constructor() {
            super();
            this._ttIsEmpty     = true;
            this._pinned        = null;
            this._ttFeatureId   = "";
        }
        
        public hideTT(fromPin: boolean) : boolean {
            if (!this._pinned || fromPin) {
                this._pinned = null;
                this._setHide(this._hidden = true);
                this._ttFeatureId   = "";
            }
            return true;
        }
        
        public pinTT(latlng: L.LatLng, info: Globals.IEventLayerInfo) : boolean {
            this.showTT(latlng, info, true);
            return false;
        }
        
        protected onShowTT(latlng: L.LatLng, info: Globals.IEventLayerInfo) : boolean {
            return this.showTT(latlng, info, false);
        }
        
        protected onHideTT(latlng: L.LatLng, info: Globals.IEventLayerInfo) : boolean {
            return this.hideTT(false);
        }
                
        public showTT(latlng: L.LatLng, info: Globals.IEventLayerInfo, fromPin: boolean) : boolean {
            let table: HTMLTableElement = document.createElement('table');
            let divPreview: HTMLDivElement = document.createElement('div');
            let feature = info && <any>info.feature;
            let previewWidth    = 50;
            let previewHeight   = 50;
            let ttText          = AFC.gui.generateTooltips(info);
            
            if (this._pinned && !fromPin)         
                return true;
            this._ttIsEmpty = false;   
            if (!ttText || (ttText == "")) {
                this._ttIsEmpty = true;
                this.hideTT(fromPin);
                return true;
            }
            if (this._pinned && (this._ttFeatureId === feature._leaflet_id))
                return true;
            this.innerHTML  = "";
            if (fromPin && this[_holder]) {
                this._pinned = new TooltipPin(this);
            }
            this._ttFeatureId = feature._leaflet_id;
                        
            table.classList.add("mapTooltipPopup");
            table.innerHTML = ttText;
            this.appendChild(table);

            divPreview.classList.add("mapTooltipPopupPreview");
            if (feature._path || feature._icon) {
                let previewShadowId = "previewShadow"
                let svg             = d3.select(divPreview)
                                        .append("svg")
                                        .attr("width", previewWidth * 2)
                                        .attr("height", previewHeight * 2);
                let svgDefs         = svg.append('defs');
                let shadowFilter    = svgDefs.append('filter')
                                            .attr("id", previewShadowId)
                                            .attr("x", 0)
                                            .attr("y", 0)
                                            .attr("width", "200%")
                                            .attr("height", "200%");
                
                shadowFilter.append('feOffset')
                            .attr("result", "offOut")
                            .attr("in", "SourceAlpha")
                            .attr("dx", 5)
                            .attr("dy", 5);
                            
                shadowFilter.append('feGaussianBlur')
                            .attr("result", "blurOut")
                            .attr("in", "offOut")
                            .attr("stdDeviation", 5);
                            
                shadowFilter.append('feBlend')
                            .attr("mode", "normal")
                            .attr("in", "SourceGraphic")
                            .attr("in2", "blurOut");
                
                if (!feature._path) {
                    let g = svg.append("g").attr("filter", "url(#" + previewShadowId + ")");
                    
                    g.append("image")
                            .attr("xlink:href", feature._icon.src)
                            .attr("width", previewWidth)
                            .attr("height", previewHeight);

                    this.appendChild(divPreview);
                }
                else {
                    let pathWidth       = feature._pxBounds.max.x - feature._pxBounds.min.x;
                    let pathHeight      = feature._pxBounds.max.y - feature._pxBounds.min.y;
                    let pathMax         = Math.max(pathWidth, pathHeight);
                    let g               = svg.append("g").attr("filter", "url(#" + previewShadowId + ")");
                    let defaultOpacity  = "";
                    
                    g = g.append("g").attr("transform", "scale(" + (previewWidth / pathMax) + " " + (previewHeight / pathMax) + ")");
                    g = g.append("g").attr("transform", "translate(" + (-feature._pxBounds.min.x) + " " + (-feature._pxBounds.min.y) + ")");
                    g.html(feature._path.outerHTML);    
                    
                    let polygon: L.Polygon<Globals.IGeoJsonProperties> = <L.Polygon<Globals.IGeoJsonProperties>>info.feature;
                    if (info.options.style) {
                        let refStyle: L.PathOptions = (<L.StyleFunction<Globals.IGeoJsonProperties>>info.options.style)(polygon.feature);
                        defaultOpacity = refStyle && refStyle.fillOpacity.toString();
                    }
                    this.appendChild(divPreview);
                    
                    if (defaultOpacity != "")
                        d3.select(this).select("path").attr("fill-opacity", defaultOpacity);
                    if (info.feature && info.feature.feature.geometry.type === "Point")
                        d3.select(this).select("path").attr("stroke-width", "0");
                }
            }
                
            this._hidden = false;
            this._setHide(this.hidden);
            return true;
        }
        
        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            switch(attrName) {
            case 'for':
                let holder = <AfcGuiMapHolder>document.getElementById(newVal);
                
                this.disconnectedCallback();                
                if (holder) {
                    holder.addEventListener('mapEvent', this[_onMapEventHandler] = this[_onMapEvent].bind(this));
                    holder.addEventListener('layersChange', this[_onMapEventHandler]);
                }
                this[_holder] = holder;
                break;
            default:
                super.attributeChangedCallback(attrName, oldVal, newVal);
                break;
            }
        }
        
        public connectedCallback(): void {
            if (!this.getAttribute('for')) {
                let parent: HTMLElement = this;
                
                while(parent = <HTMLElement>parent.parentNode) {
                    if (parent && parent.tagName === _mapHolder) {
                        parent.addEventListener('mapEvent', this[_onMapEventHandler] = this[_onMapEvent].bind(this));
                        parent.addEventListener('layersChange', this[_onMapEventHandler]);
                        this[_holder] = <AfcGuiMapHolder>parent;
                        break;
                    }
                }
            }
            this._setHide(this._hidden = true);
        }

        public disconnectedCallback(): void {
            if (this[_onMapEventHandler]) {
                this[_holder].removeEventListener('mapEvent', this[_onMapEventHandler]);
                this[_holder].removeEventListener('layersChange', this[_onMapEventHandler]);
                delete this[_onMapEventHandler];
            }
        }
        
        public refresh(): void {
        }      
        
        /** @internal */
        private [_onMapEvent](event: CustomEvent) {
            if (event.type === 'layersChange') {
                this.hideTT(true);
            } else {
                let kind            = <CustomEvent>event.detail.kind;
                let preventDefault  = false;

                if (event.detail.kind === 'click') {
                    preventDefault = event.detail.pin ?
                        !this.pinTT(event.detail.latlng, event.detail.param):
                        this.hideTT(true);
                } else if (event.detail.kind === 'out') {
                    preventDefault = !this.onHideTT(event.detail.latlng, event.detail.param);
                } else if (event.detail.kind === 'over') {
                    preventDefault = !this.onShowTT(event.detail.latlng, event.detail.param);
                }
                if (preventDefault)
                    event.preventDefault();
            }
        }
    }
    
    registerElement(_mapHolder.toLowerCase(), AfcGuiMapHolder);
    registerElement("afc-gui-map-button", AfcGuiMapButton);
    registerElement("afc-gui-layer", AfcGuiLayer);
    registerElement("afc-gui-layer-tooltip", AfcGuiLayerTooltip);
}