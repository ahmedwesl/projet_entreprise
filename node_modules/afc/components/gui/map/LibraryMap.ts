/**
 * Created by jean.rennes on 19/02/2019.
 */
///<reference path="../../models/globals/Global.ts" />

namespace AFC.gui {
    const _rest = Symbol(),
        _name = Symbol(),
        _layers = Symbol(),
        _mapView = Symbol(),
        _onDirty = Symbol(),
        _getMetadata = Symbol(),
        _bindTo = Symbol(),
        _noClustering =  Symbol(),
        _clusteringMaxZoom =  Symbol();
    
    interface ISavedState {
        name: string;
        layers: ILayerSavedState[];
    }

    export class AfcGuiLibraryMap extends AfcGuiElement implements ILayerProviderElement {
        /** @internal */
        private [_rest]: Rest.RestModel;
        /** @internal */
        private [_name]: string;
        /** @internal */
        private [_layers]: TileLayerProvider[];
        /** @internal */
        private [_mapView]: Readonly<Globals.IMapViewMetadata>;
        /** @internal */
        private [_noClustering]: boolean;
        /** @internal */
        private [_clusteringMaxZoom]: number;
        
        public static observedAttributes = AfcGuiElement.observedAttributes.concat(['name', 'no-clustering', 'clustering-max-zoom']);

        /** @internal */
        private [_onDirty](/*e: Tools.IEvent*/): void {
            _dispatchEvent(this, 'layersChange');
        }
              
        /** @internal */
        private [_getMetadata](rest: Rest.RestModel, name: string): Promise<Readonly<Globals.IMapViewMetadata>> {
            return this[_mapView] ?
                Promise.resolve(this[_mapView]) :
                new Promise(async (resolve: (metadata: Readonly<Globals.IMapViewMetadata>) => void) => {
                    if (rest && name) {
                        let mapViews: ReadonlyArray<Globals.MapViewDescriptor> = await rest.globals.getMapViews(),
                            mapView: Globals.MapViewDescriptor = Tools.findByIdOrName(name, mapViews);

                        this[_mapView] = mapView && await mapView.getMetadata();
                    }
                    resolve(this[_mapView]);
                });
        }

        /** @internal */
        private [_bindTo](name: string, states?: ISavedState['layers']): void {
            let rest: Rest.RestModel = this[_rest];
            
            if (rest) {
                let config: ILayerSavedState;

                if (!states) {
                    config = {
                        hidden: this.hidden
                    };
                    isNaN(this[_clusteringMaxZoom]) || (config.clusteringMaxZoom = this[_clusteringMaxZoom]);
                    this[_noClustering] && (config.clustering = false);
                }
                delete this[_layers];
                this[_getMetadata](rest, name).then((metadata: Readonly<Globals.IMapViewMetadata>) => {
                    this[_layers] = metadata && metadata.layers.map((layer, indice) => new TileLayerProvider(layer, config || states[indice]));
                    this[_onDirty]();
                });
            }
        }

        protected override _setHide(bHide: boolean): void {
            this._setMute(bHide);
            this[_layers]?.forEach(layer => layer.hidden = bHide);
            this[_onDirty]();
        }

        protected override _onRestoreViewState(activity: Application.RestActivity, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void {
            if (activity.getRestModel) {
                let state = savedInstanceState && this.id && savedInstanceState.getValue<ISavedState>(this.id),
                    name = this.name,
                    states: ISavedState['layers'];
                
                this[_rest] = activity.getRestModel();
                if (state) {
                    name = this[_name] = state.name;
                    states = state.layers;
                }
                name && this[_bindTo](name, states);
            }
        }

        protected override _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void {
            let layers = this.id && this[_layers],
                name = this.name;

            super._onSaveInstanceState(context, savedInstanceState);
            layers && savedInstanceState.putValue(this.id, {
                name: name,
                layers: name && layers.map(layer => ({
                    hidden: layer.hidden,
                    filter: layer.filter,
                    options: layer.options,
                    clustering: layer.clustering,
                    clusteringMaxZoom: layer.clusteringMaxZoom
                }))
            });
        }
                
        public set name(value: string) {
            if (this.name !== value) {
                delete this[_mapView];
                this[_name] = value;
                this[_bindTo](value);
            }
        }

        public get name(): string {
            return this[_name];
        }

        public getCount(): number {
            let layers = this[_layers];
            return layers ? layers.length : 0;
        }
        
        public getLayerProvider(indice: number): TileLayerProvider {
            return this[_layers]?.[indice];
        }
        
        public getInfo(): Promise<Readonly<ILayerProviderInfo>> {
            return this[_getMetadata](this[_rest], this.name).then(getProviderInfoFromMapMetadata);
        }
        
        public override attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            switch (attrName) {
                case 'name':
                    this.name = newVal;
                    break;
                case 'no-clustering':
                    this[_noClustering] = newVal !== null;
                    break;
                case 'clustering-max-zoom':
                    let value = parseInt(newVal);
                    this[_clusteringMaxZoom] = isNaN(value) ? void 0 : value;
                    break;
                default:
                    super.attributeChangedCallback(attrName, oldVal, newVal);
            }
        }
        
        public refresh(): void {
            this[_layers]?.forEach(layer => layer.refresh());
        }        
    }
    
    registerElement("afc-gui-library-map", AfcGuiLibraryMap);
}