/**
 * Created by jean.rennes on 08/12/2020.
 */
///<reference path="../Globals.ts" /> 

namespace AFC.Application {
    function _getSafeName(template: HTMLTemplateElement) {
        let s = template.getAttribute('name'); 
        return s === null ? "" : s;
    }

    interface IDataRecord extends Partial<Tools.IObservable<Tools.IObservable, Data.IDataRecordEventData>> {
        readonly setData?: (column: string, value: any)=> boolean;
        readonly getQualifiedColumn?: (qualifier: Data.Qualifier)=> Data.IDBColumn;
        getData(column: string): any;
        getColumn(column: string): Data.IDBColumn;
    }
    
    function _setData(dataRecord: IDataRecord, input: HTMLElement & Partial<HTMLInputElement>, column: Data.IDBColumn, rootForm: HTMLElement): boolean {
        if (input.tagName !== 'LABEL') {
            let value: any, ret;
            
            if (dataRecord.setData) {
                switch(input.type) {
                    case 'radio':
			            let name        = input.getAttribute('name'),
                            selector    = `input[type='radio'][name='${name}']:checked`,
                            val         = rootForm ? $(rootForm).find(selector).val() : $(selector).val();
                        value = val === void 0 ? null : val;
                        break;
                    case 'checkbox':
                        value = input.checked;
                        break;
                    default:
                        value = input.value;
                        break;
                }
                ret = dataRecord.setData(column.name, Tools.Data.castInputValue(column, value));
            }
            return ret;
        }
    }

    function _getData(dataRecord: IDataRecord, input: HTMLElement&{value: string, type?: string, checked?: boolean}, column: Data.IDBColumn, rootForm: HTMLElement): void {
        let value = dataRecord.getData(column.name);

        if (input.tagName === 'LABEL') {
            let str = value === null ? ' - ' : (Tools.Data.isNumber(value) ? new Intl.NumberFormat().format(value) : value),
                query = $(input);
                
            query.empty().append(document.createTextNode(str));
        } else {
            switch(input.type) {
                case 'radio':
                    let name    = input.getAttribute('name'),
                    selector    = `input[type='radio'][name='${name}']`,
                    radios      = rootForm ? $(rootForm).find(selector) : $(selector);
                    
                    radios.prop('checked', function (this: HTMLInputElement) { return Tools.Data.castInputValue(column, this.value) === value;});
                    break;
                case 'checkbox':
                    input.checked = !!value;
                    break;
                case 'date':
                    {
                        let offset = value.getTimezoneOffset(),
                            date = new Date(value.getTime() + (offset*60000));
                        input.value = date.toISOString().split('T')[0];
                    }
                    break;
                default:
                    input.value = value;
                    break;
            }
        }
    }
    
    const _timeout = Symbol(),
        _forEach = Symbol(),
        _on = Symbol(),
        _off = Symbol(),
        _record = Symbol(),
        _onDirty = Symbol(),
        _template = Symbol(),
        _oldTemplate = Symbol(),
        _templates = Symbol(),
        _dataChange = Symbol(),
        _detail = Symbol(),
        _refresh = Symbol(),
        _onChange = Symbol(),
        _onKeyUp = Symbol(),
        _onClick = Symbol(),
        _dispatch = Symbol();
    
    interface ITemplate extends Controls.ITemplate {
        parentNode: Node;
        refNode: Node;
    }
        
    export class AfcForm extends gui.AfcGuiElement {
        /** @internal */
        private [_timeout]: number;
        /** @internal */
        private [_record]: IDataRecord;
        /** @internal */
        private [_template]: string;
        /** @internal */
        private [_oldTemplate]: string;
        /** @internal */
        private [_templates]: {[key: string]: ITemplate[]};
        /** @internal */
        private [_dataChange]: (event: CustomEvent<ReadonlyArray<Data.IDBColumn>>)=> void;
        /** @internal */
        private [_detail]: Data.IDBColumn[];
        
        public static observedAttributes = gui.AfcGuiElement.observedAttributes.concat(['template', 'datachange']);

        /** @internal */
        private [_refresh](dataRecord: IDataRecord): void {
            if (this[_timeout] === void 0) {
                this[_timeout] = setTimeout(() => {
                    delete this[_timeout];
                    if (this[_oldTemplate] !== void 0) {
                        let nodes = this.querySelectorAll(`[data-template="${this[_oldTemplate]}"]`), node;
                        for (let i = 0; i < nodes.length; ++i) {
                            (node = nodes[i]).parentNode.removeChild(node);
                        }
                        delete this[_oldTemplate];
                    }
                    
                    if (dataRecord) {
                        let key = this[_template] || '',
                            templates;
                            
                        if (this[_templates] && (templates = this[_templates][key])) {
                            templates.forEach(template => {
                                let fragment = document.createDocumentFragment();
                                Controls.Repeater.generateContent(fragment, key, template, dataRecord);
                                $(fragment).children().attr('data-template', key);
                                template.parentNode.insertBefore(fragment, template.refNode);
                            });
                            this[_oldTemplate] = key;
                        }
                        this[_forEach](dataRecord, _getData);
                        this.dispatchEvent(new CustomEvent('draw', {bubbles: false, detail: dataRecord}));
                    }
                }, 0);
            }
        }
                    
        /** @internal */
        private [_forEach](dataRecord: IDataRecord, onColumn: (dataRecord: IDataRecord, input: HTMLInputElement, column: Data.IDBColumn, rootForm: HTMLElement) => void): void {
            let inputs: NodeListOf<HTMLInputElement> = this.querySelectorAll('*[bind]');
            let i, column;

            for (i = 0; i < inputs.length; ++i) {
                (column = this._getColumnForInput(dataRecord, inputs[i])) && onColumn(dataRecord, inputs[i], column, this);
            }
        }
        
        /** @internal */
        private [_on]() {
            this[_record] && this[_record].on && this[_record].on(AFC.Tools.EventType.Dirty, this[_onDirty], this);
        }
        
        /** @internal */
        private [_off]() {
            this[_record] && this[_record].off && this[_record].off(AFC.Tools.EventType.Dirty, this[_onDirty], this);
        }
        
        /** @internal */
        private [_onDirty](event: Data.IDataRecordEvent) {
            let index: {[key: string]: HTMLInputElement}  = {}, dataRecord = this[_record];
            let _this = this;
            this[_forEach](dataRecord, (dataRecord: IDataRecord, input: HTMLInputElement, column: Data.IDBColumn) => {
                index[column.name] = input;
            });
            event.data.columns.forEach(function(column) {
                let input = index[column.name];
                input && _getData(dataRecord, index[column.name], column, _this);
            });
        }
        
        /** @internal */
        private [_onClick](event: MouseEvent) {
            let target = <HTMLElement>event.target;
            if (target.getAttribute && (target.getAttribute('name') === 'submit')) {
                event.stopPropagation();
                this.submit();
            }
        }
        
        /** @internal */
        private [_dispatch](column: Data.IDBColumn): true {
            let detail = this[_detail];
            if (!detail) {
                this[_detail] = detail = [];
                setTimeout(() => {
                    delete this[_detail];
                    this.dispatchEvent(new CustomEvent("dataChange", {bubbles: false, cancelable: false, detail: detail}));
                }, 0);
            }
            detail.push(column);
            return true;
        }
        
        /** @internal */
        private [_onChange](event: Event): void {
            let dataRecord = this[_record],
                input = <HTMLElement>event.target,
                column: Data.IDBColumn;
            dataRecord && (column = this._getColumnForInput(this[_record], input)) && _setData(this[_record], <any>input, column, this) && this[_dispatch](column);
        }
        
        /** @internal */
        private [_onKeyUp](event: KeyboardEvent): void {
            if (event.key === 'Enter') {
                this.submit();
            }
        }
        
        private _getColumnForInput(dataRecord: IDataRecord, input: HTMLElement): Data.IDBColumn {
            let name, bind, qualifier, column;
    
            if ((name = input.getAttribute('name')) && (bind = input.getAttribute('bind'))) {
                switch(bind.toLowerCase()) {
                    case 'column':
                        column = dataRecord.getColumn(name);
                        break;
                    case 'qualifier':
                        ((qualifier = Data.qualifier(name)) !== void 0) && dataRecord.getQualifiedColumn && (column = dataRecord.getQualifiedColumn(qualifier));
                        break;
                }
            }
            return column;
        }

        public getColumnForInput(input: HTMLElement): Data.IDBColumn {
            return this._getColumnForInput(this[_record], input);
        }
        
        public setValue(column: Data.IDBColumn, value: string, fireEvent?: boolean): boolean {
            let dataRecord = this[_record];
            
            if (dataRecord && dataRecord.setData) {
                return dataRecord.setData(column.name, Tools.Data.castInputValue(column, value)) && (!fireEvent || this[_dispatch](column));
            }
        }
            
         constructor() {
            super();
            this.addEventListener('click', this[_onClick].bind(this), true);
            this.addEventListener('change', this[_onChange].bind(this), true);
            this.addEventListener('keyup', this[_onKeyUp].bind(this), true);
        }
        
        public get dataRecord(): IDataRecord {
            return this[_record];
        }
        
        public set dataRecord(value: IDataRecord) {
            if (this[_record] !== value) {
                this[_off]();
                this[_refresh](this[_record] = value);
                this[_on]();
            }
        }
        
        public get template(): string {
            return this[_template];
        }
        
        public set template(value: string) {
            if (this[_template] !== value) {
                this[_template] = value;
                this[_refresh](this[_record]);
            }
        }

        public get ondatachange(): (event: CustomEvent<ReadonlyArray<Data.IDBColumn>>)=> void {
            return this[_dataChange];
        }
        
        public set ondatachange(value: (event: CustomEvent<ReadonlyArray<Data.IDBColumn>>)=> void) {
            if (this[_dataChange] !== value) {
                this[_dataChange] && this.removeEventListener('dataChange', this[_dataChange]);
                (this[_dataChange] = value) && this.addEventListener('dataChange', value);
            }
        }
        
        public connectedCallback(): void {
            let templateNodes = this.getElementsByTagName('template');
            let templateNode, key, templates;
            if (templateNodes) {
                for (let i = templateNodes.length; i > 0; --i) {
                    key = _getSafeName(templateNode = templateNodes[i - 1]);
                    templates = (this[_templates] || (this[_templates] = {}))[key] || (this[_templates][key] = []);
                    templates.push({
                        parentNode: templateNode.parentNode,
                        refNode: templateNode.nextSibling,
                        content: templateNode.innerHTML
                    });
                    templateNode.parentNode.removeChild(templateNode);
                }
            }
            let e = new CustomEvent("connected", {bubbles: false, cancelable: false});
            let onConnected = this.getAttribute('onconnected');
            this.dispatchEvent(e);
            try {
                onConnected && eval("(function(event) { " + onConnected + "})")(e);
            } catch(e) {
            }
            this[_on]();
        }
        
        public disconnectedCallback(): void {
            this[_off]();
        }
        
        public submit(): void {
            this[_record] && this[_forEach](this[_record], _setData);
            this.dispatchEvent(new Event("submit", {bubbles: true, cancelable: true}));
        }
        
        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            attrName === 'template' ? this.template = newVal : super.attributeChangedCallback(attrName, oldVal, newVal);
        }
    }

    gui.registerElement("afc-gui-form", AfcForm);
}