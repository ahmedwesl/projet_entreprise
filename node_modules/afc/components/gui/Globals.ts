/**
 * Created by jean.rennes on 04/10/2016.
 */
namespace AFC.gui {
    export function registerElement(name: string, constructor: CustomElementConstructor, options?: ElementDefinitionOptions): void {
        customElements.define(name, constructor, options);
    }

    export function _dispatchEvent<T>(element: HTMLElement, name: string, eventInitDict?: CustomEventInit<T>): void {
        element.dispatchEvent(new CustomEvent(name, $.extend({ bubbles: true, cancelable: true }, eventInitDict)));
    }

    export function StringToObject(s: string, converters?: { [key: string]: (value: string) => any; }): { [key: string]: any } {
        let regex = /\s*(\S*)\s*:\s*([^;\s]*)\s*;?/g,
            result,
            ret: { [key: string]: any } = {};
        if (s) {
            while ((result = regex.exec(s)) !== null) {
                try {
                    let name = result[1],
                        value = result[2],
                        converter = converters[name];
                    ret[name] = converter ? converter(value) : value;
                } catch (e) {

                }
            }
        }
        return ret;
    }

    export function StringToFunction(s: string): (...args: any[]) => any {
        let f: (...args: any[]) => any;

        try {
            f = eval(`(${s})`);
        } catch (e) {

        }
        return (f instanceof Function) ? f : void 0;
    }

    export interface ICustomElement {
        attributeChangedCallback?: (attrName: string, oldVal: string, newVal: string) => void;
        connectedCallback?: () => void;
        disconnectedCallback?: () => void;
    }

    export type Window = HTMLElement;

    export interface IScreenRect {
        top: number;
        left: number;
        width: number;
        height: number;
    }

    export interface IView extends ICustomElement, HTMLElement, Readonly<IScreenRect> {
        invalidateSize(): void;
    }

    export interface IDataHolder extends Tools.IEventData {
        hasData: boolean;
    }

    export function onSaveInstanceState(context: Application.Context, node: Node, savedInstanceState: Application.Bundle): void {
        let children = node.childNodes;

        if (children) {
            for (let i: number = 0; i < children.length; ++i) {
                AfcGuiElement.onSaveInstanceState(context, children[i], savedInstanceState);
            }
        }
    }

    export function onRestoreViewState(context: Application.Context, node: Node, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void {
        let children = node.childNodes;

        if (children) {
            for (let i: number = 0; i < children.length; ++i) {
                AfcGuiElement.onRestoreViewState(context, children[i], fragmentManager, savedInstanceState);
            }
        }
    }

    const _top = Symbol(),
        _left = Symbol(),
        _width = Symbol(),
        _height = Symbol(),
        _hidden = Symbol();

    function _assign(style: CSSStyleDeclaration, field: string, value: number): void {
        (<any>style)[field] = value !== 0 ? `${value}px` : null;
    }

    export class AfcGuiElement extends HTMLElement implements ICustomElement {
        /** @internal */
        private [_top]: number;
        /** @internal */
        private [_left]: number;
        /** @internal */
        private [_width]: number;
        /** @internal */
        private [_height]: number;
        /** @internal */
        private [_hidden]: boolean;

        public static observedAttributes = ['hidden'];

        protected static _setMute(mute: boolean, element: Element): void {
            (element instanceof AfcGuiElement) && element._setMute(element.hidden || mute);
        }

        public static onSaveInstanceState(context: Application.Context, node: Node, savedInstanceState: Application.Bundle): void {
            let element = <Element>node;
            switch (element.tagName) {
                case 'INPUT':
                    if (element.id) {
                        let value: string | boolean;

                        switch ((<HTMLInputElement>element).type) {
                            case 'checkbox':
                            case 'radio':
                                value = (<HTMLInputElement>element).checked;
                                break;
                            default:
                                value = (<HTMLInputElement>element).value;
                                break;
                        }
                        savedInstanceState.putValue(element.id, value);
                    }
                    break;
                default:
                    element instanceof AfcGuiElement ? element._onSaveInstanceState(context, savedInstanceState) : onSaveInstanceState(context, node, savedInstanceState);
                    break;
            }
        }

        public static onRestoreViewState(context: Application.Context, node: Node, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void {
            let element = <Element>node;

            switch (element.tagName) {
                case 'INPUT':
                    if (savedInstanceState && element.id) {
                        let value = savedInstanceState.getValue(element.id);

                        if (value !== void 0) {
                            switch ((<HTMLInputElement>element).type) {
                                case 'checkbox':
                                case 'radio':
                                    (<HTMLInputElement>element).checked = <boolean>value;
                                    break;
                                default:
                                    (<HTMLInputElement>element).value = <string>value;
                                    break;
                            }
                        }
                    }
                    break;
                default:
                    element instanceof AfcGuiElement ? element._onRestoreViewState(context, fragmentManager, savedInstanceState) : onRestoreViewState(context, node, fragmentManager, savedInstanceState);
                    break;

            }
        }

        protected static _resize(screenRect: Partial<IScreenRect>, element: Element): void {
            (element instanceof AfcGuiElement) && element._resize(screenRect);
        }

        public get hidden(): boolean {
            return this[_hidden];
        }

        public set hidden(value: boolean) {
            let hidden = !!value;
            if (this[_hidden] !== hidden) {
                this._setHide(this[_hidden] = hidden);
            }
        }

        protected _setMute(bMute: boolean): void { }

        protected _setHide(bHide: boolean): void {
            this._setMute(bHide);
            bHide ? $(this).hide() : $(this).show();
        }

        protected _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void {
            onSaveInstanceState(context, this, savedInstanceState);
        }

        protected _onRestoreViewState(context: Application.Context, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void {
            onRestoreViewState(context, this, fragmentManager, savedInstanceState);
        }

        protected _resize(screenRect: Partial<IScreenRect>): void {
        }

        public init({ top, left, width, height }: Partial<IScreenRect>): this {
            let style = this.style;
            _assign(style, 'top', this[_top] = top);
            _assign(style, 'left', this[_left] = left);
            _assign(style, 'width', this[_width] = width);
            _assign(style, 'height', this[_height] = height);
            return this;
        }

        public set top(value: number) {
            _assign(this.style, 'top', this[_top] = value);
        }

        public get top(): number {
            return this[_top] ?? (this[_top] = this.offsetTop);
        }

        public set left(value: number) {
            _assign(this.style, 'left', this[_left] = value);
        }

        public get left(): number {
            return this[_left] ?? (this[_left] = this.offsetLeft);
        }

        public set width(value: number) {
            _assign(this.style, 'width', this[_width] = value);
        }

        public get width(): number {
            return this[_width] ?? (this[_width] = this.offsetWidth);
        }

        public set height(value: number) {
            _assign(this.style, 'height', this[_height] = value);
        }

        public get height(): number {
            return this[_height] ?? (this[_height] = this.offsetHeight);
        }

        public invalidateSize(): void {
            console.log('invalidateSize should not be called !');
        }

        public isEmpty(): boolean {
            return false;
        }

        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            (attrName === 'hidden') && (this.hidden = newVal !== null);
        }
    }

    export class AfcBindableElement<Model extends Partial<Tools.INotifier>, Adapter extends Tools.AdapterBase<Model>> extends AfcGuiElement {
        protected _connected: boolean;
        protected _model: Model;
        protected _adapter: Adapter;

        public static observedAttributes = AfcGuiElement.observedAttributes;

        protected _setMute(bMute: boolean): void {
            Tools.AdapterBase.disable(this._adapter, bMute);
            super._setMute(bMute);
        }

        protected _bindTo(model: Model): void {
            this._adapter.bindTo(model);
            //this.dispatchEvent(new CustomEvent('modelChange', {bubbles: false, detail: model}));
        }

        public get model(): Model {
            return this._model;
        }

        public connectedCallback(): void {
            this._connected = true;
            this._model && this._bindTo(this._model);
        }

        public disconnectedCallback(): void {
            this._adapter.unbind();
            this._connected = false;
        }

        public bindTo(model: Model): void {
            if (this._model !== model) {
                model ? this._model = model : delete this._model;
                this._connected && this._bindTo(model);
            }
        }

        public unbind(): void {
            this._adapter.unbind();
            delete this._model;
        }
    }

    function _onAnimationClick(this: AfcGuiAnimation, e: Event) {
        this.guiAnimate();
        e.stopPropagation();
    }

    function _trapEvent(e: Event) {
        e.stopPropagation();
    }

    function _getFinalClass(animation: AfcGuiAnimation): string {
        return animation.getAttribute('finalClass') || 'final';
    }

    function _hasContent(animation: AfcGuiAnimation): boolean {
        let children: HTMLCollection = (<HTMLElement>animation).children;
        let empty: boolean = true;

        if (children) {
            for (let i: number = 0; (i < children.length) && empty; ++i) {
                empty = (children[i] instanceof AfcGuiElement) && (<AfcGuiElement>children[i]).isEmpty();
            }
        }
        return !empty;
    }

    export class AfcGuiAnimation extends AfcGuiElement {
        private _toggle: boolean;
        public static observedAttributes = AfcGuiElement.observedAttributes.concat(['finalClass']);

        constructor() {
            super();
            this.addEventListener('click', _onAnimationClick, true);
            this.addEventListener('mousewheel', _trapEvent, true);
            this.addEventListener('mousemove', _trapEvent, true);
            this.addEventListener('dataChange', (e: CustomEvent) => this.hidden || !((e.detail && (<IDataHolder>e.detail).hasData) || _hasContent(this)) ? $(this).hide() : $(this).show(), true);
        }

        protected _setHide(bHide: boolean): void {
            bHide || !_hasContent(this) ? $(this).hide() : $(this).show();
        }

        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            switch (attrName) {
                case 'finalClass':
                    this._toggle && (this.className = this.className.replace(new RegExp(oldVal, 'g'), newVal));
                    break;
                default:
                    super.attributeChangedCallback(attrName, oldVal, newVal);
                    break;
            }
        }

        public guiAnimate(): void {
            let final: string = ` ${_getFinalClass(this)}`;
            (this._toggle = !this._toggle) ? this.className += final : this.className = this.className.replace(new RegExp(final, 'g'), '');
        }
    }

    registerElement("afc-gui-animation", AfcGuiAnimation);
}