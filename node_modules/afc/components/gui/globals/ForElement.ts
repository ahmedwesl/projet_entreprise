/**
 * Created by jean.rennes on 28/05/2019.
 */
///<reference path="../Globals.ts" />

namespace AFC.gui {
    const _connected = Symbol(),
        _model = Symbol(),
        _for = Symbol(),
        _setProvider = Symbol();

    export abstract class BindableElement<Model extends Tools.INotifier, Adapter extends Tools.AdapterBase<Model>> extends AfcGuiElement {
        /** @internal */
        private [_connected]: boolean;
        /** @internal */
        private [_model]: Model; 
        protected _adapter: Adapter;

        public static observedAttributes = AfcGuiElement.observedAttributes;

        /*protected _serialize(context: IContext): void {
            this.id && (context[this.id] = this[_model]);
        }
        
        
        protected _deserialize(context: IContext): void {
            this.id && (this[_model] = context[this.id]) && this._bind();
        }*/
        
        protected _setMute(bMute: boolean): void {
            Tools.AdapterBase.disable(this._adapter, bMute);
            super._setMute(bMute);
        }
        
        protected _onDirty(event: Tools.IEvent): void {
            this[_model] && _dispatchEvent(this, 'dataChange', {detail: event});
        }
        
        protected _bind(): Model {
            let provider = this[_model];
            this.dispatchEvent(new CustomEvent('bind', {detail: provider}));
            if (provider) {
                this._adapter.bindTo(provider);
                provider.on(Tools.EventType.Dirty, this._onDirty, this);
            }
            return provider;
        }
        
        protected _unbind(): void {
            let provider = this[_model];
            if (provider) {
                provider.off(Tools.EventType.Dirty, this._onDirty, this);
                this._adapter.unbind();
            }
            this.dispatchEvent(new CustomEvent('unbind', {detail: provider}));
        }
        
        public set model(value: Model) {
            if (this[_model] !== value) {
                this._unbind();
                this[_model] = value;
                this[_connected] && this._bind();
            }
        }
        
        public get model(): Model {
            return this[_model];
        }
        
        public get adapter(): Adapter {
            return this._adapter;
        }
        
        public connectedCallback(): void {
            this[_connected] = true;
            this._bind();
        }
        
        public disconnectedCallback(): void {
            this._unbind();
            this[_connected] = false;
        }
    }

    export abstract class ForElement<Model extends Tools.INotifier, Adapter extends Tools.AdapterBase<Model>> extends BindableElement<Model, Adapter> {
        /** @internal */
        private readonly [_setProvider]: (element: ForElement<Model, Adapter>, forVal: string) => HTMLElement;
        /** @internal */
        private [_for]: string;
        
        public static observedAttributes = BindableElement.observedAttributes.concat(['for']);

        constructor(setProvider: (element: ForElement<Model, Adapter>, forVal: string) => HTMLElement) {
            super();
            this[_setProvider] = setProvider;
        }
        
        public set for(value: string) {
            if (this[_for] !== value) {
                this[_for] = value;
                this[_connected] && this[_setProvider](this, value);
            }
        }
        
        public get for(): string {
            return this[_for];
        }
        
        public connectedCallback(): void {
            super.connectedCallback();
            this[_for] && this[_setProvider](this, this[_for]);
        }        
        
        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            if (attrName === 'for') {
                this.for = newVal;
            }
            else {
                super.attributeChangedCallback(attrName, oldVal, newVal);
            }
        }
    }
}