/**
 * Created by jean.rennes on 19/09/2017.
 */
///<reference path="../Globals.ts" />
///<reference path="../../models/data/Data.ts" />
///<reference path="../../gui/data/Repeater.ts" />
///<reference path="../../adapters/dashboards/ConfigGroupAdapter.ts" />

namespace AFC.gui {
    class ConfigGroupControlRepeater extends Controls.Repeater {
        protected _childrenElem: Array<HTMLElement> = [];

        public storeChildElem(elem: HTMLElement) {
            this._childrenElem.push(elem);
        }

        public getChildrenElem(): Array<HTMLElement> {
            return this._childrenElem;
        }

        public insertItem(container: Node, elem: HTMLElement) {
            let index = (void 0 !== elem.dataset.index) ? parseInt(elem.dataset.index, 10) : void 0;

            if (void 0 !== index && index < container.childNodes.length) {
                container.insertBefore(elem, Array.from(container.childNodes)[index]);
            } else {
                container.appendChild(elem);
            }
        }
    }

    /**
     * Config group repeater
     * 
     * defaultcursel = "VALUE" select dom item with data-value = defaultcursel (use it for item out of model !!!)
     * defaultcursel = null: default item (in mdoel) selection
     * 
     * Usage example: 
     *          <afc-gui-config-group 
     *                  handlers="app.screen.getConfigListHandlers" 
     *                  defaultcursel="0"
     *                  mru-id="mruConfigList" 
     *                  mru-active="true" 
     *                  mru-handlers="app.screen.getDataStorageHandlers">
     *              ...
     *              <template>...</template>
     *              ...
     *              <div data-index="4" onclick="myFn();">
     *                  Custom button to be added outside reapeater logic
     *              </div>
     *          </afc-gui-config-group>
     */
    export class AfcGuiConfigGroup extends AfcGuiRepeater {
        protected _control: ConfigGroupControlRepeater;
        protected _adapter: Dashboards.ConfigGroupAdapter;
        protected _manualContainerElem?: HTMLElement; // Quick access to this._control.node.querySelector(".list__item__manual")
        
        public static observedAttributes = AfcGuiRepeater.observedAttributes
            .concat(['defaultcursel', 'mru-active', 'mru-handlers', 'mru-id', 'handlers']);
        
        constructor() {
            super();
            this._adapter = new Dashboards.ConfigGroupAdapter(this._control = new ConfigGroupControlRepeater(this));
            this._adapter.compare = _compare.bind(this);
        }

        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            let f: any;

            switch (attrName) {
                case 'defaultcursel':
                    this._adapter.defaultSelection = newVal === "null" ? null : newVal;
                break;
                case 'handlers':
                    (f = StringToFunction(newVal)) && (this._adapter.handlers = f());

                    if (this._adapter.handlers && this._adapter.handlers.fnCompare) {
                        this._adapter.compare = (value0, value1) => this._adapter.handlers.fnCompare(value0.dataItem, value1.dataItem);
                    }
                break;
                case 'mru-active':
                    this._adapter.storageHelper.storageActive = (newVal === 'true');
                    break;
                case 'mru-id':
                    this._adapter.storageHelper.mruId = newVal;
                    break;
                case 'mru-handlers':
                    (f = StringToFunction(newVal)) && (this._adapter.storageHandlers = f());
                    break;
                default:
                    super.attributeChangedCallback(attrName, oldVal, newVal);
                    break;
            }
        }

        public connectedCallback(): void {
            ([ ...this.children ].filter(e => e.tagName.toLowerCase() !== "template") as Array<HTMLElement>)
            .sort((a, b) => {
                let indexA = parseInt(a.dataset.index, 10),
                    indexB = parseInt(b.dataset.index, 10),
                    res;

                if (isNaN(indexA) && isNaN(indexB)) { res = 0; }
                else if (isNaN(indexA)) { res = 1; }
                else if (isNaN(indexB)) { res = -1; }
                else { res = indexA - indexB; } 

                return res;
            })
            .forEach(elem => this._control.storeChildElem(elem));

            super.connectedCallback();
        }

        protected override _onGenerate(): void {
            super._onGenerate();

            let control = this._control;
            let node = this._control.node;

            // Add fixed items
            control.getChildrenElem().forEach(element => {
                control.insertItem(node, element);
            });

            node.removeEventListener("click", this.onListClick);
            node.addEventListener("click", this.onListClick);

            this._manualContainerElem = node.querySelector(".list__item__manual");

            if (this._manualContainerElem) {
                // For each input, set data-value default, to be reset when click on Cancel btn
                this._manualContainerElem
                    .querySelectorAll<HTMLInputElement | HTMLSelectElement>("input, select")
                    .forEach(e => e.dataset.resetvalue = e.value);

                // Attach onClick event on btns manual inputs ("Annuler" / "Valider" popin)
                this._manualContainerElem
                    .querySelectorAll(".list__item__manual__footer .btn")
                    .forEach(elem => elem.addEventListener("click", this.onListBtnClick.bind(this)));

                // Attach onKeypress event on inputs manual
                this._manualContainerElem.querySelectorAll<HTMLInputElement>("input[type='text']")
                    .forEach(elem => elem.addEventListener("keypress",
                        (event: KeyboardEvent) => {
                            let allowed = /[0-9,.]/.test(event.key);
                            if (!allowed) { event.preventDefault(); }
                            return allowed;
                        }
                    ));
            }

            // Auto select item that is in template but not in model
            try {
                if (this._adapter.model && this._adapter.defaultSelection !== null) {
                    node.querySelector(`[data-value="${this._adapter.defaultSelection}"]`)
                        .classList.toggle("selected", this._adapter.model.selection === null);
                }
            } catch(e) {
                // No dom item found, ignore
            }
        }

        public onListClick(event: MouseEvent): any {
            const currConfigGroup = this;
            let itemElem: { [key: string]: any },
                parentNode = event.target,
                list = event.currentTarget;

            if ((event.target as HTMLElement).closest(".list__item__manual")) {
                event.stopImmediatePropagation();
                return false;
            }
            
            while (parentNode && (parentNode !== list)) {
                parentNode = ((itemElem = parentNode) as HTMLElement).parentNode;
            }

            this._adapter.onListItemClick.call(this._adapter, event, itemElem)
                .then((result: boolean) => { result && currConfigGroup.toggleManualEdition(event, itemElem as HTMLElement, true); })
                .catch(() => {}); // Prevent browser from displaying err when rejected
        }

        public onListBtnClick(event: MouseEvent): any {
            const btnDOM = <HTMLElement>event.currentTarget;
            const inputsDOM = btnDOM.closest(".list__item__manual")
                .querySelectorAll<HTMLInputElement | HTMLSelectElement>("input[type='text'], select");
            let params: Array<string>;

            if (btnDOM.classList.contains("btn_ok")) {
                params = [ ...inputsDOM ].map(e => e.value);
            } else {
                this._manualContainerElem
                    .querySelectorAll<HTMLInputElement | HTMLSelectElement>("input, select")
                    .forEach(e => e.value = e.dataset.resetvalue);
            }

            this._adapter.onListBtnClick.call(this._adapter, event, params)
                .then(
                    () => { this.toggleManualEdition(event, btnDOM.closest(".list__item"), false); },
                    null
                )
                .catch(() => {});

            event && event.stopPropagation();
        }

        public toggleCollapse(forceCollapse?: boolean): any {
            this._control.node.classList.toggle("collapsed", forceCollapse);
            this._adapter.toggleCollapse.call(this._adapter, this._control.node.classList.contains("collapsed"));
        }

        public toggleManualEdition(event: MouseEvent, itemElem: HTMLElement, forceShow?: boolean) {
            const manualElem: HTMLElement = this._control.node.querySelector<HTMLElement>(".list__item__manual");
            const isDisplayed: boolean = manualElem.style.display !== "none";

            this._adapter
                .toggleManualEdition
                .call(this._adapter, event, itemElem, forceShow)
                .then(() => {
                    this._control.node.classList.toggle("show_manual", forceShow || !isDisplayed );
                    manualElem.style.display = forceShow ? "block" : ( forceShow === false || isDisplayed ? "none" : "block" );
                })
        }
    }
    
    registerElement("afc-gui-config-group", AfcGuiConfigGroup);
}