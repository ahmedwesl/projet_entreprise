/**
 * Created by jean.rennes on 04/10/2016.
 */
///<reference path="../../views/controls/Image.ts" />
///<reference path="../../adapters/dashboards/ChartAdapter.ts" />
///<reference path="../../models/data/Global.ts" />
///<reference path="../globals/ForElement.ts" />
///<reference path="../application/root.ts" />

namespace AFC.gui {
    const _source = Symbol(),
        _ctor = Symbol();

    export function parentLookup<T extends HTMLElement>(element: HTMLElement, tagName: string): T {
        let parentElement = element.parentElement;

        while (parentElement) {
            if (parentElement.tagName === tagName) {
                return <T>parentElement;
            }
            parentElement = parentElement.parentElement;
        }
    }

    export abstract class DashboardView<Model extends Dashboards.IViewModel, Adapter extends Tools.AdapterBase<Model>> extends ForElement<Model, Adapter> {
        /** @internal */
        protected [_source]: string;
        /** @internal */
        protected [_ctor]: Tools.Constructor<Model>
        public readonly label: LabelProvider<Model>;

        public static observedAttributes = ForElement.observedAttributes.concat(['source']);

        constructor(setProvider: (element: ForElement<Model, Adapter>, forVal: string) => HTMLElement, ctor: Tools.Constructor<Model>) {
            super(setProvider);
            this.label = new LabelProvider();
            this[_ctor] = ctor;
            this.model = new this[_ctor]();
        }

        public set source(value: string) {
            if (value !== this[_source]) {
                let guiDashboard = parentLookup<AfcGuiDashboard>(this, 'AFC-GUI-DASHBOARD');

                value === null ? delete this[_source] : this[_source] = value;
                if (guiDashboard) {
                    this.model.dashboardModel = guiDashboard.model;
                    this.model.setId(value);
                } else {
                    this.model = null;
                }
            }
        }

        public get source(): string {
            return this[_source];
        }

        protected _bind(): Model {

            let model = super._bind();
            this.label.model = model;
            return model;
        }

        protected _unbind(): void {
            this.label.model = null;
            super._unbind();
        }

        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            (attrName === 'source') ?
                setTimeout(() => this.source = newVal, 0) :  // set timeout to avoid a bug when connecting
                super.attributeChangedCallback(attrName, oldVal, newVal);
        }
    }

    export interface IChartProviderHolder extends HTMLElement {
        chart: Dashboards.IChartModel;
    }

    function _setChart(chart: AfcGuiChart, forVal: string): HTMLElement {
        let holder: IChartProviderHolder = forVal && <any>document.getElementById(forVal);
        chart.model = holder && holder.chart;
        return holder;
    }

    export class AfcGuiChart extends DashboardView<Dashboards.IChartModel | Dashboards.IReportModel, Dashboards.ChartAdapter> {
        public static observedAttributes = DashboardView.observedAttributes.concat(['options']);

        constructor() {
            super(_setChart, Dashboards.ChartModel);
            this._adapter = new Dashboards.ChartAdapter(new Controls.ReportPage(this), this.hasAttribute('dataMode'));
        }

        public get options(): Partial<Dashboards.IChartOptions> {
            return this._adapter.options;
        }

        public set options(value: Partial<Dashboards.IChartOptions>) {
            this._adapter.options = value;
        }

        protected override _resize(screenRect: Partial<IScreenRect>): void {
            super._resize(screenRect);
            this._adapter.isData ? this._adapter.control.invalidateSize() : this._adapter.refresh();
        }

        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            (attrName === 'options') ? this.options = newVal && JSON.parse(newVal) : super.attributeChangedCallback(attrName, oldVal, newVal);
        }
    }

    export interface IGridProviderHolder extends HTMLElement {
        grid: Dashboards.IGridModel;
    }

    function _setGrid(name: AfcGuiGrid, forVal: string): HTMLElement {
        let holder: IGridProviderHolder = forVal && <any>document.getElementById(forVal);
        name.model = holder && holder.grid;
        return holder;
    }

    function _getFunction(s: string): (...args: any[]) => any {
        return StringToFunction(`function($cell) {return ${s}}`);
    }

    interface IGridViewRemote {
        readonly selection: number;
        moveFromCurrentLine(offset: number): number;
        selectLine(key: number): void;
    }

    export interface ICellClickEventDetail {
        readonly column: number;
        readonly line: number;
        readonly originalLine: number;
        readonly model: Data.IDataModel;
        readonly key: ReadonlyArray<any>;
    }

    /* handle deprecation */
    /** @internal */
    interface IGridViewCompatibility extends Controls.GridView {
        selectItem: (pk: ReadonlyArray<any>, fire?: boolean) => void;
        isItemRowClickEnabled: () => boolean;
        createRemote: () => any;
        onItemClick: (pk: ReadonlyArray<any>, dataModel: AFC.Data.IDataModel, row: ReadonlyArray<any>) => void;
        getSelection: () => { pk: ReadonlyArray<any>; };
        _builded: () => void;
    }

    class SelectionHandler {
        public readonly element: AfcGuiGrid;
        public readonly view: Controls.GridView & IGridViewCompatibility; // dirty hack
        public adapter: Dashboards.GridAdapter;

        constructor(element: AfcGuiGrid, view: Controls.GridView & IGridViewCompatibility) {
            this.element = element;
            this.view = view;
            this.view.selectItem = (key: ReadonlyArray<any>, fire?: boolean) => {
                let model = this.model,
                    line;

                if (model) {
                    line = key ? model.find(key) : -1;
                    this.element.selectLine(line === -1 ? void 0 : line);
                    if (fire && this.view.onItemClick) {
                        this.view.onItemClick && this.view.onItemClick(key, model, model.getRow(line));
                    }
                }
            };
            this.view.createRemote = () => this;
            this.view.getSelection = () => {
                let model = this.model,
                    line, row;
                return model && (line = this.view.selection) !== void 0 && (row = model.getRow(this.adapter.convertLine(line))) && { pk: model.getKeyFromRow(row) };
            }
        }

        public get model(): Data.IDataModel {
            return this.element.model?.getForeignDataModel();
        }

        public get enabled(): boolean {
            return this.view.isItemRowClickEnabled ? this.view.isItemRowClickEnabled() : !!this.model;
        }

        public onCellClick(column: number, line: number): Partial<Mutable<ICellClickEventDetail>> {
            let model, row, key,
                detail: Partial<Mutable<ICellClickEventDetail>> = {
                    column: column,
                    line: line
                };
            if (line !== -1 && (model = detail.model = this.model) && (row = model.getRow(detail.originalLine = this.adapter.convertLine(line)))) {
                key = detail.key = model.getKeyFromRow(row);
                this.view.onItemClick && this.view.onItemClick(key, model, row);
            }
            return detail;
        }

        public onGenerate(): void {
            this.view._builded?.();
        }

        public move(offset: number): ReadonlyArray<any> {
            let line = this.element.moveFromCurrentLine(offset);
            return line !== void 0 && this.model?.getRow(line);
        }
    }
    /* end handle deprecation */

    const _handler = Symbol(),
        _selection = Symbol();

    export class AfcGuiGrid extends DashboardView<Dashboards.IGridModel, Dashboards.GridAdapter> implements IGridViewRemote {
        /** @internal */
        private [_handler]: SelectionHandler;
        /** @internal */
        private [_selection]: {
            id: string;
            line: number;
        };
        public static observedAttributes = DashboardView.observedAttributes.concat(['template', 'data-binder', 'original-size']);

        constructor() {
            let gridView;

            super(_setGrid, Dashboards.GridModel);
            gridView = new Controls.GridView(this);
            this[_handler] = new SelectionHandler(this, <Controls.GridView & IGridViewCompatibility>gridView);
            this._adapter = this[_handler].adapter = new Dashboards.GridAdapter(gridView),
                this._adapter.onCellClick = (column: number, line: number) => this.dispatchEvent(new CustomEvent('cellclick', { detail: this[_handler].onCellClick(column, line) }));
            this._adapter.onGenerate = () => {
                let selection = this[_selection],
                    header = this.querySelector('th');

                this.style.scrollPaddingTop = header ? `${header.offsetHeight}px` : '';
                _dispatchEvent(this, 'dataReady');
                this[_handler].onGenerate();
                selection && this.model.id === selection.id ?
                    this.selectLine(selection.line) :
                    delete this[_selection];
            }
        }

        protected _onDirty(event: Tools.IEvent): void {
            super._onDirty(event);
            this._adapter.enableSelection = this[_handler].enabled;
        }

        protected override _resize(screenRect: Partial<IScreenRect>): void {
            super._resize(screenRect);
            this._adapter.control.invalidateSize();
        }

        public set template(value: (value: Controls.IGridCell) => string) {
            this._adapter.control.template = value;
        }

        public get template(): (value: Controls.IGridCell) => string {
            return this._adapter.control.template;
        }

        public set dataBinder(value: (name: string, key: string, value: { [key: string]: any }) => string) {
            this._adapter.control.dataBinder = value;
        }

        public get dataBinder(): (name: string, key: string, value: { [key: string]: any }) => string {
            return this._adapter.control.dataBinder;
        }

        public set originalSize(value: boolean) {
            this._adapter.control.autoSize = !value;
        }

        public get originalSize(): boolean {
            return !this._adapter.control.autoSize;
        }

        public get selection(): number {
            let adapter = this._adapter;
            return adapter.convertLine(adapter.control.selection);
        }

        public moveFromCurrentLine(offset: number): number {
            let adapter = this._adapter,
                gridApp = adapter.control.gridApp,
                rowCount = gridApp ? gridApp.getRowCount() : 0,
                selection = this.selection;

            if (rowCount && selection !== void 0) {
                let line = (((adapter.control.selection + offset) % rowCount) + rowCount) % rowCount;
                adapter.control.highlight(line);
                line = adapter.convertLine(line/*, Dashboards.ConversionDirection.positionToNative*/);
                this[_selection] = { id: this.model.id, line }; 
                return line;
            }
        }

        public selectLine(nativeLine?: number): void {
            let line;

            delete this[_selection];
            if (Number.isInteger(nativeLine)) {
                this[_selection] = { id: this.model.id, line: nativeLine };
                line = this._adapter.convertLine(nativeLine, Dashboards.ConversionDirection.nativeToPosition);
            }
            this._adapter.control.highlight(line);

        }

        public connectedCallback(): void {
            let templates: HTMLCollectionOf<HTMLTemplateElement> = this.getElementsByTagName("template");
            let template: HTMLTemplateElement;

            if (templates) {
                for (let i: number = 0; i < templates.length; ++i) {
                    if (templates[i].parentNode === this) {
                        let name: string = (template = templates[i]).getAttribute('name');
                        this._adapter.control.setTemplate(template.innerHTML, name === null ? void 0 : name);
                    }
                }
            }
            $(this).empty();
            super.connectedCallback();
        }

        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            let f: any;

            switch (attrName) {
                case 'template':
                    (f = _getFunction(newVal)) && (this.template = f);
                    break;
                case 'data-binder':
                    (f = StringToFunction(newVal)) && (this.dataBinder = f);
                    break;
                case 'original-size':
                    this.originalSize = (newVal !== null);
                    break;
                default:
                    super.attributeChangedCallback(attrName, oldVal, newVal);
                    break;
            }
        }
    }

    enum SelectorModeLookup {
        none = <number>Dashboards.SelectorMode.none,
        type = Dashboards.SelectorMode.type,
        link = Dashboards.SelectorMode.link
    }

    function _updateSelectorMode(selector: AfcGuiSelector, value: string): void {
        let mode: Dashboards.SelectorMode = (<any>SelectorModeLookup)[value] || Dashboards.SelectorMode.type;
        selector.mode = mode;
    }

    export class AfcGuiSelector extends BindableElement<Dashboards.DashboardModel, Dashboards.SelectorAdapter> implements IChartProviderHolder, IGridProviderHolder {
        public static observedAttributes = BindableElement.observedAttributes.concat(['mode', 'filter']);

        constructor() {
            let list: HTMLDivElement = document.createElement('div'),
                radio: HTMLDivElement = document.createElement('div');

            super();
            radio.addEventListener('change', e => e.stopPropagation());
            this._adapter = new Dashboards.SelectorAdapter(new Controls.Selector(list, radio));
            this._adapter.onChange = (eventData: Dashboards.ISelectorEventData) => _dispatchEvent(this, 'change', { detail: eventData });
            this.appendChild(radio);
            this.appendChild(list);
        }

        public set mode(value: Dashboards.SelectorMode) {
            this._adapter.mode = value;
        }

        public get mode(): Dashboards.SelectorMode {
            return this._adapter.mode;
        }

        public get map(): Dashboards.IMapModel {
            return this._adapter.map;
        }

        public get grid(): Dashboards.IGridModel {
            return this._adapter.grid;
        }

        public get chart(): Dashboards.IChartModel {
            return <Dashboards.IChartModel>this._adapter.chart;
        }

        public get filter(): (dashboard: Dashboards.IDashboard, view: Dashboards.IView) => boolean {
            return this._adapter.filter;
        }

        public set filter(value: (dashboard: Dashboards.IDashboard, view: Dashboards.IView) => boolean) {
            this._adapter.filter = value;
        }

        public connectedCallback(): void {
            let guiDashboard;

            super.connectedCallback();
            (guiDashboard = parentLookup<AfcGuiDashboard>(this, 'AFC-GUI-DASHBOARD')) && (this.model = guiDashboard.model);
        }

        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            switch (attrName) {
                case 'mode':
                    _updateSelectorMode(this, newVal);
                    break;
                case 'filter':
                    this.filter = StringToFunction(newVal);
                    break;
                default:
                    super.attributeChangedCallback(attrName, oldVal, newVal);
                    break;
            }
        }

        public selectPrevious(): Promise<AFC.Dashboards.ISelectorEventData> {
            return this._adapter.previous();
        }

        public selectNext(): Promise<AFC.Dashboards.ISelectorEventData> {
            return this._adapter.next();
        }

        public selectItem(value?: string): Promise<AFC.Dashboards.ISelectorEventData> {
            return this._adapter.selectItem(value);
        }

        public getDashboardFilter(mode: Dashboards.SelectorMode): (dashboard: Dashboards.IDashboard) => Controls.ISelectorGroup[] {
            return this._adapter.getDashboardFilter(mode);
        }
    }

    const _dashboard = Symbol(),
        _rest = Symbol(),
        _setInstance = Symbol();

    interface AfcGuiDashboardData {
        dashboards: ReadonlyArray<Dashboards.IDashboard>;
        dashboard: string;
        instance: Dashboards.IDashboard;
    }

    export class AfcGuiDashboard extends AfcGuiDiv {
        /** @internal */
        private [_dashboard]: string;
        /** @internal */
        private [_rest]: Rest.RestModel;
        public readonly model: Dashboards.DashboardModel;

        constructor() {
            super();
            this.model = new Dashboards.DashboardModel();
        }

        /** @internal */
        private [_setInstance](): void {
            let name = this[_dashboard],
                restModel = this[_rest];
            name && restModel && Dashboards.getDashboard(restModel, name).then(dashboard => this.model.dashboard = dashboard);
        }

        protected _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void {
            super._onSaveInstanceState(context, savedInstanceState);
            this.id && savedInstanceState.putValue(this.id, {
                dashboard: this[_dashboard],
                instance: this.model.dashboard
            });
        }

        protected _onRestoreViewState(activity: Application.RestActivity, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void {
            let data: AfcGuiDashboardData,
                instance;

            super._onRestoreViewState(activity, fragmentManager, savedInstanceState);
            this[_rest] = activity.getRestModel();
            if (savedInstanceState && this.id && (data = savedInstanceState.getValue(this.id))) {
                instance = data.instance;
                this[_dashboard] = data.dashboard;
            }
            instance ? this.model.dashboard = instance : this[_setInstance]();
        }

        public static observedAttributes = AfcGuiDiv.observedAttributes.concat(['dashboard']);

        public get dashboard(): string {
            return this[_dashboard];
        }

        public set dashboard(value: string) {
            this[_dashboard] = value;
            this[_setInstance]();
        }

        public get instance(): Dashboards.IDashboard {
            return this.model.dashboard;
        }

        public set instance(value: Dashboards.IDashboard) {
            delete this[_dashboard];
            this.model.dashboard = value;
        }

        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            attrName === 'dashboard' ? this.dashboard = newVal : super.attributeChangedCallback(attrName, oldVal, newVal);
        }

        public disconnectedCallback(): void {
            this.model.release();
        }
    }

    type DashboadViewType = AfcGuiChart | AfcGuiGrid;

    function _applyToChildren(element: HTMLElement, f: (view: DashboadViewType, parent: HTMLElement, indice: number) => any): void {
        $(element).find('afc-gui-chart,afc-gui-grid').each(function (this: DashboadViewType, indice: number) {
            let parent: HTMLElement = this;

            while (parent.parentNode !== element) {
                parent = <HTMLElement>parent.parentNode;
            }
            f(this, parent, indice);
        });
    }

    export class AfcGuiSplitter extends AfcGuiElement {
        public static observedAttributes = AfcGuiElement.observedAttributes;

        constructor() {
            super();
            this.addEventListener('dataChange', this._onDataChange);
        }

        protected _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void {
            let hidden: boolean[] = [];

            super._onSaveInstanceState(context, savedInstanceState);
            _applyToChildren(this, (view: DashboadViewType, parent: HTMLElement) => hidden.push(parent.hidden));
            this.id && savedInstanceState.putValue(this.id, hidden);
        }

        protected _onRestoreViewState(context: Application.Context, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void {
            super._onRestoreViewState(context, fragmentManager, savedInstanceState);
            if (savedInstanceState && this.id) {
                let hidden: boolean[] = savedInstanceState.getValue(this.id);

                if (hidden) {
                    _applyToChildren(this, (view: DashboadViewType, parent: HTMLElement, indice: number) => parent.hidden = hidden[indice]);
                }
            }
        }

        public _onDataChange(e: CustomEvent): void {
            let target: DashboadViewType = <DashboadViewType>e.target;

            target.model && target.model.getType().then(viewType => {
                let globalWide: boolean = false;
                let bFound: boolean = false;
                let children: {
                    gui: DashboadViewType;
                    parent: HTMLElement;
                    target: boolean;
                    grow: number;
                }[] = [];
                let ref: DashboadViewType = (viewType !== void 0) && target;

                _applyToChildren(this, (view: DashboadViewType, parent: HTMLElement) => {
                    let viewModel: Dashboards.IViewModel = view.model,
                        properties: ReadonlyArray<Dashboards.IDashboardProperty>,
                        grow = 0;

                    if (viewModel && (properties = viewModel.properties)) {
                        let index: Dashboards.IViewsProperties = viewModel.dashboard.viewsProperties,
                            wide: boolean = index.iswide && properties[index.iswide][2];

                        grow = index.width ? properties[index.width][2] : 1;
                        globalWide = wide || globalWide;
                        ref || (ref = view);
                    }
                    children.push({ gui: view, parent: parent, target: (ref === view), grow: grow });
                    bFound = bFound || (target === view);
                });
                bFound && children.reduce((acc, item, indice) => {
                    item.parent.hidden = globalWide && !item.target;
                    item.parent.style.flexGrow = globalWide ? null : <any>item.grow;
                    return acc;
                }, 100);
            });
        }
    }

    export interface IRedistrictableElement extends HTMLElement {
        attachRedistrict: (redistrict: AfcGuiRedistrict) => any;
        detachRedistrict: (redistrict: AfcGuiRedistrict) => any;
    }

    function _attachRedistrict(redistrict: AfcGuiRedistrict, id?: string): void {
        redistrict.setRedistrictable(id && <IRedistrictableElement>document.getElementById(id));
    }

    const enum RedistrictColumnType {
        integer = 1,
        real,
        string,
        sum
    };

    enum RedistrictColumnTypeLookup {
        integer = RedistrictColumnType.integer,
        real = RedistrictColumnType.real,
        string = RedistrictColumnType.string,
        sum = RedistrictColumnType.sum
    }

    interface ICustomColumnValueMap {
        [RedistrictColumnType.integer]: ($scope: { readonly [key: string]: any }, $scopes: ReadonlyArray<{ readonly [key: string]: any }>) => number,
        [RedistrictColumnType.real]: ($scope: { readonly [key: string]: any }, $scopes: ReadonlyArray<{ readonly [key: string]: any }>) => number,
        [RedistrictColumnType.string]: ($scope: { readonly [key: string]: any }, $scopes: ReadonlyArray<{ readonly [key: string]: any }>) => string,
        [RedistrictColumnType.sum]: ($scope: { readonly [key: string]: any }, $scopes: ReadonlyArray<{ readonly [key: string]: any }>, $row: { [key: string]: any }) => number
    };

    interface IRedistrictColumn<T extends RedistrictColumnType = RedistrictColumnType> {
        readonly type: T;
        readonly definition: Data.IDBColumn;
        readonly value: ICustomColumnValueMap[T];
    }

    const DataKindLookup: { [key: number]: Data.DataKind; } = {
        [RedistrictColumnType.integer]: Data.DataKind.integer,
        [RedistrictColumnType.real]: Data.DataKind.real,
        [RedistrictColumnType.string]: Data.DataKind.character,
        [RedistrictColumnType.sum]: Data.DataKind.real
    };

    function _mapType(type_: RedistrictColumnType): Data.DataKind {
        return DataKindLookup[type_];
    }

    class CustomColumn<T extends RedistrictColumnType = RedistrictColumnType> implements IRedistrictColumn<T> {
        public readonly type: T;
        public readonly definition: Data.IDBColumn;
        public readonly value: ICustomColumnValueMap[T];

        constructor(operator: T, name: string, size: number, value: ICustomColumnValueMap[T]) {
            this.type = operator;
            this.definition = new Data.DBColumn(name, _mapType(operator), -1, size);
            this.value = value;
        }
    }

    export const enum ZoneType {
        subset = 1,
        outOfZone,
        total
    }

    const _lastColumn = 4;

    class AggregateModel extends Data.DataModelBase {
        protected _descriptor: IDistrictParameters['descriptor'];
        protected _appended: IRedistrictColumn[];
        public dataModel: Data.IRowCollection & Tools.IObservable & Data.IDBTableDefinition;
        declare public values: any[][];
        declare public readonly columns: Data.IDBColumn[];
        declare public readonly columnIndex: {
            order: 0,
            id: 1,
            name: 2,
            type: 3,
            [key: string]: number;
        };

        constructor() {
            super([
                new Data.DBColumn('order', Data.DataKind.integer, -1, 4),
                new Data.DBColumn('id', Data.DataKind.character, 0, 255),
                new Data.DBColumn('name', Data.DataKind.character, -1, 255),
                new Data.DBColumn('type', Data.DataKind.integer, -1, 4)
            ], ['order'], []);
            this.on(Tools.EventType.Attach, this._on, this);
        }

        protected _getScope(columns: ReadonlyArray<Data.IDBColumn>, row: any[]): { [key: string]: any } {
            let $scope: { [key: string]: any } = {};
            columns.forEach((column: Data.IDBColumn, indice: number) => {
                $scope[column.name] = row[indice];
            });
            return $scope;
        }

        protected _on(/*event: Tools.IEvent*/): void {
            let dataNode: Dashboards.IDataNode;

            if (this._appended && this.values.length && this.dataModel && (dataNode = this._descriptor.dataNodes.find(dataNode => dataNode.qualifier === Dashboards.DataQualifier.partition))) {
                let partition: number = this.dataModel.columns.findIndex(column => column.alias === dataNode.name),
                    items: Data.IDataEventItem[],
                    changes: { [key: number]: Data.IDataEventItem } = {},
                    index: { [key: string]: { [key: string]: any } } = {},
                    scopes: { [key: string]: any }[] = this.values.map(row => {
                        let scope = {},
                            value = row[2];
                        index[value] || (index[value] = scope);
                        return scope;
                    }),
                    last = scopes[scopes.length - 1],
                    update = (i: number, j: number, value: any): any => {
                        let row: any[] = this.values[i];

                        if (!Tools.Data.isValid(this.columns[j].type, value))
                            value = null;

                        if (value !== row[j]) {
                            row[j] = value;
                            changes[i] || (items || (items = [])).push(changes[i] = {
                                row: row,
                                type: Data.DataEventType.modify,
                                committed: true
                            });
                        }
                        return value;
                    };
                
                this.columns.forEach((column: Data.IDBColumn, j: number) => {
                    let redistrictColumn: IRedistrictColumn<any>,
                        columnName = column.name;

                    if ((j < _lastColumn) || ((redistrictColumn = this._appended[j - _lastColumn]).type !== RedistrictColumnType.sum)) {
                        scopes.forEach((scope, i) => scope[columnName] = j < _lastColumn ?
                            this.values[i][j]:
                            update(i, j, redistrictColumn.value(scope, scopes)));
                    } else {
                        scopes.forEach(scope => scope[columnName] = 0);
                        for (let l = 0, lCount = this.dataModel.length; l < lCount; ++l) {
                            let row = this.dataModel.getRow(l),
                                scope = index[row[partition]];

                            if (scope !== last) {
                                let value: number = redistrictColumn.value(scope, scopes, AFC.Tools.Data.mapRow(this.dataModel.columns, row));
                                scope[columnName] += value;
                                last[columnName] += value;
                            };
                        }
                        scopes.forEach((scope, i) => scope[columnName] = update(i, j, scope[columnName]));
                    }
                });
                items && this.fireEvent(Tools.EventType.Dirty, new Data.DataEventData(items));
            }
        }

        protected _onDirty(/*event: Data.IDataEvent*/): void {
            this.fireEvent(Tools.EventType.Attach);
        }

        public setParameters(parameters?: IDistrictParameters): void {
            let values = this.values,
                dataModel = this.dataModel,
                zone, descriptor, partition;

            values.length = 0;
            if (dataModel) {
                dataModel.off(Tools.EventType.Dirty, this._onDirty, this);
                delete this.dataModel;
            }

            if (parameters && (dataModel = parameters.dataModel) && (zone = parameters.zone) && (descriptor = parameters.descriptor) && (partition = descriptor.partition)) {
                let property: Globals.ILayerProperty<number> = parameters.colorProperty,
                    classes: ReadonlyArray<Globals.IThematicValue> = property?.thematic?.classes;

                this.dataModel = dataModel;
                this._descriptor = descriptor;
                classes && this.attachColumn(new CustomColumn(RedistrictColumnType.string, 'color', 7, ($scope: {
                    [key: string]: any;
                    order: number;
                }
                ) => classes[$scope.order] ? Tools.Style.convertColor(classes[$scope.order].value) : null));
                this.attachColumn(new CustomColumn(RedistrictColumnType.string, 'label', 255, ($scope: {
                    [key: string]: any;
                    order: number;
                }
                ) => classes?.[$scope.order]?.pattern ?? $scope.name));

                partition.subsets.forEach((subset: Dashboards.ISubsetDescriptor, indice: number) => (subset.type !== Dashboards.ZoneType.subsetUnion) && values.push([
                    values.length,
                    subset.id,
                    subset.value,
                    subset.type !== Dashboards.ZoneType.outOfZone ? ZoneType.subset : ZoneType.outOfZone
                ]));
                values.push([values.length, zone.id, zone.name, ZoneType.total]);
                dataModel.on(Tools.EventType.Dirty, this._onDirty, this);
                this.fireEvent(Tools.EventType.Attach);
            }
        }

        public attachColumn(column: IRedistrictColumn): void {
            let definition: Data.IDBColumn = column.definition;
            let index: number = this.columnIndex[definition.name];

            if (index === void 0) {
                this.columnIndex[definition.name] = index = this.columns.length;
            } else if (index < _lastColumn) {
                return;
            }
            this.columns[index] = definition;
            (this._appended || (this._appended = []))[index - _lastColumn] = column;
            if (this.values.length) {
                this.values.forEach((row: any[]) => row[index] = null);
                this.fireEvent(Tools.EventType.Attach);
            }
        }

        public detachColumn(name: string): void {
            let index: number = this.columnIndex[name];

            if ((index !== void 0) && (index >= _lastColumn)) {
                delete this.columnIndex[name];
                for (let i: number = index + 1; i < this.columns.length; ++i) {
                    --this.columnIndex[this.columns[i].name];
                }
                this.columns.splice(index, 1);
                this._appended.length == 1 ? delete this._appended : this._appended.splice(index - _lastColumn, 1);
                if (this.values.length) {
                    this.values.forEach((row: any[]) => row.splice(index, 1));
                    this.fireEvent(Tools.EventType.Attach);
                }
            }
        }

        public refresh(): void {
            this.fireEvent(Tools.EventType.Attach);
        }
    }

    function _getFunction2<T extends RedistrictColumnType>(value: string, type_: T): ICustomColumnValueMap[T] {
        return StringToFunction(type_ !== RedistrictColumnType.sum ? `function($scope,$scopes) { return ${value}; }` : `function($scope,$scopes,$row) { return ${value}; }`);
    }

    export interface IDistrictParameters {
        zone: Dashboards.IZone;
        descriptor: Dashboards.IRadiusAreaDescriptor | Dashboards.IIsodistanceAreaDescriptor | Dashboards.IIsochroneAreaDescriptor | Dashboards.IPredefinedAreaDescriptor | Dashboards.IBulkMailAreaDescriptor;
        layerModel: Globals.MapLayerStaticModel<Globals.LayerType.polygon> | Globals.IMapLayerTiledModelImpl<Globals.LayerType.polygon>;
        dataModel: Data.IDataModel;
        colorProperty: Globals.ILayerProperty<number>;
    }

    const _for = Symbol(),
        _redistrictable = Symbol(),
        _connected = Symbol(),
        _name = Symbol(),
        _definition = Symbol(),
        _type = Symbol(),
        _value = Symbol();

    export class AfcGuiColumn<T extends RedistrictColumnType = RedistrictColumnType> extends HTMLElement implements IRedistrictColumn<T> {
        /** @internal */
        private [_name]: string;
        /** @internal */
        private [_definition]: Data.IDBColumn;
        /** @internal */
        private [_type]: RedistrictColumnType;
        /** @internal */
        private [_value]: ICustomColumnValueMap[T];

        public static observedAttributes = ['name', 'type', 'value'];

        constructor() {
            super();
            this[_type] = RedistrictColumnType.string;
        }

        public set name(value: string) {
            delete this[_definition];
            this[_name] = value;
        }

        public get name(): string {
            return this[_name];
        }

        public set type(value: T) {
            if (this[_type] !== value) {
                delete this[_value];
                this[_type] = value;
            }
        }

        public get type(): T {
            return <T>this[_type];
        }

        public set value(value: ICustomColumnValueMap[T]) {
            this[_value] = value;
        }

        public get value(): ICustomColumnValueMap[T] {
            return this[_value] || (this[_value] = _getFunction2(this.getAttribute('value'), this.type));
        }

        public get definition(): Data.IDBColumn {
            return this[_definition] || (this[_definition] = new Data.DBColumn(this[_name], _mapType(this[_type]), -1, 0));
        }

        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            switch (attrName) {
                case 'name':
                    this.name = newVal;
                    break;
                case 'type':
                    let type: RedistrictColumnType = (<any>RedistrictColumnTypeLookup)[newVal];
                    type && (this.type = <T>type);
                    break;
                case 'value':
                    delete this[_value];
                    break;
            }
        }

        public connectedCallback(): void {
            let parent: AfcGuiRedistrict = <AfcGuiRedistrict>this.parentNode;
            if (parent && parent.tagName === 'AFC-GUI-REDISTRICT') {
                parent.model.attachColumn(this);
            }
        }

        public disconnectedCallback(): void {
            let parent: AfcGuiRedistrict = <AfcGuiRedistrict>this.parentNode;
            if (parent && parent.tagName === 'AFC-GUI-REDISTRICT') {
                parent.model.detachColumn(this.name);
            }
        }
    }

    export class AfcGuiRedistrict extends AfcGuiElement {
        /** @internal */
        protected [_redistrictable]: IRedistrictableElement;
        /** @internal */
        protected [_for]: string;
        public readonly model: Data.IDataModelBase & Tools.IObservable & {
            /** @internal */
            setParameters(parameters?: IDistrictParameters): void;
            /** @internal */
            attachColumn(column: IRedistrictColumn): void;
            /** @internal */
            detachColumn(name: string): void;
            /** @internal */
            refresh(): void;
            readonly dataModel: Data.IRowCollection & Tools.IObservable & Data.IDBTableDefinition;
        };
        public static observedAttributes = AfcGuiElement.observedAttributes.concat(['for']);

        constructor() {
            super();
            this.model = new AggregateModel();
            this.addEventListener('dataChange', AfcGuiRedistrict._onDataChange);
        }

        protected static _onDataChange(e: Event): void {
            let self: AfcGuiRedistrict = <AfcGuiRedistrict>e.currentTarget,
                query = $(self).find('input[name=__redistrict]');

            query.filter(':checked').length || query.val(<any>[self.model.length - 1]);
        }

        public set for(value: string) {
            if (this[_for] !== value) {
                _attachRedistrict(this, value);
                this[_for] = value;
            }
        }

        public get for(): string {
            return this[_for];
        }

        public get selected(): string {
            let s: string = <string>$(this).find('input[name=__redistrict]:checked').val(),
                selected: number,
                row: ReadonlyArray<any>;

            if (s && !isNaN(selected = parseInt(s)) && (selected < this.model.length)) {
                row = this.model.values[selected];
                if (row && row[3] !== ZoneType.total) {
                    return row[1];
                }
            }
        }

        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            attrName === 'for' ? this.for = newVal : super.attributeChangedCallback(attrName, oldVal, newVal);
        }

        public connectedCallback(): void {
            _attachRedistrict(this, this[_for]);
        }

        public disconnectedCallback(): void {
            _attachRedistrict(this);
        }

        public setRedistrictable(element?: IRedistrictableElement): void {
            let old = this[_redistrictable];

            if (old !== element) {
                old?.detachRedistrict?.(this);
                this.model.setParameters();
                (this[_redistrictable] = element)?.attachRedistrict?.(this);
            }
        }


        protected _dataBind(repeater: AfcGuiRepeater, name: string, key: string, value: Data.IDataItemContainer): string {
            let aKeys: string[],
                isCumul: boolean,
                isCumulPct: boolean,
                isPct: boolean,
                items: Data.IDataItemContainer[],
                sResult = <string>this.redistrictDataBinder(name, key, value);

            if (sResult === void 0) {
                aKeys = Controls.Repeater.splitKey(key);
                if (aKeys.length == 2) {
                    if (aKeys[0] == 'cumul') {
                        isCumul = true;
                    }
                    else if (aKeys[0] == 'cumulPct') {
                        isCumulPct = true;
                    }
                    else if (aKeys[0] == 'pct') {
                        isPct = true;
                    }
                }
                if (isCumul || isCumulPct || isPct) {
                    items = [];
                    if (value && value.dataItem) {
                        if (isPct)
                            items.push(value);
                        else if (value.dataItem.type == ZoneType.subset) {
                            for (let i = 0; i < this.model.length; i++) {
                                let item = this.model.item(i);
                                if (item.dataItem.type === ZoneType.subset)
                                    items.push(item);
                            }
                            repeater.compare && items.sort(repeater.compare);
                        }
                        else if (value.dataItem.type == ZoneType.total)
                            items.push(value);
                    }
                    if (items.length > 0) {
                        let cumul = 0;

                        for (let i = 0; i < items.length; i++) {
                            cumul += items[i].dataItem[aKeys[1]];
                            if (items[i].dataItemIndex === value.dataItemIndex) {
                                break;
                            }
                        }
                        if (isCumulPct || isPct) {
                            let typeColIndex = this.model.columnIndex.type,
                                totalZoneValuesIndex = this.model.values.findIndex(row => row[typeColIndex] === ZoneType.total),
                                totalValue;

                            if (totalZoneValuesIndex >= 0 && (totalValue = this.model.item(totalZoneValuesIndex).dataItem[aKeys[1]])) {
                                cumul /= totalValue;
                                cumul = Math.round(cumul * 1000) / 10;
                            } else {
                                return '-';
                            }
                        }
                        sResult = cumul.toString();
                    }
                }
            }
            return sResult;
        }

        public redistrictDataBinder(name: string, key: string, value: Data.IDataItemContainer): string | void {

        }

        public setParameters(parameters: IDistrictParameters) {
            let repeaters: HTMLCollectionOf<AfcGuiRepeater> = <HTMLCollectionOf<AfcGuiRepeater>>this.getElementsByTagName('afc-gui-repeater'),
                repeater = repeaters && repeaters[0];

            if (repeater) {
                this.model.setParameters(parameters);
                repeater.dataBinder = this._dataBind.bind(this, repeater);
                repeater.bindTo(this.model);
            }
        }

        public refresh(): void {
            this.model.refresh();
        }
    }

    registerElement("afc-gui-chart", AfcGuiChart);
    registerElement("afc-gui-grid", AfcGuiGrid);
    registerElement("afc-gui-selector", AfcGuiSelector);
    registerElement("afc-gui-dashboard", AfcGuiDashboard);
    registerElement("afc-gui-splitter", AfcGuiSplitter);
    registerElement("afc-gui-redistrict", AfcGuiRedistrict);
    registerElement("afc-gui-redistrict-column", AfcGuiColumn);
}