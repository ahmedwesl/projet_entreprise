/**
 * Created by jean.rennes on 18/09/2020.
 */
 ///<reference path="RestActivity.ts" />
 ///<reference path="ParcParameters.ts" />
 ///<reference path="../helpers/ParcEdition.ts" />
 
namespace AFC.Application {
    const _resources = Symbol(),
        _loading = Symbol(),
        _storage = Symbol(),
        _session = Symbol(),
        _replacements = Symbol();
    
    const enum EventType {
        ResourceReady = Tools.EventType.UserEvent
    };

    export const enum ParcType {
        dashboard = 1,
        administrative,
        query
    }
    
    const ParcFactory = {
        [ParcType.dashboard]: DashboardParc,
        [ParcType.administrative]: AdminParc,
        [ParcType.query]: AFC.Tools.ParcEdition.QueryParc
    };

    interface IParcFactory {
        [ParcType.dashboard]: DashboardParc,
        [ParcType.administrative]: AdminParc,
        [ParcType.query]: AFC.Tools.ParcEdition.QueryParc
    }

    interface IReplacements {
        sequence: Symbol;
        modifiers: Rest.ContextSubstitute[];
    };
    
    async function _getInjections(dashboardActivity: DashboardActivity, replacements: Partial<IReplacements>): Promise<any> {
        if (!replacements.sequence) {
            let rest = dashboardActivity.getRestModel(),
                sequence = replacements.sequence = Symbol(),
                replacementTable = await AFC.Tools.Data.normalizeSQLName(rest.schema, 'CATALOG_APP_INJECTION');

            if (replacementTable) {
                let [dataTable] = await (new AFC.Data.Queries(rest, null)).getDataTable([{
                        commandText: `SELECT * FROM ${replacementTable}`
                    }]) || [];

                if (dataTable && replacements.sequence === sequence) {
                    let modifiers = replacements.modifiers,
                        values = dataTable.values,
                        target: number,
                        table: number;

                    if (values && 
                            values[0] && 
                            ((target = dataTable.columns.findIndex(column => column.name === 'TARGET')) !== -1) &&
                            ((table = dataTable.columns.findIndex(column => column.name === 'SQL_NAME')) !== -1)
                            ) {
                        let invalidate = false,
                            dict0 = modifiers ?  modifiers.reduce((acc: {[key: string]: Rest.ContextSubstitute}, item) => (acc[item.reference] = item, acc), {}) : {},
                            dict1: {[key: string]: Rest.ContextSubstitute} = {};

                        replacements.modifiers = values.map(row => {
                            let reference = row[target],
                                replacement = row[table],
                                modifier = dict0[reference];

                            if (!modifier || modifier.replacement !== replacement) {
                                (modifier || rest.pushModifier(modifier = new AFC.Rest.ContextSubstitute(reference))).replacement = replacement;
                                invalidate = true;
                            }
                            dict1[modifier.reference] = modifier;
                            return modifier;
                        });
                        if (modifiers) {
                            modifiers.forEach(modifier => dict1[modifier.reference] || (invalidate = true, rest.popModifier(modifier)));
                            if (invalidate) {
                                await dashboardActivity.invalidateStaticLayers();
                            }
                        }
                    }
                }
            }
        }
        return <IReplacements>replacements;
    }
        
    export interface IStoreSourceRemote {
        confirmUpdate?: (result: Data.IUpdateCommandResult) => Promise<boolean>;
        onUpdate: (results: ReadonlyArray<Data.IUpdateCommandResult>, force: boolean, replacements: ReadonlyArray<Rest.ContextSubstitute>) => void;
    }
    
    class HistorizedModelRemote implements Data.IHistorizedModelRemote {
        public readonly activity: DashboardActivity;
        public readonly remote: IStoreSourceRemote;
        
        constructor(activity: DashboardActivity, remote: IStoreSourceRemote) {
            this.activity = activity;
            this.remote = remote;
        }
        
        public async confirmUpdate(result: Data.IUpdateCommandResult): Promise<boolean> {
            return this.remote?.confirmUpdate ? this.remote.confirmUpdate(result) : true;
        }
        
        public onUpdate(results: ReadonlyArray<Data.IUpdateCommandResult>, force: boolean) {
            let modifiers = results && this.activity[_replacements]?.modifiers,
                 invalidates = modifiers && results.reduce((acc: {[key: string]: string}, result) => {
                    let items = result?.invalidate;
                    return items ? items.reduce((acc, item) => (acc[item.reference] = item.replacement, acc), acc) : acc;
                }, {}),
                updates =  invalidates && Object.entries(invalidates).reduce((acc, [key, value]) => {
                let item = modifiers.find(item => item.reference === key);
                    if (item && item.replacement !== value) {
                        item.replacement = value;
                        acc.push(item);
                    }
                    return acc;
                }, []);
            updates?.length && this.activity.invalidateStaticLayers();
            this.remote?.onUpdate(results, force, updates);
        }
    }
        
    export class DashboardActivity extends RestActivity implements Data.ISessionProvider {
        /** @internal */
        private [_resources]: AFC.Data.ITableResource[]&{[key: string]: AFC.Data.ITableResource};
        /** @internal */
        private [_loading]: boolean;
        /** @internal */
        private [_storage]: Storage;
        /** @internal */
        private [_session]: string;
        /** @internal */        
        public [_replacements]: Partial<{
            sequence: Symbol;
            modifiers: Rest.ContextSubstitute[];
        }>;
        protected readonly _sink = new Tools.EventSink(this);
        
        public async refreshStamps(): Promise<void> {
            delete this[_session];
            this[_resources] && this[_resources].forEach(resource => resource.refreshStamps());

            let databases = await this.getRestModel().schema.getDatabases();
            databases && databases.forEach(database => database.noCache && database.refresh());
            
            let replacements = this[_replacements];
            if (replacements) {
                delete replacements.sequence;
            }
        }

        public getSession(): string {
            return this[_session] || (this[_session] = AFC.Tools.Data.generateRndString(32));
        }

        public getHistorizedTableResources(): Promise<AFC.Data.ITableResource[]&{[key: string]: AFC.Data.ITableResource}> {
            return this[_resources] ? Promise.resolve(this[_resources]) : new Promise(resolve => {
                this._sink.notify(<any>EventType.ResourceReady, (/*event: Tools.IEvent*/)=> resolve(this[_resources]));
                if (!this[_loading]) {
                    let restModel = this.getRestModel(),
                        resources: AFC.Data.ITableResource[]&{[key: string]: AFC.Data.ITableResource} = <any>[];
                    
                    this[_loading] = true;
                    restModel.schema.getDatabases()
                        .then(databases => Promise.all(databases.map(database => 
                            database.getTables().then(tables => 
                                tables.forEach(table => {
                                    if (table.isHistoricized && (table.type !== AFC.Data.TableType.seamless)) {
                                        let resource = AFC.Data.tableResource(this);
                                        resource.reset(restModel, database.name, table.name);
                                        resources.push(resource);
                                        resources[table.fullName.toLowerCase()] = resource;
                                    }
                            })))))
                        .then(() => {
                            this[_resources] = resources;
                            this._sink.fireEvent(<any>EventType.ResourceReady);
                        });
                }
            });
        }
        
        public async loadHistory(): Promise<any> {
            let resources = await this.getHistorizedTableResources();
            return Promise.all([...resources.map(resource => resource.load()), _getInjections(this, this[_replacements] || (this[_replacements] = {}))]);
        }

        public async getStoreSource<K extends ParcType>(dbName: string, name: string, parcType: K, remote?: IStoreSourceRemote): Promise<IParcFactory[K]> {
            let resources = await this.getHistorizedTableResources(),
                resource = resources[Tools.Data.makeSQLName(dbName, name).toLowerCase()],
                source: AFC.Data.StoreSource,
                rest = this.getRestModel();

            if (!resource) {
                resource = AFC.Data.tableResource(this);
                resource.reset(rest, dbName, name);
            }
            source = new (ParcFactory[parcType])(resource, new HistorizedModelRemote(this, remote));
            await Promise.all([source.getMetadata(), this.loadHistory()]);
            return <IParcFactory[K]>source;
        }

        public async invalidateStaticLayers(): Promise<any> {
            let mapViews = await this.getRestModel().globals.getMapViews();
            return Promise.all(mapViews.map(mapView => mapView.getMetadata().then(mapView => mapView.layers.forEach(layer => layer.invalidate()))));
        }

        protected async _pushContextModifiers(dashboard: Dashboards.IDashboard, storeSource: Data.StoreSource, context: any): Promise<void> {
            new AFC.Tools.Dashboards.StoreSourceLoader(dashboard, storeSource);
        }

        public async getDashboards(descriptors: ReadonlyArray<Dashboards.IDashboardDescriptor>, storeSource: Data.StoreSource, store: Data.IReadonlyStore, project?: AFC.Tools.ParcEdition.IProject, context?: any): Promise<ReadonlyArray<Dashboards.IDashboard>> {
            let dashboards = await Promise.all(descriptors.map(descriptor => descriptor && AFC.Dashboards.dashboard(descriptor, project?.id))),
                name = storeSource.fullName,
                filtered = dashboards.filter(dashboard => {
                    let sitesTable: Readonly<Dashboards.ISitesTable>;
                    return dashboard.zones.some(zone => (dashboard.mainCluster === zone.cluster) && (sitesTable = (<any>zone.reference).sitesTable) && !name.localeCompare(sitesTable.table, undefined, { sensitivity: 'accent' })) && (AFC.Tools.Dashboards.setClusterSite(dashboard.mainCluster, store), true);
                });
            return filtered.length ? Promise.all(filtered.map(dashboard => this._pushContextModifiers(dashboard, storeSource, context))).then(() => dashboards) : dashboards;
        }
        
        public getDataStorage(): Storage {
            return this[_storage] || (this[_storage] = new AFC.Application.Storage(this.getRestModel().baseUrl));
        }
    }
}

