/**
 * Created by jean.rennes on 17/05/2019.
 */
///<reference path="../gui/Globals.ts" /> 

namespace AFC.Application {
    export class DataGrabber extends Tools.EventSink {
        private _cache: {[key: string]: any};
        public readonly method: string;
        public readonly async: boolean;
        public readonly dataType: string;
        
        constructor(method: 'GET'|'POST' = 'GET', async: boolean = true, dataType: string = 'json') {
            super();
            this.method = method;
            this.async = async;
            this.dataType = dataType;
        }

        protected _onAlways(key: string, jqXHR: JQueryXHR, textStatus: string): void {
            let dataTable: Data.IDataTable = AFC.Data.updateTableData(jqXHR.responseJSON);

            this._cache[key] = dataTable?.columns && dataTable.values ? new AFC.Data.DataModel(dataTable.columns, dataTable.primaryKey, dataTable.values): null;
            HideWaitBar();
            this.fireEvent(Tools.EventType.UserEvent);
        }
                    
        public getData(url: string, body: any): Promise<any> {
            let key: string = CryptoJS.SHA1(url + JSON.stringify(body)).toString(CryptoJS.enc.Base64),
                cache = this._cache || (this._cache = {});
            
            return cache[key] !== void 0 ? Promise.resolve(cache[key]) : new Promise((resolve: (value: any) => void)=> {
                this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve(this._cache[key]));
                if (!cache.hasOwnProperty(key)) {
                    let options: JQuery.AjaxSettings = {
                        data: body,
                        method: this.method,
                        dataType: this.dataType,
                        complete: this._onAlways.bind(this, key)
                    };
                    ShowWaitBar();
                    this._cache[key] = void 0;
                    jQuery.ajax(url, options);
                }
            });
        }
    }
}