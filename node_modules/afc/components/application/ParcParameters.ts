/**
 * Created by jean.rennes on 15/05/2019.
 */
///<reference path="../models/data/StoreSource.ts" />
///<reference path="../helpers/Mutex.ts" />

namespace AFC.Application {
    const _updater = Symbol(),
        _code = Symbol(),
        _project = Symbol(),
        _selector = Symbol();
    
    function _getData(dashboard: Dashboards.IDashboard, viewName: string): Promise<AFC.Data.DataModel> {
        let view = <Dashboards.IMapView>Tools.findByIdOrName(viewName, dashboard.views);
        view.invalidate();
        return view.getLayer(0).then(layer => layer.dataModel);
    }
            
    class DashboardParcUpdater {
        constructor(historizedModel: Data.HistorizedModel, dashboard: Dashboards.IDashboard, view: string) {
            this.historizedModel = historizedModel;
            this.dashboard = dashboard;
            this.view = view;
            this.dirty = new Set;
            this.lock = new Tools.Mutex;            
        }
        
        public init(content: Data.ITableResourceContent): Rest.ResourceSubstitute {
            let requestBuilder = this.dashboard.requestBuilder;
            
            this._content = content;
            return this._updater = requestBuilder.pushModifier(new Rest.ResourceSubstitute(requestBuilder, content.descriptor.fullName));
        }
        
        protected async _update(columns: ReadonlyArray<Data.IDBColumn>, project?: { readonly id: string, readonly info?: Data.IDBHistoryBranchInfo}): Promise<boolean> {
            let result = await this.lock.acquire() === Tools.MutexState.acquired;
            
            if (result) {
                try {
                    let historizedModel = this.historizedModel,
                        info: Data.IDBHistoryBranchInfo,
                        events: Data.IModificationEvents,
                        branch: string;
                    
                    if (project) {
                        branch = project.id;
                        if (this._content.descriptor.isHistoricized) {
                            info = project.info;
                        }
                    }
                    if (result = this.dirty.has(branch)) {
                        events = historizedModel.generateEvents(branch);
                        this._updater.create(new Data.ModificationCreation(this._content.resource, events, info));
                        historizedModel.applyValuesSilent(await _getData(this.dashboard, this.view), columns, branch);
                        this.dirty.delete(branch);
                    }
                }
                finally {
                    this.lock.release();
                }
            }
            return result;
        }

        public async ready(wait: boolean, project?: { readonly id: string, readonly info?: Data.IDBHistoryBranchInfo}): Promise<boolean> {
            let columns = this.columns,
                branch = project?.id;
            
            if (columns && this.isDirty(branch)) {
                const updates = [this._update(columns, project), project && this.dirty.has(void 0) && this._update(columns)];
                if (wait)
                    await Promise.all(updates);
            }
            return true;
        }
        
        public move(point: GeoJSON.Point): void {
            this.columns && this.historizedModel.clearColumns(this.columns);
            this.dashboard.mainCluster.setSite(point);
        }
        
        public invalidate(branch?: string): void {
            this.dirty.add(branch);
        }
        
        public isDirty(branch?: string): boolean {
            return this.dirty.has(void 0) || this.dirty.has(branch);
        }
        
        public release(): void {
            let updater = this._updater;
            
            updater.release();
            this.dashboard.requestBuilder.popModifier(updater);
        }
        
        public readonly historizedModel: Data.HistorizedModel;
        public readonly dashboard: Dashboards.IDashboard;
        public readonly view: string;
        public readonly dirty: Set<string|undefined>;
        public readonly lock: Tools.Mutex;
        private _content: Data.ITableResourceContent;
        private _updater: Rest.ResourceSubstitute;
        public columns: ReadonlyArray<Data.IDBColumn>;
    }
   
    function _checkEventField(item: Data.IHistorizedDataEventItem, column: string, branch?: string): boolean {
        return (item.type === Data.DataEventType.create || (item.type === Data.DataEventType.modify && item.values.hasOwnProperty(column))) && (!branch === !item.branch);
    }
     
    export class DashboardParc extends Data.StoreSource {
        public get dirty(): boolean {
            const updater = this[_updater];
            return updater?.isDirty(this.branch);
        }
        
        protected override _load(content: Data.IStoreTableResourceContent): Promise<AFC.Data.DataModel> {
            let updater = this[_updater],
                replacement = updater.init(content);

            replacement.replacement = content.resource;
            return _getData(updater.dashboard, updater.view);
        }
        
        protected override _onDirty(event: AFC.Data.IDataEvent<Data.IHistorizedDataEventItem>): void {
            const updater = this[_updater],
                data = updater.columns && event && event.data,
                name = this.geometry.name,
                branch = this.branch;
                                        
            if (data) {
                if (data.reset) {
                    updater.invalidate();
                    updater.invalidate(branch);
                } else if (data.items) {
                    data.items.forEach(item => {
                        if (_checkEventField(item, name)) {
                            updater.invalidate();
                        }
                        else if (_checkEventField(item, name, branch)) {
                            updater.invalidate(branch);
                        }
                    });
                }
            }
            super._onDirty(event);
        }

        protected override _setBranch(project: AFC.Data.IStoreSourceProject, commit?: boolean): Promise<AFC.Data.ITableResourceContent> {
            const updater = this[_updater];

            this[_project] = project;
            if (project && updater) {
                updater.invalidate(project.id);
            }
            return super._setBranch(project, commit);
        }
        
        public override async ready(dashboardData?: boolean): Promise<boolean> {
            const ready = await super.ready(),
                updater = this[_updater];
            
            return ready && updater ? await updater.ready(dashboardData, this[_project]) : ready;
        }
        
        public override async init(project?: Data.IStoreSourceProject): Promise<boolean> {
            const ready = await super.init(project),
                columns = ready && project && this.columns.filter(column => column.readOnly);
            if (columns && columns.length) {
                this[_updater].columns = columns;
                this._historizedModel.clearBranchesColumnsSilent(columns);
            }
            return ready;
        }
        
        public override clone(): DashboardParc {
            let clone = <DashboardParc>super.clone();
            
            clone[_updater] = this[_updater];
            clone[_project] = this[_project];
            return clone;
        }
        
        public override release(): void {
            let updater = this[_updater];
            
            super._release();
            if (updater) {
                updater.release();
                delete this[_updater];
            }
        }

        public move(point: GeoJSON.Point): void {
            const updater = this[_updater];
            return updater && updater.move(point);
        }
                
        public setParameters(dashboard: Dashboards.IDashboard, point: GeoJSON.Point, view: string): void {
            (this[_updater] = new DashboardParcUpdater(this._historizedModel, dashboard, view)).move(point);
        }
        
        public override modify(key: ReadonlyArray<any>, values: {[key: string]: any}): void {
            const updater = this[_updater],
                columns = updater && updater.columns;
            
            if (columns && values[this.geometry.name]) {
                values = $.extend(columns.reduce((acc: {[key: string]: any}, column) => (acc[column.name] = null, acc), {}), values);
            }
            super.modify(key, values);
        }
        
        /** @internal */
        private [_updater]: DashboardParcUpdater;
        /** @internal */
        private [_project]: { readonly id: string, readonly info?: Data.IDBHistoryBranchInfo};
    }

    export class AdminParc extends Data.StoreSource {
        public setCode(selector: string, code: string|number) {
            this.release();
            this[_selector] = selector;
            this[_code] = code;
        }
                    
        protected override _load(content: Data.IStoreTableResourceContent) : Promise<AFC.Data.IDataTable> {
            let restModel = content.descriptor.database.schema.restModel,
                parameter = Tools.Data.QueryTemplateParameters[Tools.Data.isValid(Data.DataKind.real, this[_code]) ? Data.DataKind.real : Data.DataKind.character],
                command = {
                    commandText: `SELECT * FROM ${content.resource} WHERE ${this[_selector]}=:param0(${parameter})`,
                    parameters: {param0: this[_code]},
                    maximumRows: 1000000
                };
            return new AFC.Data.Queries(restModel).getDataTable([command]).then(tables => tables[0]);
        };
        
         /** @internal */
        private [_selector]: string;
        /** @internal */
        private [_code]: string|number;
   }
}