/**
 * Created by jean.rennes on 14/05/2019.
 */
///<reference path="../gui/Globals.ts" /> 

namespace AFC.Application {
    let _mru: string[];
    const _id = 'E8F463C8-5ECE-494A-8F18';

    function _checkLength(): void {
        let maxElement = BrandSelectorConfiguration.mruMaxElement;
        (_mru.length > maxElement) && (_mru.length = maxElement);       
    }
    
    function _getOrder(ref: { readonly [key: string]: number }): {readonly [key: string]: number} {
        let order = ref ? Object.create(ref) : {};
        _mru.forEach((brand, indice) => {
            order[brand] = indice - 0x7FFFFFFF;
        });
        return order;
    }
    
    export interface IBrandSelectorItem {
        readonly value: number;
        readonly label: string;
        readonly image: string;
        color: string;
    }
    
    export interface IBrandSelectorConfiguration {
        readonly filterEnabled: boolean;
        readonly template: string;
        compare(brand0: string, brand1: string): number;
        map(symbolFactory: Globals.SymbolFactory, brand: string, businessCode: string, indice: number): IBrandSelectorItem;
        filter(regExps: ReadonlyArray<RegExp> | null, brand: string): boolean;
        onClick(brand: string, image: string): void;
    }


    export class BrandSelectorConfiguration implements IBrandSelectorConfiguration {
        public filterEnabled: boolean = true;
        public template: string = '<span style="background-color: {{color}};"><input id="brands_{{value}}" type="radio" name="brands" value="{{value}}"><label for="brands_{{value}}" style="background-image: url(\'{{image}}\');" name="{{label}}"></label></span>';
        protected _ref: { readonly [key: string]: number };
        protected _order: {readonly [key: string]: number};
        
        protected _getOrder() {
            return this._order || (this._order = _getOrder(this._ref));
        }
        
        public static mruMaxElement = 5;
        
        constructor(order?: { readonly [key: string]: number }) {
            (_mru || (_mru = Tools.Storage.getItem(_id) || []));
            this.filterEnabled = true;
            this._ref = order;
            _checkLength();
            return this;
        }
        
        public compare(brand0: string, brand1: string): number {
            let order = this._getOrder();
            return (order[brand0] || 0xFFFFFFFF) - (order[brand1] || 0xFFFFFFFF);
        }
        
        public map(symbolFactory: Globals.SymbolFactory, brand: string, businessCode: string, indice: number): IBrandSelectorItem {
            return {
                value: indice,
                label: brand,
                image: _getSymbol(symbolFactory, brand, businessCode),
                color: this._getOrder().hasOwnProperty(brand) ? '#FAFADE' : 'transparent'
            };
        }
        
        public filter(regExps: ReadonlyArray<RegExp> | null, brand: string) {
            return !regExps || regExps.every(regex => brand.match(regex));
        }
        
        public onClick(brand: string, image: string) {
            let i;

            if ((i = _mru.indexOf(brand)) !== 0) {
                if (i !== -1) {
                    _mru.splice(i, 1);
                }
                _mru.unshift(brand);
                _checkLength();
                Tools.Storage.setItem(_id, _mru);
                delete this._order; 
            }
        }
    }

    function _getSymbolBase(symbolFactory: Globals.SymbolFactory, symbol: string): string {
        let img;
        return (symbolFactory && symbol && (img = symbolFactory.symbol(symbol)) && img.url) || Tools.Style.transparent1Pixel;
    }

    function _getBusinessCode(symbols: {readonly [key: string]: string;}, businessCode: string): string {
        let key = businessCode;

        if (symbols && !symbols[key]) {
            for (key in symbols) {
                break;
            }
        }
        return key;
    }

    function _getSymbol(symbolFactory: Globals.SymbolFactory, brand: string, businessCode: string): string {
        let symbols = symbolFactory && symbolFactory.symbols(brand),
            symbol = symbols && symbols[_getBusinessCode(symbols, businessCode)];
        return _getSymbolBase(symbolFactory, symbol);
    }

    interface IBrandSelectorValue {
        brand: string;
        symbol: string;
    }
    
    interface IBrandSelectorReference {
        value: number;
        indice: number;
        brand: string;
        businessCode: string;
        symbol: string;
    }

    function _equalValue(value0: IBrandSelectorValue, value1: IBrandSelectorValue): boolean {
        return (value0 === value1) ||  (value0 && value1 && (value0.brand === value1.brand) && (value0.symbol === value1.symbol));
    }

    function _updateBrandsControl(control: Controls.Repeater, brands: ReadonlyArray<string>, symbolFactory: Globals.SymbolFactory, selected: IBrandSelectorValue, configuration: IBrandSelectorConfiguration, maxItem: number, pattern: string): ReadonlyArray<IBrandSelectorValue> {
        let localCompare = function(reference0: IBrandSelectorReference, value1: IBrandSelectorReference) {
            return (configuration.compare && configuration.compare(reference0.brand, value1.brand)) || (reference0.value - value1.value) || (reference0.indice - value1.indice);
        };
        let regExps = pattern && (pattern.split(' ').map(function(word) {
            return new RegExp(`\\b${word}`, 'i');
        }));
        let references: IBrandSelectorReference[] = [];
        let found, input;

        maxItem = Math.min(maxItem, brands.length);
        brands.forEach((brand: string, value: number) => {
            if (brand && configuration.filter(regExps, brand)) {
                let symbols = symbolFactory.symbols(brand),
                    businessCode: string,
                    image,
                    dict: {[key: string]: true} = {},
                    reference: IBrandSelectorReference,
                    i: number, indice = 0;
                
                for (businessCode in symbols) {
                    reference = <any>{
                        value: value,
                        indice: indice,
                        brand: brand,
                        businessCode: businessCode
                    };
                    if (i === void 0) {
                        i = Tools.lower_bound(references, reference, localCompare);
                    }
                    if (i >= maxItem) {
                        break;
                    }
                    image = symbols[businessCode];
                    if (!dict[image]) {
                        dict[image] = true;
                        reference.symbol = image;
                        if (i < references.length) {
                            if (i < maxItem) {
                                references.splice(i, 0, reference);
                            }
                            (references.length > maxItem) && references.pop();
                        } else {
                            references.push(reference);
                        }
                        ++i;
                        ++indice;
                    }
                }
            }
        });

        references.forEach((reference, i) => {
            control.addItem(configuration.map(symbolFactory, reference.brand, reference.businessCode, i));
            _equalValue(reference, selected) && (found = i);
        });
        (found !== void 0) && (input = <HTMLInputElement>control.node.querySelector(`#brands_${found}`)) && (input.checked = true);
        return references;
    }

    function _setImage(control: HTMLElement, symbol: string, symbolFactory: Globals.SymbolFactory): void {
        control.style.backgroundImage = `url('${_getSymbolBase(symbolFactory, symbol)}')`;
    }

    const _value = Symbol();

    export class AfcBrand extends HTMLElement {
        /** @internal */
        private [_value]: string;
        
        public static observedAttributes = ['value'];
        
        public get value(): string {
            return this[_value];
        }
        
        public set value(value: string) {
            if (this[_value] !== value) {
                this[_value] = value;
                this.connectedCallback();
            }
        }
        
        public connectedCallback(): void {
            let value: string = this[_value];
            
            $(this).empty();
            (value !== void 0) && (value !== null) && this.appendChild(document.createTextNode(value));
        }
        
        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            this.value = newVal;
        }
    }

    const _symbols = Symbol();

    export class AfcSymbol extends gui.AfcGuiElement {
        /** @internal */
        private [_symbols]: Globals.SymbolFactory;
        /** @internal */
        private [_value]: string;
        public static observedAttributes = gui.AfcGuiElement.observedAttributes.concat(['value']);
        
        public get symbols(): Globals.SymbolFactory {
            return this[_symbols];
        }

        public set symbols(value: Globals.SymbolFactory) {
            _setImage(this, this[_value], this[_symbols] = value);
        }

        public get value(): string {
            return this[_value];
        }
        
        public set value(value: string) {
            (this[_value] !== value) && _setImage(this, this[_value] = value, this[_symbols]);
        }
        
        public connectedCallback(): void {
            let form = $(this).closest('afc-gui-store-form');

            form.length && _setImage(this, this[_value], this[_symbols]);
        }
        
        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            (attrName === 'value') ? this.value = newVal : super.attributeChangedCallback(attrName, oldVal, newVal);
        }
    }

    function _setContent(selector: AfcBusinessCodeSelector, value: string) {
        let text = value == null ? '' : value;
        $(selector).empty().append(document.createTextNode(text));
    }

    const _onClick = Symbol(),
        _change = Symbol(),
        _onKeyDown = Symbol(),
        _onMouseLeave = Symbol(),
        _onChange = Symbol(),
        _dispatch = Symbol();
        
    export class AfcBusinessCodeSelector extends gui.AfcGuiElement {
        /** @internal */
        private [_value]: string;
        public options: ReadonlyArray<string>;
        
        /** @internal */
        private [_onClick](/*event: MouseEvent*/) {
            let options = this.options, value;
            if (options && options.length) {
                value = this.options[(options.indexOf(this.value) + 1) % options.length];
                (this.value !== value) && gui._dispatchEvent(this, 'change', {detail: this.value = value});
            }
        };
        
        public static observedAttributes = gui.AfcGuiElement.observedAttributes.concat(['value']);
        
        constructor() {
            super();
            this.addEventListener('click', this[_onClick].bind(this), true);
        }
        
        public get value(): string {
            return this[_value];
        }
        
        public set value(value: string) {
            (this[_value] !== value) && _setContent(this, this[_value] = value);
        }
        
        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            (attrName === 'value') ? this.value = newVal : super.attributeChangedCallback(attrName, oldVal, newVal);
        }
    }

    const _configuration = Symbol(),
        _timeout = Symbol(),
        _control = Symbol(),
        _connected = Symbol(),
        _container = Symbol(),
        _filter = Symbol(),
        _setFilter = Symbol(),
        _items = Symbol(),
        _selected = Symbol(),
        _form = Symbol(),
        _onFormClickHandler = Symbol(),
        _refresh = Symbol(),
        _generateFilter = Symbol(),
        _onFormClick = Symbol(),
        _refreshBrands = Symbol(),
        _visible = Symbol();

    function _getItem(selector: AfcBrandSelector, input: HTMLInputElement): IBrandSelectorValue {
        return input.value && selector[_items] && selector[_items][parseInt(input.value)];
    }

    export class AfcBrandSelector extends gui.AfcGuiElement {
        /** @internal */
        private [_configuration]: IBrandSelectorConfiguration;
        /** @internal */
        private [_symbols]: Globals.SymbolFactory;
        /** @internal */
        private [_timeout]: number;
        /** @internal */
        private [_control]: Controls.Repeater;
        /** @internal */
        private [_connected]: boolean;
        /** @internal */
        private [_container]: HTMLDivElement;
        /** @internal */
        private [_filter]: HTMLInputElement;
        /** @internal */
        private [_setFilter]: (pattern: string) => void;
        /** @internal */
        private [_selected]: IBrandSelectorValue;
        /** @internal */
        private [_form]: AfcStoreForm;
        /** @internal */
        private [_onFormClickHandler]: (event: MouseEvent) => void;
        /** @internal */
        public [_visible]: boolean;
        /** @internal */
        public [_items]: ReadonlyArray<IBrandSelectorValue>;
        public disabled: boolean;
        public maxItem: number;
        
        public static observedAttributes = gui.AfcGuiElement.observedAttributes.concat(['max-item', 'disabled']);
        
        /** @internal */
        private [_onChange](event: Event) {
            let label = <HTMLLabelElement>event.target,
                input,
                hover;
            if (label.htmlFor && (input = this.querySelector<HTMLInputElement>(`input#${label.htmlFor}`)) && (hover = _getItem(this, input))) {
                gui._dispatchEvent(this, 'hover-change', {detail: hover});
            }
        }
        
        /** @internal */
        private [_onMouseLeave](/*event: MouseEvent*/) {
            gui._dispatchEvent(this, 'hover-change');
        }
        
        /** @internal */
        private [_onClick](event: MouseEvent): void {
            let input = <HTMLInputElement>event.target,
                clicked,
                toggle;
                
            if (input.getAttribute && (input.getAttribute('name') === 'brands') && (clicked = _getItem(this, input))) {
                if ((toggle = this.getAttribute('toggle')) && (document.getElementById(toggle))) {
                    $(this).hide();
                }
                if (!_equalValue(clicked, this[_selected])) {
                    this.getConfiguration().onClick(clicked.brand, clicked.symbol);
                    gui._dispatchEvent(this, 'change', {detail: this.selected = clicked});
                }
            }
        }
        
        /** @internal */
        private [_refreshBrands](): void {
            let control = this[_control],
                symbolFactory = this[_symbols],
                pattern = this[_generateFilter](),
                brands: ReadonlyArray<string>,
                configuration: IBrandSelectorConfiguration;
                
            if (control && symbolFactory && (brands = symbolFactory.brands) && (configuration = this.getConfiguration())) {
                control.setTemplate(configuration.template);
                (this[_setFilter] = (pattern: string) => {
                    let labels, mouseenter: (event: MouseEvent) => void;
                    
                    control.empty();
                    this[_items] = _updateBrandsControl(control, brands, symbolFactory, this[_selected], configuration, this.maxItem, pattern);
                    labels = <NodeListOf<HTMLLabelElement>> control.node.querySelectorAll('LABEL');
                    for (let i = 0; i < labels.length; ++i) {
                        labels[i].onmouseenter = mouseenter || (mouseenter = this[_onChange].bind(this));
                    }
                })(pattern);
            }
        }
        
        /** @internal */
        private [_onKeyDown](event: MouseEvent) {
            let target = <HTMLInputElement>event.target;

            if (target.getAttribute && target.getAttribute('name') === 'filter') {
                let setFilter = this[_setFilter];
                (this[_timeout] !== void 0) && clearTimeout(this[_timeout]);
                setFilter && (this[_timeout] = setTimeout(() => {
                    delete this[_timeout];
                    setFilter(target.value);
                }, 500));
            }
        }
        
        /** @internal */
        private [_refresh](): void {
            if (this.disabled) {
                $(this).hide();
            } else if (this[_connected]) {
                this[_refreshBrands]();
            }
        }        
        
        /** @internal */
        private [_generateFilter](): string {
            let str, filter = this[_filter], input;
            if (this[_container]) {
                if (this.getConfiguration().filterEnabled) {
                    if (filter) {
                        input = filter.querySelector('input');
                    } else {
                        (input = (this[_filter] = <HTMLInputElement>this[_container].appendChild(document.createElement('div'))).appendChild(document.createElement('input'))).type= "text";
                        input.placeholder = "Filtrer les enseignes ...";
                        input.setAttribute('name', 'filter');
                    }
                    str = input.value;
                } else if (filter) {
                    this[_container].removeChild(filter);
                    delete this[_filter];
                }
            }
            return str;
        }
         
        /** @internal */
        private [_onFormClick](event: MouseEvent) {
            let target = <HTMLElement>event.target;
            
            if (!this.disabled && target.id === this.getAttribute('toggle')) {
                let query = $(this);
                (this[_visible] = !query.is(':visible')) ? query.show() : query.hide();
            }
        }
                       
        constructor() {
            super();
            this.addEventListener('click', this[_onClick].bind(this), true);
            this.addEventListener('keydown', this[_onKeyDown].bind(this));
            this.addEventListener('mouseleave', this[_onMouseLeave].bind(this));            
            this.addEventListener('change', this[_onChange].bind(this));
            this.maxItem = 10;
        }
        
        public getConfiguration(): IBrandSelectorConfiguration {
            return this[_configuration] || (this[_configuration] = new BrandSelectorConfiguration());
        }
        
        public setConfiguration(value: IBrandSelectorConfiguration): void {
            this[_configuration] = value;
            this[_refresh]();
        }
            
        public get symbols(): Globals.SymbolFactory {
            return this[_symbols];
        }

        public set symbols(value: Globals.SymbolFactory) {
            this[_symbols] = value;
            this[_refresh]();
        }
        
        public get selected(): IBrandSelectorValue {
            return this[_selected];
        }

        public set selected(value: IBrandSelectorValue) {
            if (!_equalValue(value, this[_selected])) {
                this[_selected] = value;
                this[_refresh]();
            }
        }
        
        public connectedCallback(): void {
            let form: JQuery = $(this).closest('afc-gui-store-form');

            this[_connected] = true;
            if (!this[_container]) {
                this[_container] = this.appendChild(document.createElement('div'));
                this[_control] = new AFC.Controls.Repeater(this[_container].appendChild(document.createElement('span')));
            }
            if (form.length && (this[_form] = <AfcStoreForm>form[0])) {
                this[_refresh]();
                this[_form].addEventListener('click', this[_onFormClickHandler] = this[_onFormClick].bind(this));
            }
        }
        
        public disconnectedCallback(): void {
            this[_onFormClickHandler] && this[_form].removeEventListener('click', this[_onFormClickHandler]);
            delete this[_onFormClickHandler];
            this[_connected] = false;
        }
        
        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            switch (attrName) {
                case 'disabled':
                    this.disabled = newVal !== null;
                    this[_refresh]();
                    break;
                case 'max-item':
                    isNaN(this.maxItem = parseInt(newVal)) && (this.maxItem = 10);
                    this[_refresh]();
                    break;
                default:
                    super.attributeChangedCallback(attrName, oldVal, newVal);
                    break;
            }
        }
        
        public setVisibility(show: boolean): void {
            (this[_visible] = show) ? $(this).show() : $(this).hide();
        }
    }

    function _getSafeName(template: HTMLTemplateElement) {
        let s = template.getAttribute('name'); 
        return s === null ? "" : s;
    }

    const _casts: {[key: number]: (value: any) => any} = {
        [Data.DataKind.real]: AFC.Tools.Data.toFloat,
        [Data.DataKind.integer]: AFC.Tools.Data.toInteger,
        [Data.DataKind.bool]: AFC.Tools.Data.toBoolean,
        [Data.DataKind.date]: (value: string) => new Date(value+"T00:00")
    };
    
    function _getInputForQualifier<T extends HTMLElement&{value: string}>(form: AfcStoreForm, store: AFC.Data.IStore, qualifier: AFC.Data.Qualifier): T {
        let name: string = AFC.Data.qualifier(qualifier),
            id: string = form.getAttribute(name),
            column: AFC.Data.IDBColumn;
        return id !== null ? 
            <any>document.getElementById(id) : 
            form.querySelector(`[bind="qualifier"][name="${name}"]`) || (store && (column = store.getQualifiedColumn(qualifier)) && form.querySelector(`[bind="column"][name="${column.name}"]`));
    }
    
    function _updateInputValue<T extends HTMLElement&{value: string}>(form: AfcStoreForm, update: boolean, store: AFC.Data.IStore, qualifier: AFC.Data.Qualifier, value: string, input: T = _getInputForQualifier(form, store, qualifier)): boolean {
        if (input) {
            let ret = value !== input.value;
            if (ret) {
                input.value = value;
            }
            update && form[_change](input);
            return ret;
        }
    }
    
    function _updateBrandSelector(form: AfcStoreForm, brand: string, symbol_: string): void {
        let selector = form.querySelector<AfcBrandSelector>('afc-gui-brand-selector');
        selector && (selector.selected = {
            brand: brand,
            symbol: symbol_
        });
    }
    
    function _updateBusinessCodeControl(businessCodeControl: AfcBusinessCodeSelector, symbols: {readonly [key: string]: string;}): void {
        let options: string[] = [];

        for (let option in symbols) {
            options.push(option);
        }
        businessCodeControl.options = options;
        options.length > 1 ? $(businessCodeControl).show() : $(businessCodeControl).hide(); 
    }

    function _tryCast(column: Data.IDBColumn, value: string|boolean): any {
        let cast, ret;
        return value === '' || value === null ?
            ret = null:(
                cast = _casts[column.type],
                ret = cast && cast(value),
                ret === void 0 ? value : ret
            );
    }
    
    function _setData(store: AFC.Data.IStore, input: HTMLElement & Partial<HTMLInputElement>, column: Data.IDBColumn, rootForm: HTMLElement): boolean {
        if (input.tagName !== 'LABEL') {
            let value: any, ret;
            
            if (store.setData) {
                switch(input.type) {
                    case 'radio':
			            let name        = input.getAttribute('name'),
                            selector    = `input[type='radio'][name='${name}']:checked`,
                            val         = rootForm ? $(rootForm).find(selector).val() : $(selector).val();
                        
                        value = val === void 0 ? null : val;
                        break;
                    case 'checkbox':
                        value = input.checked;
                        break;
                    default:
                        value = input.value;
                        break;
                }
                ret = store.setData(column.name, _tryCast(column, value));
            }
            return ret;
        }
    }

    function _getData(store: AFC.Data.IStore, input: HTMLElement&{value: string, type?: string, checked?: boolean}, column: AFC.Data.IDBColumn, rootForm: HTMLElement): void {
        let value = store.getData(column.name);

        if (input.tagName === 'LABEL') {
            let str = value === null ? ' - ' : (Tools.Data.isNumber(value) ? new Intl.NumberFormat().format(value) : value),
                query = $(input);
                
            query.empty().append(document.createTextNode(str));
        } else {
            switch(input.type) {
                case 'radio':
                    let name        = input.getAttribute('name'),
                        selector    = `input[type='radio'][name='${name}']`,
                        radios      = rootForm ? $(rootForm).find(selector) : $(selector);
                    radios.prop('checked', function (this: HTMLInputElement) { return _tryCast(column, this.value) === value;});
                    break;
                case 'checkbox':
                    input.checked = !!value;
                    break;
                case 'date':
                    {
                        if (!value)
                            input.value = value;
                        else {
                            if (column.type === Data.DataKind.date) {
                                input.value = `${value.getFullYear()}-${('0' + (value.getMonth()+1)).slice(-2)}-${('0' + (value.getDate()+1)).slice(-2)}`;
                            } else {
                                let offset  = value.getTimezoneOffset(),
                                    date    = new Date(value.getTime() + (offset*60000));
                                input.value = date.toISOString().split('T')[0];
                            }
                        }
                    }
                    break;
                default:
                    input.value = value;
                    break;
            }
        }
    }
    
    const _forEach = Symbol(),
        _on = Symbol(),
        _off = Symbol(),
        _store = Symbol(),
        _onDirty = Symbol(),
        _template = Symbol(),
        _oldTemplate = Symbol(),
        _templates = Symbol(),
        _dataChange = Symbol(),
        _detail = Symbol(),
        _onHover = Symbol(),
        _updateControls = Symbol();
    
    interface ITemplate extends Controls.ITemplate {
        parentNode: Node;
        refNode: Node;
    }
        
    export class AfcStoreForm extends gui.AfcGuiElement {
        /** @internal */
        private [_timeout]: number;
        /** @internal */
        private [_store]: AFC.Data.IStore;
        /** @internal */
        private [_template]: string;
        /** @internal */
        private [_oldTemplate]: string;
        /** @internal */
        private [_templates]: {[key: string]: ITemplate[]};
        /** @internal */
        private [_dataChange]: (event: CustomEvent<ReadonlyArray<AFC.Data.IDBColumn>>)=> void;
        /** @internal */
        private [_detail]: AFC.Data.IDBColumn[];
        /** @internal */
        private [_symbols]: Globals.SymbolFactory;
        
        public static observedAttributes = gui.AfcGuiElement.observedAttributes.concat(['template', 'datachange']);

        protected _onRestoreViewState(activity: Application.RestActivity, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void {
            if (activity.getRestModel) {
                let rest = activity.getRestModel();
                rest && rest.globals.getSymbolFactory().then(symbolFactory => {
                    let store: AFC.Data.IStore;
                    (this[_symbols] = symbolFactory) && (store = this[_store]) && this[_refresh](store);
                });
            }
            super._onRestoreViewState(activity, fragmentManager, savedInstanceState);
        }
                 
        /** @internal */
        private [_refresh](store: AFC.Data.IStore): void {
            if (this[_timeout] === void 0) {
                this[_timeout] = setTimeout(() => {
                    let symbolFactory = this[_symbols],
                        symbols,
                        brand = store.brand,
                        symbol_,
                        selector,
                        id,
                        key: string,
                        templates,
                        businessCodeControl;

                    delete this[_timeout];
                    if (this[_oldTemplate] !== void 0) {
                        let nodes = this.querySelectorAll(`[data-template="${this[_oldTemplate]}"]`), node;
                        for (let i = 0; i < nodes.length; ++i) {
                            (node = nodes[i]).parentNode.removeChild(node);
                        }
                        delete this[_oldTemplate];
                    }
                    
                    if (store) {
                        key = this[_template] || '';
                        if (this[_templates] && (templates = this[_templates][key])) {
                            templates.forEach(template => {
                                let fragment = document.createDocumentFragment();
                                Controls.Repeater.generateContent(fragment, key, template, store);
                                $(fragment).children().attr('data-template', key);
                                template.parentNode.insertBefore(fragment, template.refNode);
                            });
                            this[_oldTemplate] = key;
                        }
                        if (symbolFactory) {
                            (businessCodeControl = _getInputForQualifier<AfcBusinessCodeSelector>(this, store, AFC.Data.Qualifier.businessCode)) && (symbols = symbolFactory.symbols(brand)) && _updateBusinessCodeControl(businessCodeControl, symbols);
                            _updateBrandSelector(this, brand, store.symbol);
                            (symbol_ = <AfcSymbol>this.querySelector('afc-gui-symbol')) && (symbol_.symbols = symbolFactory);
                        }
                        this[_forEach](store, _getData);
                        if (symbolFactory)
                            (selector = <AfcBrandSelector>this.querySelector('afc-gui-brand-selector')) && (selector.symbols = symbolFactory);
                        selector && (selector[_visible] === void 0) && (id = selector.getAttribute('toggle')) && document.getElementById(id) && selector.setVisibility(!store.brand);
                        this.dispatchEvent(new CustomEvent('draw', {bubbles: false, detail: store}));
                    }
                }, 0);
            }
        }
                    
        /** @internal */
        private [_forEach](store: AFC.Data.IStore, onColumn: (store: AFC.Data.IStore, input: HTMLInputElement, column: AFC.Data.IDBColumn, rootForm: HTMLElement) => void): void {
            let inputs: NodeListOf<HTMLInputElement> = this.querySelectorAll('*[bind]');
            let i, column;

            for (i = 0; i < inputs.length; ++i) {
                (column = this._getColumnForInput(store, inputs[i])) && onColumn(store, inputs[i], column, this);
            }
        }
        
        /** @internal */
        private [_on]() {
            this[_store] && this[_store].on && this[_store].on(AFC.Tools.EventType.Dirty, this[_onDirty], this);
        }
        
        /** @internal */
        private [_off]() {
            this[_store] && this[_store].off && this[_store].off(AFC.Tools.EventType.Dirty, this[_onDirty], this);
        }
        
        /** @internal */
        private [_onDirty](event: AFC.Data.IDataRecordEvent) {
            let index: {[key: string]: HTMLInputElement}  = {}, store = this[_store];
            let _this = this;

            this[_forEach](store, (store: AFC.Data.IStore, input: HTMLInputElement, column: AFC.Data.IDBColumn) => {
                index[column.name] = input;
            });
            event.data.columns.forEach(function(column) {
                let input = index[column.name];
                input && _getData(store, index[column.name], column, _this);
            });
        }
        
        /** @internal */
        private [_onClick](event: MouseEvent) {
            let target = <HTMLElement>event.target;
            if (target.getAttribute && (target.getAttribute('name') === 'submit')) {
                event.stopPropagation();
                this.submit();
            }
        }
        
        /** @internal */
        private [_dispatch](column: AFC.Data.IDBColumn): true {
            let detail = this[_detail];
            if (!detail) {
                this[_detail] = detail = [];
                setTimeout(() => {
                    delete this[_detail];
                    this.dispatchEvent(new CustomEvent("dataChange", {bubbles: false, cancelable: false, detail: detail}));
                }, 0);
            }
            detail.push(column);
            return true;
        }
        
        /** @internal */
        public [_change](input: HTMLElement): boolean {
            let column: AFC.Data.IDBColumn = this._getColumnForInput(this.store, input);
            return column && _setData(this.store, <any>input, column, this) && this[_dispatch](column);
        }
        
        private _getColumnForInput(store: AFC.Data.IStore, input: HTMLElement): AFC.Data.IDBColumn {
            let name, bind, qualifier, column;
    
            if ((name = input.getAttribute('name')) && (bind = input.getAttribute('bind'))) {
                switch(bind.toLowerCase()) {
                    case 'column':
                        column = store.getColumn(name);
                        break;
                    case 'qualifier':
                        ((qualifier = AFC.Data.qualifier(name)) !== void 0) && (column = store.getQualifiedColumn(qualifier));
                        break;
                }
            }
            return column;
        }
        public getColumnForInput(input: HTMLElement): AFC.Data.IDBColumn {
            return this._getColumnForInput(this.store, input);
        }
        
        public setStoreValue(column: AFC.Data.IDBColumn, value: string, fireEvent?: boolean): boolean {
            let store = this.store,
                cast;
            
            if (store && store.setData && (cast = _casts[column.type])) {
                return store.setData(column.name, value ? cast(value) : null) && (!fireEvent || this[_dispatch](column));
            }
        }
            
        /** @internal */
        private [_updateControls](update: boolean, brand?: string, symbol_?: string, businessCode?: string, businessCodeControl?: AfcBusinessCodeSelector): void {
            let store,
                symbols,
                brandControl: HTMLElement&{value: string};
            
            if (brand === void 0) {
                brand = (brandControl = _getInputForQualifier(this, store, AFC.Data.Qualifier.brand)) && brandControl.value;
            }
            if (brand && (store = this.store) && (symbols = this[_symbols].symbols(brand))) {
                businessCodeControl || (businessCodeControl = _getInputForQualifier(this, store, AFC.Data.Qualifier.businessCode));
                businessCode || (businessCode = businessCodeControl && businessCodeControl.value);
                _updateInputValue(this, update, store, AFC.Data.Qualifier.brand, brand, brandControl) && businessCodeControl && _updateBusinessCodeControl(businessCodeControl, symbols);
                if (symbol_) {
                    let eligible, key;
                    for (key in symbols) {
                        if (symbols[key] === symbol_) {
                            if (eligible === void 0) {
                                eligible = key;
                            }
                            if (key === businessCode) {
                                eligible = key;
                                break;
                            }
                        }
                    }
                    businessCode = eligible;
                } else {
                    symbol_ = symbols[businessCode];
                }
                _updateInputValue(this, update, store, AFC.Data.Qualifier.businessCode, businessCode, businessCodeControl);
                _updateInputValue(this, update, store, AFC.Data.Qualifier.symbol, symbol_);
            }
            update && _updateBrandSelector(this, brand, symbol_);
        }
        
        /** @internal */
        private [_onChange](event: Event): void {
            let store = this.store;
            
            if (store) {
                let target = <AfcBrandSelector>event.target,
                    selected: IBrandSelectorValue;

                if (target.tagName === 'AFC-GUI-BRAND-SELECTOR') {
                    (selected = target.selected) && this[_updateControls](true, selected.brand, selected.symbol);
                } else if (target.getAttribute && this[_change](<any>target)) {
                    let businessCodeControl = _getInputForQualifier<AfcBusinessCodeSelector>(this, store, AFC.Data.Qualifier.businessCode);
                    (businessCodeControl === <any>target) && this[_updateControls](true, void 0, void 0, void 0, businessCodeControl);
                }
            }
        }
        
        /** @internal */
        private [_onHover](event: CustomEvent<IBrandSelectorValue>): void {
            let selector: AfcBrandSelector,
                detail = event.detail || ((selector = this.querySelector<AfcBrandSelector>('afc-gui-brand-selector')) && selector.selected);
            this[_updateControls](false, detail && detail.brand, detail && detail.symbol);
        }
        
        constructor() {
            super();
            this.addEventListener('click', this[_onClick].bind(this), true);
            this.addEventListener('change', this[_onChange].bind(this), true);
            this.addEventListener('hover-change', this[_onHover].bind(this), true);
        }
        
        public get store(): AFC.Data.IStore {
            return this[_store];
        }
        
        public set store(value: AFC.Data.IStore) {
            if (this[_store] !== value) {
                this[_off]();
                this[_refresh](this[_store] = value);
                this[_on]();
            }
        }
        
        public get template(): string {
            return this[_template];
        }
        
        public set template(value: string) {
            if (this[_template] !== value) {
                this[_template] = value;
                this[_refresh](this[_store]);
            }
        }

        public get ondatachange(): (event: CustomEvent<ReadonlyArray<AFC.Data.IDBColumn>>)=> void {
            return this[_dataChange];
        }
        
        public set ondatachange(value: (event: CustomEvent<ReadonlyArray<AFC.Data.IDBColumn>>)=> void) {
            if (this[_dataChange] !== value) {
                this[_dataChange] && this.removeEventListener('dataChange', this[_dataChange]);
                (this[_dataChange] = value) && this.addEventListener('dataChange', value);
            }
        }
        
        public connectedCallback(): void {
            let templateNodes = this.getElementsByTagName('template');
            let templateNode, key, templates;
            if (templateNodes) {
                for (let i = templateNodes.length; i > 0; --i) {
                    key = _getSafeName(templateNode = templateNodes[i - 1]);
                    templates = (this[_templates] || (this[_templates] = {}))[key] || (this[_templates][key] = []);
                    templates.push({
                        parentNode: templateNode.parentNode,
                        refNode: templateNode.nextSibling,
                        content: templateNode.innerHTML
                    });
                    templateNode.parentNode.removeChild(templateNode);
                }
            }
            let e = new CustomEvent("connected", {bubbles: false, cancelable: false});
            let onConnected = this.getAttribute('onconnected');
            this.dispatchEvent(e);
            try {
                onConnected && eval("(function(event) { " + onConnected + "})")(e);
            } catch(e) {
            }
            this[_on]();
        }
        
        public disconnectedCallback(): void {
            this[_off]();
        }
        
        public submit(): void {
            this[_store] && this[_forEach](this[_store], _setData);
            this.dispatchEvent(new Event("submit", {bubbles: true, cancelable: true}));
        }
        
        public attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void {
            attrName === 'template' ? this.template = newVal : super.attributeChangedCallback(attrName, oldVal, newVal);
        }
    }

    gui.registerElement("afc-gui-brand", AfcBrand);
    gui.registerElement("afc-gui-symbol", AfcSymbol);
    gui.registerElement("afc-gui-businesscode-selector", AfcBusinessCodeSelector);
    gui.registerElement("afc-gui-brand-selector", AfcBrandSelector);
    gui.registerElement("afc-gui-store-form", AfcStoreForm);
}