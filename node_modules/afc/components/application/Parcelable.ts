namespace AFC.Application {
    const _ctorMap: Parcelable.Creator[] = [],
        _clsId = Symbol(),
        _parcelId = "___parcel_id___";
    
    type Primitive =
        | bigint
        | boolean
        | null
        | number
        | string
        | symbol
        | undefined;

    export type JSONValue = Primitive | JSONObject | JSONArray;

    interface JSONObject {
        [key: string]: JSONValue;
    }

    interface JSONArray extends Array<JSONValue> { }
    
    export class Parcel {
        /** @internal */
        public [_parcelId]: number;
        [key: string | number]: JSONValue;

        /** @internal */
        private constructor(clsId: number) {
            this[_parcelId] = clsId;
        }
    }

    export interface IParcelable<T = any> {
        //constructor: IParcelableCtor<T>;
        writeToParcel(out: Parcel): void;
    }

    //type ExtractGeneric<T> = T extends A<infer X> ? X : never;

    export namespace Parcelable {
        export interface Creator<T = any> {
            createFromParcel(parcel: Parcel): T;
        }

        class CreatorImpl<T = any> implements Creator {
            constructor(createFromParcel: (parcel: Parcel) => T) {
                this[_clsId] = _ctorMap.length;
                this.createFromParcel = createFromParcel;
                _ctorMap.push(this);
            }

            public readonly createFromParcel: (this: this, parcel: Parcel) => T;

            /** @internal */
            private readonly [_clsId]: number;
        }

        export const Creator: new <T = any>(createFromParcel: (parcel: Parcel) => T) => Creator<T> = CreatorImpl;

        interface IParcelableCtor<T = any> extends Function {
            CREATOR: CreatorImpl<T>;
        }

        export function writeToParcel(parcelable: IParcelable): Parcel {
            let ctor = <IParcelableCtor>parcelable.constructor,
                parcel;
                
            if (ctor.CREATOR) {
                parcel = Reflect.construct(Parcel, [ctor.CREATOR[_clsId]]);
                parcelable.writeToParcel(parcel);
                return parcel;
            }
        }

        export function createFromParcel<T extends IParcelable>(parcel: Parcel): T {
            let clsId = parcel[_parcelId],
                creator = <CreatorImpl<T>>_ctorMap[clsId];
            return creator?.createFromParcel(parcel);
        }
    }
}