/**
 * Created by jean.rennes on 19/09/2017.
 */
///<reference path="../../models/data/Data.ts" />
///<reference path="../../views/controls/Repeater.ts" />
///<reference path="../../helpers/AdapterBase.ts" />

namespace AFC.Data {
    export class RepeaterAdapter<M extends IDataSource & Partial<Tools.IObservable> = IDataSource & Partial<Tools.IObservable>> extends AFC.Tools.AdapterBase<M> {
        public readonly control: Controls.Repeater;
        public template: (value: IDataItemContainer)=> string;
        public compare: (value0: IDataItemContainer, value1: IDataItemContainer)=> number;
        public filter: (value: IDataItemContainer)=> boolean;
        public maxItem: number;
        public onClear: ()=> any;
        public onGenerate: ()=> any;
        
        constructor(control: Controls.Repeater) {
            super();
            this.control = control;
        }
        
        protected _update(model: M): void {
            this.onClear && this.onClear();
            this.control.empty();
            if (model) {
                let containers: IDataItemContainer[] = [],
                    maxItem: number = model.length,
                    compare = (container0: IDataItemContainer, container1: IDataItemContainer): number => {
                        let ret: number = this.compare(container0, container1);
                        return ret || (container0.dataItemIndex - container1.dataItemIndex);
                    },
                    push: (container: IDataItemContainer)=> void|boolean  = this.compare ?
                        (container: IDataItemContainer) => {
                        let i: number = Tools.lower_bound(containers, container, compare);
                        
                        if (i < containers.length) {
                            (i < maxItem) && containers.splice(i, 0, container);
                            (containers.length > maxItem) && containers.pop();
                        } else if (i < maxItem) {
                            containers.push(container);
                        }
                        return true;
                    } : (container: IDataItemContainer) => {
                        if (containers.length < maxItem) {
                            containers.push(container);
                            return true;
                        }
                    },
                    container;

                (this.maxItem !== void 0) && (maxItem = Math.min(this.maxItem, maxItem));
                for (let i = 0; i < model.length; ++i) {
                    container = model.item(i);
                    if ((!this.filter || this.filter(container)) && !push(container)) {
                        break;
                    }
                }

                for (let i: number = 0; i < containers.length; ++i) {
                    this.control.addItem(container = containers[i], this.template ? this.template(container) : void 0);
                }
            }
            this.onGenerate && this.onGenerate();
        }
        
        public unbind(): void {
            this.control.empty();
            super.unbind();
        }                        
    }
}