/**
 * Created by jean.rennes on 20/02/2017.
 */
///<reference path="../../models/globals/MapView.ts" />
///<reference path="../../helpers/AdapterBase.ts" />

namespace AFC.Globals {
    export interface ILegendsProvider extends Tools.INotifier {
        legends: ReadonlyArray<Controls.IFilterableLegendInfo | Globals.ILegendInfo>;
    }    

    class Filter {
        readonly legend: Controls.IFilterableLegendInfo;
        readonly map: number[];
        
        constructor(legend: Controls.IFilterableLegendInfo) {
            this.legend = legend;
            this.map = [];
        }
        
        protected _convert(solver: (row: ReadonlyArray<any>) => number, row: ReadonlyArray<any>): number {
            return this.map[solver(row)] || 0;
        }

        public assign(mask: number): void {
            let solver: (row: ReadonlyArray<any>)=> number;
            this.legend.filterable.filter = (row: ReadonlyArray<any>, dataModel: Data.IRowCollection & {readonly columnIndex: { [key:string]: number; };})=> !!(this._convert(solver || (solver = getThematicSolver(this.legend.property, this.legend.data, dataModel.columnIndex)), row) & mask);
        }
                
        public update(inputs: NodeListOf<HTMLInputElement>): number {
            let mask: number = 0;
            for (let i: number = 0; i < inputs.length; ++i) {
                mask += (inputs[i].checked && this.map[parseInt(inputs[i].value)]) || 0;
            }
            this.assign(mask);
            return mask;
        }
    }
    
    export class LegendsAdapter extends Tools.AdapterBase<ILegendsProvider> {
        protected _filters: {[key: string]: Filter};        
        public readonly control: Controls.Legends;
        public enableFiltering: boolean;
        
        constructor(control: Controls.Legends) {
            super();
            this.control = control;
            control.node.addEventListener('change', this._onChange.bind(this));
        }
        
        protected _onChange(e: Event): void {
            let element: HTMLInputElement = <HTMLInputElement> e.target;
            let key: string;
            let filter: Filter;
            
            if ((element.tagName === 'INPUT') && (key = element.getAttribute('name')) && (filter = this._filters[key])) {
                filter.legend.states = filter.update(this.control.node.querySelectorAll(`input[name="${key}"]`));
            }
        }
        
        protected _update(model: ILegendsProvider): void {
            let legends = model.legends;
            
            if (this.enableFiltering) {
                this._filters = {};
                legends.forEach((legend: Controls.IFilterableLegendInfo) => {
                    if (legend.filterable) {
                        let thematic: IThematic = legend.property.thematic;

                        if (thematic) {
                            let mask: number = 1;
                            let filter: Filter = this._filters[legend.id] = new Filter(legend);

                            thematic.classes.forEach(() => {
                                filter.map.push(mask);
                                mask <<= 1;
                            });
                            if (legend.states === void 0) {
                                legend.states = mask - 1;
                            }
                            filter.assign(legend.states);
                        }
                    }
                });                
            }
            this.control.update(legends, this.enableFiltering);
        }
        
        public isEmpty(): boolean {
            let legends = this._model && this._model.legends;
            return !(legends && legends.length);
        }
    }    
}