/**
 * Created by jean.rennes on 29/07/2022.
 */
namespace AFC.Globals {
    let _requestCounter: WaitModel;

    const _notify = Symbol();

    const _pollingRequestTimeout:   number = 10000;     // rest request progress timeout in ms

    const _intervalValue:           number = 1000;      // progress info bar refresh interval in ms

    const enum TaskStatus {
        idle,
        updating,
        completed
    }

    export interface IProgressInfoBarTask {
        readonly tid: string;
        readonly progressData: Readonly<AFC.Globals.IProgressData>;
        readonly status: TaskStatus;
        update(): void;
    }

    interface IProgressDataResponse {
        title: string;
        step: string;
        tid: string;
        completed: number;
	progress: string;
	uid: number;
	status: string|ProgressStatus;
    }
    
    class ProgressInfoBarRestTask implements IProgressInfoBarTask {
        public readonly restModel: Rest.RestModel;
        public readonly tid: string;
        public readonly progressInfoBar: ProgressInfoBar;
        public progressData: AFC.Globals.IProgressData;
        public status: TaskStatus;
        
        constructor(progressInfoBar: ProgressInfoBar, restModel: Rest.RestModel, tid: string) {
            this.progressInfoBar = progressInfoBar;
            this.restModel = restModel;
            this.tid = tid;
            this.progressData = {           
                title:      '',
                step:       '',
                tid:        tid,
                completed:  0,
                progress:   '',
                status:     ProgressStatus.notStarted
            };
            this.status = TaskStatus.idle;
        }

        public update(): void {
            let progressData = this.progressData;
            
            if (this.status === TaskStatus.idle) {
                let request = this.restModel.createAjaxRequest<{
                        tid: string;
                        wait: number;
                        uid: number
                    }>('/progress'),
                    data = request.options.data;
            
                this.status = TaskStatus.updating;
                data.tid = this.tid;
                data.uid = progressData.uid;
                data.wait = _pollingRequestTimeout;
                request.options.always = (sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                    let data: IProgressDataResponse = jqXHR.status === 200 && jqXHR.responseJSON;
                    
                    if (data) {
                        data.status = AFC.Globals.progressStatus(<string>data.status);
                        this.progressData = progressData = <IProgressData>data;
                    } else {
                        progressData.status = ProgressStatus.unknown;
                    }
                    this.status = progressData.status === ProgressStatus.unknown || progressData.status === ProgressStatus.completed ? TaskStatus.completed : TaskStatus.idle;
                    this.progressInfoBar.notify(this);
                };
                request.call();
            }
        }
    }
    
    class ProgressInfoBar {
        public readonly waitModel: WaitModel;
        public tasks: IProgressInfoBarTask[];
        private _counter: number;
        private _interval: number = null;
        private _enabled = false;
       
       
        constructor(waitModel: WaitModel) {
            this.waitModel = waitModel;
            this.tasks = [];
        }
       
        private _dec(): void {
            if (--this._counter <= 0) {
                this.stop();
                this.waitModel.notify(true);
            }
        }
        
        private _count(update?: true): number {
            return this._counter = this.tasks.reduce((acc: number, task: IProgressInfoBarTask) => {
                if (task.status !== TaskStatus.completed) {
                    update && task.update();
                    ++acc;
                }
                return acc;
            }, 0);
        }
        
        public start(): void {
            if (this._enabled && this._count() && this._interval === null) {
                this._interval = setInterval(() => {
                    this._count(true) || this.stop();
                    this.waitModel.notify(true);
                }, _intervalValue);
            }
        }

        public stop(): void {
            if (this._interval !== null) {
                clearInterval(this._interval);
                this._interval = null;
            }
        }
                
        public enable(enable: boolean) {
            if (this._enabled !== enable) {
                this._enabled = enable;
                enable ? this.start() : this.stop();
            }
        }
        
        public push(task: IProgressInfoBarTask): void {
            let tasks = this.tasks;
            if (!tasks.some(item => task.tid === item.tid)) {
                tasks.push(task);
                task.status !== TaskStatus.completed && this.start();
            }
        }
        
        public pop(tid: string): void {
            this.tasks = this.tasks.filter(item => {
                let keep = item.tid !== tid;
                if (!keep && item.status !== TaskStatus.completed) {
                    this._dec();
                }
                return keep;
            });
        }
        
        public notify(task: IProgressInfoBarTask): void {
            task.status === TaskStatus.completed && this._dec();
        }
    }
    
    const _timeThreshold = 30000; // 30 s
    const _from = 0.1; // min percent
    const _to = 0.9; // min percent
    const _dummy = 'dummy';
    
    function _getTime(): number {
        return new Date().getTime();
    }
    
    function _ease(x: number): number {
        return x * (2 - x); // ease out quad
    }

    class WaitModel implements IProgressInfoBarTask {
        public value: number = 0;
        public adapters: WaitAdapter[] = [];
        public readonly bar: ProgressInfoBar = new ProgressInfoBar(this);

        /* IProgressInfoBarTask */
        public readonly tid: string = _dummy;
        public readonly progressData: AFC.Globals.IProgressData = <AFC.Globals.IProgressData>{
            tid: _dummy,
            uid: -1,
            status: ProgressStatus.inProgress
        };
        public status: TaskStatus;
        private _begin: number;
        
        private _start(): void {
            this.status = TaskStatus.updating;
            this.update();
            this.bar.push(this);
        }
        
        private _stop(): void {
            this.status = TaskStatus.completed;
            this.bar.pop(this.tid);
        }
                       
        public update(): void {
            if (this._begin) {
                let progress = _getTime() - this._begin,
                    step = (_to - _from) / _timeThreshold,
                    value = _ease(progress * step + _from);

                this.progressData.completed = value < _to ?
                    value:
                    (delete this._begin,_to);
            }
        }
        /* IProgressInfoBarTask */

        public notify(progress: boolean, value?: number): void {
            this.adapters.forEach(adapter => adapter[_notify](progress, value));
        }

        public inc(restModel: Rest.RestModel, tid: string): number {
            let value = ++this.value;
            
            restModel && tid && this.bar.push(new ProgressInfoBarRestTask(this.bar, restModel, tid));
            if (value === 1) {
                this._begin = _getTime();
                this._start();
            }
            this.notify(false, value);
            return value;
        }

        public dec(tid: string): number {
            let value = --this.value;
            
            tid && this.bar.pop(tid);
            value || this._stop();
            this.notify(false, value);
            return value;
        }
    }
    
    export class WaitAdapter {
        public readonly waitBar: Controls.WaitBar;
        public readonly progressBar: Controls.ProgressBar;
        public dummyEnabled: boolean = false;

        constructor({ waitBar, progressBar }: { waitBar?: Controls.WaitBar, progressBar?: Controls.ProgressBar}) {
            _requestCounter || (_requestCounter = new WaitModel());
            this.waitBar = waitBar;
            this.progressBar = progressBar;
        }
        
        public register(): void {
            if ((this.waitBar || this.progressBar) && !_requestCounter.adapters.some(adapter => adapter === this)) {
                this.progressBar && _requestCounter.bar.enable(true);
                _requestCounter.adapters.push(this);
                _requestCounter.value > 0 && this[_notify](false, 1);
            }
        }

        public unregister(): void {
            let counter: number = 0;
            
            _requestCounter.adapters = _requestCounter.adapters.filter(adapter => {
                let keep = adapter !== this;
                if (keep && adapter.progressBar) {
                    ++counter;
                }
                return keep;
            });
            _requestCounter.bar.enable(counter > 0);
            this[_notify](false, 0);
        }

        public push(restModel: Rest.RestModel, tid?: string): void {
            _requestCounter.inc(restModel, tid);
        }

        public pop(restModel: Rest.RestModel, tid?: string): void {
            _requestCounter.dec(tid);
        }

        /** @internal */
        public [_notify](progress: boolean, value?: number): void {
            if (progress) {
                let tasks = _requestCounter.bar.tasks;
                this.progressBar?.refresh(this.dummyEnabled ? tasks : tasks.filter(task => task.tid !== _dummy));
            }
            if (value === 1) {
                this.waitBar?.show();
            }
            else if (value === 0) {
                this.waitBar?.hide();
            }
        }
    }
}