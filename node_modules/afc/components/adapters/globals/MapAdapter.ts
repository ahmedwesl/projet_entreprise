/**
 * Created by jean.rennes on 30/06/2016.
 */
///<reference path="../../models/globals/MapView.ts" />
///<reference path="../../helpers/AdapterBase.ts" />
///<reference path="../../views/controls/TileLayer.ts" />
///<reference types="leaflet" />

declare namespace L {
    export interface StripePatternOptions {
        weight?: number;         // (default: 4) - The width of the primary stripe.
        spaceWeight?: number;    // (default: 4) - The width of the secondaty stripe, typically an empty space.
        color?: string;          // (default: #000000) - The color of the primary stripe.
        spaceColor?: string;     // (default: #ffffff) - The color of the secondary stripe.
        opacity?: number;        // (default: 1.0) - The opacity of the primary stripe.
        spaceOpacity?: number;   // (default: 0.0) - The opacity of the secondary stripe.
        angle?: number;          // (default: 0.0)
        width?: number;          // (default: 8.0) - The width of the pattern
        height?: number;         // (default: 8.0) - The height of the pattern
    }

    export class Pattern {
        addTo(map: Map): this;
        remove(): this;
        removeFrom(map: Map): this;
    }

    export class StripePattern extends Pattern {
        constructor(options?: StripePatternOptions);
    }

    export function stripePattern(options?: StripePatternOptions): StripePattern;
}

namespace AFC.Globals {
    export interface GeometryForLayerType {
        [Globals.LayerType.polygon]: GeoJSON.Polygon | GeoJSON.MultiPolygon;
        [Globals.LayerType.line]: GeoJSON.LineString | GeoJSON.MultiLineString;
        [Globals.LayerType.symbol]: GeoJSON.Point;
        [Globals.LayerType.unknown]: never;
        [Globals.LayerType.label]: never;
        [Globals.LayerType.pie]: never;
        [Globals.LayerType.olap]: never;
        [Globals.LayerType.raster]: never;
        [Globals.LayerType.mxd]: never;
    }

    export type Point<P extends IGeoJsonProperties = IGeoJsonProperties> = (L.CircleMarker<P> & { feature: GeoJSON.Feature<GeoJSON.Point, P>; }) | (L.Marker<P> & { feature: GeoJSON.Feature<GeoJSON.Point, P>; });
    export type PolyLine<P extends IGeoJsonProperties = IGeoJsonProperties> = L.Polyline<GeoJSON.LineString | GeoJSON.MultiLineString, P> & { feature: GeoJSON.Feature<GeoJSON.LineString, P> | GeoJSON.Feature<GeoJSON.MultiLineString, P>; };
    export type Polygon<P extends IGeoJsonProperties = IGeoJsonProperties> = L.Polygon<P> & { feature: GeoJSON.Feature<GeoJSON.Polygon, P> | GeoJSON.Feature<GeoJSON.MultiPolygon, P>; };

    export type LayerForLayerType<K extends LayerType = LayerType, P extends Globals.IGeoJsonProperties = IGeoJsonProperties> =
        K extends LayerType.symbol ? Point<P> :
        K extends LayerType.line ? PolyLine<P> :
        K extends LayerType.polygon ? Polygon<P> :
        never;

    export interface ITileLayer<K extends DrawableLayerType = DrawableLayerType, D extends ITileVectorModel<K> = ITileVectorModel<K>> extends Controls.ITileLayer<K> {
        readonly tiledModel: IMapLayerTiledModel<K, D>;

        getBoundsFromKeys(keys: ReadonlyArray<string>): L.LatLngBounds;
        intersect(keys: ReadonlyArray<string>, rectangle: Tools.Geometry.Rectangle): boolean;
    }

    class TileLayer<K extends DrawableLayerType = DrawableLayerType, D extends ITileVectorModel<K> = ITileVectorModel<K>> extends Controls.TileLayer<K> implements ITileLayer<K, D> {
        private _counter: number;
        private _clustered: boolean;
        public readonly tiledModel: IMapLayerTiledModel<K, D>;
        declare public readonly getGeometryFromResult: (row: ReadonlyArray<any>) => GeometryForLayerType[K];

        constructor(tiledModel: IMapLayerTiledModel<K, D>, geojsonOptions?: L.GeoJSONOptions<Globals.IGeoJsonProperties>) {
            let data = tiledModel.data;
            let options: Controls.TileLayerOptions = {
                minZoom: tiledModel.minZ,
                maxZoom: tiledModel.maxZ,
                minNativeZoom: tiledModel.minNativeZ,
                maxNativeZoom: tiledModel.maxNativeZ
            };
            let clustered = tiledModel.clustering && (tiledModel.type === Globals.LayerType.symbol);

            if (clustered) {
                options.layerProvider = <any>((options: L.GeoJSONOptions) => Controls.markerClusterGroup<Globals.ITileFeatureProperties<K>>(tiledModel.data, options, { disableClusteringAtZoom: tiledModel.clusteringMaxZoom }));
            }
            super(data, options, geojsonOptions);
            this.tiledModel = tiledModel;
            this._counter = 0;
            this._clustered = clustered;
            this.getGeometryFromResult = Tools.Cartographer.getRowConverter(tiledModel.type, data.geometryIndice);
        }

        public get geoJSONOptions(): L.GeoJSONOptions<Globals.IGeoJsonProperties> {
            return this._clustered ? (<MarkerClusterGroup><any>this._geoJSON).geoJSONOptions : (<GeoJSON><any>this._geoJSON).options;
        }

        public requestTiles(tiles: ReadonlyArray<string>, callback: (tiles: ReadonlyArray<string>, rows: ReadonlyArray<ReadonlyArray<any>>) => any): void {
            this.tiledModel.data.provider.requestTiles(this, tiles, callback);
        }

        public getBoundsFromKeys(keys: ReadonlyArray<string>): L.LatLngBounds {
            let bounds: L.LatLngBounds;

            keys.forEach(key => {
                let tile = this._tiles[key], loc;
                if (tile) {
                    loc = this._tileCoordsToBounds(tile.coords);
                    bounds ? bounds.extend(loc) : bounds = loc;
                }
            });
            return bounds;
        }

        public intersect(keys: ReadonlyArray<string>, rectangle: Tools.Geometry.Rectangle): boolean {
            let zoom: number,
                bounds: L.Bounds;

            return keys.some(key => {
                let tile = this._tiles[key];
                if (tile && !tile.loaded) {
                    if (tile.coords.z !== zoom) {
                        bounds = this._pxBoundsToTileRange(this._getPixelBoundsFromRect(rectangle, zoom = tile.coords.z));
                    }
                    return bounds.contains(tile.coords);
                }
            });
        }
    }

    type GeoJSON<K extends DrawableLayerType = DrawableLayerType> = Controls.GeoJSON<K, any>;
    type MarkerClusterGroup = Controls.MarkerClusterGroup<any>;
    export type FeatureGroup<K extends DrawableLayerType = DrawableLayerType> = K extends LayerType.symbol ? GeoJSON<LayerType.symbol> | ITileLayer<LayerType.symbol> | MarkerClusterGroup : GeoJSON<K> | ITileLayer<K>;

    export interface ILayerDescriptor<K extends DrawableLayerType = DrawableLayerType> {
        model: IMapLayerModel;
        options: L.GeoJSONOptions;
        featureGroup: FeatureGroup<K>;
    }

    interface ILayerDescriptorEx<K extends DrawableLayerType = DrawableLayerType> extends ILayerDescriptor<K> {
        pane: string;
    }    

    export interface IEventLayerInfo<K extends DrawableLayerType = DrawableLayerType> extends ILayerDescriptor<K> {
        feature?: LayerForLayerType<K>;
        index: number;
        options: L.GeoJSONOptions<Globals.IGeoJsonProperties>;
    }

    type _extendedEvents = 'animationend';

    export type MapEventHandler<K extends keyof L.LeafletEventHandlerFnMap | _extendedEvents = keyof L.LeafletEventHandlerFnMap | _extendedEvents> = (event: K extends keyof L.LeafletEventHandlerFnMap ? Parameters<L.LeafletEventHandlerFnMap[K]>[0] : L.LeafletEvent, info: IEventLayerInfo) => any;

    const _mouseEvents = ['click', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'animationend'];

    export type IMapEventHandlers = {
        [K in keyof L.LeafletEventHandlerFnMap | _extendedEvents]?: K extends typeof _mouseEvents[number] ? MapEventHandler<K> : never;
    }

    const _tokenValue: string = '<TKVALUE>';
    const _tokenBound: string = '<TKUB>';

    function _alignClasses(classes: ReadonlyArray<IThematicValue>, data: ReadonlyArray<IClassInfo>): ReadonlyArray<IClassInfo> {
        let len = classes.length,
            dataLen = data.length,
            ret: IClassInfo[]; 
        
        if (dataLen < 2 || len <= dataLen)
            return data;
            
        ret = [...data];
        while (ret.length < len) {
            ret.splice(ret.length - 1, 0, data[dataLen - 1]);
        }
        return ret;
    }
    
    export function isQuali(data: ReadonlyArray<IClassInfo>): boolean {
        return data.length > 0 && data[0].hasOwnProperty(_tokenValue);
    }

    export function getMonoThematicSolver(column: string, classes: ReadonlyArray<IThematicValue>, legendData: Partial<ILegendData>, columnIndex: { readonly [key: string]: number; }): (row: ReadonlyArray<any>) => number {
        let thematic: IThematicData = legendData && legendData.thematic,
            solver: (row: ReadonlyArray<any>) => number,
            indice = columnIndex[column];

        if ((indice !== void 0) && thematic) {
            let data: ReadonlyArray<IClassInfo> = thematic.classes;

            if (isQuali(data)) {
                let index: { [key: string]: number; } = {};

                data.forEach((info: IClassInfo, indice: number) => {
                    info && (index[info[_tokenValue].value] = indice);
                });
                solver = (row: ReadonlyArray<any>) => index[<string | number>row[indice]];
            } else {
                data = _alignClasses(classes, data);
                solver = (row: ReadonlyArray<any>) => {
                    let value: number = row[indice],
                        i: number, iLength: number;
                    if (value !== null) {
                        for (i = 0, iLength = data.length - 1; i < iLength; ++i) {
                            if (value < data[i][_tokenBound].value) {
                                break;
                            }
                        }
                    }
                    return i;
                };
            }
        }
        return solver;
    }

    export function getThematicSolver(property: Partial<ILayerProperty>, legendData: Partial<ILegendData>, columnIndex: { readonly [key: string]: number; }): (row: ReadonlyArray<any>) => number {
        let thematic  = property.thematic, 
            columns: ReadonlyArray<string> = thematic && thematic.columns;
        return columns && columns.length === 1 && getMonoThematicSolver(columns[0], thematic.classes, legendData, columnIndex);
    }

    function _checkValue<T>(property: Partial<ILayerProperty<T>>, value: T): T {
        return value === null ? property.value : value;
    }

    interface ILayerPropertyReader<V> {
        readValue(row: ReadonlyArray<any>): V;
    }

    function _getPropertyReader<T>(property: Partial<ILayerProperty<T>>, legendData: Partial<ILegendData>, columnIndex: { readonly [key: string]: number; }): (row: ReadonlyArray<any>) => T {
        if (columnIndex) {
            let reader: (row: ReadonlyArray<any>) => T,
                solver: (row: ReadonlyArray<any>) => number,
                index: number;

            if (property.column) {
                index = columnIndex[property.column];
                reader = (row: ReadonlyArray<any>) => row[index];
            } else if (solver = getThematicSolver(property, legendData, columnIndex)) {
                reader = (row: ReadonlyArray<any>) => {
                    let value = solver(row),
                        _class = property.thematic.classes[value];
                    return _class ? _class.value : null;
                }
            }
            return reader;
        }
    }

    export class LayerPropertyReader<T, V = T> implements ILayerPropertyReader<V> {
        protected _reader: (row: ReadonlyArray<any>) => T;
        protected _converter: (t: T) => V;

        constructor(property: Partial<ILayerProperty<T>>, legendData: Partial<ILegendData>, columnIndex: { readonly [key: string]: number; }, converter?: (t: T) => V) {
            let reader: (row: ReadonlyArray<any>) => T = _getPropertyReader(property, legendData, columnIndex);
            this._reader = reader ? ((row: ReadonlyArray<any>) => _checkValue(property, reader(row))) : ((row: ReadonlyArray<any>) => property.value);
            this._converter = converter;
        }

        public readValue(row: ReadonlyArray<any>): V {
            let t: T = this._reader(row);
            return this._converter ? this._converter(t) : <any>t;
        }
    }

    type IStyleParameters<P extends { [K in keyof P]: ILayerProperty }, M extends { [K in keyof L.PathOptions]: keyof P }> = {
        [K in keyof L.PathOptions]: M[K] extends keyof P ? ILayerPropertyReader<L.PathOptions[K]> : never;
    }

    import convertColor = Tools.Style.convertColor;

    function convertTransparency(v: number): number {
        return Math.min((100 - v) / 100);
    }

    class Style<P extends IGeoJsonProperties = IGeoJsonProperties> implements L.GeoJSONOptions<P> {
        public readonly filter: (feature: GeoJSONFeature<P>) => boolean;

        constructor(properties: ILayerProperties, data: IMapLayerModelData) {
            let visibility: LayerPropertyReader<boolean, ReturnType<L.GeoJSONOptions['filter']>>;

            if (properties.visibility && properties.visibility.column && properties.visibility.column != "") {
                visibility = new LayerPropertyReader(properties.visibility, void 0, data.columnIndex);
                this.filter = (feature: GeoJSONFeature) => visibility.readValue(feature.properties.data);
            }
        }

        public build(filter: GeoJSONFilterOverride, options: GeoJSONOptionOverrides): L.GeoJSONOptions<P> {
            let instance: L.GeoJSONOptions<P>;
            if (filter || options) {
                instance = Object.create(this);
                filter && (instance.filter = (feature: GeoJSONFeature<P>) => filter(!this.filter || this.filter(feature), feature));
                if (options) {
                    options.pane && (instance.pane = options.pane);
                    options.attribution && (instance.attribution = options.attribution);
                    options.pointToLayer && (instance.pointToLayer = options.pointToLayer.bind(options, this));
                    options.style && (instance.style = typeof options.style === 'function' ? options.style.bind(options, this) : options.style);
                    options.onEachFeature && (instance.onEachFeature = options.onEachFeature.bind(options, this));
                    options.coordsToLatLng && (instance.coordsToLatLng = options.coordsToLatLng.bind(options, this));
                }
            } else {
                instance = this;
            }
            return instance;
        }
    }

    interface ISymbolPropertiesMap {
        color: 'color';
        fillColor: 'fillColor';
    }

    type IPointStyleParameters = IStyleParameters<ISymbolProperties, ISymbolPropertiesMap> & {
        size: LayerPropertyReader<ISymbolProperties['size']['value'], number>;
        icon: LayerPropertyReader<ISymbolProperties['icon']['value'], string>;
    }

    function pointToLayer<P extends IGeoJsonProperties>(
        parameters: IPointStyleParameters,
        symbolFactory: SymbolFactory,
        symbolIndex: { [key: string]: any },
        feature: GeoJSON.Feature<GeoJSON.Point, P>,
        latlng: L.LatLng,
        pane: string
    ): L.Layer {
        let row: ReadonlyArray<any> = feature.properties.data;
        let icon: string;;
        let size: number = parameters.size.readValue(row);
        let markerOptions: L.MarkerOptions;

        if (symbolFactory && (icon = parameters.icon.readValue(row))) {
            let key: string = icon + '|' + size;

            if (!(markerOptions = symbolIndex[key])) {
                let symbol: ISymbol = symbolFactory.symbol(icon);

                if (symbol) {
                    let maxPixelWidth: number = 0.010 * size; // 0.8*96/7200
                    let iconStyle: L.IconOptions = {
                        iconUrl: symbol.url,
                        iconSize: (symbol.width > symbol.height) ? [maxPixelWidth, maxPixelWidth * (symbol.height / symbol.width)] : [maxPixelWidth * (symbol.width / symbol.height), maxPixelWidth]
                    };
                    markerOptions = symbolIndex[key] = {
                        icon: L.icon(iconStyle)
                    };
                    pane && (markerOptions.pane = pane);
                }
            }
        }
        if (markerOptions)
            return L.marker(latlng, markerOptions);

        let weight: number = 100,
            options: L.CircleMarkerOptions = {
                weight: weight / 100,
                color: parameters.color.readValue(row),
                opacity: 1,
                fillOpacity: 1,
                fillColor: parameters.fillColor.readValue(row),
                bubblingMouseEvents: false,
                //   fillOpacity: this._opacity.readValue(row),
                radius: (size - weight) * 0.0027      // 0.8*96/(7200*4)
            };
        options.pane = pane || 'markerPane';
        return L.circleMarker(latlng, options);
    }

    class PointStyle<P extends IGeoJsonProperties = IGeoJsonProperties> extends Style<P> {
        public readonly pointToLayer: (point: GeoJSON.Feature<GeoJSON.Point>, latlng: L.LatLng) => L.Layer;

        constructor(properties: ISymbolProperties, thematics: ISymbolLegendData, data: Globals.IMapLayerModelData, symbolFactory: SymbolFactory, pane: string) {
            let parameters = {
                color: new LayerPropertyReader(properties.color, thematics.color, data.columnIndex, convertColor),
                fillColor: new LayerPropertyReader(properties.fillColor, thematics.fillColor, data.columnIndex, convertColor),
                //opacity: new LayerPropertyReader(properties.transparency, void 0, dataInfo.columnIndex, convertTransparency),
                size: new LayerPropertyReader(properties.size, thematics.size, data.columnIndex),
                icon: new LayerPropertyReader(properties.icon, thematics.icon, data.columnIndex)
            }, symbolIndex = {};
            super(properties, data);
            this.pointToLayer = (feature: GeoJSON.Feature<GeoJSON.Point, P>, latlng: L.LatLng) => pointToLayer<P>(parameters, symbolFactory, symbolIndex, feature, latlng, pane)
        }
    }

    interface IPolyLinePropertiesMap {
        color: 'color';
        weight: 'weight';
    }

    function styleLine<P extends IGeoJsonProperties>(parameters: IStyleParameters<IPolyLineProperties, IPolyLinePropertiesMap>, feature: GeoJSONFeature<P>): L.PolylineOptions {
        let row: ReadonlyArray<any> = feature.properties.data;
        return {
            weight: 0.010 * parameters.weight.readValue(row), // 0.8*96/7200
            color: parameters.color.readValue(row),
            bubblingMouseEvents: false
        };
    }

    class PolylineStyle<P extends IGeoJsonProperties = IGeoJsonProperties> extends Style<P> {
        public readonly style: (feature: GeoJSONFeature<P>) => L.PolylineOptions;
        public readonly pane: string;

        constructor(properties: IPolyLineProperties, thematics: IPolyLineLegendData, data: Globals.IMapLayerModelData, pane: string) {
            let parameters = {
                color: new LayerPropertyReader(properties.color, thematics.color, data.columnIndex, convertColor),
                weight: new LayerPropertyReader(properties.weight, thematics.weight, data.columnIndex)
            };
            super(properties, data);
            this.style = (feature: GeoJSONFeature<P>) => styleLine(parameters, feature)
            this.pane = pane;
        }
    }

    interface IPolygonPropertiesMap {
        color: 'color';
        opacity: 'transparency';
        weight: 'weight';
    }

    interface IPolygonBackground {
        pattern?: L.Pattern;
        color?: string;
    }

    type IPolygonStyleParameters = IStyleParameters<IPolygonProperties, IPolygonPropertiesMap> & {
        background?: ILayerPropertyReader<IPolygonBackground>;
    }

    export const enum PatternStyle {
        empty = 0,
        solid = 1,
        hatch = 10,
        thickHatch = 11,
        crossHatch = 15,
        cross = 16,
        emptyCircle = 20,
        circle = 21,
        emptyDiamond = 25,
        diamond = 26,
        checkered = 30
    }

    class PatternReader implements ILayerPropertyReader<IPolygonBackground> {
        public readonly mapAdapter: MapAdapter;
        public readonly pattern: ILayerPropertyReader<number>;
        public readonly color: ILayerPropertyReader<number>;
        public readonly bkColor: ILayerPropertyReader<number>;
        public readonly angle: ILayerPropertyReader<number>;
        public readonly space: ILayerPropertyReader<number>

        constructor(mapAdapter: MapAdapter, pattern: ILayerPropertyReader<number>, color: ILayerPropertyReader<number>, bkColor: ILayerPropertyReader<number>, angle: ILayerPropertyReader<number>, space: ILayerPropertyReader<number>) {
            this.mapAdapter = mapAdapter;
            this.pattern = pattern;
            this.color = color;
            this.bkColor = bkColor;
            this.angle = angle;
            this.space = space;
        }

        public readValue(row: ReadonlyArray<any>): IPolygonBackground {
            let value = this.pattern.readValue(row),
                pattern: PatternStyle = value & 0xFFFF,
                bNoBackground: number = value & 0x10000,
                color = convertColor(this.color.readValue(row));

            switch (pattern) {
                case PatternStyle.hatch:
                case PatternStyle.thickHatch:
                    let weight = pattern === PatternStyle.thickHatch ? 2.66 : 1.33,
                        spaceWeight = Math.round(weight + this.space.readValue(row) * 1.33) / 100,
                        width = spaceWeight + weight,
                        options = {
                            color: color,
                            spaceColor: convertColor(bNoBackground ? -1 : this.bkColor.readValue(row)),
                            spaceOpacity: 1,
                            angle: -this.angle.readValue(row),
                            weight: weight,
                            spaceWeight: spaceWeight,
                            width: width,
                            height: width
                        },
                        key = `${options.color}|${options.spaceColor}|${options.angle}|${options.weight}|${options.spaceWeight}`;
                    return { pattern: this.mapAdapter.addPattern(key, options) };
            }
            return { color: color };
        }
    }

    class CompositeReader implements ILayerPropertyReader<{ pattern?: L.Pattern, color?: string }> {
        public readonly color0: (row: ReadonlyArray<any>) => number;
        public readonly color1: (row: ReadonlyArray<any>) => number;
        public readonly defaultColor: number;
        public readonly pattern: PatternReader;

        constructor(color0: (row: ReadonlyArray<any>) => number, color1: (row: ReadonlyArray<any>) => number, defaultColor: number, pattern: PatternReader) {
            this.color0 = color0;
            this.color1 = color1;
            this.defaultColor = defaultColor;
            this.pattern = pattern;
        }

        public readValue(row: ReadonlyArray<any>): IPolygonBackground {
            let color0 = this.color0(row),
                b0 = (color0 !== null) && (color0 !== -1),
                color1 = this.color1(row),
                b1 = (color1 !== null) && (color1 !== -1),
                pattern = b0 && b1 && this.pattern.readValue(row);

            if (!pattern) {
                if (b0 || b1) {
                    color0 = b0 ? color0 : color1;
                } else {
                    color0 = this.defaultColor;
                }
                pattern = { color: convertColor(color0) };
            }
            return pattern;
        }
    }

    function compositeReader(mapAdapter: MapAdapter, properties0: IPolygonProperties, thematics: IPolygonLegendData, override: IMapLayerModel['override'], columnIndex: { readonly [key: string]: number; }): CompositeReader {
        let reader0 = _getPropertyReader(properties0.fillColor, thematics.fillColor, columnIndex),
            reader1 = reader0 && _getPropertyReader(override.properties.fillColor, override.legendData, columnIndex);

        if (reader1) {
            let properties1 = override.properties,
                pattern: ILayerPropertyReader<number> = new LayerPropertyReader(properties1.pattern, {}, columnIndex),
                fillColor: ILayerPropertyReader<number> = new LayerPropertyReader({ value: override.properties.fillColor.value }, {}, columnIndex),
                bkColor: ILayerPropertyReader<number> = { readValue: (row: ReadonlyArray<any>) => reader0(row) },
                angle: ILayerPropertyReader<number> = new LayerPropertyReader(properties1.patternAngle, {}, columnIndex),
                space: ILayerPropertyReader<number> = new LayerPropertyReader(properties1.patternSpacing, {}, columnIndex),
                reader = new PatternReader(mapAdapter, pattern, fillColor, bkColor, angle, space);
            return new CompositeReader(reader0, reader1, properties0.fillColor.value, reader);
        }
    }

    interface PolygonOptions extends L.PolylineOptions {
        fillPattern?: L.StripePattern;
    }

    function stylePolygon<P extends IGeoJsonProperties>(parameters: IPolygonStyleParameters, feature: GeoJSONFeature<P>): PolygonOptions {
        let row: ReadonlyArray<any> = feature.properties.data,
            opacity: number = parameters.opacity.readValue(row),
            style: PolygonOptions = {
                weight: 0.010 * parameters.weight.readValue(row), // 0.8*96/7200
                color: parameters.color.readValue(row),
                opacity: opacity,
                fillOpacity: opacity,
                bubblingMouseEvents: false
            },
            background = parameters.background.readValue(row);
        background.pattern ? style.fillPattern = background.pattern : style.fillColor = background.color;
        return style;
    }

    class PolygonStyle<P extends IGeoJsonProperties = IGeoJsonProperties> extends Style<P> {
        public readonly style: (feature: GeoJSONFeature<P>) => L.PolylineOptions;
        public readonly pane: string;

        constructor(mapAdapter: MapAdapter, properties: IPolygonProperties, thematics: IPolygonLegendData, data: Globals.IMapLayerModelData, pane: string, override: IMapLayerModel['override']) {
            let parameters: IPolygonStyleParameters = {
                color: new LayerPropertyReader(properties.color, thematics.color, data.columnIndex, convertColor),
                opacity: new LayerPropertyReader(properties.transparency, thematics.transparency, data.columnIndex, convertTransparency),
                weight: new LayerPropertyReader(properties.weight, thematics.weight, data.columnIndex)
            }, background: ILayerPropertyReader<{ pattern?: L.Pattern, color?: string }>;

            if (!override || !(background = compositeReader(mapAdapter, properties, thematics, override, data.columnIndex))) {
                if (properties.pattern) {
                    let pattern: ILayerPropertyReader<number> = new LayerPropertyReader(properties.pattern, {}, data.columnIndex),
                        fillColor: ILayerPropertyReader<number> = new LayerPropertyReader(properties.fillColor, thematics.fillColor, data.columnIndex),
                        bkColor: ILayerPropertyReader<number> = new LayerPropertyReader(properties.patternBkColor, {}, data.columnIndex),
                        angle: ILayerPropertyReader<number> = new LayerPropertyReader(properties.patternAngle, {}, data.columnIndex),
                        space: ILayerPropertyReader<number> = new LayerPropertyReader(properties.patternSpacing, {}, data.columnIndex);
                    background = new PatternReader(mapAdapter, pattern, fillColor, bkColor, angle, space);
                } else {
                    background = new LayerPropertyReader(properties.fillColor, thematics.fillColor, data.columnIndex, (color: number) => ({ color: convertColor(color) }));
                }
            }

            parameters.background = background;
            super(properties, data);
            this.style = (feature: GeoJSONFeature<P>) => stylePolygon(parameters, feature);
            this.pane = pane;
        }
    }

    function _buildOptions<P extends IGeoJsonProperties>(mapAdapter: MapAdapter, mapLayerModel: IMapLayerModel, pane: string): L.GeoJSONOptions<P> {
        let properties: ILayerProperties = mapLayerModel.properties,
            data: IMapLayerModelData,
            thematics: ILayerLegendData,
            builder: Style;

        if (properties && (data = mapLayerModel.data)) {
            thematics = mapLayerModel.legend || {};
            switch (mapLayerModel.type) {
                case LayerType.symbol:
                    builder = new PointStyle(properties, thematics, data, mapLayerModel.symbolFactory, pane);
                    break;
                case LayerType.polygon:
                    builder = new PolygonStyle(mapAdapter, properties, thematics, data, pane, mapLayerModel.override);
                    break;
                case LayerType.line:
                    builder = new PolylineStyle(properties, thematics, data, pane);
                    break;
            }
            return builder.build(mapLayerModel.filter, mapLayerModel.options);
        }
    }

    const _implemented = (model: IMapLayerModel): boolean => model.type === LayerType.symbol || model.type === LayerType.polygon || model.type === LayerType.line;

    const _paneLookup: { [key: number]: [number, string] } = {
        [LayerType.symbol]: [600, 'markerPane'],
        [LayerType.line]: [400, 'overlayPane'],
        [LayerType.polygon]: [400, 'overlayPane']
    };

    const _layers = Symbol(),
        _onChange = Symbol();

    export class MapAdapter extends Tools.AdapterBase<Globals.MapModel> {
        /** @internal */
        private [_layers]: ReadonlyArray<ILayerDescriptorEx>;
        public readonly control: L.Map;
        protected _featureGroup: L.FeatureGroup;
        protected _patterns: { [key: string]: L.StripePattern };
        public handlers: IMapEventHandlers;
        public onComplete: (layers: ReadonlyArray<ILayerDescriptor>) => void;

        constructor(mapControl: L.Map) {
            super();
            this.control = mapControl;
            this._attachHandlers(_mouseEvents, this.control, this._onMapEvent);
        }

        protected _buildFeature({ model, options }: { model: IMapLayerModel, options: L.GeoJSONOptions }): FeatureGroup<any> {
            let featureGroup: FeatureGroup<any>;

            if (model.isTiled) {
                featureGroup = new TileLayer(<IMapLayerTiledModel>model, options);
            } else {
                let geoJSON = (<IMapLayerStaticModel>model).geoJSON;

                if (geoJSON?.type) {
                    let data = model.data,
                        exOptions = { minZoom: model.minZ, maxZoom: model.maxZ, disableClusteringAtZoom: model.clusteringMaxZoom };
                    featureGroup = model.clustering && model.type == Globals.LayerType.symbol ?
                        Controls.markerClusterGroup(data, options, exOptions).addData(geoJSON) :
                        new Controls.GeoJSON(data, geoJSON, $.extend(exOptions, options));
                }
            }
            featureGroup && this._attachLayerHandlers(featureGroup);
            return featureGroup;
        }

        /** @internal */
        private [_onChange](layers: ReadonlyArray<ILayerDescriptorEx>): void {
            delete this[_layers];
            
            if (layers) {
                let featureGroup: L.FeatureGroup,
                    shadow: { [key: string]: boolean } = {};
                
                (this[_layers] = layers).forEach(descriptor => {
                    let pane = descriptor.pane || _paneLookup[descriptor.model.type]?.[1];

                    shadow[pane] = !!descriptor.model.properties.shadow;
                    if (descriptor?.featureGroup) {
                        descriptor.model.hidden || (featureGroup || (featureGroup = L.featureGroup())).addLayer(descriptor.featureGroup);
                    }
                });
                featureGroup && (this._featureGroup = featureGroup).addTo(this.control);
                Object.entries(shadow).forEach(([key, value]) => {
                    let pane = this.control.getPane(key),
                        classList = pane?.classList;
                    if (classList) {
                        value ? classList.add('drop-shadow') : classList.remove('drop-shadow');
                    }
                });
            }
            this.onComplete && this.onComplete(layers);
        }

        protected _addItem(layerModel: Globals.IMapLayerModel, modelData: Globals.IMapLayerModelData, featureGroup: FeatureGroup, row: ReadonlyArray<any>, iGeometry: number): void {
            let geometry = (featureGroup.getGeometryFromResult ?
                featureGroup.getGeometryFromResult :
                Tools.Cartographer.getRowConverter(layerModel.type, iGeometry))(row);
            featureGroup.addData(Tools.Cartographer.feature(geometry, { data: row }));
        }

        protected _modifyItem(layerModel: Globals.IMapLayerModel, modelData: Globals.IMapLayerModelData, featureGroup: FeatureGroup, row: ReadonlyArray<any>, iGeometry: number): void {
            let items = featureGroup.getLayers(),
                item,
                feature: GeoJSON.Feature<GeoJSON.Geometry, Globals.IGeoJsonProperties>, properties: Globals.IGeoJsonProperties;

            for (let i = 0, iLength = items.length; i < iLength; ++i) {
                item = items[i];
                if ((feature = item.feature) && (properties = feature.properties) && (modelData.compareRow(properties.data, row) === 0)) {
                    featureGroup.removeLayer(<any>item);
                    return this._addItem(layerModel, modelData, featureGroup, row, iGeometry);
                }
            }
        }

        protected _removeItem(modelData: Globals.IMapLayerModelData, featureGroup: FeatureGroup, row: ReadonlyArray<any>): void {
            let items = featureGroup.getLayers(),
                item,
                feature: GeoJSON.Feature<GeoJSON.Geometry, Globals.IGeoJsonProperties>,
                properties: Globals.IGeoJsonProperties;

            for (let i = 0, iLength = items.length; i < iLength; ++i) {
                item = items[i];
                if ((feature = item.feature) && (properties = feature.properties) && (modelData.compareRow(properties.data, row) === 0)) {
                    featureGroup.removeLayer(<any>item);
                    return;
                }
            }
        }

        protected _needReset(item: IMapEventDataLayer): boolean {
            let b: boolean = (item.data && item.data.reset),
                featureGroup: FeatureGroup;

            if (!b && (featureGroup = this[_layers]?.[item.indice].featureGroup) && (item.filter || item.style)) {
                b = (item.style && item.layer.type === Globals.LayerType.symbol) || (item.filter && !(featureGroup instanceof TileLayer));
            }
            return b;
        }

        protected _createPane(layerModel: IMapLayerModel, counters: number[]): string {
            let template = _paneLookup[layerModel.type],
                i: number,
                pane: string,
                cnt: number;

            if (template) {
                cnt = counters[i = layerModel.type === LayerType.symbol ? 1 : 0]++;
                if (cnt) {
                    pane = template[1] + cnt;
                    if (!this.control.getPane(pane))
                        this.control.createPane(pane).style.zIndex = `${template[0] + cnt}`;
                }   
            }
            return pane;
        }

        protected _update(model: Globals.MapModel, event?: IMapEvent): void {
            let data: Globals.IMapEventData = event && event.data;

            if (data && data.layers && !data.layers.some(this._needReset.bind(this))) {
                this[_layers] && data.layers.forEach(item => {
                    let layer = this[_layers][item.indice],
                        featureGroup = layer?.featureGroup;
                    if (featureGroup) {
                        if (item.visibility) {
                            // hide layer
                            layer.model.hidden && this._featureGroup.removeLayer(featureGroup);
                            delete layer.featureGroup;
                        } else {
                            let data = item.data,
                                layerModel = item.layer;

                            if (item.style || item.filter) {
                                let destination = featureGroup instanceof Controls.GeoJSON ? (<GeoJSON>featureGroup).options : (<MarkerClusterGroup | TileLayer>featureGroup).geoJSONOptions,
                                    source = layer.options = _buildOptions(this, layerModel, layer.pane);

                                destination.style = source.style;
                                if (item.filter) {
                                    (<TileLayer>featureGroup).setFilter(destination.filter = source.filter);
                                } else {
                                    featureGroup.setStyle(destination.style);
                                }
                            }
                            if (data && layerModel.data && !item.filter) {
                                let modelData = layerModel.data,
                                    iGeometry: number = modelData.geometryIndice;

                                data.items && data.items.forEach((event: Data.IDataEventItem) => {
                                    switch (event.type) {
                                        case Data.DataEventType.create:
                                            this._addItem(layerModel, modelData, featureGroup, event.row, iGeometry);
                                            break;
                                        case Data.DataEventType.modify:
                                            this._modifyItem(layerModel, modelData, featureGroup, event.row, iGeometry);
                                            break;
                                        case Data.DataEventType.delete_:
                                            this._removeItem(modelData, featureGroup, event.row);
                                            break;
                                    }
                                });
                            }
                        }
                    } else if (_implemented(layer.model) && !layer.model.hidden) {
                        if (item.style || item.filter || item.visibility) {
                            layer.options = _buildOptions(this, layer.model, layer.pane);
                        }
                        if (item.visibility)
                            this._featureGroup.addLayer(layer.featureGroup = this._buildFeature(layer));
                    }
                });
            } else {
                let counters: number[] = [0, 0],
                    layers: ILayerDescriptorEx[];
                    
                this.clearMap();
                model.layers.forEach(model => { 
                    let layer: Partial<ILayerDescriptorEx> = {
                            model: model
                        };

                    if (_implemented(model)) {
                        if (!model.hidden) {
                            layer.options = _buildOptions(this, model, layer.pane = this._createPane(model, counters));
                            layer.featureGroup = this._buildFeature(<ILayerDescriptorEx>layer);
                        }
                        (layers || (layers = [])).push(<ILayerDescriptorEx>layer);
                    }
                });
                this[_onChange](layers);
            }
        }

        protected _raiseLayerEvent(e: L.LeafletEvent, handlers: IMapEventHandlers, fn: MapEventHandler): void {
            fn && this[_layers].some((layer, indice) => { 
                if (layer?.featureGroup === e.target) {
                    let info: IEventLayerInfo = {
                        model: layer.model,
                        options: layer.options,
                        featureGroup: e.target,
                        feature: e.propagatedFrom,
                        index: indice
                    }
                    fn.call(handlers, e, info);
                    return true;
                }
            });
        }

        protected _handleClick(e: L.LeafletMouseEvent & { originalEvent: { readonly _stopped: boolean } }): void {
            if (e.originalEvent._stopped) { return; }

            // get the target pane
            let currentTarget = <HTMLElement>e.originalEvent.target,
                stopped;

            // hide the target node
            let removed = { node: currentTarget, pointerEvents: currentTarget.style.pointerEvents };
            currentTarget.style.pointerEvents = 'none';

            // attempt to grab the next layer below
            let nextTarget = document.elementFromPoint(e.originalEvent.clientX, e.originalEvent.clientY);

            // we keep drilling down until we get stopped,
            // or we reach the map container itself
            if (nextTarget?.nodeName.toLowerCase() !== 'body') {
                let ev = <MouseEvent & { readonly _stopped: boolean }>new MouseEvent(e.originalEvent.type, e.originalEvent);
                stopped = !nextTarget.dispatchEvent(ev);
                if (stopped || ev._stopped) {
                    L.DomEvent.stop(e);
                }
            }
            // restore pointerEvents
            removed.node.style.pointerEvents = removed.pointerEvents;
        }

        protected _onLayerEvent(e: L.LeafletEvent): void {
            let handlers = this.handlers,
                fn = handlers && handlers[<keyof IMapEventHandlers>e.type];
            fn && this._raiseLayerEvent(e, handlers, fn);
        }

        protected _onMapEvent(e: L.LeafletEvent): void {
            let handlers = this.handlers,
                fn = handlers && handlers[<keyof IMapEventHandlers>e.type];
            fn && fn.call(handlers, e);
        }

        protected _attachHandlers(events: string[], o: L.Evented, fn: L.LeafletEventHandlerFn): void {
            events.forEach(event => { o.on(event, fn, this); });
        }

        protected _attachLayerHandlers(o: L.Evented): void {
            this._attachHandlers(_mouseEvents, o, this._onLayerEvent);
            o.on('click', this._handleClick, this);
        }

        protected _detachHandlers(events: string[], o: L.Evented, fn: L.LeafletEventHandlerFn): void {
            events.forEach(event => { o.off(event, fn, this); });
        }

        protected _detachLayerHandlers(o: L.Evented): void {
            o.off();
        }

        public clearMap(): void {
            let layers: ReadonlyArray<ILayerDescriptorEx> = this[_layers],
                patterns = this._patterns, key: string;

            if (layers) {
                let featureGroup: L.FeatureGroup = this._featureGroup;

                //this._detachHandlers(_mouseEvents, this.control, this._onMapEvent);
                if (featureGroup) {
                    this.control.removeLayer(featureGroup);
                    this.control.closePopup();
                    delete this._featureGroup;
                }
                layers.forEach(descriptor => descriptor && descriptor.featureGroup && this._detachLayerHandlers(descriptor.featureGroup));
                delete this[_layers];
            }
            if (patterns) {
                for (key in patterns) {
                    try {
                        patterns[key].remove();
                    } catch (e) {    // catch an error in library implementation

                    }
                }
                delete this._patterns;
            }
        }

        public get featureGroup(): L.FeatureGroup {
            return this._featureGroup;
        }

        public get layers(): ReadonlyArray<ILayerDescriptor> {
            return this[_layers];
        }

        public addPattern(key: string, options: L.StripePatternOptions): L.StripePattern {
            let patterns = this._patterns || (this._patterns = {});
            return patterns[key] || (patterns[key] = L.stripePattern(options).addTo(this.control));
        }

        public unbind() {
            this.clearMap();
            super.unbind();
        }
    }
};