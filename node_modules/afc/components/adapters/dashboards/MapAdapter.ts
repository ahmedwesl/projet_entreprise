/**
 * Created by jean.rennes on 03/02/2016.
 */
///<reference types="leaflet" />
///<reference path="../../models/dashboards/Dashboard.ts" />
///<reference path="../../helpers/AdapterBase.ts" />
///<reference path="../../gui/map/Map.ts" />

namespace AFC.Dashboards {
    class DashboardLayer extends gui.MapLayerProvider<Globals.IMapLayerStaticModel, Dashboards.IMapLayerDescriptor> {
        public readonly model: IMapModel;
        public readonly offset: number;

        constructor(model: IMapModel, descriptor: Dashboards.IMapLayerDescriptor, offset: number) {
            super(`${model.id}_${offset}`, descriptor);
            this.model = model;
            this.offset = offset;
        }
        
        public get type(): Globals.LayerType {
            return this.descriptor.template.type;
        }
                
        protected override async _getLayerModel(): Promise<Globals.IMapLayerStaticModel> {
            return this.model.getLayer(this.offset);
        }
    }
    
    function _addLayerIndicators(descriptor: Dashboards.IMapLayerDescriptor, dataNodes: {[key: string]: string}, dict: {[key: string]: true}, indicators: string[]): void {
        let template = descriptor.template,
            properties: {[key: string]: Globals.ILayerProperty} = <any>template.properties,
            push = (indicator: string) => dict[indicator] || (dict[indicator] = true, indicator && indicators.push(indicator));
            
        indicators.forEach(indicator => dict[indicator] = true);
        template.tooltips.forEach(tooltip => push(tooltip.id));
        for (let key in properties) {
            let property = properties[key];
            property.column && push(dataNodes[property.column]);
            property.thematic && property.thematic.columns.forEach(column => push(descriptor.dataNodes[column]));
        }
    }
    
    function _getMetadata(reference: Readonly<Globals.IMapVectorLayerMetaData<Globals.LayerType.polygon>>, library: Globals.IMapVectorLayerMetaData<Globals.LayerType.polygon>): Globals.IMapVectorLayerMetaData<Globals.LayerType.polygon> {
        let template: Mutable<Globals.IMapVectorLayerMetaData<Globals.LayerType.polygon>> = Object.create(reference),
            properties: Mutable<Globals.IPolygonProperties> = Object.create(reference.properties);
        properties.visibility = library.properties.visibility;
        template.properties = properties;
        return template;
    }
        
    function _getThematicData(partition: IZonePartition): Globals.IPolygonLegendData {
        let classes: Globals.IClassInfo[] = [];
        
        partition.subsets.forEach(subset=> {
            if ((subset.type === Dashboards.ZoneType.subset) || (subset.type === Dashboards.ZoneType.outOfZone)) {
                let value: string = subset.value;
                classes.push({
                    '<TKVALUE>': {
                        text: value,
                        value: value
                    }
                });
            }
        });
        return {
            fillColor: {
                thematic: {
                    classes: classes
                }
            }
        };
    }
    
    function _getLayerMapping(zoneUnits: Dashboards.IMapLayerDescriptor<Globals.LayerType.polygon>, cannibalization: Dashboards.IMapLayerDescriptor<Globals.LayerType.polygon>): {[key: string]: string} {
        let ret: {[key: string]: string} = {};
        
        zoneUnits.dataNodes && Object.entries(zoneUnits.dataNodes).forEach(([key, value]) => ret[value] = key);
        cannibalization?.dataNodes && Object.entries(cannibalization.dataNodes).forEach(([key, value]) => ret[value] = key);
        return ret;
    }
    
    function _getPattern(cannibalization: Dashboards.IMapLayerDescriptor<Globals.LayerType.polygon>, dataNodes: ReadonlyArray<IDataNode>): Globals.IMapLayerModel['override'] {
        let properties = cannibalization.template.properties;
        return properties.pattern && {
            properties: properties,
            legendData: {
                thematic: {
                    classes: [{
                            "<TKLB>": {value: Number.NEGATIVE_INFINITY, text: "-INF"},
                            "<TKUB>": {value: 1, text: "1"}
                        },{
                            "<TKLB>": {value: 1, text: "1"},
                            "<TKUB>": {value: Number.POSITIVE_INFINITY, text:"+INF"}
                        }
                    ]
                }
            }
        };
    }
    
    const _timeout = 1000;
    
    class TableUpdater {
        protected _sequence: number;
        protected _timeout: number;
        public readonly layer: DistrictLayer;
        public readonly zone: Dashboards.IZone;
        public readonly dataModel: Data.DataModel;
        
        constructor(layer: DistrictLayer, zone: Dashboards.IZone, dataModel: Data.DataModel) {
            this._sequence = 0;
            this.layer = layer;
            this.zone = zone;
            this.dataModel = dataModel;
        }
        
        protected _update(): void {
            let layerInfo = this.layer.layerInfo,
                dataModel = this.dataModel,
                promises: [Promise<Data.IDataModelBase>, ...Promise<Data.IDataModelBase>[]],
                sequence = ++this._sequence;
                
            delete this._timeout;
            if (dataModel && layerInfo) {
                if (layerInfo.tile) {
                    promises = [this.zone.getData(DataSourceKind.outOfZone, layerInfo.indicators)];
                    layerInfo.cannibalization && promises.push(this.zone.getData(DataSourceKind.cannibalization, layerInfo.indicators));
                } else {
                    promises = [this.zone.getData(DataSourceKind.unknown, layerInfo.indicators)];
                }
                Promise.all(promises).then(results => {
                    if (sequence == this._sequence) {
                        let reader = new Tools.Data.TableReader(dataModel, results[0], results[1]),
                            values = this.dataModel.values,
                            component,
                            i = 0, iCount = 0;
                        
                        for (component of reader) {
                            let diff;

                            diff = -1;
                            iCount++;
                            while (i < values.length) {
                                let key = dataModel.getKeyFromRow(values[i]);
                                    
                                diff = Data.compareKey(component.key, key);
                                if (diff > 0) {
                                    dataModel.deleteAt(i);
                                } else {
                                    break;
                                }
                            }
                            diff < 0 ? dataModel.createAt(i++, component.row) : dataModel.modifyAtEx(i++, component.row);
                        }
                        while (values.length > iCount) {
                            dataModel.deleteAt(values.length - 1);
                        }
                    }
                });
            }
        }
        
        public update(delay?: boolean) {
            this._timeout && clearTimeout(this._timeout);
            delay ? this._timeout = setTimeout(() => this._update(), _timeout) : this._update();
        }

        public clear(): void {
            if (this._timeout) {
                clearTimeout(this._timeout);
                delete this._timeout;
                delete this.layer.updater;
            }
        }
    }
    
    class DistrictLayer extends Tools.EventSink implements gui.IDistrictLayerProvider {
        protected readonly _dashboard: Dashboards.IDashboard;
        protected readonly _template: string;
        protected _layer: gui.ILayer<Globals.MapLayerStaticModel<Globals.LayerType.polygon> | Globals.IMapLayerTiledModelImpl<Globals.LayerType.polygon>>;
        protected _loading: boolean;
        protected _zoneUnits: Dashboards.IMapLayerDescriptor<Globals.LayerType.polygon>;
        protected _cannibalization: Dashboards.IMapLayerDescriptor<Globals.LayerType.polygon>;
        protected _zone: IZone;
        protected _descriptor: IRadiusAreaDescriptor | IIsodistanceAreaDescriptor | IIsochroneAreaDescriptor | IPredefinedAreaDescriptor | IBulkMailAreaDescriptor;
        protected _dataModel: Data.DataModel;
        protected _colorProperty: Globals.ILayerProperty<number>;
        public readonly name: string;
        public readonly descriptor: Globals.MapLayerDescriptor;
        public readonly filterable?: boolean;
        public readonly indicators: ReadonlyArray<string>;
        public updater: TableUpdater;
        public layerInfo: {
            cannibalization?: boolean;
            tile: boolean;
            indicators: ReadonlyArray<string>;
        };
        
        constructor(dashboard: Dashboards.IDashboard, template: string, name: string, indicators: ReadonlyArray<string>) {
            super();
            this._dashboard = dashboard;
            this._template = template;
            this.name = name;
            this.indicators = indicators;
        }

        protected _buildTable(zone: IZone, descriptor: IRadiusAreaDescriptor | IIsodistanceAreaDescriptor | IIsochroneAreaDescriptor | IPredefinedAreaDescriptor | IBulkMailAreaDescriptor, zoneUnits: Dashboards.IMapLayerDescriptor<Globals.LayerType.polygon>, cannibalization: Dashboards.IMapLayerDescriptor<Globals.LayerType.polygon>): Promise<Data.DataModel> {
            let dataNodes: {[key: string]: string} = {},
                dict: {[key: string]: true} = {},
                indicators: string[] = this.indicators ? this.indicators.slice(0) : [],
                promises: [Promise<Data.IDataModelBase>, ...Promise<Data.IDataModelBase>[]];
            
            descriptor.dataNodes.forEach(dataNode => {
                dataNodes[dataNode.name] = dataNode.id;
                if (dataNode.qualifier === DataQualifier.partition) {
                    indicators.push(dataNode.id);
                } else if (cannibalization && (dataNode.qualifier === DataQualifier.cannibalizationCount)) {
                    indicators.push(dataNode.id);
                }
            });
            _addLayerIndicators(zoneUnits, dataNodes, dict, indicators);
            cannibalization && _addLayerIndicators(cannibalization, dataNodes, dict, indicators);            
            promises = [zone.getData(DataSourceKind.outOfZone, indicators)];
            cannibalization && promises.push(zone.getData(DataSourceKind.cannibalization, indicators));
            this.layerInfo = {
                cannibalization: !!cannibalization,
                indicators: indicators,
                tile: true
            }
            return Promise.all(promises).then(results => Tools.Data.mergeTables(results[0], results[1]));
        }
        
        protected async _buildStaticTable(zone: IZone, descriptor: IRadiusAreaDescriptor | IIsodistanceAreaDescriptor | IIsochroneAreaDescriptor | IPredefinedAreaDescriptor | IBulkMailAreaDescriptor, zoneUnits: Dashboards.IMapLayerDescriptor<Globals.LayerType.polygon>): Promise<Data.DataModel> {
            let dataNodes: {[key: string]: string} = {},
                dict: {[key: string]: true} = {},
                indicators: string[] = this.indicators ? this.indicators.slice(0) : [],
                dataModelBase;
            
            descriptor.dataNodes.forEach(dataNode => {
                dataNodes[dataNode.name] = dataNode.id;
                if (dataNode.qualifier === DataQualifier.partition) {
                    indicators.push(dataNode.id);
                }
            });
            _addLayerIndicators(zoneUnits, dataNodes, dict, indicators);
            this.layerInfo = {
                indicators: indicators,
                tile: false
            };            
            dataModelBase = await zone.getData(DataSourceKind.unknown, indicators);
            return new Data.DataModel(dataModelBase.columns, dataModelBase.primaryKey, dataModelBase.values);
        }
        
        protected async _buildLayer(zoneUnits: Dashboards.IMapLayerDescriptor<Globals.LayerType.polygon>, cannibalization: Dashboards.IMapLayerDescriptor<Globals.LayerType.polygon>): Promise<Globals.MapLayerStaticModel<Globals.LayerType.polygon> | Globals.IMapLayerTiledModelImpl<Globals.LayerType.polygon>> {
            let layerModel: Globals.MapLayerStaticModel<Globals.LayerType.polygon> | Globals.IMapLayerTiledModelImpl<Globals.LayerType.polygon>,
                zone: IZone<ZoneType.radius> | IZone<ZoneType.isodistance> | IZone<ZoneType.isochrone> | IZone<ZoneType.predefined> | IZone<ZoneType.bulkMail> = Tools.findById(zoneUnits.zone, this._dashboard.zones),
                descriptor = await zone.getDescriptor(),
                dataModel;
                
            if (descriptor.partition) {
                let globals = this._dashboard.descriptor.restModel.globals,
                    [info, geographicalLevels] = await Promise.all([
                        Globals.getMapLayerDrawingInfo<Globals.IMapVectorLayerMetaData<Globals.LayerType.polygon>>(globals, this._template, this.name),
                        globals.getGeographicalLevels()
                    ]);
                    
                if (info && (dataModel = await this._buildTable(zone, descriptor, zoneUnits, cannibalization))) {
                    let level = geographicalLevels.levels[descriptor.geographicalLevels.detailed.id],
                        dataModelView = new Data.DataModelView(dataModel, _getLayerMapping(this._zoneUnits, this._cannibalization)),
                        layerModelEx = Globals.compoundMapLayerTiledModel(info.descriptor, info.layer.table, _getThematicData(descriptor.partition), dataModelView, _getMetadata(zoneUnits.template, info.layer), this.name, info.layer);

                    if (level.table !== info.layer.table.name) {    // Check tile layer geographical level
                        let contextSubstitute = new Rest.ContextSubstitute(info.layer.table.name);
                        contextSubstitute.replacement = level.table;
                        layerModelEx.data.provider.pushModifier(contextSubstitute);
                    }
                    layerModel = layerModelEx;
                    cannibalization && (layerModel.override = _getPattern(cannibalization, descriptor.dataNodes));
                } else if (dataModel = await this._buildStaticTable(zone, descriptor, zoneUnits)) {
                    layerModel = new Globals.MapLayerStaticModel(zoneUnits.template, dataModel, _getThematicData(descriptor.partition));
                }
                if (layerModel) {
                    this._zone = zone;
                    this._descriptor = descriptor;
                    this._dataModel = dataModel;
                    this._colorProperty = zoneUnits.template.properties.fillColor;                    
                }
            }
            return layerModel;
        }
        
        public refresh(): void {
            (this.updater || (this.updater = new TableUpdater(this, this._zone, this._dataModel))).update(true);
        }
        
        public getQualifiedColumn(data: Data.IDBTableDefinition, dataQualifier: DataQualifier): number {
            let descriptor = this._descriptor,
                dataNode: IDataNode,
                indice;
            return descriptor && (dataNode = descriptor.dataNodes.find(dataNode => dataNode.qualifier === dataQualifier)) && ((indice = data.columns.findIndex(column => column.alias === dataNode.name)) !== void 0) ? indice : -1;
        }
        
        public async getLayer(): Promise<Readonly<gui.ILayer<Globals.MapLayerStaticModel<Globals.LayerType.polygon> | Globals.IMapLayerTiledModelImpl<Globals.LayerType.polygon>>>> {
            return this._layer || new Promise(async resolve => {
                this.notify(Tools.EventType.Dirty, ()=> resolve(this._layer));
                if (!this._loading) {
                    let layerModel: Globals.MapLayerStaticModel<Globals.LayerType.polygon> | Globals.IMapLayerTiledModelImpl<Globals.LayerType.polygon>,
                        zoneUnits = this._zoneUnits;
                    
                    this._loading = true;
                    if (zoneUnits) {
                        let cannibalization;
                        if (this._cannibalization && this._cannibalization.zone === this._zoneUnits.zone) {
                            cannibalization = this._cannibalization;
                        }
                        layerModel = await this._buildLayer(zoneUnits, cannibalization);
                    }
                    this._layer = {
                        id: Tools.Data.generateRndString(10),
                        layerModel: layerModel
                    };
                    this.fireEvent(Tools.EventType.Dirty);
                }
            });
        }
        
        public addSource(descriptor: Dashboards.IMapLayerDescriptor<Globals.LayerType.polygon>): void {
            delete this._layer;
            if ((descriptor.dataSourceKind === DataSourceKind.zoneUnits) || (descriptor.dataSourceKind === DataSourceKind.outOfZone)) {
                this._zoneUnits = descriptor;
            } else if (descriptor.dataSourceKind === DataSourceKind.cannibalization) {
                this._cannibalization = descriptor;
            }
        }
        
        public async getDistrictParameters(): Promise<gui.IDistrictParameters> {
            const layer = await this.getLayer();
            if (this._dataModel && layer) {
                let subset = this._descriptor.partition.subsets.find(subset_1 => subset_1.type === ZoneType.outOfZone), filter: (row_1: ReadonlyArray<any>) => boolean;

                if (subset || this.layerInfo?.cannibalization) {
                    let column = this.getQualifiedColumn(this._dataModel, DataQualifier.partition), value = subset.value;
                    filter = row_2 => row_2[column] !== null && row_2[column] !== value;
                }
                return {
                    zone: this._zone,
                    descriptor: this._descriptor,
                    dataModel: filter ? new Data.FilterModel(filter, this._dataModel) : this._dataModel,
                    colorProperty: this._colorProperty,
                    layerModel: layer?.layerModel
                };
            }
        }
        
        public isRedistricted(): boolean  {
            return this._zone && !!this._zone.district.isRedistricted;
        }
        
        public reset(): void  {
            this._zone?.district.reset();
        }
        
        public async affectRow(data: Globals.IMapLayerModelData, row: ReadonlyArray<any>, id: string): Promise<void> {
            let descriptor = this._descriptor,
                dataModel: Data.DataModel,
                subset: ISubsetDescriptor;
                
            if (descriptor && (dataModel = this._dataModel) && (subset = descriptor.partition.subsets.find(item => item.id === id))) {
                let partition = this.getQualifiedColumn(dataModel, DataQualifier.partition),
                    partitionColumn = dataModel.columns[partition],
                    key = data.getKeyFromRow(row),
                    indice = dataModel.lowerKeyBound(key),
                    row1 = dataModel.getRow(indice),
                    affect: boolean;

                if (row1 && !dataModel.compareKey(row1, key)) {
                    affect = dataModel.modifyAt(indice, {[partitionColumn.name]: subset.value});
                } else {
                    row1 = dataModel.columns.map((column, indice) => {
                        let value = null,
                            position;

                        if (column.index === -1) {
                            if (partition === indice) {
                                value = subset.value;
                            } else if (((position = data.columnIndex[column.name]) !== void 0) || ((position = data.columnIndex[column.alias]) !== void 0)) {
                                value = row[position];
                            }
                        } else {
                            value = key[column.index];
                        }
                        return value;
                    });
                    affect = dataModel.createAt(indice, row1);
                }

                if (affect) {
                    this.refresh();
                    return this._zone.district.affect(row[this.getQualifiedColumn(data, DataQualifier.code)], id);
                }
            }
        }
        
        public async getOwnership(data: Globals.IMapLayerModelData, row: ReadonlyArray<any>): Promise<void> {
            let dataModel: Data.DataModel = this._dataModel,
                zone: IZone;
                
            if (dataModel && (zone = this._zone)) {
                let key = data.getKeyFromRow(row),
                    indice = dataModel.find(key),
                    row1 = dataModel.getRow(indice),
                    codeColumn: number,
                    countColumn: number,
                    name: string;
                
                if (row1) {
                    codeColumn = this.getQualifiedColumn(dataModel, DataQualifier.code);
                    if ((countColumn = this.getQualifiedColumn(dataModel, DataQualifier.cannibalizationCount)) !== -1) {
                        name = dataModel.columns[countColumn].name;
                        dataModel.modifyAt(indice, {[name]: 0});
                    }
                    this.refresh();
                    return zone.district.getOwnership(row1[codeColumn]);
                }
            }
        }
        
        public async deleteUnit(data: Globals.IMapLayerModelData, row: ReadonlyArray<any>): Promise<void> {
            let dataModel: Data.DataModel = this._dataModel,
                zone: IZone;
                
            if (dataModel && (zone = this._zone)) {
                let key = data.getKeyFromRow(row),
                    indice = dataModel.find(key),
                    row1 = dataModel.getRow(indice),
                    codeColumn: number,
                    partition: number;
                
                if (row1) {
                    codeColumn = this.getQualifiedColumn(dataModel, DataQualifier.code);
                    partition = this.getQualifiedColumn(dataModel, DataQualifier.partition);
                    dataModel.modifyAt(indice, {[dataModel.columns[partition].name]: null});
                    this.refresh();
                    return zone.district.delete(row1[codeColumn]);
                }
            }
        }
        
        public release(): void {
            this.updater && this.updater.clear();
            delete this._dataModel;
        }
    }

    export class MapAdapter extends Tools.AdapterBase<IMapModel> {
        protected _sequence: number;
        protected _redistrict: boolean;
        protected _district: number;
        protected _indicators: ReadonlyArray<string>;
        public onUpdate: (districtLayerProvider: gui.IDistrictLayerProvider) => any;
        public readonly layers: (gui.IBaseLayerProvider & {release?: ()=> void})[];
        
        constructor() {
            super();
            this.layers = [];
            this._redistrict = false;
            this._sequence = 0;
        }
        
        protected _update(model: IMapModel, event: Tools.IEvent<IMapModel, IDashboardEventData>):void {
            if (!event?.data?.districting) {
                let sequence = ++this._sequence;
                
                delete this._district;
                this.layers.forEach(layer => layer.release && layer.release());
                this.layers.length = 0;                
                model.getMapTemplate().then(template => {
                    let dashboard: Dashboards.IDashboard = model.dashboard;

                    if (dashboard) {
                        let properties: ReadonlyArray<Dashboards.IDashboardProperty> = model.properties,
                            redistrict: number = dashboard.viewsProperties.redistrict,
                            name: string;

                        if (this._redistrict && (redistrict !== void 0) && properties[redistrict]) {
                            name = properties[redistrict][2];
                            name && (name = name.toLowerCase());
                        }
                        model.getDescriptors().then(descriptors => descriptors && this._onLayers(sequence, model, dashboard, descriptors, template, name));
                    }
                });
            }
        }
        
        protected _onLayers(sequence: number, model: IMapModel, dashboard: Dashboards.IDashboard, descriptors: ReadonlyArray<Dashboards.IMapLayerDescriptor>, template: string, name: string): void {
            if (sequence === this._sequence) {
                let districtLayer: DistrictLayer;

                descriptors && descriptors.forEach((descriptor: Dashboards.IMapLayerDescriptor, indice: number) => {
                    if (name && descriptor && (descriptor.type === Dashboards.LayerType.thematic) && (descriptor.name.toLowerCase() === name)) {
                        if (!districtLayer) {
                            this.layers.push(districtLayer = new DistrictLayer(dashboard, template, descriptor.name, this._indicators));
                            this._district = indice;
                        }
                        districtLayer.addSource(descriptor);
                    } else {
                        this.layers.push(new DashboardLayer(model, descriptor, indice));
                    }
                });
                this.onUpdate && this.onUpdate(districtLayer);
            }
        }


        public canDistrict(): boolean  {
            return this._district !== void 0;
        }
        
        public isRedistricted(): boolean  {
            return this.canDistrict() && (<DistrictLayer>this.layers[this._district]).isRedistricted();
        }
        
        public resetDistrict(): void  {
            if (this.canDistrict()) {
                let districtLayer = <DistrictLayer>this.layers[this._district];
                districtLayer.reset();
                this.refresh();
                //this.onUpdate && this.onUpdate(districtLayer);
            }
        }
        
        public getCount(): number {
            return /*this.ready &&*/ this.layers ? this.layers.length : 0;
        }
        
        public getLayerProvider(indice: number): gui.IBaseLayerProvider {
            return this.layers[indice];
        }
        
        public async getInfo(): Promise<Readonly<gui.ILayerProviderInfo>> {
            let globals = this._model.dashboard?.descriptor.restModel.globals;
            
            if (globals) {
                let results = await Promise.all([this._model.getMapTemplate(), globals.getMapViews()]),
                    mapView = results[0] && results[1] && Tools.findById(results[0], results[1]),
                    metadata = mapView && await mapView.getMetadata();
                return gui.getProviderInfoFromMapMetadata(metadata);
            }
        }
        
        public enableDistricting(enable: boolean, indicators?: ReadonlyArray<string>): void {
            if ((this._redistrict !== enable) || (this._indicators !== indicators)) {
                let id = this._model.id;
                
                this._redistrict = enable;
                this._indicators = indicators;
                this._model.setId();
                this._model.setId(id);
            }
        }
    }
};