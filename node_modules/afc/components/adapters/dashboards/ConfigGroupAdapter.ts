/**
 * Created by jean.rennes on 19/09/2017.
 */
///<reference path="../../models/data/Data.ts" />
///<reference path="../../models/dashboards/ConfigGroupModel.ts" />
///<reference path="../../views/controls/Repeater.ts" />
///<reference path="../../helpers/AdapterBase.ts" />
///<reference path="../../adapters/data/RepeaterAdapter.ts" />

namespace AFC.Dashboards {
    const KEYWORD_MODE_COLLAPSED = "collapsed";
    
    interface IStorageHandlers { getItems: (key: string) => any, setItems: (key: string, items: IITemData[]) => void };
    interface IConfigGroupHandlers { [key: string]: Function };

    class StorageHelper {
        public mruSize = 10;
        public mruId: string;
        protected _setItems?: (key: string, items: IITemData[]) => void;
        protected _getItems?: (key: string) => IITemData[];

        public storageActive: boolean = true;

        constructor(mruId?: string, storageActive?: boolean) {
            if (mruId) this.mruId = mruId;
            if (void 0 !== storageActive) this.storageActive = storageActive;
        }

        public set customSetItems(fnSetItems: (key: string, items: IITemData[]) => void) {
            this._setItems = fnSetItems;
        }

        public get customSetItems() {
            return this._setItems;
        }

        public set customGetItems(fnGetItems: (key: string) => any) {
            this._getItems = fnGetItems;
        }

        public get customGetItems() {
            return this._getItems;
        }

        public setItems: (key: string, item: IITemData[]) => void = (key, item) => {
            this.storageActive && this._setItems && this._setItems(key, item);
        }

        public getItems: (key: string) => IITemData[] = (key) => {
            return this.storageActive && this._getItems ? this._getItems(key) : null;
        }
    }

    export class ConfigGroupAdapter extends AFC.Data.RepeaterAdapter {
        protected _list: any[] = [];
        protected _sortedList: any[] = [];
        protected _model: ConfigGroupModel;
        protected _builtInModel: ConfigGroupModel;

        public handlers: IConfigGroupHandlers;
        public storageHelper: StorageHelper;
        public defaultSelection: string = null;

        constructor(control: Controls.Repeater) {
            super(control);

            this.storageHelper = new StorageHelper();
        }

        public get storageSetItems(): (items: IITemData[]) => void {
            return (items: any) => this.storageHelper.setItems(this.storageHelper.mruId, items);
        }

        public get storageGetItems(): () => IITemData[] {
            return () => this.storageHelper.getItems(this.storageHelper.mruId);
        }

        public get mruId(): string {
            return this.storageHelper.mruId;
        }

        public set mruId(mruId: string) {
            this.storageHelper.mruId = mruId;
        }
        
        public get mruSize(): number {
            return this.storageHelper.mruSize;
        }

        public set mruSize(mruSize: number) {
            if (mruSize <= 0 || mruSize >= 20) {
                throw new Error("Incorrect value for mruSize (must be between 0 and 20).");
            }

            this.storageHelper.mruSize = mruSize;
            this.model.maxListSize = mruSize;

            this.storageSetItems(this.model.list);
            this.refresh();
        }

        public set storageHandlers(handlers: IStorageHandlers) {
            if (handlers.setItems) this.storageHelper.customSetItems = handlers.setItems;
            if (handlers.getItems) this.storageHelper.customGetItems = handlers.getItems;
        }
        
        /**
         * Return template name according to current model.mode
         * 
         * @param item 
         * @returns "collapsed-selected" | "collapsed" | "selected"
         */
        public template: (item: AFC.Data.IDataItemContainer) => string = (item) => {
            let templateNames: string[] = [];

            if (this._model.mode === "collapsed") {
                templateNames.push("collapsed");
            }
            
            if (item.dataItemIndex === this._model.selection) {
                templateNames.push("selected");
            }

            return templateNames.join("-");
        }

        public set model(model: ConfigGroupModel) {
            this._model = model;
        }

        public get model(): ConfigGroupModel {
            return this._model;
        }

        public set mode(collapse: string) {
            if (this._model)
                this._model.mode = collapse;
        }

        public get mode(): string {
            return this._model?.mode;
        }

        public selectByDefault(item: { dataItem: IITemData, dataIndex: number }) {
            if (this.defaultSelection === null) {
                this.select(item);
            }
        }

        public select(item: { dataItem: IITemData, dataIndex: number }) {
            this._model?.select(item);
        }

        public bindTo(model: ConfigGroupModel):void {
            let newListnewList: Array<IITemData> = this.storageGetItems() || [];
            model.setList(newListnewList);

            // Save to datastorage
            this.storageSetItems(model.list);

            super.bindTo(model);
        }

        public toggleCollapse(forceCollapse?: boolean): void {
            this.mode = forceCollapse ? KEYWORD_MODE_COLLAPSED : "";
            this.refresh();
        }

        /**
         * Do something before show or hide manual edition box (DOM elem #manualEdition),
         * then triggers control AfcGuiConfigGroup toggleManualEdition default function
         * @see AFC.gui.AfcGuiConfigGroup.toggleManualEdition
         * @param event 
         * @param itemElem 
         * @param forceCollapse 
         * @returns 
         */
        public toggleManualEdition(event: any, itemElem: HTMLElement, forceCollapse?: boolean): boolean {
            const handlers = this.handlers;

            return void 0 !== handlers.fnToggleManualEdition ?
                handlers.fnToggleManualEdition(event, itemElem, forceCollapse)
                : Promise.resolve();
        }

        public async onListItemClick(event: MouseEvent, itemElem: HTMLElement): Promise<boolean> {
            const currAdapter = this;
            const handlers = currAdapter.handlers;
            const clickedValue = parseInt(itemElem.dataset.value, 10);
            const model = currAdapter.model;
            let item: IITemConfig;

            if (!Number.isNaN(clickedValue)) {
                if (clickedValue !== model.selection) {
                    item = model.item(clickedValue, true);

                    if (void 0 !== handlers.fnOnListItemClick) {
                        return handlers.fnOnListItemClick(event, item.dataItem).then(
                            () => {
                                model.select(item.dataItem);
                                currAdapter.refresh();
                                
                                return Promise.resolve(false);
                            }, 
                            () => Promise.reject()
                        );
                    }
                }
            } else {
                return Promise.reject();
            }

            return Promise.resolve(true);
        }

        public onListBtnClick(event: MouseEvent, params?: Array<string>): Promise<any> {
            const handlers = this.handlers;
            let item: { dataItem: any, dataIndex: 0 };

            if (params && params.length) {
                item = handlers.fnCreateItemFromInput(params);

                if (void 0 !== handlers.fnOnListItemClick) {
                    return handlers.fnOnListItemClick(event, item).then(
                        () => {
                            this.model.select(item);
                            this.refresh();
                            
                            return Promise.resolve(); // Click "Valider"
                        }, 
                        () => Promise.reject()
                    );
                }
            }

            return Promise.resolve(); // Click "Annuler"
        }
    }
}