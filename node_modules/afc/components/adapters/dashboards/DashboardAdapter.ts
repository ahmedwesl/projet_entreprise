/**
 * Created by jean.rennes on 28/09/2015.
 */
///<reference path="../../models/dashboards/Dashboard.ts" />
///<reference path="../../views/controls/ListBox.ts" />
///<reference path="../../helpers/AdapterBase.ts" />

namespace AFC.Dashboards {
    function _viewComp(pos: number, view0: Dashboards.IView, view1: Dashboards.IView): number {
        let str0: string, str1: string;

        if (pos !== void 0) {
            view0.properties[pos]&&(str0 = view0.properties[pos][2]);
            view1.properties[pos]&&(str1 = view1.properties[pos][2]);
        }
        if ((str0 === str1) && (view0.name === view1.name))
            return 0;
        if (str0)
            return str1 ? parseInt(str0) - parseInt(str1) : -1;
        return str1 ? 1 : (view0.name < view1.name ? -1 : 1);
    }
    
    function _filterView(dashboard: Dashboards.IDashboard, visible: number, view: Dashboards.IView): boolean {
        return (visible === void 0) || view.properties[visible][2];
    }
    
    function _filterNone(dashboard: Dashboards.IDashboard, visible: number, filter: (dashboard: Dashboards.IDashboard, view: Dashboards.IView) => boolean): Controls.ISelectorGroup[] {
        let views: Dashboards.IView[] = dashboard.views.filter((view: Dashboards.IView) => filter ? filter(dashboard, view) : _filterView(dashboard, visible, view));
        views.sort(_viewComp.bind(null, dashboard.viewsProperties.order));
        return [{id: '', items: views||[]}];
    }
    
    export const enum SelectorType {
        map = 1,
        grid,
        chart
    }
    
    const SelectorTypeMap: {[n: string]: SelectorType} = {
        map: SelectorType.map,
        grid: SelectorType.grid,
        chart: SelectorType.chart
    };
    
    const TypeMap:{[n: number]: SelectorType} = {
        [Dashboards.ViewType.map]: SelectorType.map,
        [Dashboards.ViewType.detailedSheet]: SelectorType.grid,
        [Dashboards.ViewType.aggregatedSheet]: SelectorType.grid,
        [Dashboards.ViewType.chart]: SelectorType.chart,
        [Dashboards.ViewType.report]: SelectorType.chart
    };

    function _getType(view: Dashboards.IView, viewsProperties: Dashboards.IViewsProperties): SelectorType {
        return (view.type === Dashboards.ViewType.spreadSheet) ? 
            ((/*viewsProperties.isgrid ? view.properties[viewsProperties.isgrid][2] :*/ ((<Dashboards.ISpreadSheetDescriptor>view.descriptor).displayType === Dashboards.SpreadSheetDisplayType.grid))?SelectorType.grid:SelectorType.chart):
            TypeMap[view.type];
    }
    
    function _filterByType(dashboard: Dashboards.IDashboard, visible: number, filter: (dashboard: Dashboards.IDashboard, view: Dashboards.IView) => boolean): Controls.ISelectorGroup[] {
        let viewsProperties: Dashboards.IViewsProperties = dashboard.viewsProperties;
        let a1: Controls.ISelectorGroup[] = [];
        let a0: {[n: number]: Dashboards.IView[]} = [];

        dashboard
            .views
            .slice()
            .sort(_viewComp.bind(null, viewsProperties.order))
            .forEach((view: Dashboards.IView)=>{
                let _type: SelectorType;
                (filter ? filter(dashboard, view) : _filterView(dashboard, visible, view)) && (_type = _getType(view, viewsProperties)) && (a0[_type] || (a0[_type] = [])).push(view);
            });
        a0[SelectorType.map] && a1.push({id: 'map', items: a0[SelectorType.map]});
        a0[SelectorType.grid] && a1.push({id: 'grid', items: a0[SelectorType.grid]});
        a0[SelectorType.chart] && a1.push({id: 'chart', items: a0[SelectorType.chart]});
        return a1;
    }    
    
    interface ILinkHolder extends Controls.IBlockListItem {
        [n: number]: Dashboards.IView;
    }
 
    function _filterByLink(dashboard: Dashboards.IDashboard, visible: number, filter: (dashboard: Dashboards.IDashboard, view: Dashboards.IView) => boolean): Controls.ISelectorGroup[] {
        let viewsProperties: Dashboards.IViewsProperties = dashboard.viewsProperties;
        let link: number = viewsProperties.link;
        let a: Dashboards.IView[], b: ILinkHolder[] = [];
        
        if (link !== void 0) {
            let label: string, ref:{[key: string]: ILinkHolder} = {};

            a = dashboard.views.filter((view: Dashboards.IView) => (filter ? filter(dashboard, view) : _filterView(dashboard, visible, view)) && view.properties[link][2]);
            a.sort((view0: Dashboards.IView, view1: Dashboards.IView)=>{
                let p0: SelectorType = _getType(view0, viewsProperties),
                    p1: SelectorType = _getType(view1, viewsProperties);
                return p0 === p1 ? _viewComp(viewsProperties.order, view0, view1) : p0 - p1;
            });
            a.forEach((view: Dashboards.IView) => {
                let holder: ILinkHolder, group: number;
                
                view.properties[link][2].split(',').map((label: string) => label.trim()).forEach((label: string) => {
                    if (!(holder = ref[label])) {
                        ref[label] = holder = { id: view.id, name: label, properties: view.properties};
                        b.push(holder);
                    }
                    group = _getType(view, viewsProperties);
                    !holder[group] && (holder[group] = view);
                });
            });
        }
        return [{id: '', items: b}];
    }

    export const enum SelectorMode {
        none,
        type,
        link
    }

    const SelectorFilters: {[n: number]: (dashboard: Dashboards.IDashboard, visible: number, filter: (dashboard: Dashboards.IDashboard, view: Dashboards.IView) => boolean) => Controls.ISelectorGroup[]} = {
        [SelectorMode.none]: _filterNone,
        [SelectorMode.type]: _filterByType,
        [SelectorMode.link]: _filterByLink
    };
    
    export interface ISelectorEventData {
        group: string;
        item: string;
        map?: Dashboards.IMapView;
        grid?: Dashboards.IGrid;
        chart?: Dashboards.IChart | Dashboards.IReport;
    }

    export class SelectorAdapter extends AFC.Tools.AdapterBase<DashboardModel> {
        protected _selector: Controls.Selector;
        protected _mode: SelectorMode;
        protected _dashboard: IDashboard;
        protected _filter: (dashboard: Dashboards.IDashboard, view: Dashboards.IView) => boolean;
        protected _groups: Controls.ISelectorGroup[];
        protected _selection: Partial<Controls.ISelection>;
        protected [SelectorType.map]: Dashboards.IMapModel;
        protected [SelectorType.grid]: Dashboards.IGridModel;
        protected [SelectorType.chart]: Dashboards.IChartModel;
        protected _initial: string;
        public onChange: (eventData: ISelectorEventData)=>void;

        constructor(selector: Controls.Selector) {
            super();
            (this._selector = selector).dispatchChange = this._onClick.bind(this);
            this._mode = SelectorMode.none;
            this[SelectorType.map] = new MapModel();
            this[SelectorType.grid] = new GridModel();
            this[SelectorType.chart] = new ChartModel();
            this.on(Tools.EventType.Dirty, Tools.AfcReferenceMixin(async (event: Tools.IEvent)=> {
                let groups: Controls.ISelectorGroup[] = this._groups;
                
                if (!this.map.id && !this.grid.id && !this.chart.id) {
                    this._selector.setGroups(groups);
                    if (this._selection) {
                        this._selector.select(groups[0].id);
                    } else {
                        let eventData: ISelectorEventData = (this._initial && await this.selectItem(this._initial)) || this._selectItem(groups[0], 0);
                        delete this._initial;
                        this.onChange && this.onChange(eventData);
                    }
                }
            }, this._refresh), this);
        }
        
        protected _update(model: DashboardModel, event: Tools.IEvent<DashboardModel, IDashboardEventData>): void {
            const dashboard = model.dashboard;

            if (dashboard !== this._dashboard) {
                delete this._selection;
                this._dashboard = dashboard;
                this._refresh();
            }
        }

        protected _refresh(): void {
            let dashboard: IDashboard = this._dashboard,
                groups: Controls.ISelectorGroup[];
            
            if (dashboard && (this._groups = groups = SelectorFilters[this._mode](this._dashboard, this._dashboard.viewsProperties.visible, this._filter))) {
//                delete this._selection;
                this.fireEvent(Tools.EventType.Dirty);
            }
        }
        
        public set filter(value: (dashboard: Dashboards.IDashboard, view: Dashboards.IView) => boolean) {
            this._filter = value;
            this._refresh();
        }

        public get filter(): (dashboard: Dashboards.IDashboard, view: Dashboards.IView) => boolean {
            return this._filter;
        }        

        public set mode(value: SelectorMode) {
            if (this._mode !== value) {
                this._mode = value;
                this._refresh();
            }
        }

        public get mode(): SelectorMode {
            return this._mode;
        }

        public get map(): IMapModel {
            return this[SelectorType.map];
        }

        public get grid(): IGridModel {
            return this[SelectorType.grid];
        }
        
        public get chart(): IChartModel {
            return this[SelectorType.chart];
        }
        
        protected _updateView(view: Dashboards.IView, group: string, item: string, _type: SelectorType, eventData?: ISelectorEventData): ISelectorEventData {
            let id: string = view && view.id;

            eventData || (eventData = {group: group, item: item});
            if (id !== this[_type].id) {
                this[_type].setId(id);
                switch(_type) {
                    case SelectorType.map:
                        eventData.map = <IMapView>view;
                        break;
                    case SelectorType.grid:
                        eventData.grid = <IGrid>view;
                        break;
                    case SelectorType.chart:
                        eventData.chart = <IChart>view;
                        break;
                }
            }
            return eventData;
        }

        protected _onClick(): void {
            let eventData: ISelectorEventData = this._setViews(this._selector.selected);
            eventData && this.onChange && this.onChange(eventData);
        }

        protected _setViews(selection: Partial<Controls.ISelection>): ISelectorEventData {
            let group: Controls.ISelectorGroup = selection.group,
                item: number = selection.item,
                eventData: ISelectorEventData;
            
            if (group && (item !== void 0)) {
                let view: Dashboards.IView;
                let _type: SelectorType;

                this._selection = selection;
                if (this._mode === SelectorMode.type) {
                    (_type = SelectorTypeMap[group.id]) && (eventData = this._updateView(view = <Dashboards.IView>group.items[item], group.id, view.id, _type));
                } else if (this._mode === SelectorMode.link) {
                    let holder: ILinkHolder = <ILinkHolder>group.items[item];
                    eventData = this._updateView(holder[SelectorType.map], group.id, holder.id, SelectorType.map);
                    eventData = this._updateView(holder[SelectorType.grid], group.id, holder.id, SelectorType.grid, eventData);
                    eventData = this._updateView(holder[SelectorType.chart], group.id, holder.id, SelectorType.chart, eventData);
                } else {
                    (view = <Dashboards.IView>group.items[item]) && (_type = _getType(view, this._dashboard.viewsProperties))&&(eventData = this._updateView(view, group.id, view.id, _type));
                }
            }
            return eventData;
        }

        protected _selectItem(group: Controls.ISelectorGroup, indice: number): ISelectorEventData {
            let items: ReadonlyArray<Controls.IBlockListItem> = group.items;
            
            if (items.length > 0) {
                this._selector.select(group.id, items[indice < items.length ? indice : 0].id);
                return this._setViews({
                    group: group,
                    item: indice
                });
            }
            return null;
        }
        
        public bindTo(model: DashboardModel):void {
            this[SelectorType.map].dashboardModel = model;
            this[SelectorType.grid].dashboardModel = model;
            this[SelectorType.chart].dashboardModel = model;
            super.bindTo(model);
        }
        
        public unbind(): void {
            this._selector.setGroups();
            delete this._selection;
            super.unbind();
        }
        
        public async next(): Promise<ISelectorEventData> {
            if (this._groups) {
                let selected: Partial<Controls.ISelection> = this._selection;
                let group: Controls.ISelectorGroup;

                if (group = selected.group || this._groups[0]) {
                    let next: number = selected.item !== void 0 ? (selected.item + 1) % group.items.length : 0;
                    return this._selectItem(group, next);        // To do : do real async someday :(
                }
            }
        }
        
        public async previous(): Promise<ISelectorEventData> {
            if (this._groups) {
                let selected: Partial<Controls.ISelection> = this._selection;
                let group: Controls.ISelectorGroup;

                if (group = selected.group || this._groups[0]) {
                    let previous: number = selected.item !== void 0 ? (group.items.length + selected.item - 1) % group.items.length : group.items.length - 1;
                    return this._selectItem(group, previous);        // To do : do real async someday :(
                }
            }
        }
        
        public async selectItem(value?: string): Promise<ISelectorEventData> {
            if (this._groups) {
                let selected: Partial<Controls.ISelection> = this._selection,
                    group: Controls.ISelectorGroup,
                    name: string,
                    indice: number;
                
                if (group = (selected && selected.group) || this._groups[0]) {
                    indice = value !== void 0 ?
                        (name = value.toLowerCase(),Tools.indexOf(group.items, (item: Controls.IBlockListItem) => (item.id === value) || (item.name.toLowerCase() === name))):
                        0;
                    return (indice !== -1) && this._selectItem(group, indice);         // To do : do real async someday :(
                }
            } else {
                this._initial = value;
            }
        }
        
        public getDashboardFilter(mode: SelectorMode): (dashboard: Dashboards.IDashboard)=> Controls.ISelectorGroup[] {
            return (dashboard: Dashboards.IDashboard)=> dashboard && SelectorFilters[mode](dashboard, dashboard.viewsProperties.visible, this._filter);
        }
    }
};