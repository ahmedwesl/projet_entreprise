/**
 * Created by jean.rennes on 08/10/2015.
 */
///<reference path="../../models/dashboards/Dashboard.ts" />
///<reference path="../../views/controls/GridView.ts" />
///<reference path="../../helpers/AdapterBase.ts" />

namespace AFC.Dashboards {
    function _compare(gridApp: Globals.IGridApp, sortedColumns: ReadonlyArray<Globals.ISortedColumn>, line0: number, line1: number): number {
        let value0: any,
            value1: any,
            ret: number = 0,
            collator: Intl.Collator,
            sortedColumn: Globals.ISortedColumn;

        for (let i: number = sortedColumns.length; !ret&&(i > 0); --i) {
            sortedColumn = sortedColumns[i - 1];
            value0 = gridApp.getValue(sortedColumn.name, line0);
            value1 = gridApp.getValue(sortedColumn.name, line1);
            if ((value0 === null) || (value1 === null))
            {
                if (value0 === null) {
                    ret = (value1 === null) ? 0 : 1;
                }
                else
                    ret = -1;
            }
            else {
                ret = typeof value0 === 'string' ? (collator || (collator = new Intl.Collator(void 0, {sensitivity: 'base'}))).compare(value0, value1) : (((value0 < value1) && -1) || ((value0 > value1) && 1) || 0);
                if (sortedColumn.descending)
                    ret *= -1;
            }
        }
        return ret || (line0 - line1);
    }
     
    function _buildIndex(gridApp: Globals.IGridApp, sortedColumns: ReadonlyArray<Globals.ISortedColumn>, index?: number[]): number[] {
        let a: number[] = index || Array.from(Array(gridApp.getRowCount()).keys());
        a.sort(_compare.bind(null, gridApp, sortedColumns));
        return a;
    }
    
    class SortableGridApp implements Globals.IGridApp {
        private _index: number[];
        public sortedColumns: Globals.ISortedColumn[];
        public readonly gridApp: Globals.IGridApp;
        public readonly allowOrdering: boolean;
        
        constructor(gridApp: Globals.IGridApp) {
            let sortedColumns = gridApp.sortedColumns;
            
            this.gridApp = gridApp;
            this.allowOrdering = true;
            if (sortedColumns) {
                this.sortedColumns = sortedColumns;
                sortedColumns.length && (this._index = _buildIndex(gridApp, sortedColumns));
            }
        }

        public getOriginalLine(line: number): number {
            return this._index ? this._index[line] : line;
        }

        public getTargetLine(line: number): number {
            return this._index ? this._index.indexOf(line) : line;
        }

        public get hasRowHeader(): boolean {
            return this.gridApp.hasRowHeader;
        }
        
        public get hasColumnHeader(): boolean {
            return this.gridApp.hasColumnHeader;
        }
                
        public getRowCount(): number {
            return this.gridApp.getRowCount();
        }
        
        public getRowHeader(line: number): Globals.IGridAppCell {
            return this.gridApp.getRowHeader(this.getOriginalLine(line));
        }
        
        public getRowHeaderWidth(): number {
            return this.gridApp.getRowHeaderWidth();
        }
        
        public getRowHeight(line: number): number {
            return this.gridApp.getRowHeight(this.getOriginalLine(line));
        }
        
        public getColumnInfo(column: number): Globals.IGridAppColumnInfo {
            return this.gridApp.getColumnInfo(column);
        }

        public getColumnCount(): number {
            return this.gridApp.getColumnCount();
        }
        
        public getColumnHeader(column: number): Globals.IGridAppCell {
            let cell = this.gridApp.getColumnHeader(column),
                columnInfo = this.gridApp.getColumnInfo(column),
                sortedColumn;
                
            if (columnInfo) {
                if (this.sortedColumns && (sortedColumn = this.sortedColumns.find(sortedColumn => sortedColumn.name === columnInfo.name))) {
                    cell.className = 'gridViewSorted';
                    sortedColumn.descending && (cell.className += ' descending');
                } else if (columnInfo.supportOrdering) {
                    cell.className = 'gridViewSortable';
                }
            }
            return cell;
        }
        
        public getColumnHeaderHeight(): number {
            return this.gridApp.getColumnHeaderHeight();
        }
        
        public getColumnWidth(column: number): number {
            return this.gridApp.getColumnWidth(column);
        }
        
        public getCell(column: number, line: number): Globals.IGridAppCell {
            return this.gridApp.getCell(column, this.getOriginalLine(line));
        }
        
        public getValue(column: string, line: number): number|string {
            return this.gridApp.getValue(column, this.getOriginalLine(line));
        }

        public getSymbol(key: string): string {
            return this.gridApp.getSymbol(key);
        }
        
        public sort(column: number): boolean {
            let columnInfo = this.gridApp.getColumnInfo(column),
                sortedColumns: Globals.ISortedColumn[],
                sortedColumn: Globals.ISortedColumn,
                indice: number;
            
            if (columnInfo?.supportOrdering && columnInfo.name) {
                sortedColumns = this.sortedColumns || (this.sortedColumns = []);
                indice = sortedColumns.findIndex(sortedColumn => sortedColumn.name === columnInfo.name);

                if (indice === -1) {
                    sortedColumn = {
                        name: columnInfo.name,
                        descending: false
                    };
                    (sortedColumns.length > 2) && sortedColumns.shift();
                } else {
                    sortedColumn = sortedColumns.splice(indice, 1)[0];
                    if (indice === sortedColumns.length)
                        sortedColumn.descending = !sortedColumn.descending;
                }
                sortedColumns.push(sortedColumn);
                this._index = _buildIndex(this.gridApp, sortedColumns, this._index);
                return true;
            }
        }
    }
    
    export const enum ConversionDirection {
        positionToNative,
        nativeToPosition
    }
    
    export class GridAdapter extends AFC.Tools.AdapterBase<IGridModel> {
        private _sortableGridApp: SortableGridApp;
        public readonly control: Controls.GridView;
        public onGenerate: ()=> any;
        public onCellClick: (column: number, line: number)=> any;
        public enableSelection: boolean;

        constructor(grid: Controls.GridView) {
            super();
            this.control = grid;
            this.enableSelection = false;
        }

        protected _update(model: IGridModel, event: Tools.IEvent<IGridModel, IDashboardEventData | Array<number>>): void {
            let data = event?.data;
            
            if (data instanceof Array) {
                // column mode
                data.forEach(column => {
                    let gridApp = this.control.gridApp;
                    
                    if (gridApp) {
                        for (let y = 0, yMax = gridApp.getRowCount(); y < yMax; ++y) {
                            this.control.refreshCell(column, y);
                        }
                    }
                });
            } else if (!data?.districting) {
                this.control.setGrid();
                this.control.onCellClick = null;
                this._sortableGridApp = null;
                model && model.getGridApp().then(gridApp => {
                    if (gridApp) {
                        let enableSelection: boolean = this.enableSelection,
                            setGrid = (gridApp: Globals.IGridApp) => (this.control.setGrid(gridApp, enableSelection),this.onGenerate&&this.onGenerate()),
                            sortableGridApp: SortableGridApp = gridApp.allowOrdering && gridApp.hasColumnHeader && new SortableGridApp(gridApp);
                        
                        this.control.onCellClick = (column: number, line: number) => {
                            if (sortableGridApp && line === -1 && column > -1) {
                                let selection;
                                
                                if (enableSelection)
                                    selection = sortableGridApp.getOriginalLine(this.control.selection);
                                if (sortableGridApp.sort(column)) {
                                    setGrid(sortableGridApp);
                                    enableSelection && this.control.highlight(sortableGridApp.getTargetLine(selection));
                                }
                            }
                            if (enableSelection && (line !== -1)) {
                                this.control.highlight(line);
                            }
                            this.onCellClick && this.onCellClick(column, line);
                        };
                        setGrid(sortableGridApp ? this._sortableGridApp = sortableGridApp : gridApp);
                    }
                });
            }
        }
        
        public convertLine(line: number, conversionDirection?: ConversionDirection /* positionToNative */): number {
            let indice = line;
            
            if (this._sortableGridApp) {
                indice = conversionDirection === ConversionDirection.nativeToPosition ? 
                    this._sortableGridApp.getTargetLine(line) : 
                    this._sortableGridApp.getOriginalLine(line);
            }
            return indice;
        }
        
        public unbind(): void {
            this.control.setGrid();
            super.unbind();
        }                
    }
};