/**
 * Created by jean.rennes on 20/11/2015.
 */
///<reference path="../../AFC.ts" />
///<reference path="../../helpers/EventSink.ts" />
///<reference path="../../helpers/Data.ts" />
///<reference path="../../application/Parcelable.ts" />

namespace AFC.Rest {
    "use strict";

    export const enum ConnectionStatus {
        ok = 1,
        failed,
        maxConnection,
        error,
        resetPassword,
        timeout
    }

    const ConnectionStatusLookup: { [key: string]: ConnectionStatus } = {
        ok: ConnectionStatus.ok,
        failed: ConnectionStatus.failed,
        maxConnection: ConnectionStatus.maxConnection,
        error: ConnectionStatus.error,
        resetPassword: ConnectionStatus.resetPassword,
        timeout: ConnectionStatus.timeout
    };

    const enum State {
        uninitialized = 0,
        pending,
        ready
    }

    interface IRequestInfo {
        session?: string;
        rnd?: string;
    };

    export interface IUserRequestInfo extends IRequestInfo {
        name: string;
        password: string;
    }

    interface IForgottenInfo extends IRequestInfo {
        name: string;
        url: string;
    };

    export interface ISecurityToken {
        providerKey: any;
        provider: any;
        productKey: string;
        creationDate: Date;
        expiryDate: Date;
        data?: any;
    }

    export interface IUserResponseInfo {
        status: number;
        userName?: string;
        credentials?: string;
        data?: any;
    }

    export interface IIdentity<T = any> extends Application.IParcelable<IIdentity<T>> {
        readonly authorizationPolicy: IAuthorizationPolicy;
        readonly name: string;
        readonly isAuthenticated: boolean;
        readonly status: ConnectionStatus;
        readonly data: T;
        readonly logoutUri: string;
        getAjaxBody(): string;
        getCredentials<T = { [key: string]: any }>(): T;
        refresh(): Promise<this>;
        invalidate(): void;
    }

    declare interface RSAKey {
        setPublic(n: string, e: string): void;
        encrypt(key: string): string;
    }
    declare const RSAKey: { new(): RSAKey };

    declare interface KeyValue {
        n: string;
        e: string;
    }

    declare namespace CryptoJS {
        enum enc {
            Base64,
            Latin1,
            Utf8
        }

        export interface Digest {
            toString(encoding?: enc): string;
        }

        export function SHA1(value: string): Digest;
        export namespace Rabbit {
            function encrypt(value: string, key: any): Digest;
            function decrypt(value: string, key: any): Digest;
        }
    }

    export interface IAuthorizationPolicy extends UrlLoader {
        init(): Promise<AuthType>;
        invalidate(): void;
        getIdentity(): Promise<IIdentity>;
        restart(loose?: boolean): void;
    }

    const _rsa = Symbol(),
        _identity = Symbol(),
        _mode = Symbol(),
        _logoutUri = Symbol(),
        _tokenUri = Symbol(),
        _authorizationUri = Symbol(),
        _state = Symbol(),
        _refresh = Symbol();
    let gCnt: number = 0;

    export const enum AuthType {
        uninitialized,
        loading,
        error,
        self,
        direct = 0x10,
        openIdForward = 0x100000,
        authorizationCode = 0x100010
    }
    function _isCodeBased(authType: AuthType): boolean {
        return !!(authType & 0x100000);
    }
    function _allowDirectIdentity(authType: AuthType): boolean {
        return !!(authType & 0x10);
    }
    function _getLocation(): string {
        return window.location.href;
    }

    const AuthTypeLookup: { [key: string]: AuthType } = {
        direct: AuthType.direct,
        openIdForward: AuthType.openIdForward,
        authorizationCode: AuthType.authorizationCode
    }

    function authType(value: string): AuthType {
        return AuthTypeLookup[value];
    }

    function _key(): string {
        return AFC.Tools.Data.generateRndString(116);
    }

    let _session = AFC.Tools.Data.generateRndString(20);

    interface IIdentityEx extends IIdentity {
        /** @internal */
        [_refresh](userName?: string, credentials?: string, status?: ConnectionStatus, data?: any): void;
    }

    export class UrlLoader {
        public readonly searchParams: URLSearchParams;

        constructor() {
            this.searchParams = new URLSearchParams(window.location.search);
            window.history.replaceState(null, '', _getLocation().split(/[?#]/)[0]);
        }
    }


    export class AuthorizationPolicy extends Tools.EventSinkMixin(UrlLoader) implements IAuthorizationPolicy {
        public readonly baseUrl: string;
        /** @internal */
        private [_rsa]: Readonly<KeyValue>;
        /** @internal */
        private [_identity]: Identity;
        /** @internal */
        private [_logoutUri]: string;
        /** @internal */
        private [_tokenUri]: string;
        /** @internal */
        private [_authorizationUri]: string;
        /** @internal */
        private [_mode]: AuthType;
        /** @internal */
        private [_state]: State;
        private _sequence: number;

        public static Identity: {
            new(policy: AuthorizationPolicy, userName?: string, credentials?: string, status?: ConnectionStatus, data?: any): IIdentityEx
        } = class Identity implements IIdentity {
                public readonly authorizationPolicy: AuthorizationPolicy;
                private _name: string;
                private _token: string;
                private _status: ConnectionStatus;
                private _data: any;

                constructor(policy: AuthorizationPolicy, userName?: string, credentials?: string, status?: ConnectionStatus, data?: any) {
                    this.authorizationPolicy = policy;
                    this[_refresh](userName, credentials, status, data);
                }

                public get name(): string {
                    return this._name;
                }

                public get status(): ConnectionStatus {
                    return this._status;
                }

                public get data(): any {
                    return this._data;
                }

                public get isAuthenticated(): boolean {
                    return this._status === ConnectionStatus.ok || this._status === ConnectionStatus.resetPassword;
                }

                public get logoutUri(): string {
                    return this.authorizationPolicy.getLogoutUri();
                }

                public [_refresh](userName: string = '', credentials?: string, status: ConnectionStatus = ConnectionStatus.failed, data?: any): void {
                    this._name = userName;
                    this._token = encodeURIComponent(credentials);
                    this._status = status;
                    data && (this._data = data);
                }

                public getAjaxBody(): string {
                    return `token=${this._token}`;
                }

                public getCredentials<U = { [key: string]: any }>(): U & { token: string } {
                    return <any>{
                        token: this._token
                    };
                }

                public refresh(): Promise<this> {
                    return this.authorizationPolicy._refresh(this);
                }

                public async getAuthorizationCode(): Promise<string> {
                    return new Promise((resolve, reject) => {
                        let settings: JQuery.AjaxSettings = {
                            url: this.authorizationPolicy.baseUrl + '/auth/code',
                            complete: (jqXHR: JQueryXHR, textStatus: string) => {
                                let token: string = jqXHR.status === 200 && <string>jqXHR.responseText;
                                token ? resolve(token) : reject();
                            },
                            method: 'POST',
                            processData: false,
                            async: true,
                            data: this.authorizationPolicy._getBody(_key(), {
                                session: _session, rnd: _key()
                            })
                        };
                        settings.data += `&${this.getAjaxBody()}`;
                        jQuery.ajax(settings);
                    });
                }

                public invalidate(): void {
                    if (this.isAuthenticated) {
                        jQuery.ajax({
                            url: `${this.authorizationPolicy.baseUrl}/logout`,
                            method: 'POST',
                            processData: false,
                            async: true,
                            data: `content=${this._token}`
                        });
                        this[_refresh]();
                        this.authorizationPolicy.invalidate();
                    }
                }

                public static CREATOR = new Application.Parcelable.Creator<Identity>(
                    (parcel: Application.Parcel): Identity => {
                        let authorizationPolicy = new AuthorizationPolicy(<string>parcel.baseUrl),
                            identity = new Identity(authorizationPolicy, <string>parcel.name, "", <ConnectionStatus>parcel.status, parcel.data);

                        identity._token = <string>parcel.token;
                        authorizationPolicy[_rsa] = <any>parcel.rsa;
                        authorizationPolicy[_logoutUri] = <string>parcel.logoutUri;
                        authorizationPolicy[_tokenUri] = <string>parcel.tokenUri;
                        authorizationPolicy[_authorizationUri] = <string>parcel.authorizationUri;
                        authorizationPolicy[_mode] = <AuthType>parcel.mode;
                        authorizationPolicy[_state] = <State>parcel.state;
                        authorizationPolicy._sequence = <number>parcel.sequence;
                        _session = <string>parcel.session;
                        return identity;
                    }
                );

                public writeToParcel(out: Application.Parcel): void {
                    out.baseUrl = this.authorizationPolicy.baseUrl;
                    out.rsa = this.authorizationPolicy[_rsa];
                    out.logoutUri = this.authorizationPolicy[_logoutUri];
                    out.tokenUri = this.authorizationPolicy[_tokenUri];
                    out.authorizationUri = this.authorizationPolicy[_authorizationUri];
                    out.mode = this.authorizationPolicy[_mode];
                    out.state = this.authorizationPolicy[_state];
                    out.sequence = this.authorizationPolicy._sequence;
                    out.session = _session;
                    out.name = this._name;
                    out.token = this._token;
                    out.status = this._status;
                    out.data = this._data;
                }
            }

        constructor(url: string) {
            super();
            this.baseUrl = url;
            this[_mode] = AuthType.uninitialized;
            this[_state] = State.uninitialized;
            this[_identity] = new AuthorizationPolicy.Identity(this);
        }

        public getLogoutUri(): string {
            return this[_logoutUri];
        }

        protected _onTokenAlways(sequence: number, key: string, jqXHR: JQueryXHR, textStatus: string): void {
            if (this._sequence === sequence) {
                let message,
                    responseInfo: IUserResponseInfo,
                    userName: string,
                    credentials: string,
                    status: ConnectionStatus,
                    data: any;

                if (jqXHR.status === 200 && (message = jqXHR.responseText) && (message = CryptoJS.Rabbit.decrypt(message, key).toString(CryptoJS.enc.Utf8)) && (responseInfo = JSON.parse(message))) {
                    userName = responseInfo.userName;
                    credentials = responseInfo.credentials;
                    status = ConnectionStatusLookup[responseInfo.status];
                    data = responseInfo.data;
                }
                userName || (userName = '');
                status || (status = ConnectionStatus.failed);
                this[_identity][_refresh](userName, credentials, status, data);
                this[_state] = State.ready;
                this.fireEvent(Tools.EventType.UserEvent);
            }
        }

        protected _getBody(key: string, message: any): string {
            let crypted: string = message && encodeURIComponent(CryptoJS.Rabbit.encrypt(JSON.stringify(message), key).toString()) || AFC.Tools.Data.generateRndString(64),
                rsaKey = new RSAKey();
            rsaKey.setPublic(this[_rsa].n, this[_rsa].e);
            return `content=${rsaKey.encrypt(key) + crypted}`;
        }

        protected _buildAjaxSettings(key: string, endPoint: string, message?: IRequestInfo & { [key: string]: any; }): JQueryAjaxSettings {
            this[_state] = State.pending;
            (message || (message = {})).session = _session;
            message.rnd = _key();
            return {
                url: this.baseUrl + (endPoint ? `/${endPoint}` : ''),
                complete: this._onTokenAlways.bind(this, this._sequence = ++gCnt, key),
                method: 'POST',
                processData: false,
                async: true,
                data: this._getBody(key, message)
            };
        }

        protected _loadCertificate(url: string): Promise<boolean> {
            return new Promise(resolve => jQuery.ajax({
                url: url,
                complete: (jqXHR: JQueryXHR, textStatus: string) => {
                    let o: { keys: ReadonlyArray<KeyValue> } = jqXHR.responseJSON,
                        success = false;

                    if (o && o.keys && o.keys.length) {
                        this[_rsa] = o.keys[0];
                        success = true;
                    }
                    resolve(success);
                },
                method: 'GET',
                async: true
            }));
        }

        protected _setAuthorizationCode(code: string): Promise<IIdentity> {
            return new Promise(resolve => {
                this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve(this[_identity]));
                if (this[_state] !== State.pending) {
                    let key = _key(),
                        settings = this._buildAjaxSettings(key, '');

                    settings.url = this[_tokenUri];
                    settings.data += `&code=${code}&redirect_uri=${this.getRedirectUri()}`;
                    jQuery.ajax(settings);
                }
            });
        }

        protected async _refresh<U extends InstanceType<typeof AuthorizationPolicy.Identity>>(identity: U): Promise<U> {
            return new Promise(resolve => {
                this.notify(AFC.Tools.EventType.UserEvent, (/*event*/) => resolve(identity));
                if (this[_state] !== State.pending) {
                    let key = _key(),
                        settings = this._buildAjaxSettings(key, 'authenticate'),
                        tokenUri = this[_tokenUri];

                    if (tokenUri) {
                        settings.url = tokenUri;
                    }
                    settings.data += `&${identity.getAjaxBody()}&redirect_uri=${this.getRedirectUri()}`;
                    jQuery.ajax(settings);
                }
            });
        }

        public restart(loose?: boolean): void {
            if (!loose || (_isCodeBased(this[_mode]) && !this.searchParams.get('code'))) {
                let authorizationUri = this[_authorizationUri];

                if (!authorizationUri || (_getLocation() !== authorizationUri.split(/[?#]/)[0])) {
                    window.location.replace(this.getAuthorizationUri());
                }
            }
        }

        public getAuthorizationUri(): string {
            return this[_authorizationUri] || `${_getLocation()}?rnd=${Tools.Data.generateRndString(20)}`;;
        }

        public getRedirectUri(): string {
            return _getLocation().split(/[?#]/)[0].replace(/\/index.html$|\/$/i, '');
        }

        public async init(): Promise<AuthType> {
            return this[_mode] !== AuthType.uninitialized && this[_mode] !== AuthType.loading ? this[_mode] :
                new Promise(resolve => {
                    this.notify(AFC.Tools.EventType.UserEvent + 1, (/*event*/) => resolve(this[_mode]));
                    if (this[_mode] === AuthType.uninitialized) {
                        this[_mode] = AuthType.loading;
                        jQuery.ajax({
                            url: `${this.baseUrl}/auth`,
                            complete: async (jqXHR, textStatus) => {
                                this[_mode] = AuthType.direct;
                                if (jqXHR.status === 200) {
                                    let discovery: {
                                        type: string,
                                        jwks_uri: string,
                                        authorization_endpoint: string,
                                        end_session_endpoint: string,
                                        token_endpoint: string
                                    } = jqXHR.responseJSON;

                                    if (discovery) {
                                        let mode = authType(discovery.type),
                                            code: string,
                                            isCodeBased = _isCodeBased(mode);

                                        if (isCodeBased && (this[_tokenUri] = discovery.token_endpoint)) {
                                            code = this.searchParams.get('code');
                                            this[_mode] = mode;
                                        }
                                        this[_authorizationUri] = discovery.authorization_endpoint;
                                        this[_logoutUri] = discovery.end_session_endpoint;

                                        if (await this._loadCertificate(discovery.jwks_uri)) {
                                            isCodeBased && code ?
                                                this._setAuthorizationCode(code) :
                                                this[_state] = State.ready;
                                        } else {
                                            this.fireEvent(Tools.EventType.UserEvent);
                                            this[_mode] = AuthType.error;
                                        }
                                    }
                                }
                                this.fireEvent(AFC.Tools.EventType.UserEvent + 1);
                            },
                            method: 'GET',
                            async: true,
                            data: `redirect_uri=${this.getRedirectUri()}`
                        });
                    }
                });
        }

        public getIdentity(): Promise<IIdentity> {
            return this.init().then(authType =>
                authType !== AuthType.error
                && (this[_state] === State.ready ? this[_identity] : new Promise(resolve => this.notify(AFC.Tools.EventType.UserEvent, (/*event*/) => resolve(this[_identity])))));
        }

        public setDirectIdentity(name: string, password: string): Promise<IIdentity> {
            return this.init().then(authType =>
                _allowDirectIdentity(authType)
                && new Promise(resolve => {
                    let key = _key(),
                        message: IUserRequestInfo = {
                            name: name,
                            password: CryptoJS.SHA1(password).toString(CryptoJS.enc.Base64)
                        };

                    this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve(this[_identity]));
                    jQuery.ajax(this._buildAjaxSettings(key, 'authenticate', message));
                }));
        }

        public resetPasswordUntrusted(name: string, oldPassword: string, newPassword: string): Promise<IIdentity> {
            return this.init().then(authType =>
                _allowDirectIdentity(authType)
                && new Promise(resolve => {
                    let key = _key(),
                        message: IUserRequestInfo & { newPassword: string } = {
                            name: name,
                            password: CryptoJS.SHA1(oldPassword).toString(CryptoJS.enc.Base64),
                            newPassword: CryptoJS.SHA1(newPassword).toString(CryptoJS.enc.Base64)
                        };

                    this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve(this[_identity]));
                    jQuery.ajax(this._buildAjaxSettings(key, 'reset', message));
                }));
        }

        public resetPasswordTrusted(credentials: string, newPassword: string): Promise<IIdentity> {
            return this.init().then(authType =>
                _allowDirectIdentity(authType)
                && new Promise(resolve => {
                    let key = _key(),
                        message: { trusted: boolean; newPassword: string; credentials: string } = {
                            trusted: true,
                            newPassword: CryptoJS.SHA1(newPassword).toString(CryptoJS.enc.Base64),
                            credentials: credentials
                        };

                    this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve(this[_identity]));
                    jQuery.ajax(this._buildAjaxSettings(key, 'reset', message));
                }));
        }

        public sendReminder(name: string, returnUrl: string): Promise<boolean> {
            return this.init().then(authType =>
                _allowDirectIdentity(authType)
                && new Promise(resolve => {
                    let message: IForgottenInfo = {
                        name: name,
                        url: returnUrl + `${returnUrl.indexOf('?') === -1 ? '?' : '&'}content=%1`
                    };
                    let opts: JQueryAjaxSettings = {
                        url: `${this.baseUrl}/forgotten`,
                        complete: (jqXHR: JQueryXHR, textStatus: string) => {
                            resolve((jqXHR.status === 200) && (jqXHR.responseText === (ConnectionStatus.ok).toString()));
                        },
                        method: 'POST',
                        processData: false,
                        async: true,
                        data: this._getBody(_key(), message)
                    };
                    jQuery.ajax(opts);
                }));
        }

        public invalidate(): void {
            delete this._sequence;
            this[_state] = State.ready;
            this[_identity].invalidate();
        }
    }

    type Identity = InstanceType<typeof AuthorizationPolicy.Identity>;

    class Self<T = any> implements IIdentity<T> {
        private readonly _key: string;
        public readonly authorizationPolicy: SelfAuthorizationPolicy<T>;
        public readonly name: string;
        public isAuthenticated: boolean;
        public readonly status: ConnectionStatus;
        public readonly data: T;
        public readonly logoutUri: string;

        constructor(authorizationPolicy: SelfAuthorizationPolicy<T>, key: string, name: string, data: T) {
            this.authorizationPolicy = authorizationPolicy;
            this._key = key;
            this.name = name || '';
            this.isAuthenticated = true;
            this.status = ConnectionStatus.ok;
            data && (this.data = data);
        }

        public getAjaxBody(): string {
            return `key=${this._key}`;
        }

        public getCredentials<U = { [key: string]: any }>(): U & { key: string } {
            return <any>{
                key: this._key
            };
        }

        public async refresh(): Promise<this> {
            return this;
        }

        public invalidate(): void {
        }

        public static CREATOR = new Application.Parcelable.Creator<Self>(
            (parcel: Application.Parcel): Self => {
                let authorizationPolicy = new SelfAuthorizationPolicy(<string>parcel.key, <string>parcel.name, parcel.data);
                _session = <string>parcel.session;
                return authorizationPolicy[_identity];
            }
        );

        public writeToParcel(out: Application.Parcel): void {
            out.session = _session;
            out.key = this._key;
            out.name = this.name;
            out.data = <any>this.data;
        }
    }

    export class SelfAuthorizationPolicy<T = any> extends UrlLoader implements IAuthorizationPolicy {
        /** @internal */
        public [_identity]: Self<T>;

        constructor(key: string, name: string, data?: T) {
            super();
            this[_identity] = new Self(this, key, name, data);
        }

        public init(): Promise<AuthType> {
            return Promise.resolve(AuthType.self);
        }

        public restart(loose?: boolean): void {
            loose || window.location.replace(this.getAuthorizationUri());
        }

        public getIdentity(): Promise<IIdentity<T>> {
            return Promise.resolve(this[_identity]);
        }

        public getAuthorizationUri(): string {
            return `${AuthorizationPolicy.prototype.getRedirectUri.call(null)}?rnd=${Tools.Data.generateRndString(20)}`;
        }

        public invalidate(): void {
        }
    }
}