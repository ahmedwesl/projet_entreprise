/**
 * Created by jean.rennes on 29/09/2015.
 */
///<reference path="../../AFC.ts" />
///<reference path="../../helpers/EventSink.ts" />
///<reference path="../data/Global.ts" />

namespace AFC.Rest {
    function _extract(s:string):string {
        return s.startsWith('dataCreations:') ? s.substr(14) : void 0;
    }

    const _dataCnt = Symbol(),
        _entries = Symbol();

    export interface ICreationContext {
        dataCreations?: {
            [key: string]: Data.IDataCreation;
        };
    }
    
    export interface IDataCreatorEntry<T extends Data.IDataCreation = Data.IDataCreation> {
        readonly key: string;
        readonly creation: T;
        readonly persist: boolean;
        show?: boolean; 
    }

    export type IContextModifierOptions = {
        [key: string]: any;
        noReplacements?: boolean;
    };

    export interface IContextModifier<T extends IRequestBody = IRequestBody> {
        updateBody(body: T, options?: IContextModifierOptions): void;
        readonly load?: (options?: IContextModifierOptions) => Promise<any>;
        readonly release?: ()=> void;
    }
    
    export class DataCreator<T extends IRequestBody<ICreationContext> = IRequestBody<ICreationContext>> extends Tools.EventSink implements IContextModifier<T> {
        private static _global: number = 0;
        /** @internal */        
        private [_dataCnt]: number = 0;
        /** @internal */        
        private [_entries]: { [keys: string]: Mutable<IDataCreatorEntry> };
        public readonly base: IContextModifier;

        constructor(base?: IContextModifier) {
            super();
            this.base = base;
        }
        
        public load(options?: IContextModifierOptions): Promise<any> {
            return this.base?.load?.(options);
        }

        public updateBody(body: IRequestBody<ICreationContext>, options?: IContextModifierOptions): void {
            let entries = this[_entries];

            this.base?.updateBody(body, options);
            if (entries) {
                let context = body.context || (body.context = {}),
                    entry;
                
                for (let key in entries) {
                    entry = entries[key];
                    if (entry.persist || entry.show) {
                        delete entry.show;
                        (context.dataCreations || (context.dataCreations = {}))[key] = entry.creation;
                    }
                }
            }
        }

        public createData<T extends Data.IDataCreation = Data.IDataCreation>(creation: T, autoDisable?: boolean): IDataCreatorEntry<T> {
            let entries = this[_entries] || (this[_entries] = {}),
                key = `t${DataCreator._global++}`;

            ++this[_dataCnt];
            return entries[key] = {
                key: `dataCreations:${key}`,
                creation: creation,
                persist: !autoDisable
            };
        }

        public getData(id: string): Data.IDataCreation {
            let s: string = _extract(id);
            let creations = this[_entries];
            return s && creations && creations[s].creation;
        }

        public updateData(id: string, creation: Data.IDataCreation): string {
            let s: string = _extract(id);
            let creations = this[_entries];

            if (s && creations&&creations[s]) {
                creations[s].creation = creation;
                return id;
            }
        }

        public discardData(id?: string): void {
            if (id) {
                let s: string = _extract(id);
                let creations = this[_entries];

                if (s&&creations && creations[s]) {
                    delete creations[s];
                    if (--this[_dataCnt] === 0) {
                        delete this[_entries];
                    }
                }
            } else {
                delete this[_entries];
                delete this[_dataCnt];
            }
        }

        public clone(): DataCreator {
            let clone: DataCreator = Reflect.construct(DataCreator, [this.base], this.constructor);
            if (this[_dataCnt]) {
                let destinations: {[keys: string]: Mutable<IDataCreatorEntry>} = clone[_entries] = {},
                    sources = this[_entries],
                    source;

                clone[_dataCnt] = this[_dataCnt];
                for (let key in sources) {
                    source = sources[key];
                    destinations[key] = {
                        key: key,
                        creation: source.creation,
                        persist: source.persist
                    };
                }
            }
            return clone;
        }
    }
    
    export class DataResource<Type extends DataCreator> {
        protected _provider: Type;
        protected _entry: IDataCreatorEntry;

        public get provider(): Type {
            return this._provider;
        }

        public get id(): string {
            return this._provider && this._entry?.key;
        }

        public create(provider: Type, creation: AFC.Data.IDataCreation): boolean {
            if (this._provider === provider) {
                provider.updateData(this.id, creation);
                return false;
            }
            this.release();
            this._entry = (this._provider = provider).createData(creation);
            return true;
        }

        public release(): void {
            if (this._provider) {
                this._provider.discardData(this.id);
                delete this._provider;
            }
        }

        public clone<Type2 extends DataCreator>(provider: Type2): DataResource<Type2> {
            let clone: DataResource<Type2> = Object.create(this.constructor.prototype),
                id: string = this.id,
                creation: AFC.Data.IDataCreation = id && this._provider.getData(id);
            creation && clone.create(provider, creation);
            return clone;
        }
    }    
}