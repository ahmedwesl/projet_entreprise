/**
 * Created by jean.rennes on 29/09/2015.
 */
///<reference path="RequestBuilder.ts" />
///<reference path="AuthorizationPolicy.ts" />
///<reference path="../data/Schema.ts" />
///<reference path="../globals/Global.ts" />

namespace AFC {
    export namespace Rest {
        export const enum RestFormat {
            json=1,
            pdf,
            xml,
            googleservice,	// kmz
            geojson,
            pptx,
            jpeg,
            png4,
            png8,
            png24,
            png32,
            gif,
            bmp,
            tiff,
            xlsx,
            csv,
            native,
        }

        export const enum RestMethod {
            POST = "POST",
            GET = "GET"
        }

        export const enum MimeType {
            xlsx = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        }

        export const enum LogAction {
            authenticate = 0,
            reset = 1,
            forgotten = 2,
            logout = 3,
            openIdInvalidJWT = 1000,
            openIdCheckFailed = 1001,
            openIdUnknownUser = 1002,
            reportGeneration = 10000,
            user = 20000
        }
                
        const RestFormatLookUp: {[key: number]: string} = {
            [RestFormat.json]: "json",
            [RestFormat.pdf]: "pdf",
            [RestFormat.xml]: "xml",
            [RestFormat.googleservice]: "googleservice",
            [RestFormat.geojson]: "geojson",
            [RestFormat.pptx]: "pptx",
            [RestFormat.jpeg]: "jpeg",
            [RestFormat.png4]: "png4",
            [RestFormat.png8]: "png8",
            [RestFormat.png24]: "png24",
            [RestFormat.png32]: "png32",
            [RestFormat.gif]: "gif",
            [RestFormat.bmp]: "bmp",
            [RestFormat.tiff]: "tiff",
            [RestFormat.xlsx]: "xlsx",
            [RestFormat.csv]: "csv",
            [RestFormat.native]: "native",
        };

        export interface IRequestBody<T = any> {
            context?: T;
            tid?: string;
            lang?: never;
            encoding?: never;
            f?: never;
            token?: never;
            key?: never;
        }
        
        export interface IAjaxOptions<T = any> {
            done? (sequence:number, data: any, textStatus: string, jqXHR: JQueryXHR): any;
            fail? (sequence:number, jqXHR: JQueryXHR, textStatus: string, errorThrown: string): boolean;
            always? (sequence:number, jqXHR: JQueryXHR, textStatus: string): any;
            byPassError? : boolean,
            method?: string;
            async?: boolean;
            format?: RestFormat;
            encoding?: string;
            skipDefaultParameters?: boolean;
            locale: Tools.Lang.Locale;
            data: T & IRequestBody<ICreationContext>;
            converter?: (text: string) => any;
            xhrFields?: any
        }
        
        export interface IAjaxRequest<T = any> {
            readonly sequence: number;
            readonly uri?: string;
            readonly options: IAjaxOptions<T>;
            readonly progressId: string;
            enableCompression: boolean;
            getBody(): string;
            call(): number;
        }

        export class NetworkStatus {
            public readonly request: Rest.IAjaxRequest;
            public readonly jqXHR: JQueryXHR;
            public readonly textStatus: string;
            public readonly errorThrown: string;

            constructor(request: Rest.IAjaxRequest, jqXHR: JQueryXHR, textStatus: string, errorThrown?: string) {
                this.request = request;
                this.jqXHR = jqXHR;
                this.textStatus = textStatus;
                errorThrown && (this.errorThrown = errorThrown);
            }
        }

        type Version = {
            majorVersion: number;
            minorVersion: number;
            majorBuildNumber: number;
            minorBuildNumber: number;
            neighborhoodMatrices: {
                id: string;
                name: string;
                countryCode: string;
                adminLevel: string;
                unitVersion: string;
                unitName: string;
                comment: string;
                creationDate: Date;
            }[];
            serverScript: {
                version: string;
            };
        };

        declare namespace Zlib {
            export class Gzip {
                constructor(data: Uint8Array);
                public compress(): Uint8Array;
            }
        }

        function toUTF8Array(str:string) {
            var utf8 = new Uint8Array(str.length*4);
            for (var i=0, j = 0; i < str.length; i++) {
                var charcode = str.charCodeAt(i);
                if (charcode < 0x80) utf8[j++] = charcode;
                else if (charcode < 0x800) {
                    utf8[j++] = 0xc0 | (charcode >> 6);
                    utf8[j++] = 0x80 | (charcode & 0x3f);
                }
                else if (charcode < 0xd800 || charcode >= 0xe000) {
                    utf8[j++] = 0xe0 | (charcode >> 12);
                    utf8[j++] = 0x80 | ((charcode>>6) & 0x3f);
                    utf8[j++] = 0x80 | (charcode & 0x3f);
                }
                // surrogate pair
                else {
                    i++;
                    // UTF-16 encodes 0x10000-0x10FFFF by
                    // subtracting 0x10000 and splitting the
                    // 20 bits of 0x0-0xFFFFF into two halves
                    charcode = 0x10000 + (((charcode & 0x3ff)<<10)
                        | (str.charCodeAt(i) & 0x3ff));
                    utf8[j++] = 0xf0 | (charcode >>18);
                    utf8[j++] = 0x80 | ((charcode>>12) & 0x3f);
                    utf8[j++] = 0x80 | ((charcode>>6) & 0x3f);
                    utf8[j++] = 0x80 | (charcode & 0x3f);
                }
            }
            return utf8.slice(0, j);
        }

        const LocaleLookup: {[key: number]: string} = {
            [Tools.Lang.Locale.fr]: 'fr',
            [Tools.Lang.Locale.us]: 'us',
            [Tools.Lang.Locale.en]: 'en'
        };

        function _append(body: string, value: string): string {
            return body ? `${body}&${value}` : value;
        }

        function _getAjaxBody(options: IAjaxOptions, identity: IIdentity, progessId: string): any {
            let data: any = Object.create(options.data || {}),
                body: string;
                
            if (!options?.skipDefaultParameters) {
                data.f = RestFormatLookUp[options.format] || 'json';
                options.locale && (data.lang = LocaleLookup[options.locale]);
                options.encoding && (data.encoding = options.encoding);
                progessId && (data.tid = progessId);
            }
            for (let i in data) {
                let val = data[i];

                if (val !== void 0) {
                    if (typeof val !== 'string') val = JSON.stringify(val);
                    body = _append(body, `${i}=${encodeURIComponent(val)}`); 
                }
            }
            return _append(body, identity.getAjaxBody());
        }

        export interface IRestRequestOptions<T = any> {
            format?: Rest.RestFormat;
            locale?: Tools.Lang.Locale;
            baseURL?: string;
            useProgressInfo?: boolean;
            data?: T & IRequestBody<ICreationContext>;
            builder?: DataCreator;
            modifierOptions?: IContextModifierOptions;
            byPassError?: boolean;
        }

        export function getServiceUrl(directory: string, baseUrl?: string): string {
            let uri: string = (directory[0] != '/') ? '/' : '';
            return `${(baseUrl || (window.location.protocol + '//' + window.location.host))}/asterop/rest${uri}${directory}`;
        }

        const _sequence = Symbol();
        export class RestModel extends RequestBuilder {
            protected _schema: Data.SchemaDescriptor;
            /** @internal */        
            private [_sequence]: number = 0;
            protected _pending: number = 0;
            protected _locale: Tools.Lang.Locale;
            protected _zip: boolean = false;
            public readonly baseUrl: string;
            public readonly identity: IIdentity;
            public readonly globals: Globals.GlobalsDescriptor;
            public readonly dashboardsDescriptor: Dashboards.DashboardsDescriptor;

            public static AjaxRequest: {
                    new (restModel: RestModel, sequence: number, uri: string, options?: IAjaxOptions, useProgressInfo?: boolean, enableCompression?: boolean): IAjaxRequest
                } = class implements IAjaxRequest {
                private _cnt: number;
                public readonly restModel: RestModel;
                public readonly sequence: number;
                public readonly uri: string;
                public readonly options: IAjaxOptions;
                public readonly progressId: string;
                public enableCompression: boolean;

                constructor(restModel: RestModel, sequence: number, uri: string, options: IAjaxOptions, useProgressInfo: boolean, enableCompression: boolean) {
                    this.restModel = restModel;
                    this.sequence = sequence;
                    this.uri = uri;
                    this.options = options;
                    useProgressInfo && (this.progressId = AFC.Tools.Data.generateRndString(10));
                    this.enableCompression = enableCompression;
                    this._cnt = 0;
                }

                private _call(identity: IIdentity, settings: JQuery.AjaxSettings, enableCompression: boolean) {
                    if (identity?.isAuthenticated) {
                        let body = _getAjaxBody(this.options, identity, this.progressId);

                        if (enableCompression) {
                            let gzip = new Zlib.Gzip(toUTF8Array(body));
                            body = new Blob([gzip.compress()], {type: "application/octet-binary"});
                        }
                        settings.data = body;
                        $.ajax(settings);
                    }
                }

                public getBody(): string {
                    let identity = this.restModel.identity;
                    return identity.isAuthenticated && _getAjaxBody(this.options, identity, this.progressId);
                }

                public call(): number {
                    let options = this.options,
                        enableCompression = this.enableCompression,
                        settings: JQuery.AjaxSettings = {
                            url: this.uri,
                            method: options.method || 'POST',
                            async: options.async || true,
                            processData: false
                        },
                        retry = 0,
                        identity  = this.restModel.identity,
                        call = (identity: Rest.IIdentity) => {
                            identity.isAuthenticated ?
                                this._call(identity, settings, enableCompression):
                                this.restModel._onIdentityError(identity);
                        },
                        doRetry = (jqXHR: JQueryXHR, textStatus: string) => {
                            if (jqXHR.status == 401) {
                                if (!retry++) {
                                    identity.refresh().then(call);
                                }
                                return retry <= 2;
                            }
                            return false;
                        };

                    options.converter && (settings.converters = {'text json': options.converter});
                    if (enableCompression) {
                        settings.headers = {
                            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
                            'Content-Encoding': 'gzip'
                        };
                    }
                    settings.complete = (jqXHR: JQueryXHR, textStatus: string) => {
                        if(!doRetry(jqXHR, textStatus)) {
                            this.restModel._onRequestComplete(this, jqXHR, textStatus);
                        }
                    };
                    settings.error = (jqXHR: JQueryXHR, textStatus: string, errorThrown: string) => {
                        if (!doRetry(jqXHR, textStatus)) {
                            this.restModel._onRequestError(this, jqXHR, textStatus, errorThrown);
                        }
                    };

                    if (options.xhrFields) {
                        settings.xhrFields = { ...options.xhrFields };
                    }

                    this.restModel._onRequestBegin(this);
                    options.done && (settings.success = (data: any, textStatus: string, jqXHR: JQueryXHR)=> options.done && options.done(this.sequence, data, textStatus, jqXHR));
                    call(identity);
                    return this.sequence;
                }
            }
        
            constructor(identity: IIdentity, url: string) {
                super();
                this.identity = identity;
                this.baseUrl = url;
                this.globals = new Globals.GlobalsDescriptor(this);
                this.dashboardsDescriptor = new Dashboards.DashboardsDescriptor(this);
            }

            public get pending(): number {
                return this._pending;
            }

            public get schema(): Data.SchemaDescriptor {
                return this._schema || (this._schema = new Data.SchemaDescriptor(this));
            }

            public set enableCompression(b: boolean) {
                this._zip = b;
            }

            public set locale(locale: Tools.Lang.Locale) {
                this._locale = locale;
            }

            public static createEntry<T = any>(o:any, key: string): T {
                return o[key] || (o[key] = {});
            }

            public getVersion(): Promise<Version> {
                return new Promise(resolve => {
                    let request: IAjaxRequest = this.createAjaxRequest('/version');
                    request.options.always = (sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                        let version: Version&{toString: ()=>string;} = jqXHR.responseJSON;
                        version && (version.toString = function() {
                            return `${version.majorVersion}.${version.minorVersion}.${version.majorBuildNumber}.${("0" + version.minorBuildNumber).slice(-2)}`;
                        });
                        version.neighborhoodMatrices.forEach(matrix => {matrix.creationDate = new Date(<any>matrix.creationDate);});
                        resolve(version);
                    };
                    request.call();
                });
            }

            private _onRequestBegin(request: IAjaxRequest): void {
                ++this._pending;
                this.fireEvent(Tools.EventType.NetworkBegin, [request]);
            }
            
            private _onRequestComplete(request: IAjaxRequest, jqXHR: JQueryXHR, textStatus: string):void {
                --this._pending;
                this.fireEvent(Tools.EventType.NetworkComplete, [new NetworkStatus(request, jqXHR, textStatus)]);
                request.options.always && request.options.always(request.sequence, jqXHR, textStatus);
            }

            private _onRequestError(request: IAjaxRequest, jqXHR: JQueryXHR, textStatus: string, errorThrown?: string): void {
                this.fireEvent(Tools.EventType.NetworkError, [new NetworkStatus(request, jqXHR, textStatus, errorThrown)]);
                request.options.fail && request.options.fail(request.sequence, jqXHR, textStatus, errorThrown);
            }
            
            private _onIdentityError(identity: IIdentity): void {
                this.fireEvent(Tools.EventType.IdentityError, [{identity: identity}]);
            }
            
            public createAjaxRequest<T = any>(path: string = '', bypassContext: boolean = true, options?: IRestRequestOptions): IAjaxRequest<T> {
                let data: T = options?.data || <any>{},
                    ajaxOptions: Partial<Mutable<IAjaxOptions<T>>> = {
                        locale: options?.locale || this._locale,
                        data: data
                    },
                    builder,
                    modifierOptions,
                    useProgressInfo,
                    baseURL = this.baseUrl;
                    
                 if (options) {
                    ajaxOptions.format = options.format;
                    builder = options.builder;
                    modifierOptions = options.modifierOptions;
                    if (options.baseURL)
                        baseURL = options.baseURL;
                    useProgressInfo = options.useProgressInfo;
                 }
                    
                bypassContext || (builder || this).updateBody(data, modifierOptions);
                return <any>new RestModel.AjaxRequest(this, ++this[_sequence], `${baseURL}${path}`, <IAjaxOptions<T>>ajaxOptions, useProgressInfo, this._zip);
            }

            public log(action: number, comment?: string): void {
                let data = this.identity.getCredentials<{action: number, comment: string}>();
                data.action = action;
                data.comment = comment;
                jQuery.ajax({
                    url: `${this.baseUrl}/log`,
                    method: 'POST',
                    processData: false,
                    async: true,
                    data: `content=${JSON.stringify(data)}`
                });
            }            
        }
        
        export type Info = {
            afc: string;
            components: Version,
            databases: ReadonlyArray<Data.DatabaseInfo>;
            networks: ReadonlyArray<TradeArea.NetworkDescriptor>;
            dma: ReadonlyArray<TradeArea.DMAConfigDescriptor>;
        };

        export function getInfo(rest: Rest.RestModel): Promise<Readonly<Info>>  {
            return Promise.all([
                rest.getVersion(),
                rest.schema.getDatabases().then(
                    (descriptors: ReadonlyArray<Data.DatabaseDescriptor>) => {
                        let promises: Promise<Data.DatabaseInfo>[]  = [];
                        descriptors.forEach((descriptor, indice)=> {
                            indice && promises.push(descriptor.getInfo());
                        });
                        return Promise.all(promises);
                    }
                ),
                (new AFC.TradeArea.Networks(rest)).getNetworks(),
                (new AFC.TradeArea.DMAConfigsDescriptor(rest)).getConfigurations()
            ]).then((results: [Version, Data.DatabaseInfo[], ReadonlyArray<TradeArea.NetworkDescriptor>, ReadonlyArray<TradeArea.DMAConfigDescriptor>]) => {
                return {
                    afc: AFC.Version,
                    components: results[0],
                    databases: results[1],
                    networks: results[2],
                    dma: results[3]
                };
            });
        }
    }

    export function createRest(identity: Rest.IIdentity, url: string): Rest.RestModel {
        return new Rest.RestModel(identity, url);
    }
}