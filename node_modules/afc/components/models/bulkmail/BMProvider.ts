///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />

namespace AFC {
    export namespace BulkMail {

        export const enum BMVersionStatus {
            production = "production",
            upcoming = "upcoming",
            deprecated = "deprecated",
            template = "template"
        }

        export interface IProviderCustomData {
            code: string,
            name: string,
            direction?: "ASC" | "DESC",     // Mode par défaut de l'indicateur : "ASC" ou "DESC"
            enabled?: boolean               // Par défaut cet indicateur est-il activé ?
        }

        export interface IVersionData {
            code:           string,
            dateAdded:      string,
            dateProduction: string,
            name:           string,
            provider:       string,
            dashboardGeoLevel: string;
            status:         BMVersionStatus,
            dataTables: {
                id:         string,
                database:   string,
                name:       string
            }[];
        }

        interface IPersona {
            code:           string,
            name:           string,
            description:    string,
            price:          number
        }

        export class BMProvider extends BMEntity {
            /**
             * Provider identifier in DB, auto generated at creation
             */
            protected _code: string; // is protected in parent class @see AFC.Bulkmail.BMEntity

            /**
             * Provider name
             */
            private _name: string;

            /**
             * Tableau d'objets décrivant les segments
             */
            private _segmentList: Array<{[key: string]: any}>;

            /**
             * Tableau des données custom pouvant servir pour le tri des secteurs lors du calcul d'une zone
             * eg. [{code: "CA", name: "CA"}, {code: "CRIT_1", name: "Critère numéro 1"},…]
             */
            private _ordering: Array<IProviderCustomData>;

            /**
             * Tableau des données custom pouvant être agrégées sur les zones (pour faire par exemple des graphiques, …)
             * eg. [{code: "CA", name: "CA"}, {code: "DATA1", name: "Agrégat 1"}, {code: "DATA2", name: "Agrégat 2"}]
             */
            private _aggregates: Array<IProviderCustomData>;

            /**
             * Tableau des versions des secteurs géographiques
             */
            private _featureVersions: Array<IVersionData>;

            public channel: BMCampaignChannel;
            public balance: {balance: number, scheduled: number};
            public description: string;
            public senders: Array<string> = [];
            public placeholders: Array<{id: string, name: string}>;

            constructor(item?: { [key: string]: any }) {
                super();

                if (item) {
                    this._code = item.code;
                    this._name = item.name;
                    this.description = item.description ?? item.name;
                    this.channel = item.channel;
                    if (item.balance)
                        this.balance    = item.balance;
                    else
                        this.balance    = null;
                    this.senders = item.senders ?? [];
                    this.placeholders = item.placeHolders ?? [];

                    if (item.targets && item.targets.segments) {
                        this._segmentList = item.targets.segments.map((segment: IPersona) => {
                            return { ...segment, code: segment.code } // Add code: for compatibility segments/personae.........
                        });
                    } else {
                        item.segments && (this._segmentList = [ ...item.segments ]);
                    }

                    item.aggregates && (this._aggregates = [ ...item.aggregates ]);
                    item.featuresVersions && (this._featureVersions = [ ...item.featuresVersions ]);

                    if (item.ordering) {
                        this._ordering = item.ordering.map((v: any) => {
                            return { ...v, direction: v.direction.toUpperCase().trim(), checked: v.enabled ? "checked" : "" }
                        });
                    }
                }
            }

            public get code() { return this._code }
            public get name() { return this._name }
            public get segments() { return this._segmentList }
            public get ordering() { return this._ordering }
            public get aggregates() { return this._aggregates }
            public get featureVersions() { return this._featureVersions }

            /**
             * Get an array of aggregates codes, used to compute total aggregates values (in campaign details screen > charts)
             *
             * @returns An array of aggregates code eg. [ "CA", "DATA1", "DATA2" ]
             */
            public getAggregatesCodeList(): string[] {
                return this.aggregates.map((agg: AFC.BulkMail.IProviderCustomData) => agg.code);
            }

            /**
             * Get the aggregate name corresponding to given code aggergate
             *
             * @param code The aggregate code
             * @returns The corresponding aggregate name
             */
            public getAggregateName(code: string) {
                let aggr;

                return (aggr = this.aggregates.find(_aggr => _aggr.code === code)) && aggr.name
            }

            /**
             * Get the segment name corresponding to given code segment
             *
             * @param code The segment code
             * @returns The corresponding segment name
             */
            public getSegmentName(code: string) {
                let segment;

                return (segment = this.segments.find(_segment => _segment.code === code)) && segment.name
            }

            /**
             * Return provider's paramaters (= Provider.ordering) as data model
             * 
             * @returns The provider's ordering aggregates as a DataModel
             */
            public getConfigParameters(): BMParametersDataModel {
                return new BMParametersDataModel(this.ordering);
            }

            /**
             * Returns feature version current in production
             *
             * @returns The current feature version in production
             */
            public getCurrentVersion(): {[key: string]: any} {
                return this._featureVersions.find(elem => elem.status === BMVersionStatus.production);
            }

            /**
             * Returns upcoming feature version
             *
             * @returns The next feature version
             */
            public getNextVersion(): IVersionData {
                return this._featureVersions.find(elem => elem.status === BMVersionStatus.upcoming);
            }

            /**
             * Returns feature version corresponding to given code version
             *
             * @returns 
             */
            public getVersion(codeVersion: string): IVersionData {
                return this._featureVersions.find(elem => elem.code === codeVersion);
            }
        }

        export class BMParametersDataModel extends Data.DataSource {
            private _items: IProviderCustomData[];

            public get length() { return this._items.length }

            constructor(items: IProviderCustomData[]) {
                super();

                this._items = [...items];
                this.fireEvent(Tools.EventType.UserEvent);
            }

            public item(index: number): Data.IDataItemContainer<IProviderCustomData> {
                return {
                    dataItem: this._items[index],
                    dataItemIndex: index,
                };
            }
        }
    }
};