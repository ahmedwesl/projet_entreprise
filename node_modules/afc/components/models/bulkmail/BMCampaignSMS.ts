///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="./BMEntity.ts" />
///<reference path="./BMStore.ts" />
///<reference path="./BMZone.ts" />
///<reference path="./BMCampaign.ts" />

namespace AFC {
    export namespace BulkMail {

        export const EventType_MessageDirty = 45679645;

        
        export interface ICampaignSMSRestData extends ICampaignRestData {
            cost?:              {
                                    budget: number,
                                    volume: number
            },
            target?:            {
                                    segments:   Array<{code: string}>,
                                    options:    Array<string>,
            },
            routeStatus:        BMCampaignRouteStatus,
            routeStatusDetail?: string;
            sender:             string,
            message?:           {
                                    text:       string,
                                    shortenURL: boolean
            }
        }
        
        export interface IPreviewSMSRestData {preview: string, smsCount: number, remainingChars: number, warnings?: Array<string>, errors?: Array<string>}

        export class BMCampaignSMS extends BMCampaign {
            private _sender:            string              = "";
            private _message:           string              = "";
            private _shortenURL:        boolean             = false;
            private _personaOptions:    Array<string>       = [];
            protected _segmentList:     Map<string, string> = new Map();
            public volume:              number;
            public budget:              number;
            private _routeStatus:       BMCampaignRouteStatus = BMCampaignRouteStatus.sleeping;
            private _routeStatusDetail: string;

            constructor(item?: ICampaignSMSRestData, isNew?: boolean) {
                super(item, isNew);

                if (item) {
                    this.volume             = item.cost?.volume || 0;
                    this.budget             = item.cost?.budget || 0;
                    this.personaOptions     = item.target?.options;
                    this.segments           = item.target?.segments;
                    this._routeStatus       = item.routeStatus;
                    this._routeStatusDetail = item.routeStatusDetail;
                    this.sender             = item.sender;
                    this.message            = item.message?.text || "";
                    this.shortenURL         = item.message?.shortenURL || false;
                }
            }

            public get routeStatusDetail() { return this._routeStatusDetail; }
            public get routeStatus() { return this._routeStatus; }
            public set routeStatus(routeStatus: BMCampaignRouteStatus) { this._routeStatus = routeStatus; }
            public get segments(): Map<string, string> { return this._segmentList }

            public set segments(segments: Map<string, string> | Array<{code: string}>) {
                if (segments instanceof Map) {
                    this._segmentList = new Map(segments);
                } else {
                    this._segmentList = new Map();

                    segments && segments.forEach(persona => this._segmentList.set(persona.code, BMSegmentStatus.enabled));
                }
            }

            public get personaId(): string {
                return [...this._segmentList]?.[0]?.[0]
            }

            public get persona(): string {
                const personaId = this.personaId;

                if (personaId) {
                    return this.getProvider().segments.find(elem => elem.code == personaId)?.name;
                }

                return void 0;
            }

            public override get qty(): number {
                return this.volume;
            }

            public get shortenURL() {
                return this._shortenURL
            }

            public set shortenURL(shorten: boolean) {
                this._shortenURL = shorten;
                if (!this._disableDirtyEvent)
                    this.fireEvent(Tools.EventType.Dirty);
                this.fireEvent(EventType_MessageDirty);
            }

            public get message() {
                return this._message
            }

            public set message(message: string) {
                this._message = message;
                if (!this._disableDirtyEvent)
                    this.fireEvent(Tools.EventType.Dirty);
                this.fireEvent(EventType_MessageDirty);
            }

            public get sender() {
                return this._sender
            }

            public set sender(sender: string) {
                this._sender = sender;
                if (!this._disableDirtyEvent)
                    this.fireEvent(Tools.EventType.Dirty);
            }

            public get personaOptions() {
                return this._personaOptions
            }

            public set personaOptions(options: Array<string>) {
                this._personaOptions = options;
            }

            public getTarget(): Readonly<{
                segments: Array<{code: string}>,
                options: Array<string>
            }> {
                return {
                    segments: [ {code: this.personaId} ],
                    options: this.personaOptions
                }
            }

            protected override _updateFromPublish(item: ICampaignRestData) {
                let smsItem = <ICampaignSMSRestData>item;

                this.routeStatus = smsItem.routeStatus; 
            }
            public isCompleted() : boolean {
                if (this.status == BMCampaignStatus.published)
                    return (this.routeStatus == BMCampaignRouteStatus.completed) || (this.routeStatus == BMCampaignRouteStatus.completedFinal) 
                return false;
            }
            public override canPublish() {
                return this.isValid() && this.status === BMCampaignStatus.validated; // TODO: check BAT ?
            }
            public canUnpublish() {
                return      (this.status === BMCampaignStatus.published) 
                        &&  (   (this.routeStatus == BMCampaignRouteStatus.sleeping)
                            ||  (this.routeStatus == BMCampaignRouteStatus.verification)
                            ||  (this.routeStatus == BMCampaignRouteStatus.scheduled)
                            ) 
            }

            public override isValidDates() {
                let timestampStart = (this.beginDate as Date).getTime();

                //TODO: test supp than now()

                return !isNaN(timestampStart)
                    //&& timestampStart > Date.now() + 34; // TODO:
            }

            public get beginDateTimeAsString() {
                let beginDate   = this._beginDate;
                let hours       = beginDate.getHours();
                let minutes     = beginDate.getMinutes();

                if (!Number.isNaN(hours) && !Number.isNaN(minutes))
                    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                return '';
            }

            public override hasUpcoming() {
                return false;
            }

            public hasOption(opt: string) {
                return this.personaOptions.indexOf(opt) !== -1
            }

            public override fillCampaignWithRestData(item: ICampaignSMSRestData) {
                let campaign = this;

                super.fillCampaignWithRestData(item);

                campaign.volume             = item.cost?.volume || 0;
                campaign.budget             = item.cost?.budget || 0;
                campaign.personaOptions     = item.target?.options;
                campaign.segments           = item.target?.segments;
                campaign.targetedAggregates = item.targeted.aggregates;
                campaign._storesCounter     = item.stores;
                campaign.routeStatus        = item.routeStatus;
                campaign.sender             = item.sender;
                campaign.shortenURL         = item.message?.shortenURL;
                campaign.message            = item.message?.text;
                if (item.status)
                    campaign.status         = item.status;
            }

            public getParamItemSave(): {[key: string]: any} {
                const campaign  = this;
                
                return {
                    name:       campaign.name,
                    dateStart:  campaign.beginDate,
                    target:     campaign.getTarget(),
                    sender:     campaign.sender,
                    message: {
                        text:       campaign.message,
                        shortenURL: campaign.shortenURL
                    }
                }
            }

            public override update(item?: ICampaignUpdateData, forceSave = false, isSimulation = false, silent = false): Promise<any> {
                let itemSms;

                if (item) {
                    let segments = { ...item.segments };
                    itemSms = {
                        name:       item.name,
                        dateStart:  item.dateStart,
                        target: {
                            options: item.target.options,
                            segments:
                                Object.keys(segments)
                                .filter(key => segments[key] === BMSegmentStatus.enabled)
                                .map(key => { return {code: key} })
                        }
                    };
                } else
                    itemSms = this.getParamItemSave();

                return super.update(itemSms, forceSave, isSimulation, silent);
            }

            protected override hasErrorEx() : string[] {
                if (this._routeStatus == BMCampaignRouteStatus.stopped)
                    return [this.routeStatusDetail != "" ? this.routeStatusDetail : "Erreur lors du routage de la campagne"];
                if (this._message == "")
                    return ["Erreur: le texte du SMS est vide"];
                return [];
            }
            public override hasErrorSegments(): boolean {
                return 1 !== (this.segments as Map<string, string>).size;
            }

            public callSendSmsTest(phoneNumbers: Array<string>): Promise<any> {
                return this.code ? new Promise((resolve, reject) => {
                    const cachedData = BMEntityCacheData.getInstance();
                    let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(
                        `${BMCampaign.getUriCampaign(this)}/sms/test`,
                        true,
                        {
                            data: {
                                phoneNumbers: phoneNumbers
                            },
                        }
                    );
                    request.options.byPassError = true;
                    request.options.method      = "POST";
                    request.options.always      = (sequence: number, jqXHR: JQueryXHR) => {
                        if (jqXHR.status === 200) {
                            this.status = (<ICampaignUpdateData>jqXHR.responseJSON).status;
                            this.fireEvent(Tools.EventType.Dirty);
                            resolve(this.status == BMCampaignStatus.checked);
                        } else
                            resolve(null)
                    };
                    request.call();
                }) : Promise.reject("Error: campaign must be saved in DB before sending test SMS.");
            }

            public callPreviewMessage(refCode: string = ""): Promise<IPreviewSMSRestData | null> {
                return new Promise((resolve, reject) => {
                    const cachedData = BMEntityCacheData.getInstance();

                    if (this.message && this.message != "") {
                        let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(
                            `${BMEntityCacheData.path}/sms/preview`, // asterop/rest/{projet}/bm/sms/preview
                            true,
                            {
                                data: {
                                    sms: {
                                        message: { text: this.message, shortenURL: this.shortenURL }
                                    },
                                    codeCampaign: refCode != "" ? refCode : this.code
                                },
                            }
                        );
                        request.options.method = "GET";
                        request.options.always = (sequence: number, jqXHR: JQueryXHR) => {
                            resolve(jqXHR.responseJSON);
                        };
                        request.call();
                    } else {
                        resolve({
                            preview:        "", 
                            smsCount:       0, 
                            remainingChars: 0, 
                            errors:         ["Message du SMS vide"]
                        });
                    }
                });
            }

            public validate(): Promise<boolean> {
                const campaign      = this;
                const cachedData    = BMEntityCacheData.getInstance();

                return campaign.isValid() ? new Promise((resolve, reject) => {
                        let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(BMCampaign.getUriCampaign(campaign));
                        request.options.data        = { action: { type: "validate" } };
                        request.options.byPassError = true;
                        request.options.always      = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                            if (jqXHR.status === 200) {
                                campaign.status = (<ICampaignUpdateData>jqXHR.responseJSON).status;
                                campaign.fireEvent(Tools.EventType.Dirty);
                                resolve(this.status == BMCampaignStatus.validated)
                            } else
                                resolve(false);
                        }).bind(this);
                        request.call();
                    })
                    : Promise.resolve(false);
            }

            public getNewVolumeBudget(campaignReference?: BMCampaignSMS): Promise<{volume: number, budget: number}> {
                const campaign      = this;
                const cachedData    = BMEntityCacheData.getInstance();

                return new Promise((resolve, reject) => {
                    let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(`${BMCampaign.getUriCampaign(campaignReference ?? campaign)}/sms/cost`);
                    
                    request.options.data    = { target: { segments: [{code: this.personaId}], options: this.personaOptions }, method: "estimate" };
                    request.options.always  = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                        campaign.volume = jqXHR.responseJSON.volume;
                        campaign.budget = jqXHR.responseJSON.budget;
                        campaign.fireEvent(Tools.EventType.Dirty);

                        resolve((<{volume: number, budget: number}>jqXHR.responseJSON));
                    }).bind(this);

                    cachedData.sequence = request.call();
                });
            }
        }
    }
};