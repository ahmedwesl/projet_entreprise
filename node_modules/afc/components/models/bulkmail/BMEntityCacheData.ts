///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />

namespace AFC {
    export namespace BulkMail {
        /**
         * Class for cache singleton
         */
        export class BMEntityCacheData {
            public static readonly path             = '/bm'; //eg. http://localhost/asterop/rest/ciblageISA/bm
            public static readonly pathCampaign     = `${BMEntityCacheData.path}/campaigns`; //eg. http://localhost/asterop/rest/ciblageISA/bm/campaigns
            public static readonly pathProviders    = `${BMEntityCacheData.path}/providers`; //eg. http://localhost/asterop/rest/ciblageISA/bm/providers
            public static readonly pathZones        = `${BMEntityCacheData.path}/zones`; //eg. http://localhost/asterop/rest/ciblageISA/bm/zones

            public restModel:       Rest.RestModel;
            public eventHandler:    Tools.EventSink;

            private static instance: BMEntityCacheData;

            private _campaignList:  BMDataModel;
            private _providerList:  BMDataModel;
            private _storeList:     BMDataModel;
            private _zoneList:      BMDataModel;

            /**
             * Current XHR sequence number
             */
            private _sequence: number;

            private constructor() { } // prevent new

            public static getInstance(restModel?: Rest.RestModel): BMEntityCacheData {
                if (!BMEntityCacheData.instance) {
                    BMEntityCacheData.instance                  = new BMEntityCacheData();
                    BMEntityCacheData.instance.eventHandler     = new Tools.EventSink();
                    BMEntityCacheData.instance.restModel        = restModel;
                }

                return BMEntityCacheData.instance;
            }

            public get campaignList() {
                return this._campaignList;
            }

            public get providerList() {
                return this._providerList;
            }

            public get sequence() {
                return this._sequence;
            }

            public set sequence(value) {
                this._sequence = value;
            }

            public get storeList() {
                return this._storeList;
            }

            public get zoneList() {
                return this._zoneList;
            }

            /**
             * Return stored campaign corresponding to given code
             *
             * @param code
             */
            public campaign(code: string) {
                return <BMCampaign>this.campaignList.items.find(item => item.code === code);
            }

            /**
             * Return stored provider corresponding to given code provider or given codeVersion
             *
             * @param code
             * @param codeVersion
             */
            public provider(code?: string, codeVersion?: string) {
                return code ? <BMProvider>this.providerList.items.find(item => item.code === code)
                    : codeVersion ? <BMProvider>this.providerList.items.find(item => (item as BMProvider).featureVersions?.find(itemV => itemV.code === codeVersion))
                    : void 0;
            }

            public static flushCampaignList() {
                this.getInstance()._campaignList = void 0;
            }

            /**
             * Clear all cached data
             */
            public static flushAll() {
                // let instance = this.getInstance();

                // instance._campaignList = new BMDataModel();
                // instance._providerList = new BMDataModel();
                // instance._storeList = new BMDataModel();
                // instance._zoneList = new BMDataModel();

                // instance._campaignList.on(Tools.EventType.UserEvent, () => { instance.getCampaigns(true); });
                // instance._campaignList.on(Tools.EventType.Dirty, () => instance.eventHandler.fireEvent(AFC.Tools.EventType.UserEvent + 32));
                // instance._providerList.on(Tools.EventType.Dirty, () => instance.getCampaigns(true)); // TODO:
                // instance._storeList.on(Tools.EventType.Dirty, () => instance.getCampaigns(true)); // TODO:
                // instance._zoneList.on(Tools.EventType.Dirty, () => instance.getCampaigns(true)); // TODO:
            }

            /**
             * Fireevent on complete XHR request
             *
             * @param sequence
             * @param jqXHR
             * @param textStatus
             */
            private _onComplete(sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
                if (this._sequence === sequence) {
                    // this._legend = <ILayerLegendData>jqXHR.responseJSON;
                    this.eventHandler.fireEvent(Tools.EventType.UserEvent + 1);
                }
            }

            /**
             * Update campaigns from DB if not already done, otherwise, get campaignList
             * 
             * @param forceUpdate Set true to force call to api and refresh campaignList
             * @returns Promise<campaignList>
             */
            public getCampaigns(forceUpdate = false): Promise<BMDataModel> {
                let instance = this;

                return (instance._campaignList === void 0 || forceUpdate) ?
                    new Promise((resolve, reject) => {
                        // instance.eventHandler.notify(Tools.EventType.UserEvent + 1, (/*event: Tools.IEvent*/) => console.log("resolve(instance._campaignList)"));

                        let request: Rest.IAjaxRequest = instance.restModel.createAjaxRequest(BMEntityCacheData.pathCampaign);
                        request.options.always = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                            instance._campaignList = new BMDataModel();

                            jqXHR.responseJSON.forEach((value: any) => {
                                instance._campaignList.addItem(BMCampaignFactory.createCampaign(value));
                            });

                            instance._onComplete(sequence, jqXHR, textStatus);

                            resolve(instance._campaignList);
                        }).bind(this);

                        instance._sequence = request.call();
                    })
                    : Promise.resolve(instance._campaignList);
            }

            /**
             * Create new BMCampaign and add this newly created campaign to campaign list.
             * New campaign has empty dates: force user to indicate value.
             */

            public createCampaign(provider: BulkMail.BMProvider): void {
                // let dateNow = new Date();
                if (!provider)
                    return;

                let campaignBase = this.campaignList.items
                        .filter((cp: AFC.BulkMail.BMCampaign) => cp.getProvider().code === provider.code)
                        .filter((cp: AFC.BulkMail.BMCampaign) => cp.status !== AFC.BulkMail.BMCampaignStatus.new)
                        .sort((a: AFC.BulkMail.BMCampaign, b: AFC.BulkMail.BMCampaign) => a.status !== AFC.BulkMail.BMCampaignStatus.template ? -1 : 1)
                        .filter((cp: AFC.BulkMail.BMCampaign, index, arr) => index === arr.findIndex((_cp: AFC.BulkMail.BMCampaign) => _cp.zoneCodeTargeted === cp.zoneCodeTargeted))
                        [0] as BMCampaign;

                let campaign = BMCampaignFactory.createCampaign({
                        "code": Tools.Data.generateRndString(32), // Temporary code ! final one will be sent by api
                        "name": "",
                        "channel": provider.channel,
                        // "dateStart": dateNow,
                        // "dateEnd": new Date(new Date().setDate(dateNow.getDate() + 7)),
                        targeted: {
                            zoneCode: campaignBase.zoneCodeTargeted,
                            featuresVersion: provider.getCurrentVersion().code,
                            aggregates: campaignBase.targetedAggregates
                        },
                        "status": BMCampaignStatus.new,
                        "segments": campaignBase.segments,
                        "stores": [ ...campaignBase.storesCounter ],
                    }, true);

                campaign.copyZonesFromCampaign(campaignBase.code);
                this._campaignList.addItem(campaign);

                this.eventHandler.fireEvent(Tools.EventType.UserEvent + 32);
            }

            /**
             * Call given campaign update function @see BMCampaign.update()
             *
             * @param code Campaign code to be updated
             * @returns promise
             */
            public updateCampaign(code: string, item?: ICampaignUpdateData, silent = false): Promise<boolean> {
                const instance = this;
                const campaign = instance.campaign(code);

                return campaign ? 
                    campaign.update(item, false, false, silent)
                    : Promise.reject("Campaign not found.");
            }

            /**
             * Call given campaign deletion function @see BMCampaign.delete() and remove campaign from cache
             * 
             * @param code Campaign code to be removed
             * @returns promise
             */
            public deleteCampaign(code: string): Promise<boolean> {
                const instance = this;
                const campaign = instance.campaign(code);

                return campaign ? campaign.delete().then((deleted) => {
                        if (deleted) {
                            instance.campaignList.removeItem(code);
                            instance.eventHandler.fireEvent(Tools.EventType.UserEvent + 32);
                        }
                        return Promise.resolve(deleted);
                    })
                    : Promise.reject("Campaign not found.");
            }

            /**
             * Copy zone from campaign to another (used in campaign creation)
             *
             * @param codeCampaignFrom
             * @param codeCampaignTo
             */
            public copyZones(codeCampaignFrom: string, codeCampaignTo: string): void {
                this.campaign(codeCampaignTo).copyZonesFromCampaign(codeCampaignFrom);

                this.eventHandler.fireEvent(Tools.EventType.UserEvent + 32);
            }

            public async getProvidersChannels(): Promise<Array<BMCampaignChannel>> {
                let channels: BMCampaignChannel[] = [];
                let providers = await this.getProviders();

                providers.forEach((provider: BMProvider) => {
                    if (channels.indexOf(provider.channel) === -1) {
                        channels.push(provider.channel);
                    }
                });

                return channels;
            }

            /**
             * Update providers from DB if not already done, otherwise, get providerList
             *
             * @param forceUpdate Set true to force call to api and refresh providerList
             * @returns Promise<providerList>
             */
            public getProviders(forceUpdate = false): Promise<BMDataModel> {
                let instance = this;

                return (instance._providerList === void 0 || forceUpdate) ?
                    new Promise((resolve, reject) => {
                        // instance.eventHandler.notify(Tools.EventType.UserEvent + 1, (/*event: Tools.IEvent*/) => resolve(instance._providerList));

                        let request: Rest.IAjaxRequest = instance.restModel.createAjaxRequest(BMEntityCacheData.pathProviders);
                        request.options.always = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                            instance._providerList = new BMDataModel();

                            jqXHR.responseJSON.forEach((value: any) => {
                                instance._providerList.addItem(new BMProvider(value));
                            });

                            resolve(instance._providerList);

                            instance._onComplete(sequence, jqXHR, textStatus);
                        }).bind(this);

                        instance._sequence = request.call();
                    })
                    : Promise.resolve(instance._providerList);
            }
        }

        export interface IDataItemContainerCustomProps extends Data.IDataItemContainer {
            readonly entity: BMEntity,
            props: any
        }

        export class BMDataModel extends Tools.EventSink implements Data.IDataSource {
            private _items: IDataItemContainerCustomProps[];

            constructor() {
                super();

                this._items = new Array<IDataItemContainerCustomProps>();
                this.fireEvent(Tools.EventType.UserEvent);
            }

            public get length() {
                return this._items.length;
            }

            public get items() {
                return this._items.map(_item => _item.entity);
            }

            public entity(index: number): BMEntity {
                return this._items[index].entity;
            }

            public item(index: number): IDataItemContainerCustomProps {
                return this._items[index];
            }

            public addItem(obj: BMEntity) {
                this._items.push(<IDataItemContainerCustomProps>{
                    dataItem: obj,
                    dataItemIndex: this._items.length,
                    entity: obj,
                    props: {}
                });
            }

            public removeItem(code: string) {
                this._items = this._items.filter(item => item.entity.code !== code);
            }

            public flushItemProps(index: number) {
                let item = this.item(index);

                item.entity.fireEvent(Tools.EventType.Dirty); // hack

                item && (item.props = {});
            }

            public flushProps() {
                this._items.forEach(_item => _item.props = {})
            }

            public forEach(callbackfn: (value: BMEntity, index: number, array: BMEntity[]) => any): void {
                this.items.forEach(callbackfn);
            }

            public filter(callbackfn: (value: BMEntity, index: number, array: BMEntity[]) => any): BMEntity[] {
                return this.items.filter(callbackfn);
            }
        }
    }
};