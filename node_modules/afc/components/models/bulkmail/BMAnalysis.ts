namespace AFC {
    export namespace BulkMail {
        const ALL_STORES_COLOR  = "#d4d0cf";
        const ALL_STORES_CODE   = "ALL_STORES"

        export interface IBMAnalysisDataValue {
            from():         Date;
            value():        number;
        }
        
        export class BMAnalysisDataValue implements IBMAnalysisDataValue {
            private _from:          Date;
            private _value:         number;
                        
            constructor (from: Date, value: number) {
                this._from  = from;
                this._value = value;
            }
            public from() {
                return this._from;
            }
            public value() {
                return this._value;
            }
        }
        export class BMAnalysisDataValues {
            private _custom:            (dataId: string, values: BMAnalysisDataValues) => IBMAnalysisDataValue[];
            private _group:             IBMAnalysisGroupItem;
            private _values:            {from: Date, values: {[key:string]: number}}[];
            
            constructor(group: IBMAnalysisGroupItem, custom: (dataId: string, values: BMAnalysisDataValues) => IBMAnalysisDataValue[]) {
                this._custom    = custom;
                this._group     = group;
                this._values    = [];
            }
            public get values() {
                return this._values;
            }
            public get(dataId: string) : IBMAnalysisDataValue[] {
                let values: IBMAnalysisDataValue[] = [];

                if (this._custom)
                    values = this._custom(dataId, this);
                if (values.length == 0) {
                    this._values.forEach(vs => {
                        let value = vs.values[dataId];

                        if (value != undefined)
                            values.push(new BMAnalysisDataValue(vs.from, value));
                    });
                }
                return values;
            }
            public dateRange() : Date[] {
                return this._values.map(v => v.from);
            }
            public pushValue(from: Date, values: {[key:string]: number}) {
                this._values.push({
                    from:   new Date(from),
                    values: values
                });
            }
            public get group() {
                return this._group;
            }
        }

        export class BMAnalysisData {
            private _id:            string;
            private _name:          string;
            private _description:   string;
            private _canAggregate:  boolean;
            private _suffix:        string;
            private _precision:     number;
            private _isCustom:      boolean;
            private _format:        (x: number) => string;

            constructor(id: string, name: string = "", description: string = "", suffix: string = "", canAggregate = true, precision = NaN, format: (x: number) => string = null, isCustom = false) {
                this._id            = id;
                this._name          = name;
                this._description   = description;
                this._canAggregate  = canAggregate;
                this._suffix        = suffix;
                this._precision     = precision;
                this._isCustom      = isCustom;
                this._format        = format;
            }

            public get id() {
                return this._id;
            }
            public get name() {
                return this._name;
            }
            public get description() {
                return this._description;
            }
            public get isCustom() {
                return this._isCustom;
            }
            public canAggregate() {
                return this._canAggregate;
            }
            public toString(x: number) {
                let _round = (v: number, precision: number) => {
                    if (isNaN(precision))
                        return v;
                    let f = Math.pow( 10, precision);
                    return Math.round(v * f ) / f;
                }
                return this._format ? this._format(x) : `${_round(x, this._precision).toLocaleString()}${this._suffix}`;
            }
        }

        export interface IBMAnalysisGroupItemStyle {
            get color()         : string;
        }
        class BMAnalysisGroupItemStyle implements IBMAnalysisGroupItemStyle {
            private _color: string;

            constructor(color: string)  {
                this._color = color;
            }
            public get color() {
                return this._color;
            }
        }

        export interface IBMAnalysisGroupItem {
            get key()           : {id: string, value: string};
            get id()            : string;
            get name()          : string;
            get description()   : string;
            get isStore()       : boolean;
            get style()         : IBMAnalysisGroupItemStyle;
            get count()         : number;
        }

        class _StoreGroupItem implements IBMAnalysisGroupItem {
            private _store:         {code: string, name: string};
            private _codeColumn:    string;
            
            constructor(codeColumn: string, store: {code: string, name: string}) {
                this._store         = store;
                this._codeColumn    = codeColumn;
            }

            public get key() {
                return {id: this._codeColumn, value: this._store.code};
            }
            public get id() {
                return this._store.code;
            }
            public get name() {
                return this._store.name;
            }
            public get description() {
                return "";
            }
            public get isStore() {
                return true;
            }
            public get style() : IBMAnalysisGroupItemStyle {
                return null;
            }
            public get count() : number {
                return 1;
            }
        }

        class _GroupGroupItem implements IBMAnalysisGroupItem {
            private _key:       string;
            private _value:     string;
            private _stores:    {code: string, name: string}[];
            private _color:     string;

            constructor(groupKey: string, groupValue: string, items : {code: string, name: string}[], color: string) {
                this._key       = groupKey;
                this._value     = groupValue;
                this._stores    = items;
                this._color     = color;
            }

            public get key() {
                return {id: this._key, value: this._value};
            }
            public get id() {
                return `${this._key}-${this._value}`;
            }
            public get name() {
                return this._value;
            }
            public get description() {
                return `${this._stores.length} magasin${this._stores.length > 1 ? 's' : ''}`;
            }
            public get isStore() {
                return false;
            }
            public get style() : IBMAnalysisGroupItemStyle {
                return new BMAnalysisGroupItemStyle(this._color);
            }
            public get count() : number {
                return this._stores.length;
            }
        }
        
        export interface IBMAnalysisGroupDescription {
            get id():       string
            get name():     string
            get style():    IBMAnalysisGroupItemStyle
        }

        export class BMAnalysisGroupsSettings {
            private _storesTable:       AFC.Data.IDataTable;
            private _nameColum:         string;
            private _codeColum:         string;
            private _groupColumns:      {name: string, color: string, alias: string, description: string}[];
            private _allowAllStores:    boolean;
            private _isValid:           boolean;
            private _allStores:         {code: string, name: string}[];
            private _groups:            Map<string, number[]>[];
            private _allStoresLabel:    string;
            
            constructor() {
                this._storesTable       = null;
                this._groupColumns      = [];
                this._groups            = null;
                this._allStoresLabel    = "";

                this._allowAllStores    = false;
                this._isValid           = false;
            }
            public load() : Promise<boolean> {
                const cachedData    = BMEntityCacheData.getInstance();

                return new Promise<boolean>((resolve, reject) => {
                    let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(`${BMAnalysis.uri}/groups`, true);
                        
                    request.options.method = "GET";
                    request.options.always = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                        if (jqXHR.status == 200) {
                            let items: {id: string, name: string, description?: string}[] = jqXHR.responseJSON;
                            this.groupColumns = items;
                        }
                        resolve(true);
                    });
                    request.call();
                })
            }

            public get description() : IBMAnalysisGroupDescription[] {
                let res: IBMAnalysisGroupDescription[] = [];

                if (this._allowAllStores) {
                    let allStoresGroup  = this._getAllStoresGroup();
                    let label           = this._allStoresLabel;
                    res.push({
                        get id()    {return allStoresGroup.key.id},
                        get name()  {return label},
                        get style() {return allStoresGroup.style}
                    })
                }
                return res.concat(this._groupColumns.map(col => {
                    let color   = col.color;
                    let colId   = col.name;
                    let colName = col.alias;
                    return {
                        get id()    {return colId},
                        get name()  {return colName},
                        get style() {return new BMAnalysisGroupItemStyle(color)}
                    }
                }));
            }

            public set storesTable(storesTable: AFC.Data.IDataTable) {
                if (this._storesTable != storesTable) {
                    this._storesTable   = storesTable;
                    this._isValid       = false;
                }
            }
            public set nameColum(col: string) {
                if (this._nameColum != col) {
                    this._nameColum     = col;
                    this._isValid       = false;
                }
            }
            public set codeColum(col: string) {
                if (this._codeColum != col) {
                    this._codeColum     = col;
                    this._isValid       = false;
                }
            }
            private set groupColumns(cols: {id: string, name: string, description?: string}[]) {
                let colors          = ["#E77423", "#345995", "#3C896D", "#390040", "#FFE066"]
                
                this._allowAllStores    = false;
                this._allStoresLabel    = "";
                this._groupColumns      = cols.filter(c => c.id != ALL_STORES_CODE).map((c, idx) => { return {name: c.id, alias: c.name, description: c.description, color: colors[idx%colors.length]}});
                this._isValid           = false;

                let allStores = cols.find(c => c.id == ALL_STORES_CODE);
                if (allStores != undefined) {
                    this._allowAllStores = true;
                    this._allStoresLabel = allStores.name;
                }
            }
            
            public findFromKey(key: {id: string, value: string}) : IBMAnalysisGroupItem {
                this._init();

                if (key.id == this._codeColum) {
                    let store = this._allStores.find(store => store.code == key.value);
                    if (store != undefined)
                        return (new _StoreGroupItem(this._codeColum, store));
                } else if (key.id == "") {
                    return this._getAllStoresGroup();
                } else {
                    let groupIndex = this._groupColumns.findIndex(col => col.name == key.id);
                    if (groupIndex != -1 && groupIndex < this._groups.length) {
                        let group = this._groups[groupIndex].get(key.value);

                        return (new _GroupGroupItem(key.id, key.value, group.map(storeIdx => this._allStores[storeIdx]), this._groupColumns[groupIndex].color));
                    }
                }
                return null
            }
            public find(searchString: string, groupsOnly?: boolean) : IBMAnalysisGroupItem[] {
                let res: IBMAnalysisGroupItem[]     = [];
                let _this                           = this;
                let lcSearchString                  = searchString.toLowerCase();
                let isStoreOKForFilter              = function(store: {code: string, name: string}) {
                    if (searchString == "")
                        return true;
                    return store.name.toLowerCase().includes(lcSearchString) || store.code.toLowerCase().includes(lcSearchString);
                    
                };
                let isGroupOKForFilter              =  function(groupValue: string, storesIdx: number[]) {
                    if (searchString == "")
                        return true;
                    if (groupValue.toLowerCase().includes(lcSearchString))
                        return true;
                    return storesIdx.map(idx => _this._allStores[idx]).some(store => isStoreOKForFilter(store));
                };
                let addStores                       = true;
                let addGroups                       = true;

                if (groupsOnly != undefined) {
                    addStores   = !groupsOnly;
                    addGroups   = groupsOnly;
                }

                this._init();
                if (addStores) {
                    this._allStores.forEach(store => {
                        if (isStoreOKForFilter(store))
                            res.push(new _StoreGroupItem(this._codeColum, store));
                    });
                }

                if (addGroups) {
                    this._groups.forEach((groupMap, groupIdx) => {
                        let groupKey = this._groupColumns[groupIdx];
                        groupMap.forEach((stores, groupValue) => {
                            if (isGroupOKForFilter(groupValue, stores)) {
                                res.push(new _GroupGroupItem(groupKey.name, groupValue, stores.map(storeIdx => this._allStores[storeIdx]), groupKey.color));
                            }
                        })
                    });
                }

                if (this._allowAllStores && addGroups && res.length > 0)
                    res.unshift(this._getAllStoresGroup());
                return res;
            }

            private _getAllStoresGroup() {
                return new _GroupGroupItem("", this._allStoresLabel, this._allStores, ALL_STORES_COLOR);
            }
            
            private _init() {
                if (!this._isValid && this._storesTable) {
                    let columnsIndex    = new Map<String, number>();
                    let pkColumnIdx     = "";
                    let pk              = this._storesTable.primaryKey;
                    let values          = this._storesTable.values;

                    this._storesTable.columns.forEach((col: AFC.Data.IDBColumn, idx: number) => {
                        columnsIndex.set(col.name.toLowerCase(), idx);
                        if (col.alias != "")
                            columnsIndex.set(col.alias.toLowerCase(), idx);
                    });

                    let groupColumnsIdx = this._groupColumns.map(col => columnsIndex.get(col.name.toLowerCase()));
                    let nameColumnIdx   = columnsIndex.get(this._nameColum.toLowerCase());
                    let codeColumnIdx   = columnsIndex.get(this._codeColum.toLowerCase());

                    if ([...groupColumnsIdx, nameColumnIdx, codeColumnIdx].every(idx => idx !== undefined)) {
                        this._allStores = [];
                        this._groups    = [];
                        groupColumnsIdx.forEach(_ => this._groups.push(new Map()));
                        values.forEach((store: any) => {
                            this._allStores.push({code: store[codeColumnIdx], name: store[nameColumnIdx]});
                            
                            let storeIndex = this._allStores.length-1;
                            groupColumnsIdx.forEach((colIdx, groupIdx) => {
                                let groupValue  = store[colIdx];
                                let groupStores = this._groups[groupIdx].get(groupValue);
                                
                                if (groupStores == undefined)
                                    this._groups[groupIdx].set(groupValue, [storeIndex]);
                                else {
                                    groupStores.push(storeIndex);
                                    this._groups[groupIdx].set(groupValue, groupStores);
                                }
                            });
                        });
                    }
                    this._isValid = true;
                }
            }
        }
        export class BMAnalysis extends Tools.EventSink {
            private _data:              BMAnalysisData[];
            private _customData:        BMAnalysisData[];
            private _customValues:      (dataId: string, values: BMAnalysisDataValues) => IBMAnalysisDataValue[];
            private _groupsSettings:    BMAnalysisGroupsSettings; 
            private _dataValuesCache:   Map<string, BMAnalysisDataValues>
            private _pendingRequests:   Set<String>

            public static get uri() {
                return `${BMEntityCacheData.path}/analysis`
            }

            constructor(groupsSettings: BMAnalysisGroupsSettings) {
                super();

                this._data              = undefined;
                this._customData        = [];
                this._customValues      = null;
                this._groupsSettings    = groupsSettings;
                this._dataValuesCache   = new Map();
                this._pendingRequests   = new Set();
            }

            public findGroupsFromKey(key: {id: string, value: string}) : IBMAnalysisGroupItem {
                return this._groupsSettings.findFromKey(key);
            }
            public findGroups(searchString: string, groupsOnly?: boolean) : IBMAnalysisGroupItem[] {
                return this._groupsSettings.find(searchString, groupsOnly);
            }
            public get groupsDescription() : IBMAnalysisGroupDescription[] {
                return this._groupsSettings.description;
            }
            public get data() : Promise<BMAnalysisData[]> {
                if (this._data == undefined) {
                    const cachedData    = BMEntityCacheData.getInstance();

                    this._data = [];
                    return new Promise((resolve, reject) => {
                        let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(`${BMAnalysis.uri}/indicators`, true);
                        
                        request.options.method = "GET";
                        request.options.always = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                            if (jqXHR.status == 200) {
                                let items: {id: string, name: string, description?: string, suffix?: string, precision?: number, canAggregate: boolean}[] = jqXHR.responseJSON;
                                this._data = items.map(item => new BMAnalysisData(item.id, item.name, item.description, item.suffix, item.canAggregate, item.precision));
                            }
                            this.data.then(d => resolve(d));
                            //resolve([...this._data, ...this._customData]);
                        });
                        request.call();
                    });
                } else
                    return  Promise.resolve([...this._data, ...this._customData]);
            }
            public requestDataValues(group: IBMAnalysisGroupItem) : Promise<BMAnalysisDataValues> {
                let key         = `${group.key.id}=${group.key.value}`;
                let isPending   = this._pendingRequests.has(key);
                let values      = this._dataValuesCache.get(key);

                if (values == undefined) {
                    const cachedData    = BMEntityCacheData.getInstance();
                    
                    return new Promise((resolve, reject) => {
                        let onNotify = () => {
                            let values = this._dataValuesCache.get(key);
                            if (values != undefined) {
                                resolve(values);
                                this.off(Tools.EventType.UserEvent, onNotify);
                            }
                        };
                        this.on(Tools.EventType.UserEvent, onNotify);

                        if (!isPending) {
                            let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(`${BMAnalysis.uri}/compute`, true);
                            
                            this._pendingRequests.add(key);
                            request.options.method = "GET";
                            request.options.data   = {filterColumn: group.key.id, filterValue: group.key.value};
                            request.options.always = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                                if (jqXHR.status == 200) {
                                    let vs: {date: string, values: any}[] = jqXHR.responseJSON;

                                    values = new BMAnalysisDataValues(group, this._customValues);
                                    vs.forEach(value => {
                                        values.pushValue(new Date(value.date), value.values);
                                    });
                                }
                                this._dataValuesCache.set(key, values);
                                this._pendingRequests.delete(key);
                                this.fireEvent(Tools.EventType.UserEvent);
                                //resolve(values);
                            });
                            request.call();
                        }
                    });
                }
                return Promise.resolve(values);
            }
            
            public set customData(data: BMAnalysisData[]) {
                this._customData = data;
            }
            public set customValues(fn: (dataId: string, values: BMAnalysisDataValues) => IBMAnalysisDataValue[]) {
                this._customValues = fn;
            }

            public XLSExport(groups: {group0: IBMAnalysisGroupItem, group1: IBMAnalysisGroupItem}, dateRanges: {date0: {from: Date, to: Date}, date1: {from: Date, to: Date}, date2 : {from: Date, to: Date}}) {
                let cachedData                  = BMEntityCacheData.getInstance();
                let request: Rest.IAjaxRequest  = cachedData.restModel.createAjaxRequest(`${BMAnalysis.uri}/report`, true);

                this.data.then(async (d: BMAnalysisData[]) => {
                    /*
                    let [values0, values1] = await Promise.all([this.requestDataValues(groups.group0), this.requestDataValues(groups.group1)]);
                    
                    let valuesToSend0: {from: Date, values: {[key: string]: number}}[]          = [];
                    let valuesToSend1: {from: Date, values: {[key: string]: number}}[]          = [];
                    let customValues                                                            = {} as ({[key: string]: {[key: string]: number}});
                    d.forEach(data => {
                        if (data.isCustom) {
                            [values0, values1].forEach((vs, idx) => {
                                vs.get(data.id).forEach(customValue => {
                                    let key         = `${customValue.from().getTime()}##${idx}`;
                                    let value       = customValue.value();
                                    let knownValue  = customValues[key];
                                    
                                    if (knownValue == undefined)
                                        customValues[key] = {};
                                    customValues[key][data.id] = value;
                                })
                            });
                        }
                    });

                    [values0.values, values1.values].forEach((vs, idx) => {
                        vs.forEach(v => {
                            let key             = `${v.from.getTime()}##${idx}`;
                            let customValue     = customValues[key];
                            let finalValue      = {...v};
                            
                            for (let cv in customValue)
                                finalValue.values[cv] = customValue[cv];
                            if (idx == 0)
                                valuesToSend0.push(finalValue);
                            else
                                valuesToSend1.push(finalValue);
                        });
                    });
                    */
                    request.options.data        = {
                        groups:         {
                            group0: {filterColumn: groups.group0.key.id, filterValue: groups.group0.key.value/*, values: valuesToSend0*/},
                            group1: {filterColumn: groups.group1.key.id, filterValue: groups.group1.key.value/*, values: valuesToSend1*/},
                        },
                        dateRanges:     dateRanges
                    };
                    request.options.method      = Rest.RestMethod.POST;
                    request.options.format      = Rest.RestFormat.xlsx;
                    request.options.xhrFields   = { responseType: "blob" };

                    request.options.done = (sequence: number, data: any, textStatus: string, jqXHR: JQueryXHR) => {
                        let blob = new Blob([data], { type: Rest.MimeType.xlsx });
                        saveAs(blob,  AFC.Tools.StringTools.normalizeString(`AnalysisReport.xlsx`));
                    };
                    cachedData.sequence = request.call();
                });
            }
        }
    }
}
