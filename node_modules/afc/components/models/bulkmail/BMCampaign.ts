///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="./BMEntity.ts" />
///<reference path="./BMStore.ts" />
///<reference path="./BMZone.ts" />

namespace AFC {
    export namespace BulkMail {

        export const enum BMCampaignChannel {
            sms     = "sms",
            eddm    = "eddm",
            social  = "social"
        }

        export class BMCampaignExtraInfo {
            private _messages:          BMCampaignMessage[];
            private _providerMetaData:  any;

            constructor(item?: ICampaignRestData) {
                this._messages = [];
                if (item.messages)
                    this._messages = item.messages.map(i => new BMCampaignMessage(i));
                if (item.providerMetaData)
                    this._providerMetaData = item.providerMetaData;
            }

            public get messages() {
                return this._messages;
            }
            public get providerMetaData() {
                return this._providerMetaData;
            }
        }

        export class BMCampaignMessage {
            private _code:          string;
            private _name:          string;
            private _preview:       string;
            private _description:   string;
            private _color:         string;

            constructor(item?: ICampaignRestMessage) {
                this._code          = item.code;
                this._name          = item.name;
                this._preview       = item.preview;
                this._description   = item.description;
                this._color         = item.color;
            }

            public get code() {
                return this._code;
            }
            public get name() {
                return this._name;
            }
            public get description() {
                return this._description;
            }
            public get preview() {
                return this._preview;
            }
            public get color() {
                return this._color;
            }

            public toHTMLText() : string {
                return `<div class='campaign-message-text-container'><div class='campaign-message-text-circle' style='--campaign-message-color:${this.color}'></div><div class=''>${this.name.replace(/ /g,'&nbsp;')}</div></div>` 
            } 
        }

        export abstract class BMCampaign extends BMEntity {
            protected _disableDirtyEvent: boolean = false;
            /**
             * Campaign identifier in DB, auto generated at creation
             */
            protected _code: string; // is protected in parent class @see AFC.Bulkmail.BMEntity

            /**
             * (FK) Targeted zone identifier for this campaign
             */
            private _zoneCodeTargeted: string;

             /**
             * (FK) Upcoming zone identifier for this campaign
             */
            private _zoneCodeUpcoming: string;

            /**
             * Current feature version the campaign is based on
             */
            private _codeVersionTargeted: string;

            /**
             * Upcoming feature version
             */
            private _codeVersionUpcoming: string;

            /**
             * Campaign name defined by user, eg. "OP32 - Le blanc 2022"
             */
            private _name: string;

            /**
             * Start date for the campaign, must be lower than end date, ignore date's time part
             */
            protected _beginDate: Date;

            /**
             * End date of the campaign, must be higher than end date, ignore date's time part
             */
            protected _endDate: Date;

            /**
             * Tableau d'objets fournissant les quantités et le statut de chaque type d'habitat (segments HRVA)
             */
            protected _segmentList: Map<string, string>;

            /**
             * Campaign status (eg. edition mode, computing in progress, deleted, ...) @see BMCampaignStatus for values
             */
            private _status: BMCampaignStatus;

            /**
             * Nombre de BAL ciblées par segment et cumul des données client sur les zones ciblées en cours de production
             * Propriétés des objets : valeurs des segments
             */
            private _targetedAggregates: Map<string, number>;

            /**
             * Nombre de BAL ciblées par segment et cumul des données client sur les zones ciblées en cours de production
             * Propriétés des objets : valeurs des segments
             */
            private _upcomingAggregates:  Map<string, number>;

            /**
             * Nombre de magasins par statut
             * eg. [{status: "active", count: 291}, {status: "inactive", count: 15}]
             *
             * !!!! /!\= de storeList
             */
            protected _storesCounter: Array<{ status: BMStoreStatus, count: number }>;

            /**
             * Store list
             * eg. [{code: 'E001', status: 'inactive'}, ...]
             */
            private _storeList: Array<IStoreDataInStoreList>;

            /**
             * Store entity list
             */
            private _storeEntityList: Array<BMStore>;

            /**
             * Date for sorting when on create new campaign...........................................
             */
            private _timestampCreatedAt: number;

            /**
             * Keep date of last call api for stats on targeted zone
             */
            private _timestampStatsTargeted: number;

            private _timestampStats: number;

            /**
             * Keep date of last call api for stats on upcoming zone
             */
            private _timestampStatsUpcoming: number;

            public channel: BMCampaignChannel;

            constructor(item?: ICampaignRestData, isNew?: boolean) {
                let cachedData = BMEntityCacheData.getInstance();

                super();

                if (item) {
                    this._code                  = item.code;
                    this._codeVersionTargeted   = item.targeted?.featuresVersion;
                    this._zoneCodeTargeted      = item.targeted?.zoneCode;
                    this._name                  = item.name;
                    this._beginDate             = item.dateStart instanceof Date ? item.dateStart : new Date(item.dateStart);
                    this._endDate               = item.dateEnd instanceof Date ? item.dateEnd : new Date(item.dateEnd);
                    this._status                = item.status;
                    this._storesCounter         = item.stores ?? [];
                                                                          
                    this.segments               = item.segments;
                    this.targetedAggregates     = item.targeted?.aggregates;
                    this.channel                = item.channel ?? BMCampaignChannel.eddm;

                    if (item.upcoming) {
                        this.upcomingAggregates     = item.upcoming.aggregates;
                        this._codeVersionUpcoming   = item.upcoming.featuresVersion;
                        this._zoneCodeUpcoming      = item.upcoming.zoneCode;
                    }
                }

                if (isNew) {
                    this._timestampCreatedAt = Date.now();
                }

                this.on(Tools.EventType.UserEvent, () => cachedData.campaignList.fireEvent(Tools.EventType.UserEvent));
                this.on(Tools.EventType.Dirty, () => {
                    cachedData.campaignList.fireEvent(Tools.EventType.Dirty)
                });
            }

            public get code() {
                return this._code
            }

            public get timestampCreatedAt() { return this._timestampCreatedAt }

            public get codeVersionTargeted() { return this._codeVersionTargeted }
            public set codeVersionTargeted(code: string) { this._codeVersionTargeted = code }

            public get codeVersionUpcoming() { return this._codeVersionUpcoming }
            public set codeVersionUpcoming(code: string) { this._codeVersionUpcoming = code }

            public get zoneCodeTargeted() { return this._zoneCodeTargeted }
            public set zoneCodeTargeted(zoneCode: string) { this._zoneCodeTargeted = zoneCode }

            public get zoneCodeUpcoming() { return this._zoneCodeUpcoming }
            public set zoneCodeUpcoming(zoneCode: string) { this._zoneCodeUpcoming = zoneCode }

            public get beginDate() { return this._beginDate }
            public get beginDateAsString() { return formatDate(this._beginDate, "", this.isChannelSMS()) }
            public get beginDateAsStringInput() { return formatDate(this._beginDate, "input") }
            public set beginDate(date: string | Date) { 
                this._beginDate = date instanceof Date ? date : new Date(date);

                if (!this._disableDirtyEvent)
                    this.fireEvent(Tools.EventType.Dirty);
            }

            public get endDate() { return this._endDate }
            public get endDateAsString() { return formatDate(this._endDate) }
            public get endDateAsStringInput() { return formatDate(this._endDate, "input") }
            public set endDate(date: string | Date) { 
                this._endDate = date instanceof Date ? date : new Date(date) 

                if (!this._disableDirtyEvent)
                    this.fireEvent(Tools.EventType.Dirty);
            }

            public get name() { return this._name }
            public set name(name: string) { this._name = name }

            public get segments() : Map<string, string> { return this._segmentList }
            public set segments(segments: Map<string, string> | {[key: string]: any}) {
                if (segments instanceof Map) {
                    this._segmentList = new Map(segments);
                } else {
                    this._segmentList = new Map();

                    segments && Object.keys(segments).forEach(key => this._segmentList.set(key, segments[ key ]));
                }
            }

            public get status() {
                return this._status
            }

            public set status(status: BMCampaignStatus) {
                if (status) this._status = status
            }

            public get storesCounter() {
                return this._storesCounter
            }

            public set storesCounter(storesCounter: { status: BMStoreStatus, count: number }[]) {
                if (Array.isArray(storesCounter)) {
                    this._storesCounter = storesCounter;
                }
            }

            public set stores(stores: IStoreDataInStoreList[]) {
                this._storeEntityList = stores.map((_store) => new BMStore(this, _store))
            }

            public get stores(): BMStore[] {
                return this._storeEntityList
            }

            public get targetedAggregates() {
                return this._targetedAggregates
            }

            public set targetedAggregates(aggr: Map<string, number> | {[key: string]: number}) {
                if (aggr instanceof Map) {
                    this._targetedAggregates = new Map(aggr);
                } else {
                    this._targetedAggregates = new Map();
                    aggr && Object.keys(aggr).forEach(key => this._targetedAggregates.set(key, aggr[ key ]));
                }
            }

            public get upcomingAggregates() {
                return this._upcomingAggregates
            }

            public set upcomingAggregates(aggr: Map<string, number> | {[key: string]: number}) {
                if (aggr instanceof Map) {
                    this._upcomingAggregates = new Map(aggr);
                } else {
                    this._upcomingAggregates = new Map();
                    aggr && Object.keys(aggr).forEach(key => this._upcomingAggregates.set(key, aggr[ key ]));
                }
            }

            public cancelSession(session: string) : Promise<any> {
                return Promise.all([this.getStoreZone(session, false).cancelComputeStoreZone(), this.manageStoresSession(session, true)]);
            }
            public validateSession(session: string) : Promise<any> {
                return Promise.all([this.updateCommitZone(session), this.manageStoresSession(session, false)]);
            }


            public manageStoresSession(session: string, doCancel: boolean) : Promise<boolean> {
                const campaign      = this;
                const cachedData    = BMEntityCacheData.getInstance();

                return new Promise((resolve, reject) => {
                        let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(
                            `${ BMCampaign.getUriCampaign(this) }/stores`,
                            true,
                            { data: { action: {type: doCancel ? "cancelSession" : "validateSession", session: session } } }
                        );
                        
                        request.options.method = "GET";
                        request.options.always = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                            if (jqXHR.status == 200)
                                resolve(true);
                            else
                                resolve(false);
                        });
                        request.call();
                    });

                }


            /**
             * Return nb store active
             * !!! If campaign list dashboard => value comes from store counter (returned counter by api)
             * if details screen of a campaign, value comes from reducer on store list loaded by api
             */
            public get nbStoresActive() {
                if (this._storeList) {
                    return this._storeList.reduce((prev, curr) => curr.status === BMStoreStatus.active ? prev + 1 : prev, 0)
                } else {
                    let found;
                    return (found = this._storesCounter.find(elem => elem.status === BMStoreStatus.active) ?? [] as any).count
                }
            }
            public get nbStoresActiveInitial() {
                if (this._storeEntityList)
                    return this._storeEntityList.reduce((prev, curr) => curr.statusInitial === BMStoreStatus.active ? prev + 1 : prev, 0)
                return 0;
            }

            public getNbStoresActive(customFilter?: ((store: IStoreDataInStoreList) => boolean)) {
                if (this._storeList)
                    return this._storeList.reduce((prev, curr) => curr.status === BMStoreStatus.active && (customFilter ? customFilter(curr) : true) ? prev + 1 : prev, 0)
                return 0;                    
            }

            /**
             * Return total of stores for the campaign (active and inactive), stores without zone are ignored,
             * if store list exists, get length of collection
             * otherwise, return store counter value provided by api (eg. in campaign screen)
             */
            public get nbStoresTotal() {
                if (this._storeList)
                    return this._storeList.length;
                if (this._storesCounter)
                    return this._storesCounter.reduce((prev, curr) => prev + curr.count, 0);
                return 0;
            }

            public getNbStoresTotal(customFilter?: ((store: IStoreDataInStoreList) => boolean)) {
                let list = customFilter ? this._storeList.filter(customFilter) : this._storeList;
                if (list)
                    return list.length;
                return 0;
            }

            /**
             * Return sum of targeted segment, according to values from targeted version
             */
            public get qty(): number {
                return this.isChannelSMS() ?
                    this._targetedAggregates.get('VOLUME')
                    : Array.from(this._segmentList.keys())
                        .filter(elem => this._segmentList.get(elem) === BMSegmentStatus.enabled)
                        .reduce((prev, curr) => prev + (this._targetedAggregates.get(curr) || 0), 0);
            }

            /**
             * Return sum of targeted segment, according to values from upcoming version
             */
            public get qtyUpcoming(): number {
                return Array.from(this._segmentList.keys())
                    .filter(elem => this._segmentList.get(elem) === BMSegmentStatus.enabled)
                    .reduce((prev, curr) => prev + (this._upcomingAggregates.get(curr) || 0), 0);
            }

            /**
             * Return sum of targeted according to given segments if any
             * 
             * @param segmentCodeList The code segment list
             * @returns The sum of targeted aggregates according to segments
             */
            public getQty(segmentCodeList?: string[]): number {
                return segmentCodeList === void 0 ?
                    this.qty
                    : segmentCodeList
                        .reduce((prev, curr) => prev + (this._targetedAggregates.get(curr) || 0), 0);
            }

            /**
             * Return sum of each participating store's live qty (qty computed by user)
             */
            public getStoresQty(): number {
                return this.stores.reduce((prev: number, store) => store.isActive() ? prev + store.getQty() : prev, 0)
            }

            /**
             * Return uri campaign API (eg. "/bm/campaigns/_CODE_CAMPAIGN_")
             *
             * @param campaign
             * @returns the uri for current campaign
             */
            public static getUriCampaign(campaign: BMCampaign | string): string {
                return `${BMEntityCacheData.pathCampaign}/${(campaign instanceof BMCampaign ? campaign.code : campaign)}`;
            }

            /**
             * Download campaign's xlsx file, call api and save file as blob
             * eg. "http://localhost/asterop/rest/CiblageISA/bm/campaigns/e70aba3e6a8b49b787d9d054dd4f7f7d?f=xlsx&token=XXX...XXX"
             */
            public downloadFile(): void {
                let cachedData = BMEntityCacheData.getInstance();
                let request: Rest.IAjaxRequest = cachedData.restModel
                    .createAjaxRequest(
                        BMCampaign.getUriCampaign(this),
                    );

                request.options.method = Rest.RestMethod.GET;
                request.options.format = Rest.RestFormat.xlsx;
                request.options.xhrFields = { responseType: "blob" };

                const restModel = BMEntityCacheData.getInstance().restModel;

                request.options.done = (sequence: number, data: any, textStatus: string, jqXHR: JQueryXHR) => {
                    // use xhr.done instead of .always for data as blob (why????)
                    let blob = new Blob([data], { type: Rest.MimeType.xlsx });
                    saveAs(blob,  AFC.Tools.StringTools.normalizeString(`${ this.name }.xlsx`));
                };

                cachedData.sequence = request.call();
            }

            /**
             * Check validity of campaign's inputs (eg. name, dates) and return an array of errors if any
             * 
             * @returns string[]
             */
            public hasError(): string[] {
                let errors: string[] = this.hasErrorEx();

                // Invalid dates or begin date and end dat not corresponding
                if (!this.isValidDates()) {
                    errors.push("Les dates de début et de fin de la campagne doivent être renseignées et doivent être valides. La date de fin de la campagne doit être supérieure à la date de début.");
                }

                // Empty name
                if (this.hasErrorTitle()) {
                    errors.push("Le nom de la campagne ne doit pas être vide.");
                }

                // Empty segment list
                if (this.hasErrorSegments()) {
                    errors.push("Au moins un segment doit être sélectionné.");
                }

                return errors;
            }
            protected hasErrorEx() : string[] {
                return [];
            }

            public hasErrorSegments(): boolean {
                return 0 === Array.from(this.segments.keys()).filter(key => this.segments.get(key) === BMSegmentStatus.enabled).length;
            }

            public hasErrorTitle(): boolean {
                return !this.name || !this.name.trim();
            }

            public hasErrorDates(): boolean {
                return !this.isValidDates();
            }

            public canPublish() {
                return this.isValid() && this.status === BMCampaignStatus.pending
            }
            public canUnpublish() {
                return this.status === BMCampaignStatus.published
            }

            public isValid() {
                return this.isValidDates() && !this.hasErrorTitle() && !this.hasErrorSegments()
            }

            public isChannelSMS() {
                return this.channel === BMCampaignChannel.sms
            }

            public isChannelEddm() {
                return this.channel === BMCampaignChannel.eddm
            }

            public isChannelSocial() {
                return this.channel === BMCampaignChannel.social
            }

            /**
             * Check if dates valid and check if begin date is before end date
             * 
             * @returns boolean
             */
            public isValidDates(): boolean {
                let timestampStart = this.beginDate ? (this.beginDate as Date).getTime() : void 0;
                let timestampEnd = this.endDate ? (this.endDate as Date).getTime() : void 0;

                return !isNaN(timestampStart)
                    && !isNaN(timestampEnd)
                    && timestampStart > 0 && timestampEnd > 0
                    && this.beginDate < this.endDate;
            }

            public disableDirtyEvent(disable: boolean) {
                this._disableDirtyEvent = disable;
            }

            public fillCampaignWithRestData(item: ICampaignRestData) {
                let campaign = this;

                campaign._code                      = item.code;
                campaign.codeVersionTargeted        = item.targeted.featuresVersion;
                campaign.zoneCodeTargeted           = item.targeted.zoneCode;

                //!!! Si la liste des magasins participants change,
                // alors mise à jour des quantités à distribuer par segment
                // (cumul des BAL sur les zones pour les magasins participants)
                campaign.segments                   = item.segments;
                campaign.targetedAggregates         = item.targeted.aggregates;
                campaign._storesCounter             = item.stores;

                if (item.upcoming) {
                    campaign.upcomingAggregates     = item.upcoming.aggregates;
                    campaign.codeVersionUpcoming    = item.upcoming.featuresVersion; // eg. "ADREXO-2022-Q2"
                    campaign.zoneCodeUpcoming       = item.upcoming.zoneCode;
                }
            }

            /**
             * Tag campaign as deleted in DB
             * @returns
             */
            public delete(): Promise<boolean> {
                let cachedData = BMEntityCacheData.getInstance();
                const campaign = this;

                return new Promise((resolve, reject) => {
                        cachedData.eventHandler.notify(Tools.EventType.UserEvent + 1, (/*event: Tools.IEvent*/) => resolve(true));
                        cachedData.eventHandler.notify(Tools.EventType.UserEvent + 2, (/*event: Tools.IEvent*/) => resolve(false));

                        let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(BMCampaign.getUriCampaign(campaign));
                        request.options.data        = { action: { type: "delete" } };
                        request.options.byPassError = true;
                        request.options.always      = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                            if (cachedData.sequence === sequence) {
                                if (jqXHR.status == 200)
                                    cachedData.eventHandler.fireEvent(Tools.EventType.UserEvent + 1);
                                else
                                    cachedData.eventHandler.fireEvent(Tools.EventType.UserEvent + 2);
                            }
                        }).bind(this);

                        cachedData.sequence = request.call();
                        //cachedData.eventHandler.fireEvent(Tools.EventType.UserEvent + 1);
                    });
            }

            public getParamItemSave(): {[key: string]: any} {
                const campaign = this;

                return {
                    name: campaign.name,
                    dateStart: campaign.beginDate,
                    dateEnd: campaign.endDate,
                    segments: [...campaign.segments.keys()].map(key => { return { code: key, status: campaign.segments.get(key) } })
                }
            }

            /**
             * (alias) Save new campaign in DB
             * 
             * @param item
             * @returns
             */
            public save(item: { [key: string]: any } = null, basedOnCodeCampaign: string): Promise<any> {
                const cachedData    = BMEntityCacheData.getInstance();
                const campaign      = this;
                let campaignValidity;

                if (item) {
                    if (item.name) campaign.name = item.name;
                    if (item.dateStart) campaign.beginDate = item.dateStart;
                    if (item.dateEnd) campaign.endDate = item.dateEnd;
                    if (item.segments) campaign.segments = item.segments;
                }

                // *************************************************
                // Check if campaign is valid before saving in DB
                // *************************************************

                if ((campaignValidity = this.hasError()).length > 0) {
                    campaign.fireEvent(Tools.EventType.Dirty);

                    return Promise.reject(campaignValidity);
                }

                // *************************************************
                // Campaign is valid, continue
                // *************************************************

                campaign.status = BMCampaignStatus.pending;

                campaign.fireEvent(Tools.EventType.Dirty);

                return new Promise((resolve, reject) => {
                        let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(BMCampaign.getUriCampaign(basedOnCodeCampaign));

                        request.options.data = {
                            action: {
                                type: "create",
                                ...campaign.getParamItemSave()
                            }
                        };

                        request.options.always = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                            const item = jqXHR.responseJSON;

                            campaign.fillCampaignWithRestData(item);
                            campaign.fireEvent(Tools.EventType.Dirty);

                            if (cachedData.sequence === sequence) {
                                cachedData.eventHandler.fireEvent(Tools.EventType.UserEvent + 32);
                            }

                            resolve(true);
                        }).bind(this);

                        cachedData.sequence = request.call();

                        cachedData.eventHandler.fireEvent(Tools.EventType.UserEvent + 1);
                    });
            }

            /**
             * Update campaign in DB if not new. If new, only update attributes.
             * Call api:
             *      /bm/campaigns/{codeCampaign}
             *      action={
                        "type":"update", 
                        "name":"Le blanc 2018", 
                        "dateStart":"2018-08-31", 
                        "dateEnd":"2018-08-11",
                        "segments":[{"code":"NB_BALS_A", "status":"enabled"}, {"code":"NB_BALS_R", "status":"enabled"}]
                    }
             * 
             * @param item eg. 
             *      {
             *      dateEnd: "1999-08-11"
                    dateStart: "1999-08-31"
                    name: "Random 1"
                    segments:
                        {NB_BALS_A: "enabled"
                        NB_BALS_H: "disabled"
                        NB_BALS_R: "enabled"
                        NB_BALS_V: "enabled"}
                    }
             * @returns
             */
            public update(item?: ICampaignUpdateData, forceSave = false, isSimulation = false, silent = false): Promise<any> {
                const cachedData    = BMEntityCacheData.getInstance();
                const campaign      = this;
                let campaignValidity;

                if (isSimulation === false) {
                    campaign.disableDirtyEvent(true);

                    if (item.name) 
                        campaign.name       = item.name;
                    if (item.dateStart) 
                        campaign.beginDate  = item.dateStart;
                    if (item.dateEnd) 
                        campaign.endDate    = item.dateEnd;
                    if (item.stores) 
                        campaign.stores     = item.stores;
                    if (item.segments) 
                        campaign.segments   = item.segments;

                    this.invalidateStats();

                    campaign.disableDirtyEvent(false);
                }

                if (campaign.isNew() && !forceSave) {
                    if (silent === false)
                        campaign.fireEvent(Tools.EventType.Dirty);
                    return Promise.resolve(true) // No update for new campaign, use forceSave = true to create in DB through api
                } else 
                    return new Promise((resolve, reject) => {

                        // *************************************************
                        // Check if campaign is valid before saving in DB
                        // *************************************************

                        /*
                        if ((campaignValidity = this.hasError()).length > 0) {
                            campaign.fireEvent(Tools.EventType.Dirty);
                            return reject(campaignValidity);
                        }
                        */

                        // *************************************************
                        // Campaign is valid, continue
                        // *************************************************

                        let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(
                            BMCampaign.getUriCampaign(item.basedOnCodeCampaign ?? campaign)
                        );

                        // *************************************************
                        // Transform item.dateStart
                        // *************************************************

                        if (item.dateStart) {
                            item.dateStart = new Date(item.dateStart).toISOString();
                        }

                        request.options.data = {
                            action: {
                                type: campaign.status === BMCampaignStatus.new ?
                                    "create"
                                    : (isSimulation ? "simulate" : "update"),
                                ...item,
                                ...(item.segments ?
                                    { segments: Object.keys(item.segments).map(key => { return { code: key, status: item.segments[key] } })}
                                    : {})
                            }
                        };

                        request.options.always = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                            const item = jqXHR.responseJSON as ICampaignRestData;

                            if (isSimulation === false) {
                                campaign.disableDirtyEvent(true);
                                campaign.fillCampaignWithRestData(item);
                                campaign.disableDirtyEvent(false);

                                if (silent === false)
                                    campaign.fireEvent(Tools.EventType.Dirty);

                                if (cachedData.sequence === sequence) {
                                    cachedData.eventHandler.fireEvent(Tools.EventType.UserEvent + 1);
                                }
                            }

                            resolve(isSimulation ? item : true);
                        }).bind(this);

                        cachedData.sequence = request.call();

                        if (isSimulation === false) {
                            cachedData.eventHandler.fireEvent(Tools.EventType.UserEvent + 1);
                        }
                    });
            }

            /**
             * 
             * @param item 
             * @returns 
             */
            public simulate(item?: ICampaignUpdateData): Promise<ICampaignRestData> {
                return this.update(item, false, true)
            }

            /**
             * Commit temp zone for current campaign
             * 
             * Si un code de zone et un code de session sont passés, alors mise à jour de la table de zones 
             * (les zones associées au code de session deviennent les zones courantes de la campagne)
             * 
             * @param codeSession
             * @returns
             */
            public updateCommitZone(codeSession: string): Promise<any> {
                const cachedData = BMEntityCacheData.getInstance();
                const campaign = this;

                return (!codeSession) ?
                    Promise.reject("Error, empty params")
                    : new Promise((resolve, reject) => {
                        this.invalidateStats();

                        let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(BMCampaign.getUriCampaign(campaign));
                        let dataAction: ICampaignCommitZone = {
                            type: "update",
                            stores: campaign._storeList
                        };

                        if (campaign.hasUpcoming()) {
                            dataAction.upcoming = {
                                session: codeSession,
                                zoneCode: campaign.zoneCodeUpcoming,
                                featuresVersion: campaign.codeVersionUpcoming
                            }
                        } else {
                            dataAction.targeted = {
                                session: codeSession,
                                zoneCode: campaign.zoneCodeTargeted,
                                featuresVersion: campaign.codeVersionTargeted
                            }
                        }

                        request.options.data = { action: dataAction };
                        request.options.always = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                            const item = jqXHR.responseJSON as ICampaignRestData;
                            campaign.zoneCodeTargeted       = item.targeted.zoneCode;
                            campaign.targetedAggregates     = item.targeted.aggregates;
                            campaign.codeVersionTargeted    = item.targeted.featuresVersion;
                            campaign._storesCounter         = item.stores;
                            // TODO: refacto this update

                            if (item.upcoming) {
                                campaign.zoneCodeUpcoming = item.upcoming.zoneCode;
                                campaign.upcomingAggregates = item.upcoming.aggregates;
                                campaign.codeVersionUpcoming = item.upcoming.featuresVersion;
                            }

                            campaign.fireEvent(Tools.EventType.Dirty);

                            if (cachedData.sequence === sequence) {
                                cachedData.eventHandler.fireEvent(Tools.EventType.UserEvent + 1);
                            }

                            resolve(true);
                        }).bind(this);

                        cachedData.sequence = request.call();
                    });
            }

            /**
             * Activate or deactivate a list of stores for the current campaign
             * !!! Don't wait for api return to trigger Event update on cachedData
             * !!! => but campaign segments and aggregates is updated w/ api call return
             * 
             * @param stores An array of stores to be activated or deactivaed
             * @returns Promise true if call API ok
             */
            public updateStores(stores: IStoreDataInStoreList[]): Promise<any> {
                const cachedData = BMEntityCacheData.getInstance();
                const campaign = this;

                // *************************************************
                // Update stores for current campaign obj stored in cached data
                // *************************************************
                // = dont wait api return

                stores.forEach((_store) => {
                    campaign._storeList.find((__s) => __s.code === _store.code).status = _store.status; // TODO: remove line when BMStore OK
                    campaign._storeEntityList.find((__s) => __s.code === _store.code).status = _store.status;
                });

                this.invalidateStats();

                cachedData.eventHandler.fireEvent(Tools.EventType.UserEvent + 5);

                // *************************************************
                // Update stores in DB
                // *************************************************
                // + update segments campaign in cached data after resulted campaign in api

                return campaign.status === BMCampaignStatus.new ?
                    Promise.resolve(true) // No update for new campaign, use forceSave = true to create in DB through api
                    : new Promise((resolve, reject) => {
                        let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(
                            BMCampaign.getUriCampaign(campaign)
                        );

                        request.options.data = {
                            action: {
                                type: "update",
                                stores: stores
                            }
                        };

                        request.options.always = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                            const item: ICampaignRestData = jqXHR.responseJSON;

                            // !!! Si la liste des magasins participants change, alors mise à jour des quantités à distribuer par segment
                            // (cumul des BAL sur les zones pour les magasins participants)
                            campaign.segments           = item.segments;
                            campaign.storesCounter      = item.stores;
                            campaign.targetedAggregates = item.targeted.aggregates;

                            if (cachedData.sequence === sequence) {
                                cachedData.eventHandler.fireEvent(Tools.EventType.UserEvent + 5);
                            }

                            resolve(true);
                        });

                        cachedData.sequence = request.call();
                    });
            }

            protected _updateFromPublish(item: ICampaignRestData) {

            }

            /**
             * Publish campaign to provider (set status to "published")
             *
             * @param setIsPublish If true, set campaign to publish, if not, unpublish campaign (= set status pending). True by default.
             * @returns
             */
            public publish(setIsPublish = true, immediate?: boolean, publishDate?: Date, publishDate2?: Date): Promise<boolean> {
                const campaign = this;
                let cachedData = BMEntityCacheData.getInstance();

                return (campaign.canPublish() && setIsPublish) || (campaign.status === BMCampaignStatus.published && setIsPublish === false)
                    ? new Promise((resolve, reject) => {
                        let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(BMCampaign.getUriCampaign(campaign));
                        
                        request.options.byPassError = true;
                        request.options.data        = { action: { type: setIsPublish ? "publish" : "unpublish" } };
                        if (immediate)
                            request.options.data.action.immediate   = true;
                        if (publishDate)
                            request.options.data.action.dateStart   = publishDate;
                        if (publishDate2)
                            request.options.data.action.dateEnd     = publishDate2;

                        request.options.always      = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                            if (jqXHR.status === 200) {
                                //campaign.status = setIsPublish ? BMCampaignStatus.published : BMCampaignStatus.pending;
                                const item: ICampaignRestData = jqXHR.responseJSON;

                                if (item && item.status) {
                                    campaign.status         = item.status;
                                    campaign._updateFromPublish(item);
                                    if (item.dateStart)
                                        campaign.beginDate  = new Date(item.dateStart);
                                    if (item.dateEnd)
                                        campaign.endDate  = new Date(item.dateEnd);
                                }
                                campaign.fireEvent(Tools.EventType.Dirty);
                                if (cachedData.sequence === sequence)
                                    resolve(campaign.status == BMCampaignStatus.published);
                            } else if (cachedData.sequence === sequence)
                                resolve(false);
                        }).bind(this);

                        cachedData.sequence = request.call();
                    })
                    : Promise.resolve(true);
            }

            /**
             * 
             * @param campaignCopyCode 
             * @returns 
             */
            public postUpcomingApplyZone(campaignCopyCode: string): Promise<boolean> {
                const campaign = this;
                const campaignCopy = BMEntityCacheData.getInstance().campaign(campaignCopyCode);

                return campaign.isPostUpcoming() ?
                    campaign.update(
                        <ICampaignUpdateData>{
                            upcoming: {
                                zoneCode: campaignCopy.zoneCodeTargeted,
                                featuresVersion: campaignCopy.codeVersionTargeted
                            }
                        })
                    : Promise.resolve(true);
            }

            /**
             * Validate upcoming zone for the current campaign
             * 
             * @returns 
             */
            public validateUpcoming(): Promise<boolean> {
                const campaign = this;
                let cachedData = BMEntityCacheData.getInstance();

                return campaign.hasUpcoming()
                    ? new Promise((resolve, reject) => {
                        cachedData.eventHandler.notify(Tools.EventType.UserEvent + 1, (/*event: Tools.IEvent*/) => resolve(true));
                        this.invalidateStats();

                        let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(BMCampaign.getUriCampaign(campaign));

                        request.options.data = { action: { type: "upcomingValidation" } };
                        request.options.always = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {

                            // TODO: refresh campaign !!!!!
                            const item: ICampaignRestData = jqXHR.responseJSON; // TODO: extract update from item in fn helper?

                            campaign.upcomingAggregates = void 0;
                            campaign.codeVersionUpcoming = void 0;
                            campaign.zoneCodeUpcoming = void 0;

                            campaign.targetedAggregates = item.targeted.aggregates;
                            campaign.codeVersionTargeted = item.targeted.featuresVersion;
                            campaign.zoneCodeTargeted = item.targeted.zoneCode;

                            campaign.fireEvent(Tools.EventType.Dirty);

                            if (cachedData.sequence === sequence) {
                                cachedData.eventHandler.fireEvent(Tools.EventType.UserEvent + 1);
                            }
                        }).bind(this);

                        cachedData.sequence = request.call();
                        cachedData.eventHandler.fireEvent(Tools.EventType.UserEvent + 1);
                    })
                    : Promise.resolve(true);
            }

            /**
             * Set zones and targetted aggregates from a given code campaign to the current campaign
             * (used in campaign creation)
             *
             * @param basedOnCodeCampaign The campaign code to be copied
             */
            public copyZonesFromCampaign(basedOnCodeCampaign: string): void {
                const basedOnCampaign = BMEntityCacheData.getInstance().campaign(basedOnCodeCampaign);

                this.codeVersionTargeted    = basedOnCampaign.codeVersionTargeted;
                this.zoneCodeTargeted       = basedOnCampaign.zoneCodeTargeted;
                this.targetedAggregates     = basedOnCampaign.targetedAggregates;
                this.storesCounter          = [...basedOnCampaign.storesCounter];
                this.segments               = basedOnCampaign.segments;

                if (basedOnCampaign.hasUpcoming()) {
                    this.codeVersionUpcoming    = basedOnCampaign.codeVersionUpcoming;
                    this.zoneCodeUpcoming       = basedOnCampaign.zoneCodeUpcoming;
                    this.upcomingAggregates     = basedOnCampaign.upcomingAggregates;
                } else {
                    this.codeVersionUpcoming    = void 0;
                    this.zoneCodeUpcoming       = void 0;
                    this.upcomingAggregates     = void 0;
                }
            }

            public copyZonesFromCampaignUpcoming(basedOnCodeCampaign?: string, undoCopy = false): void {
                const basedOnCampaign = BMEntityCacheData.getInstance().campaign(basedOnCodeCampaign);

                if (!undoCopy && basedOnCampaign.hasUpcoming()) {
                    this.codeVersionUpcoming = basedOnCampaign.codeVersionTargeted;
                    this.zoneCodeUpcoming = basedOnCampaign.zoneCodeTargeted;
                    this.upcomingAggregates = basedOnCampaign.targetedAggregates;
                } else if (undoCopy) {
                    this.codeVersionUpcoming = void 0;
                    this.zoneCodeUpcoming = void 0;
                    this.upcomingAggregates = void 0;
                }
            }

            /**
             * Return segment list as array
             *
             * @returns
             */
            public getSegments(): {
                code: string;
                status: AFC.BulkMail.SegmentStatus;
            }[] {
                return Array.from(this.segments as any).map((_item: Array<any>) => { return { code: _item[0], status: _item[1] }})
            }

            /**
             * Return store entity corresponding to given store code
             *
             * @param storeCode The store code
             * @returns The BMStore entity found or undefined
             */
            public getStore(storeCode: string): BMStore {
                return this._storeEntityList && this._storeEntityList.find(_store => _store.code === storeCode);
            }

            /**
             * Get all stores for a campaign: for each stores, indicates if it is active or not for the current campaign.
             *      url: /asterop/rest/bulkmail/bm/campaigns/{codeCampaign}/stores
             *      api response: [{code: "E001", status: "inactive"}, {code: "E002", status: "active"},…]
             * 
             * Fills 
             * - this._storeList // TODO: --remove this line when  BMStore entity OK
             * - this._storeEntityList
             *
             * @returns Promise result returning the list of active/inactive stores for the current campaign
             */
            public getStoreList(forceUpdate = false): Promise<IStoreDataInStoreList[]> {
                const campaign = this;
                const cachedData = BMEntityCacheData.getInstance();

                // TODO: remove this._storeList whene BMStore entity OK

                return this._storeList && !forceUpdate ? Promise.resolve(this._storeList)
                    : new Promise((resolve, reject) => {
                        let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(
                            `${ BMCampaign.getUriCampaign(this) }/stores`,
                        );

                        request.options.method = "GET";
                        request.options.always = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                            let storesResponse: IStoreDataInStoreList[] = jqXHR.responseJSON;

                            this._storeList = storesResponse;

                            campaign._storeEntityList = storesResponse.map((_store) => new BMStore(this, _store));
                            cachedData.eventHandler.fireEvent(Tools.EventType.UserEvent + 1);

                            resolve(jqXHR);
                        });

                        request.call();
                    });
            }
            public setStoreName(channel: BMCampaignChannel, storeCode: string, storeName: string) : Promise<IStoreDataInStoreList> {
                return new Promise((resolve, refect) => {
                    this.getStoreList().then(_ => {
                        let store = this._storeList.find((s) => s.code === storeCode);

                        if (store) {
                            let request: Rest.IAjaxRequest  = BMEntityCacheData.getInstance().restModel.createAjaxRequest(`${ BMCampaign.getUriCampaign(this) }/stores`,);
                            let chanKey                     = channel == BMCampaignChannel.sms ? 'sms' : ''; 

                            if (chanKey != '') {
                                request.options.data        = { 
                                                                action: { 
                                                                    type:       "update",
                                                                    values: {
                                                                        code:   storeCode,
                                                                        name:   storeName
                                                                    },
                                                                    channel:    chanKey, 
                                                                } 
                                                            };
                                request.options.byPassError = true;
                                request.options.method      = "GET";
                                request.options.always = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                                    //let response: IStoreDataInStoreList[] = jqXHR.responseJSON;
                                    if (jqXHR.status == 200)
                                        store.channels[chanKey].name = storeName;
                                    resolve(store);
                                });
                                request.call();
                            } else
                                resolve(store);
                        } else
                            resolve(null);
                    });
                });
            }

            /**
             * Call api to get kpis (per segmentations, aggregates, ...) for each store
             *          url: asterop/rest/{projet}/bm/zones/{code zone} + action type = "stats"
             *          api response:
             *          {"stores": [
             *              {"code":"E002","values":{"NB_BALS_H":2708,"NB_BALS_R":5107,"NB_BALS_V":25055,"NB_BALS_A":1869,"CA":0,"DATA1":0,"DATA2":0}},
             *              ...
             *          ]}
             *
             * @params codeSession - The session id generated by client on screen creation
             * @param storeCodes - A list of store codes to be refreshed
             * @params saveToCampaignStores - Force update for all campaign' stores obj, in both cases true or false, values are passed to promise result
             * @params saveToupdateQtyTmpComputed - If true, set value to temp computed qty of each store
             * 
             * @returns
             */
            public computeZoneData(
                    codeSession: string,
                    storeCodes: string[] = [],
                    saveToCampaignStores = true
                ): Promise<void> {
                const campaign = this;
                
                let pStoreListLoading = this._storeEntityList === void 0 ?
                    this.getStoreList().then(() => this._storeEntityList)
                    : Promise.resolve(this._storeEntityList);

                return !this._timestampStats ? new Promise((resolve, reject) => {
                    pStoreListLoading.then((storeList: BMStore[]) => {
                        let request = campaign._generateApiStats(codeSession);
                        request.options.always = ((sequence: number, jqXHR: JQueryXHR) => { 
                            let targetedRes:    IStatsStoresRestData[]  = [];
                            let upcomingRes:    IStatsStoresRestData[]  = [];
                            let toProcess:      IStatsStoresRestData[]  = []; 
                            let hasUpcoming                             = false;
                                                        
                            if (jqXHR.responseJSON.targeted) {
                                targetedRes = <IStatsStoresRestData[]>jqXHR.responseJSON.targeted.stores;
                                toProcess   = targetedRes;
                            }
                            if (jqXHR.responseJSON.upcoming) {
                                upcomingRes = <IStatsStoresRestData[]>jqXHR.responseJSON.upcoming.stores;
                                toProcess   = upcomingRes;
                                hasUpcoming = true;
                            }

                            //if (saveToCampaignStores || updateQtyTmpComputed) {
                            targetedRes && targetedRes.forEach((_store: IStatsStoresRestData) => {
                                if (storeCodes && (storeCodes.length > 0 && storeCodes.indexOf(_store.code) === -1)) {
                                    return;
                                }
                                try {
                                    let store = this.getStore(_store.code);
                                    saveToCampaignStores && ((store.valuesTargeted = _store.targeted) && (store.valuesTargetedMax = _store.whole));
                                    
                                    if (!hasUpcoming) {
                                        if (_store.targeted.cost)
                                            store.qtyTempComputed = this.isChannelSocial() ? _store.targeted.cost.budget  : _store.targeted.cost.volume; 
                                        else 
                                            store.qtyTempComputed = campaign.getActiveSegments().reduce((__prev, __codeSegment) => __prev + (_store.targeted[ __codeSegment ] ?? 0), 0);
                                    }
                                } catch (e) {
                                    // console.log(`Erreur pour le magasin ${ _store.code }`);
                                }
                            });
                            upcomingRes && upcomingRes.forEach((_store: IStatsStoresRestData) => {
                                if (storeCodes && (storeCodes.length > 0 && storeCodes.indexOf(_store.code) === -1)) {
                                    return;
                                }
                                try {
                                    let store = this.getStore(_store.code);
                                    saveToCampaignStores && ((store.valuesUpcoming = _store.targeted) && (store.valuesUpcomingMax = _store.whole));

                                    if (hasUpcoming) {
                                        if (_store.targeted.cost)
                                            store.qtyTempComputed = this.isChannelSocial() ? _store.targeted.cost.budget  : _store.targeted.cost.volume; 
                                        else 
                                            store.qtyTempComputed = campaign.getActiveSegments().reduce((__prev, __codeSegment) => __prev + (_store.targeted[ __codeSegment ] ?? 0), 0);
                                    }
                                } catch (e) {
                                    // console.log(`Erreur pour le magasin ${ _store.code }`);
                                }
                            });

                            // Log loading stats, to prevent
                            saveToCampaignStores && (this._timestampStats = Date.now());
                            resolve();
                        });
                        request.call();
                    });
                }) : Promise.resolve()
            }

            protected _generateApiStats(codeSession: string): Rest.IAjaxRequest {
                const cachedData = BMEntityCacheData.getInstance();
                const campaign = this;
                //let action = campaign._generateApiStatsParam(codeSession, codeVersion);

                let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(
                    `${BMCampaign.getUriCampaign(this)}/stores/stats`, // asterop/rest/{projet}/bm/campaigns/{code campaign}/stores/stats
                    true,
                    { data: { session: codeSession } }
                );
                request.options.method = "GET";

                return request
            }

            /**
             * Get campaign provider
             * 
             * @returns 
             */
            public getProvider(): BMProvider {
                return BMEntityCacheData.getInstance().provider(null, this.codeVersionTargeted);
            }

            public loadExtraInfo() : Promise<BMCampaignExtraInfo> {
                const cachedData = BMEntityCacheData.getInstance();

                return new Promise((resolve, reject) => {
                    let request: Rest.IAjaxRequest = cachedData.restModel.createAjaxRequest(
                        `${ BMCampaign.getUriCampaign(this) }`,
                        true
                    );
                    
                    request.options.method = "GET";
                    request.options.always = ((sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                        if (jqXHR.status == 200) {
                            resolve(new BMCampaignExtraInfo(<ICampaignRestData>jqXHR.responseJSON));
                        }
                        else
                            resolve(null);
                    });
                    request.call();
                });

            }
            
            /**
             * Compute aggregates for campaign/zones with kpis comming from @see BMCampaign::computeZoneData()
             * and stores definition (active/inactive)
             * // TODO: refacto totalStores, activeStores, selectedStores
             *
             * @param selectedStoreList Array of store codes wich will be used to computed aggreagation for store selection by user (if any given)
             * @param codeSession
             * @param filteredStoredList Array of store codes wich will be used to computed aggreagation on filtered stores only
             * @returns Promise with computed results
             */
            public getZoneAggregates(selectedStoreList: string[] = [], codeSession: string, filteredStoredList?: string[]): Promise<{
                totalStores:    { [key: string]: number },
                activeStores:   { [key: string]: number },
                selectedStores: { [key: string]: number }
            }> {
                const campaign              = this;
                const cachedData            = BMEntityCacheData.getInstance();
                const provider              = cachedData.provider(null, this.codeVersionTargeted);
                const aggregateCodeList     = provider.aggregates.map((agg: AFC.BulkMail.IProviderCustomData) => agg.code); // extract all aggregates code to be computed
                const fnStorePassedFilter   = (store: BMStore) => filteredStoredList === void 0 || filteredStoredList.indexOf(store.code) !== -1;

                //MD : push getActiveSegments values to aggregates
                aggregateCodeList.push(...campaign.getActiveSegments())

                // TODO: do it once? store values?

                return Promise.all([
                    campaign.computeZoneData(codeSession, null, true), // TODO: do not use this value anymore
                    campaign.getStoreList()
                ]).then((values) => {
                        const [ _, storeList ]   = values;
                        let reduceValues         = (stores: BMStore[]) => {
                            let useUpcoming = false;

                            return stores.reduce((counter: any, store: BMStore) => {
                                if (fnStorePassedFilter(store)) {
                                    aggregateCodeList.forEach(aggCode => {
                                        let found = false;

                                        counter[aggCode] = counter[aggCode] ?? 0;
                                        if (store.valuesUpcoming) {
                                            useUpcoming         = true;
                                            counter[aggCode]    += store.valuesUpcoming[aggCode];
                                        }
                                        if (store.valuesTargeted) {
                                            if (!useUpcoming)
                                                counter[aggCode] += store.valuesTargeted[aggCode];
                                            
                                            counter[aggCode + ".targeted"] = counter[aggCode + ".targeted"] ?? 0;
                                            counter[aggCode + ".targeted"] += store.valuesTargeted[aggCode];
                                        }
                                    });

                                    let propsToCheck = ["cost", "insights"];

                                    propsToCheck.forEach(prop => {
                                        let p = null;
                                        if (store.valuesUpcoming && store.valuesUpcoming[prop])
                                            p = store.valuesUpcoming[prop];
                                        else if (store.valuesTargeted && store.valuesTargeted[prop])
                                            p = store.valuesTargeted[prop];
                                        if (p) {
                                            for (let pp in p) {
                                                let key = `${prop}.${pp}`;

                                                counter[key] =  counter[key] ?? 0;
                                                counter[key] += p[pp];
                                            }
                                        }
                                    });
                                }
                                return counter;
                            }, {})
                        }

                        return Promise.resolve({
                            totalStores:    reduceValues(campaign.stores),
                            activeStores:   reduceValues(campaign.stores.filter((store: BMStore) => {
                                        let isActive = false;
                                        try {
                                            isActive = storeList.find((s: any) => s.code === store.code).status === BMStoreStatus.active;
                                        } catch(e) {
                                            //console.error(`Store not found: ${ store.code }`);
                                        }
                                        return isActive;
                                    })),
                            selectedStores: reduceValues(selectedStoreList.filter((storeCode: string) => campaign.stores.find((store: BMStore) => store.code === storeCode))
                                                                          .map((storeCode: string) => campaign.stores.find((store: BMStore) => store.code === storeCode)))
                        });
                });
            }

            /**
             * Returns codes segments that are enabled for the current campaign
             *
             * @returns array[]
             */
            public getActiveSegments(): string[] {
                return Array.from<string>(this.segments.keys()).filter((key: string) => this.segments.get(key) === BMSegmentStatus.enabled);
            }

            /**
             * Returns zone model for handling zone sectors,
             * BEWARE ! in case of upcoming, return upcoming zone !!!!!!
             *
             * @returns BMZone
             */
            public getStoreZone(session: string, forceGetTargeted: false): BMZone {
                return this.hasUpcoming() && forceGetTargeted === false ? 
                    new BMZone(this, this.zoneCodeUpcoming, this.codeVersionUpcoming, session)
                    : new BMZone(this, this.zoneCodeTargeted, this.codeVersionTargeted, session);
            }

            /**
             * Return nb stores that have been modified by user
             * @returns 
             */
            public getKpiNbDiffStores(customFilter?: (store: BMStore) => boolean): number {
                return this.stores ? this.stores.filter(_store => _store.qtyTemp !== void 0 && (customFilter ? customFilter(_store) : true)).length : 0;
            }

            public getKpiNbActiveStores(): number {
                return this.stores ? this.stores.filter(_store => _store.isActive()).length : 0;
            }

            /**
             * Clean store list (eg. use when leaving campaign details screen)
             */
            public flushStores() {
                this._storeList = void 0;
                this._storeEntityList = void 0;

                this.invalidateStats();
            }

            /**
             * Resset timestamp for stats to allow calling once again stats API (otherwise stats data are stores in each stores)
             */
            public invalidateStats() {
                /*
                this._timestampStatsTargeted = void 0;
                this._timestampStatsUpcoming = void 0;
                */
                this._timestampStats = void 0;
            }

            /**
             * Check if campaign still has an upcoming version
             *
             * @returns If true, campaign has an upcoming version
             */
            public hasUpcoming() {
                return !!this._zoneCodeUpcoming;
            }

            /**
             * Compares campaign begin date and next version delivery date
             *
             * @returns True if campaign starts after upcoming version is delivered to production
             */
            public isPostUpcoming(withoutUpcomingZone = true) {
                const nextVersion = this.getProvider()?.getNextVersion();

                return nextVersion
                    && this._beginDate >= new Date(nextVersion.dateProduction)
                    && this.codeVersionTargeted !== nextVersion.code
                    && (
                        (withoutUpcomingZone && !this.hasUpcoming())
                        || !withoutUpcomingZone
                    )
                    && !this.isNew();
            }

            public isPublished() {
                return this.status === BMCampaignStatus.published
            }

            public isNew() {
                return this.status === BMCampaignStatus.new
            }

            public storeToggleActive(storeOrCode: string | BMStore, active?: boolean): BMStoreStatus { // TODO: do it all in BMStore, trigger event, etc...
                let store               = typeof storeOrCode === "string" ? this.getStore(storeOrCode) : storeOrCode;
                let finalStoreStatus    = store.toggleActive(active);

                this._storeList.some((_store, _i) => {
                    if (_store.code === store.code) {
                        this._storeList[ _i ].status = finalStoreStatus;
                        return true;
                    }
                });

                this.fireEvent(Tools.EventType.Dirty);

                return finalStoreStatus;
            }
        }

        const formatDate = (date: Date, type = "", withTime = false): string => {
            let dateString = "";

            if (!date || isNaN(date.getTime())) {
                return dateString
            }

            if (type === "input") {
                let splittedDate = date
                    .toLocaleString("fr-FR", { year: "numeric", month: "numeric", day: "numeric" })
                    .split('/');

                dateString = `${splittedDate[2]}-${splittedDate[1]}-${splittedDate[0]}`;
            } else {
                dateString = date.toLocaleString(
                    "fr-FR",
                    !withTime ? 
                        { year: "numeric", month: "numeric", day: "numeric" }
                        : { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric" }
                );
            }

            return dateString
        };

        export const enum BMCampaignStatus {
            new         = "new", // unused in DB, only for repeater...
            pending     = "pending",
            published   = "published",
            deleted     = "deleted",
            template    = "template",
            validated   = "validated",
            checked     = "checked",
        }
        export const enum BMCampaignRouteStatus {
            sleeping        = "sleeping",
            verification    = "verification",
            scheduled       = "scheduled",
            started         = "started",
            completed       = "completed",
            completedFinal  = "completedFinal",
            canceled        = "canceled",
            stopped         = "stopped",
        }

        export const enum BMSegmentStatus {
            enabled = "enabled",
            disabled = "disabled"
        }

        export interface IStoreDataInStoreList {
            code:           string;
            status:         BMStoreStatus;
            channels? :     {[key: string]: any};
            values?:        {[key: string]: any};
        }

        /**
         * Rest result declaration of api service : /bm/campaigns for a campaign item
         * or data coming from new campaign creation from UI
         * 
         * eg. 
         *          {
                        "code": "5bb364ad746c4387970ae6988254ec1a",
                        "name": "Opération Vacances d'été 2022",
                        "dateStart": "2022-08-06T00:00:00.000Z",
                        "dateEnd": "2022-10-06T00:00:00.000Z",
                        "targeted": {
                            "zoneCode": "e9587b83d39a4f0787f21c91df7bde49",
                            "featuresVersion": "wsorawtuorjdz3h8sh4dynipunh4rid8",
                            "aggreagtes": {
                                "CA": 0,
                                "DATA1": 0,
                                "DATA2": 0
                            }
                        },
                        "status": "pending",
                        "segments": {
                            "NB_BALS_R": "enabled",
                            "NB_BALS_A": "enabled"
                        },
                        "stores": [
                            {
                                "status": "active",
                                "count": 1
                            },
                            {
                                "status": "inactive",
                                "count": 305
                            }
                        ]
                    }
         */
        export interface ICampaignRestData {
            code?:      string;
            name?:      string;
            channel?:   BMCampaignChannel;
            dateStart?: string | Date;
            dateEnd?:   string | Date;
            targeted?:  {
                zoneCode:           string;
                featuresVersion:    string;
                aggregates?:        {[key: string]: any} | Map<string, number>;
            };
            upcoming?:  {
                zoneCode:           string;
                featuresVersion:    string;
                aggregates?:        {[key: string]: any} | Map<string, number>;
            };
            status?:    BMCampaignStatus;
            segments?:  {
                [key: string]: any
            };
            stores?:    {
                status:             BMStoreStatus,
                count:              number
            }[];
            messages?:  [ICampaignRestMessage];
            providerMetaData?:      any
        }

        export interface ICampaignRestMessage {
            code:           string,
            name:           string,
            description:    string,
            color:          string,
            preview:        string,
        }

        export interface ICampaignUpdateData extends Omit<ICampaignRestData, 'stores'> {
            stores?:                IStoreDataInStoreList[];
            basedOnCodeCampaign?:   BMCampaign;
            target?:                {
                options?:   Array<string>,
                segments?:  Array<{id: string}>
            }
        }

        interface ICampaignCommitZone {
            type: "update";
            stores?: IStoreDataInStoreList[],
            targeted?: {
                session: string;
                zoneCode: string;
                featuresVersion: string;
            },
            upcoming?: {
                session: string;
                zoneCode: string;
                featuresVersion: string;
            }
        }

        interface IStatsStoresRestData {
            code:       string,
            targeted:   TStoreDataValues,
            whole:      TStoreDataValues
        }
    }
};