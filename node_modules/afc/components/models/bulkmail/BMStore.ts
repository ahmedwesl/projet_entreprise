///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="./BMCampaign.ts" />

namespace AFC {
    export namespace BulkMail {

        export const enum BMStoreStatus {
            active = "active",
            inactive = "inactive",
            undefined = "undefined" // parce que t'es obligé de gérer les erreurs data coté front
        }

        export type TStoreDataValues = { [key: string]: any };

        /**
         * Instance of store for a campaign
         */
        export class BMStore extends BMEntity {
            /**
             * Store identifier in DB, given by api
             */
            protected _code: string; // is protected in parent class @see AFC.Bulkmail.BMEntity

            /**
             * Store status, if active, store is participating to the campaign
             */
            protected _status: BMStoreStatus;
            protected _statusInitial: BMStoreStatus;
            protected _campaign: BMCampaign;

            /**
             * 
             */
            protected _valuesTargeted: TStoreDataValues;
            protected _valuesTargetedMax: TStoreDataValues; // max allowed values = .whole attribute from api

            protected _valuesUpcoming: TStoreDataValues;
            protected _valuesUpcomingMax: TStoreDataValues; // max allowed values = .whole attribute from api

            /**
             * Intial values of eather upcoming in case of upcoming exists, or targeted if not.
             * This save initial values to populate initial qty in table, otherwise, valuesTargeted or Upcoming may be updated
             * after computing operation
             */
            protected _valuesInitial: Readonly<TStoreDataValues>;

            /**
             * Store temp qty given by user
             */
            public qtyTemp: number;

            /**
             * Store temp qty computed
             */
            public qtyTempComputed: number;

            constructor(campaign: BMCampaign, item?: IStoreDataInStoreList) {
                super();

                this._campaign = campaign;

                if (item) {
                    this._code = item.code;
                    this._status = item.status;
                    this._statusInitial = this._status;

                    if (item["values"]) {
                        this._valuesTargeted = item["values"];
                    }
                }
            }

            public get code() { return this._code }

            public get status() { return this._status }
            public set status(status: BMStoreStatus) { this._status = status }
            public get statusInitial() { return this._statusInitial }
            
            public get valuesInitial() { return this._valuesInitial }

            public get valuesTargeted() { return this._valuesTargeted }
            public set valuesTargeted(values: TStoreDataValues) {
                if (this._valuesInitial === void 0 && !this._campaign.hasUpcoming()) {
                    this._valuesInitial = { ...values };
                }

                this._valuesTargeted = { ...values };
            }
            public get valuesTargetedMax() { return this._valuesTargetedMax }
            public set valuesTargetedMax(values: TStoreDataValues) { this._valuesTargetedMax = { ...values } }

            public get valuesUpcoming() { return this._valuesUpcoming }
            public set valuesUpcoming(values: TStoreDataValues) {
                if (this._valuesInitial === void 0 && this._campaign.hasUpcoming()) {
                    this._valuesInitial = { ...values };
                }

                this._valuesUpcoming = { ...values };
            }
            public get valuesUpcomingMax() { return this._valuesUpcomingMax }
            public set valuesUpcomingMax(values: TStoreDataValues) { this._valuesUpcomingMax = { ...values } }

            /**
             * Test if store is active (in campaign)
             *
             * @returns
             */
            public isActive(): boolean {
                return this.status === BMStoreStatus.active;
            }

            /**
             * Toggle store status to active or inactive (no DB saving)
             *
             * @param active
             * @returns
             */
            public toggleActive(active?: boolean): BMStoreStatus {
                this.status = active === true || !this.isActive() ? BMStoreStatus.active : BMStoreStatus.inactive;

                return this.status
            }

            public getQtyTargeted(options?: string[]): number {
                return this._getQty(this.valuesTargeted, options);
            }

            public getQtyUpcoming(options?: string[]): number {
                return this._getQty(this.valuesUpcoming, options);
            }

            public getQtyDiff(): number {
                return this.getQtyUpcoming() - this.getQtyTargeted();
            }

            /**
             * Return computed quantity according to given options (= segments), if no option, return sum of all
             * active segments in campaign
             *
             * @param options An array of segments code
             * @param optGetInitial If force true, retrieve intial values targeted or upcoming (valeus that hasnt changed following multiple computes by user), default is false
             * @returns sum of qty according to segments given or default active segments in campaign
             */
            public getQty(options?: string[], optGetInitial: boolean = false): number {
                const values = optGetInitial ? this.valuesInitial
                    : (this._campaign.hasUpcoming() ? this.valuesUpcoming : this.valuesTargeted);

                return this._getQty(values, options);
            }

            /**
             * Get max qty available
             * // TODO: refacto with previous getQty() fn
             *
             * @param options
             * @returns
             */
            public getQtyMax(options?: string[]): number {
                const values = this._campaign.hasUpcoming() ? this.valuesUpcomingMax : this.valuesTargetedMax;

                return this._getQty(values, options);
            }

            private _getQty(values: TStoreDataValues, options?: string[]) {
                if (values) {
                    if (values.cost)
                        return values.cost.volume;
                    return (options || this._campaign.getActiveSegments()).reduce((prev: number, curr: (keyof TStoreDataValues)) => prev + (values[curr] ?? 0), 0)
                }
                return 0;
            }

            /**
             * Return qty temp = input by user in store edition table
             *
             * @returns
             */
            public getQtyTemp(): number {
                return this.qtyTemp !== void 0 ? this.qtyTemp : this.getQty();
            }

            public getBudget(): number {
                return this.valuesTargeted?.cost?.budget || 0;
            }

            public getBudgetMax(): number {
                return this.valuesTargetedMax?.cost?.budget;
            }

            public getVolume(): number {
                return this.valuesTargeted?.cost?.volume;
            }

            public getVolumeMax(): number {
                return this.valuesTargetedMax?.cost?.volume;
            }

            public getZoneAggregates(): { [key: string]: number } {
                const cachedData = BMEntityCacheData.getInstance();
                const store = this;
                const valuesUpcoming = store.valuesUpcoming;
                const valuesTargeted = store.valuesTargeted;
                const campaign = store._campaign;
                const provider = cachedData.provider(null, campaign.codeVersionTargeted);
                const segments = campaign.getActiveSegments();
                const aggregateCodeList = [...segments];
                const aggregates: { [key: string]: number } = {};
                    
                provider.aggregates.forEach((agg: AFC.BulkMail.IProviderCustomData) => aggregateCodeList.push(agg.code)); // extract all aggregates code to be computed
                aggregateCodeList.forEach(aggCode => {
                    if (valuesUpcoming)
                        aggregates[aggCode] = valuesUpcoming[aggCode];
                    if (valuesTargeted) {
                        if (!valuesUpcoming)
                            aggregates[aggCode] = valuesTargeted[aggCode];
                        aggregates[`${aggCode}.targeted`] = valuesTargeted[aggCode] ?? 0;
                    }
                    aggregates[aggCode] || (aggregates[aggCode] = 0);
                });

                let cost = valuesUpcoming?.cost || valuesTargeted?.cost;
                if (cost) {
                    for (let prop in cost) {
                        aggregates[`cost.${prop}`] = cost[prop];
                    }
                } else {
                    aggregates['cost.volume'] = segments.reduce((acc, segment) => acc + (aggregates[segment] || 0), 0);
                }
                return aggregates;
            }
        }
    }
};