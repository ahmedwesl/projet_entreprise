///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="./BMEntity.ts" />

namespace AFC.BulkMail {
    export interface IStoreZoneUnitsDataValues {
        [key: string]: number | IStoreZoneUnitsDataValues;
    }

    export interface IStoreZoneUnitsData {
        targeted: boolean;
        code: string;
        values: IStoreZoneUnitsDataValues;
    }
    
    interface IStoreZoneData {
        storeCode: string|number;
        units: IStoreZoneUnitsData[];
    };
    
    export interface IStoreZoneInfo {
        featuresVersion: string;
        whole?: {
            table: {
                database: string;
                name: string;
            };
            outlineTable?: {
                database: string;
                name: string;
            };
        };
        targeted: {
            table: {
                database: string;
                name: string;
            };
            outlineTable?: {
                database: string;
                name: string;
            };
        }
    }

    export const enum SegmentStatus {
        enabled = 'enabled',
        disabled = 'disabled'
    }
    
    const _target = Symbol();

    function _normalize(campaign: BMCampaign, data: IStoreZoneData[]): IStoreZoneData[] {
        if (campaign.isChannelEddm()) {
            const segments = campaign.getActiveSegments();
            data.forEach(storeData => 
                storeData?.units?.forEach(unit => (unit.values || (unit.values = {})).cost = { volume: segments.reduce((acc: number, segment) => acc + (<number>unit.values[segment] || 0), 0) })
            );                
        }
        return data;
    }


    export class BMZone {
        constructor(campaign: BMCampaign, zoneCode: string, featuresVersion: string, session: string) {
            this.campaign = campaign;
            this.code = zoneCode;
            this.featuresVersion = featuresVersion;
            this.session = session;
            this._unitsData = {};
        }
        
        public createAjaxRequest<T = any>(action?: any): Rest.IAjaxRequest<T> {
            let request = BMEntityCacheData.getInstance().restModel.createAjaxRequest(`${BMEntityCacheData.pathZones}/${this.code}`);
            request.options.data = {
                action: $.extend(action || {}, {
                    session: this.session,
                    featuresVersion: this.featuresVersion
                })
            };
            return request;
        }

        protected _getStoreZone(stores: ReadonlyArray<string|number>): Promise<void> {
            return new Promise((resolve, reject) => {
                let request: Rest.IAjaxRequest = this.createAjaxRequest({
                        type: 'units',
                        stores: stores,
                    ...(this.campaign.isChannelSMS() ? { target: (<BMCampaignSMS>this.campaign).getTarget() } : {})
                    });
                request.options.always = (sequence: number, jqXHR: JQuery.jqXHR, textStatus: string) => {
                    if (jqXHR.status === 200) {
                        let data: ReadonlyArray<IStoreZoneData> = _normalize(this.campaign, jqXHR.responseJSON);
                        stores.forEach(code => this._unitsData[code] = null);
                        data.forEach(item => this._unitsData[item.storeCode] = item.units);
                        resolve();
                    } else {
                        reject();
                    }
                };
                request.call();
            });
        }

        protected _compute(
            stores: ReadonlyArray<{ storeCode: string | number, quantity: number }>,
            criteria: ReadonlyArray<{ data: string, isASC: boolean }>,
            segments: ReadonlyArray<{ code: string, status: SegmentStatus }> | null,
            target: Readonly<{ segments: Array<{ code: string }>, options: Array<string> }> | null,
            reset: boolean,
            update: boolean,
            hideUnits: boolean): Promise<IStoreZoneData[]> {
            return new Promise((resolve, reject) => {
                let request: Rest.IAjaxRequest = this.createAjaxRequest({
                    type: update ? 'update' : 'compute',
                    stores: stores,
                    criteria: criteria,
                    reset: reset,
                    hideUnits: hideUnits ?? false,
                    ...(segments ? { segments: segments } : { target: target })
                });
                request.options.always = (sequence: number, jqXHR: JQuery.jqXHR, textStatus: string) => {
                    jqXHR.status === 200 ?
                        resolve(_normalize(this.campaign, jqXHR.responseJSON)):
                        reject();
                };
                request.call();
            });
        }

        public async computeStoreZone(
                stores: ReadonlyArray<{storeCode: string|number, quantity: number}>,
                criteria: ReadonlyArray<{data: string, isASC: boolean}>,
                segments: ReadonlyArray<{code: string, status: SegmentStatus}> | null,
                target: Readonly<{ segments: Array<{code: string}>, options: Array<string> }> | null,
                reset: boolean,
                hideUnits?: boolean): Promise<ReadonlyArray<Readonly<IStoreZoneUnitsData>>[]> {
            let data = await this._compute(stores, criteria, segments, target, reset, false, hideUnits);
            return data.map(items => items.units);
        }

        public async updateStoreZone(
                stores: ReadonlyArray<{ storeCode: string | number, quantity: number }>,
                criteria: ReadonlyArray<{ data: string, isASC: boolean }>,
                reset: boolean,
                hideUnits?: boolean): Promise<ReadonlyArray<Readonly<IStoreZoneUnitsData>>[]> {
            let data = await this._compute(
                stores,
                criteria,
                this.campaign.isChannelEddm() ? this.campaign.getSegments() : null,
                this.campaign.isChannelSMS() ? (<AFC.BulkMail.BMCampaignSMS>this.campaign).getTarget() : null,
                reset,
                true,
                hideUnits);
            stores.forEach(store => this._unitsData[store.storeCode] = null);
            return data.map(item => this._unitsData[item.storeCode] = item.units);
        }

        /**
         * Cancel session > call api, will trigger DB cleaning
         * 
         * @returns
         */
        public cancelComputeStoreZone(): Promise<Boolean> {
            return new Promise((resolve, reject) => {
                let request = BMEntityCacheData.getInstance().restModel.createAjaxRequest(`${BMEntityCacheData.pathZones}`);
                request.options.data = {
                    action: {
                        type: "cancelSession",
                        session: this.session
                    }
                };

                request.options.always = (sequence: number, jqXHR: JQuery.jqXHR, textStatus: string) => {
                    jqXHR.status === 200 ? resolve(true) : reject(false);
                };

                request.call();
            });
        }

        public replaceStoreZone(areas: ReadonlyArray<{storeCode: string|number, featureCodes: ReadonlyArray<string>}>): Promise<ReadonlyArray<Readonly<IStoreZoneUnitsData>>[]> {
            return new Promise((resolve, reject) => {
                let request: Rest.IAjaxRequest = this.createAjaxRequest({
                    type: 'replace',
                    areas: areas,
                    ...(this.campaign.isChannelSMS() ? (<BMCampaignSMS>this.campaign).getTarget() : {})
                });
                request.options.always = (sequence: number, jqXHR: JQuery.jqXHR, textStatus: string) => {
                    if (jqXHR.status === 200) {
                        let data: IStoreZoneData[] = jqXHR.responseJSON;
                        areas.forEach(area => this._unitsData[area.storeCode] = null);
                        resolve(data.map(item => this._unitsData[item.storeCode] = item.units));
                    } else {
                        reject();
                    }
                };
                request.call();
            });
        }
        
        public async getUnits(storeCodes: ReadonlyArray<string|number>): Promise<ReadonlyArray<Readonly<IStoreZoneUnitsData>>[]> {
            let missing: (string|number)[],
                index: {[key: string]: number},
                results = storeCodes.map((code, indice) => (this._unitsData.hasOwnProperty(code) || ((missing || (index = {}, missing = [])).push(code), index[code] = indice),this._unitsData[code]));
                
            if (missing) {
                await this._getStoreZone(missing);
                missing.forEach(code => results[index[code]] = this._unitsData[code]);
            }
            return results;
        }
        
        public async getInfo(): Promise<Readonly<IStoreZoneInfo>> {
            return this._info || new Promise((resolve, reject) => {
                let request: Rest.IAjaxRequest = this.createAjaxRequest({
                    type: 'info'
                });
                request.options.always = (sequence: number, jqXHR: JQuery.jqXHR, textStatus: string) => {
                    if (jqXHR.status === 200) {
                        resolve(this._info = jqXHR.responseJSON);
                    } else {
                        reject();
                    }
                };
                request.call();
            });
        }
        
        private _unitsData: {[key: string]: IStoreZoneUnitsData[]};
        private _info: IStoreZoneInfo;
        public readonly campaign: BMCampaign;
        public readonly code: string;
        public readonly featuresVersion: string;
        public readonly session: string;
        
        public get unitsData() { return this._unitsData }
    }
}