/**
 * Created by jean.rennes on 23/09/2015.
 */
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="Global.ts" />
///<reference path="DashboardView.ts" />
///<reference path="SiteFinder.ts" />

namespace AFC.Dashboards {
    export interface IDashboardEventData extends Tools.IEventData {
        readonly views: boolean;        // views were invalidated
        readonly districting: boolean;  // districting only
    }
    
    export interface IZoneCluster {
        readonly id: string;
        readonly zones: ReadonlyArray<IZone>;
        readonly dashboard: IDashboard;
        current: string | number;
        setSite(point: GeoJSON.Point): void;
    }
    
    export interface IDashboard extends Tools.EventSink {
        readonly descriptor: IDashboardDescriptor;
        readonly reaffectStorages: IReaffectStorages;
        readonly id: string;
        readonly name: string;
        readonly branch: string;
        readonly zones: ReadonlyArray<IZone>;
        readonly views: ReadonlyArray<IView>;
        readonly reportTemplates: ReadonlyArray<IReportTemplate>;
        readonly properties: IDashboardProperties;
        readonly viewsProperties: Readonly<IViewsProperties>;
        readonly mainCluster: IZoneCluster;
        readonly clusters: ReadonlyArray<IZoneCluster>;
        readonly requestBuilder: Rest.RequestBuilder<IDashboardContextData>;
        createRequest<T extends IDashboardContextData = IDashboardContextData>(path?: string, options?: Rest.IRestRequestOptions, districtType?: DistrictType): [number, Promise<Rest.IAjaxRequest<T>>];
        getContextDashboard(): Promise<IGlobalDashboardContextData>;
        getProperty(value: string): any;
        invalidateViews(districtOperation?: IDistrictOperation): void;
        invalidate(): void;
        clone(): IDashboard;
    }
    
//---------------------------------------------------------------------------

    const _sitesTable = Symbol(),
        _updateContext = Symbol(),
        _clone = Symbol();

    type IZoneClusterEx = InstanceType<typeof Dashboard._ZoneCluster>;

    export interface IDashboardContextModifierOptions extends Rest.IContextModifierOptions {
        districtType: DistrictType;
    }

    class DashboardEventData implements IDashboardEventData {
        public views: boolean;
        public districting: boolean;
        
        constructor(views?: boolean) {
            this.views = views;
        }
        
        public concat(d: DashboardEventData): DashboardEventData {
            !d.views && (this.views = false);
            !d.districting && (this.districting = false);
            return this;
        }
    }

    class Dashboard extends Tools.EventSink<IDashboard, IDashboardEventData> implements IDashboard {
        public branch: string;
        public readonly descriptor: IDashboardDescriptor;
        public readonly zones: IZone[];
        public readonly views: IView[];
        public readonly reportTemplates: IReportTemplate[];
        public readonly requestBuilder: Rest.RequestBuilder<IDashboardContextData>;
        public mainCluster: IZoneCluster;
        public readonly clusters: IZoneClusterEx[];
        public readonly reaffectStorages: IReaffectStorages;
        protected _content: IDashboardContent;
        protected _properties: IDashboardProperties;

        public static _ZoneCluster = class {
            protected _dataCreation: Rest.DataResource<Rest.DataCreator>;
            protected _current: string | number;
            public [_sitesTable]: ISitesTable;
            public readonly id: string;
            public readonly dashboard: Dashboard;
            public zones: IZone[];

            constructor(id: string, dashboard: Dashboard) {
                this.id = id;
                this.dashboard = dashboard;
                this.zones = [];
            }

            public set current(value: string | number) {
                delete this[_sitesTable];
                this._dataCreation && this._dataCreation.release();
                this._current = value;
                this.dashboard._onSiteChange(this.zones);
            }
            
            public get current(): string | number {
                return this._current;
            }
            
            public setSite(point: GeoJSON.Point): void {
                let dataCreation: Data.IDataCreation;
                let codeColumn: string, nameColumn: string;

                let bk: Data.DBColumn = new Data.DBColumn(codeColumn = nameColumn = 'bookmark', AFC.Data.DataKind.integer, 0, 4);
                let geometry: Data.DBColumn = new Data.DBColumn('geometry', AFC.Data.DataKind.point, -1);

                dataCreation = new Data.EmbeddedCreation([bk, geometry], [codeColumn], [[this._current = 1, point]]);
                (this._dataCreation || (this._dataCreation = new Rest.DataResource())).create(this.dashboard.requestBuilder, dataCreation);
                this[_sitesTable] = {
                    table: this._dataCreation.id,
                    codecolumn: codeColumn,
                    namecolumn: nameColumn
                };
                this.dashboard._onSiteChange(this.zones);
            }
            
            public [_updateContext](data: IDashboardContextDataBase): void {
                let current = this.current;
                (current !== void 0) && (data.sites || (data.sites = [])).push({zone: this.zones[0].id, site: current});
            }
            
            public [_clone](dashboard: Dashboard): IZoneClusterEx {
                let clone = new Dashboard._ZoneCluster(this.id, dashboard);
                this[_sitesTable] && (clone[_sitesTable] = this[_sitesTable]);
                this._dataCreation && (clone._dataCreation = this._dataCreation.clone(dashboard.requestBuilder));
                this._current && (clone._current = this._current);
                return clone;
            }
        }

        constructor(descriptor: IDashboardDescriptor, content: IDashboardContent, branch: string, builder?: Rest.RequestBuilder) {
            super();
            this.branch = branch;
            this.descriptor = descriptor;
            this._content = content;
            this.zones = [];
            this.views = [];
            this.reportTemplates = [];
            this.clusters = [];
            this.reaffectStorages = reaffectStorages(this);
            this.requestBuilder = builder || new Rest.RequestBuilder(descriptor.restModel);
            this.on(Tools.EventType.Attach, this._onAttach, this);
        }
        
        protected _onAttach(event: Tools.IEvent<this, IDashboardEventData>): void {
            this.fireEvent(Tools.EventType.Dirty, event?.data);
        }

        protected _onSiteChange(zones: IZone[]): void {
            zones && zones.forEach(zone => {zone.invalidate(true);});
            this.invalidateViews();
        }

        public get id(): string {
            return this.descriptor.id;
        }

        public get name(): string {
            return this.descriptor.name;
        }

        public get properties(): IDashboardProperties {
            return this._properties || (this._properties = propertiesLookup(this.descriptor.properties));
        }

        public get viewsProperties(): Readonly<IViewsProperties> {
            return this._content.viewsProperties;
        }

        public init(): this {
            let clusters: {[key: string]: IZoneClusterEx;} = {};
            this._content.zones.forEach(descriptor => {
                let cluster = clusters[descriptor.cluster] || (this.clusters.push(clusters[descriptor.cluster] = new Dashboard._ZoneCluster(descriptor.cluster, this)), clusters[descriptor.cluster]),
                    item = zone(this, descriptor, <IZoneCluster>cluster);
                cluster.zones.push(item);
                this.zones.push(item);
            });
            this._content.views.forEach(descriptor => {
                this.views.push(view(this, descriptor));
            });
            this._content.reportTemplates.forEach(descriptor => {
                this.reportTemplates.push(reportTemplate(this, descriptor));
            });
            
            this.mainCluster = clusters[this._content.mainCluster];
            return this;
        }
        
        public get site(): string|number {
            return this.mainCluster.current;
        }

        private async _apply(data: IDashboardContextDataBase & Rest.ICreationContext, modifierOptions?: IDashboardContextModifierOptions): Promise<IGlobalDashboardContextData> {
            let reaffectStorages: ReadonlyArray<IReaffectStorage>;
            
            await this.requestBuilder.load(modifierOptions);
            this.clusters.forEach(cluster => cluster[_updateContext](data));
            modifierOptions || (reaffectStorages = await this.reaffectStorages.load());
            this.zones.forEach((zone, indice) => zone.updateContext(data, reaffectStorages && reaffectStorages[indice], (<InstanceType<typeof Dashboard._ZoneCluster>>zone.cluster)[_sitesTable]));
            return this.requestBuilder.updateBody(data, modifierOptions);
        }

        public async getContextDashboard(): Promise<IGlobalDashboardContextData> {
            return this._apply(<IDashboardContextDataBase>{id: this.id});
        }

        public createRequest<T extends IDashboardContextData = IDashboardContextData>(path?: string, options?: Rest.IRestRequestOptions, districtType?: DistrictType): [number, Promise<Rest.IAjaxRequest<T>>] {
            let descriptor = this.descriptor,
                request: Rest.IAjaxRequest<T> = descriptor.restModel.createAjaxRequest<T>(`/dashboards/${descriptor.id}${path}`, false, options),
                modifierOptions = districtType !== void 0 && districtType !== DistrictType.full && {districtType: districtType};
                
            return [request.sequence, this._apply(request.options.data, modifierOptions).then(() => request)];
        }
        
        public clone(branch: string = this.branch): Dashboard {
            let clone: Dashboard = Reflect.construct(Dashboard, [this.descriptor, this._content, branch, this.requestBuilder.clone()], this.constructor),
                clusters: {[key: string]: IZoneClusterEx} = {};
                
            this.clusters.forEach(cluster => clone.clusters.push(clusters[cluster.id] = cluster[_clone](clone)));
            this.zones.forEach(zone => {
                let descriptor: IZoneDescriptor = zone.reference,
                    cluster = clusters[descriptor.cluster],
                    item = zone.clone(clone, cluster);
                cluster.zones.push(item);
                clone.zones.push(item);
            });
            this.views.forEach(view => {
                clone.views.push(view.clone(clone));
            });
            this.reportTemplates.forEach(reportTemplate => {
                clone.reportTemplates.push(reportTemplate.clone(clone));
            });
            
            clone.mainCluster = clusters[this._content.mainCluster];
            clone._properties = this._properties;
            return clone;
        }
        
        public getProperty(value: string): any {
            return this.descriptor.getProperty(value);
        }
        
        public invalidateReportTemplates(): void {
            this.reportTemplates && this.reportTemplates.forEach(reportTemplate => {reportTemplate.invalidate();});
        }

        public invalidateViews(districtOperation?: IDistrictOperation): void {
            if (this.views)  {
                let eventData = new DashboardEventData(true);
                districtOperation && (eventData.districting = districtOperation.type !== OperationType.reset);
                this.views.forEach(view => view.invalidate());
                this.fireEvent(Tools.EventType.Attach, eventData);
            }
        }

        public invalidate(): void {
            this.zones && this.zones.forEach(zone => zone.invalidate(true));
            this.invalidateViews();
            this.invalidateReportTemplates();
        }        
    }

    export async function dashboard(descriptor: IDashboardDescriptor, branch?: string): Promise<IDashboard> {
        const content = await descriptor.getContent();
        return content && (new Dashboard(descriptor, content, branch)).init();
    }

    export async function getDashboard(restModel: Rest.RestModel, id?: string, branch?: string): Promise<IDashboard> {
        const descriptors = await restModel.dashboardsDescriptor.getDashboards();
        let descriptor: IDashboardDescriptor = id !== void 0 ? Tools.findByIdOrName(id, descriptors) : descriptors[0];
        return descriptor && dashboard(descriptor, branch);
    }

    export async function getDashboards(restModel: Rest.RestModel, branch?: string): Promise<ReadonlyArray<IDashboard>> {
        const descriptors = await restModel.dashboardsDescriptor.getDashboards();
        return Promise.all(descriptors.map(descriptor => descriptor && dashboard(descriptor, branch)));
    }
};