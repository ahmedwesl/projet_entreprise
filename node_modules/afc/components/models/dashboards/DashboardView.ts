/**
 * Created by jean.rennes on 12/10/2015.
 */
///<reference path="Dashboard.ts" />
///<reference path="DashboardViewDescriptor.ts" />

namespace AFC.Dashboards {
    export interface IView {
        readonly dashboard: IDashboard;
        readonly id: string;
        readonly name: string;
        readonly type: ViewType;
        readonly descriptor: IViewDescriptor;
        readonly properties: ReadonlyArray<Dashboards.IDashboardProperty>;
        readonly getLegendInfo?: ()=> Promise<Globals.ILegendInfo>;
        createRequest<T2>(path?: string, options?: Rest.IRestRequestOptions): [number, Promise<Rest.IAjaxRequest<T2>>];
        getLegend(width: number, height: number, horizontal?: boolean, quality?: number): Promise<string>;
        invalidate(): void;
        clone(dashboard: IDashboard): IView;
    }
    
    export interface IReportTemplate {
        readonly dashboard: IDashboard;
        readonly descriptor: IReportTemplateDescriptor;
        createRequest<T2>(path?: string, options?: Rest.IRestRequestOptions): [number, Promise<Rest.IAjaxRequest<T2>>];
        invalidate(): void;
        clone(dashboard: IDashboard): IReportTemplate;
    }

    const enum EventType {
        chart = Tools.EventType.UserEvent + 1,
        grid,
        layer,
        report,
        data
    }

    interface IImageRequestOptions {
        path?: string;
        format?: Rest.RestFormat.jpeg | Rest.RestFormat.png4 | Rest.RestFormat.png8 | Rest.RestFormat.png24 | Rest.RestFormat.png32 | Rest.RestFormat.gif | Rest.RestFormat.bmp | Rest.RestFormat.tiff;
        quality?: number;
        
        // report only
        page?: number;
        
        // legend only
        horizontal?: boolean;
    }
    
    const _makeKey = (width: number, height: number, options: IImageRequestOptions) => `${width}|${height}|${options.format}|${options.page||options.horizontal||''}|${options.quality||''}`

    class Image {
        public readonly stamp: number;
        public readonly onAlways: (sequence: number, jqXHR: JQueryXHR, textStatus: string) => void;
        private _handles: ((data: string)=> any)[];
        private _data: string;
        
        constructor(stamp: number) {
            this.stamp = stamp;
            this._handles = [];
            this.onAlways = (sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                let data: string,
                    indice: number = 1;

                if (jqXHR.status === 200) {
                    data = this._data = jqXHR.responseText;
                    indice = 0;
                }
                this._handles.forEach(handle => handle(data));
                delete this._handles;
            };
        }
        
        public getData(): Promise<string> {
            return this._handles ? new Promise(resolve => this._handles.push(resolve)) : Promise.resolve(this._data);
        }
    }

    const maxCacheLength: number = 3;
    
    class ImageCache {
        public counter: number = 0;
        public remove: number = -maxCacheLength;
        public readonly dataSet: { [key: string]: Image; } = {};
        
        public get(key: string): Image {
            return this.dataSet[key];
        }
        
        public create(key: string): Image {
            let remove = ++this.remove;
            if (remove >= 0) {
                for (let key in this.dataSet) {
                    if (this.dataSet[key].stamp === remove) {
                        delete this.dataSet[key];
                        break;
                    }
                }
            }
            return this.dataSet[key] = new Image(this.counter++);
        }
    }
    
    class View<D extends IViewDescriptor> extends Tools.EventSink implements IView {
        protected _cache: ImageCache;
        public readonly dashboard: IDashboard;
        public readonly descriptor: D;

        constructor(dashboard: IDashboard, descriptor: D) {
            super();
            this.dashboard = dashboard;
            this.descriptor = descriptor;
        }

        protected async _requestImage(cache: ImageCache, width: number, height: number, opt?: IImageRequestOptions): Promise<string> {
            if (!width || !height) {
                return Tools.Style.transparent1Pixel.substr(22);
            }

            let options = $.extend({format: Rest.RestFormat.png24}, opt),
                key = _makeKey(width, height, options),
                image = cache.get(key);

            if (!image) {
                let request: Rest.IAjaxRequest<{
                        width: number;
                        height: number;
                        quality: number;
                        page: number;
                        horizontal: boolean;
                    }>,
                    promise = this.createRequest(options.path, {format: options.format});
                    
                image = cache.create(key);
                request = await promise[1];
                request.options.always = image.onAlways;
                request.options.encoding = 'base64';
                request.options.data.width = width;
                request.options.data.height = height;
                options.quality && (request.options.data.quality = options.quality);
                options.page && (request.options.data.page = options.page);
                options.horizontal && (request.options.data.horizontal = options.horizontal);
                request.call();
            }
            return image.getData();
        }
                                
        public get id(): string {
            return this.descriptor.id;
        }
        
        public get name(): string {
            return this.descriptor.name;            
        }
        
        public get type(): ViewType {
            return this.descriptor.type;
        }
        
        public get properties(): ReadonlyArray<Dashboards.IDashboardProperty> {
            return this.descriptor.properties;
        }
        
        public createRequest<T2 = any>(path: string = '', options?: Rest.IRestRequestOptions): [number, Promise<Rest.IAjaxRequest<T2>>] {
            return this.dashboard.createRequest<T2>(`/views/${this.id}${path}`, options);
        }

        public getLegend(width: number, height: number, horizontal?: boolean, quality?: number): Promise<string> {
            return this._requestImage(this._cache || (this._cache = new ImageCache()), width, height, {path: '/legend', horizontal: horizontal, quality: quality});
        }

        public invalidate(): void {
            delete this._cache;
        }
        
        public clone(dashboard: IDashboard): View<D> {
            return Reflect.construct(View, [dashboard, this.descriptor], this.constructor);
        }
    }
    
    class ReportTemplate extends Tools.EventSink implements IReportTemplate {
        public readonly dashboard: IDashboard;
        public readonly descriptor: IReportTemplateDescriptor;

        constructor(dashboard: IDashboard, descriptor: IReportTemplateDescriptor) {
            super();
            this.dashboard = dashboard;
            this.descriptor = descriptor;
        }

        public get id(): string {
            return this.descriptor.id;
        }
        
        public get name(): string {
            return this.descriptor.name;            
        }
        
        public createRequest<T2 = any>(path: string = '', options?: Rest.IRestRequestOptions): [number, Promise<Rest.IAjaxRequest<T2>>] {
            return this.dashboard.createRequest<T2>(`/templates/${this.id}${path}`, options);
        }

        public getRequest<T2 = any>(options?: IReportRequestOptions): Promise<Rest.IAjaxRequest<T2>> {
            let promise = this.createRequest<T2>(void 0, options);
            return promise[1];
        }
        
        public invalidate(): void {
        }
        
        public clone(dashboard: IDashboard): ReportTemplate {
            return Reflect.construct(ReportTemplate, [dashboard, this.descriptor], this.constructor);
        }
    }
    
    const _cache = Symbol();
    
    function imageMixin<D extends IViewDescriptor, T2 extends Tools.Constructor<View<D>> = Tools.Constructor<View<D>>>(Base: T2) {
        return class extends Base {
            private [_cache]: ImageCache;

            public getImage(width: number, height: number, quality?: number): Promise<string> {
                return this._requestImage(this[_cache] || (this[_cache] = new ImageCache()), width, height, {quality: quality});
            }
            
            public invalidate(): void {
                delete this[_cache];
                super.invalidate();
            }
        };
    }
    
    export interface ILayer {
        readonly descriptor: IMapLayerDescriptor;
        readonly dataModel: Data.DataModel;
        readonly thematics: Globals.ILayerLegendData;
    }
    
    interface ILayerContent extends Mutable<ILayer>  {
        _sequence: number;
        _loaded: boolean;
    }    

    export interface IMapView extends IView {
        readonly descriptor: IMapDescriptor;
        getLayer(indice: number): Promise<ILayer>;
        getImage(width: number, height: number, quality?: number): Promise<string>;
        getBbox(): Promise<Tools.Geometry.Rectangle>;
    }
    
    const ImageView = imageMixin(View);
     
    class MapView extends ImageView<IMapDescriptor> implements IMapView {
        protected _layers: ILayerContent[];
        protected _sequence: number;
        protected _bbox: Tools.Geometry.Rectangle;
        
        protected _onAlways(indice: number, layer: ILayerContent, sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            if (layer._sequence === sequence) {
                let data: Globals.IMapLayerData = jqXHR.responseJSON,
                    dataTable: Data.IDataTable;
                    
                layer._loaded = true;
                if (data) {
                    dataTable = AFC.Data.updateTableData(data.table);
                    dataTable && (layer.dataModel = new Data.DataModel(dataTable.columns, dataTable.primaryKey, dataTable.values));
                    data.legend && (layer.thematics = data.legend);
                }
                this.fireEvent(<any> EventType.layer + indice);
            }    
        }

        protected _loadMetadata(indice: number, layer: ILayerContent): Promise<void> {
            return this.descriptor.getLayer(indice).then((descriptor: IMapLayerDescriptor) => {
                layer.descriptor = descriptor;
            });
        }
                
        protected _loadLayer(indice: number, layer: ILayerContent): Promise<void> {
            return new Promise(async (resolve: ()=> void) => {
                this.notify(<any> EventType.layer + indice, (/*event: Tools.IEvent*/) => resolve());
                if (!layer._sequence) {
                    let promise = this.createRequest(`/layers/${indice}`),
                        request;
                    
                    layer._sequence = promise[0];
                    request = await promise[1];
                    request.options.always = this._onAlways.bind(this, indice, layer);
                    request.options.fail = ()=> false;
                    request.call();
                }
            });            
        }
        
        public getLayer(indice: number): Promise<ILayer> {
            let layer: ILayerContent = (this._layers || (this._layers = []))[indice] || (this._layers[indice] = <any>{}), promises: Promise<any>[] = [];
            
            layer.descriptor || promises.push(this._loadMetadata(indice, layer));
            layer._loaded || promises.push(this._loadLayer(indice, layer));
            return Promise.all(promises).then((/*value: any*/) => layer);
        }
        
        public getBbox(): Promise<Tools.Geometry.Rectangle> {
            return this._bbox ? Promise.resolve(this._bbox): new Promise(async resolve => {
                this.notify(<any>EventType.data, (/*event: Tools.IEvent*/)=> resolve(this._bbox));
                if (!this._sequence) {
                    let promise = this.createRequest('/content'),
                        request;
                    
                    this._sequence = promise[0];
                    request = await promise[1];
                    request.options.always = (sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                        if (this._sequence === sequence) {
                            this.fireEvent(<any>EventType.data);
                            this._bbox = jqXHR.responseJSON.bbox;
                        }
                    };
                    request.call();
                };
            });            
        }
        
        public invalidate(): void {
            super.invalidate();
            delete this._sequence;
            delete this._bbox;
            if (this._layers) {
                this._layers.forEach(layer => (delete layer._sequence, delete layer._loaded));
                delete this._layers;
            }
        }
        
        public clone(dashboard: IDashboard): MapView {
            let clone = <MapView> super.clone(dashboard);
            this._layers && (clone._layers = this._layers);
            return clone;
        }        
    }

    interface ViewDescriptorForViewType {
        [key: number]: IViewDescriptor;
        [ViewType.map]: IMapDescriptor;
        [ViewType.detailedSheet]: IDetailedSheetDescriptor;
        [ViewType.aggregatedSheet]: IAggregatedSheetDescriptor;
        [ViewType.chart]: IChartDescriptor;
        [ViewType.spreadSheet]: ISpreadSheetDescriptor;
        [ViewType.detailedChart]: IChartDescriptor;
        [ViewType.report]: IReportDescriptor;
    }
    
    interface GridDataForGridType {
        [ViewType.detailedSheet]: Globals.IDetailData;
        [ViewType.aggregatedSheet]: Globals.IDataSheet;
        [ViewType.spreadSheet]: Globals.IDataSheet;
    }
    
    export interface IGrid<T extends keyof GridDataForGridType = any> extends IView {
        getGridData(): Promise<IGridData|void>;
        getData(): Promise<Readonly<GridDataForGridType[T]>>;
        getRequest<T2 = any>(options?: IReportRequestOptions): Promise<Rest.IAjaxRequest<T2>>;
    }
    
    export interface ISheet<T extends keyof SheetMetadataForGridType = any> extends IGrid<T> {
        getMetadata(): Promise<Readonly<SheetMetadataForGridType[T]>>;
    }
    
    class Sheet<T extends keyof SheetMetadataForGridType> extends View<ViewDescriptorForViewType[T]> implements ISheet<T> {
        protected _sequence: number;
        protected _data: GridDataForGridType[T];
        protected _gridSequence: number;
        protected _gridData: IGridData;

        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): boolean {
            if (this._gridSequence === sequence) {
                this.fireEvent(<any>EventType.grid);
                return !!(this._gridData = convertSheetInfo(<IGridData>jqXHR.responseJSON));
            }
        }
        
        protected _bind(info: any): GridDataForGridType[T] {
            return convertSheetInfo(info);
        }
        
        public getMetadata(): Promise<Readonly<SheetMetadataForGridType[T]>> {
            return <Promise<Readonly<SheetMetadataForGridType[T]>>>this.descriptor.getMetadata();
        }
        
        public getData(): Promise<Readonly<GridDataForGridType[T]>> {
            return this._data ? Promise.resolve(this._data): new Promise(async resolve => {
                this.notify(<any>EventType.data, (/*event: Tools.IEvent*/)=> resolve(<GridDataForGridType[T]>this._data));
                if (!this._sequence) {
                    let promise = this.createRequest('/content'),
                        request;
                    
                    this._sequence = promise[0];
                    request = await promise[1];
                    request.options.always = (sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                        if (this._sequence === sequence) {
                            this.fireEvent(<any>EventType.data);
                            this._data = this._bind(jqXHR.responseJSON);
                        }
                    };
                    request.call();
                };
            });
        }
        
        public getGridData(): Promise<IGridData> {
            return this._gridData ? Promise.resolve(this._gridData): new Promise(async resolve => {
                this.notify(<any>EventType.grid, (/*event: Tools.IEvent*/)=> resolve(this._gridData));
                if (!this._gridSequence) {
                    let promise = this.createRequest<{svg: number;}>(),
                        request;
                    
                    this._gridSequence = promise[0];
                    request = await promise[1];
                    request.options.data.svg = 1;
                    request.options.always = this._onAlways.bind(this);
                    request.call();
                };
            });
        }

        public invalidate(): void {
            super.invalidate();
            delete this._gridData;
            delete this._gridSequence;
            delete this._data;
            delete this._sequence;
        }
        
        public clone(dashboard: IDashboard): Sheet<T> {
            let clone = <Sheet<T>> super.clone(dashboard);
            this._gridData && (clone._gridData = this._gridData);
            return clone;
        }    
        
        public getRequest<T2 = any>(options?: IReportRequestOptions): Promise<Rest.IAjaxRequest<T2>> {
            let promise = this.createRequest<T2>('/content', options);
            return promise[1];
        }
    }

    export interface IAggregatedSheet extends IGrid<ViewType.aggregatedSheet> {
        readonly descriptor: IAggregatedSheetDescriptor;
    }
    
    export interface IDetailedSheet extends ISheet<ViewType.detailedSheet> {
        readonly descriptor: IDetailedSheetDescriptor;
        readonly sortable: boolean;
        getSortedColumns(): Promise<Globals.ISortedColumn[]>;
    }
   
    class DetailedSheet extends Sheet<ViewType.detailedSheet> implements IDetailedSheet {
        protected _sortedColumns: Globals.ISortedColumn[];
        public readonly sortable: boolean = true;
        
        protected _bind(info: {
                table: Parameters<typeof AFC.Data.updateTableData>[0];
                thematic: Globals.IThematicData;
                }): GridDataForGridType[ViewType.detailedSheet] {
            let dataTable: Data.IDataTable = info && AFC.Data.updateTableData(info.table),
                data: Partial<Globals.IDetailData> = {};
                
            dataTable && (data.dataModel = new Data.DataModelBase(dataTable.columns, dataTable.primaryKey, dataTable.values));
            info.thematic && (data.thematic = info.thematic);
            return <Globals.IDetailData>data;
        }
        
        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): boolean {
            let ret = super._onAlways(sequence, jqXHR, textStatus),
                columnHeaders = ret && this._gridData.columnHeaders;
            if (columnHeaders) {
                columnHeaders.items.forEach((cell: Mutable<IGridColumnHeader>) => cell.type = Data.dataKind(<string><any>cell.type));
                columnHeaders.ordering && !this._sortedColumns && (this._sortedColumns = columnHeaders.ordering.reduceRight((accumulator, order) => (accumulator.push({name: columnHeaders.items[order.index].name, descending: order.descending}),accumulator), []));
            }
            return ret;
        }
                
        public async getSortedColumns(): Promise<Globals.ISortedColumn[]> {
            return this._sortedColumns || this.getMetadata().then(metadata => this._sortedColumns = metadata.sheetProperties.sortColumns?.map(column => ({name: column.column, descending: column.orientation === Globals.SortOrientation.descending})).reverse()||[]);
        }
        
        public clone(dashboard: IDashboard): DetailedSheet {
            let clone = <DetailedSheet> super.clone(dashboard);
            this._sortedColumns && (clone._sortedColumns = this._sortedColumns);
            return clone;
        }
    }

    export interface IChart extends IView {
        readonly descriptor: IChartDescriptor;
        getImage(width: number, height: number, quality?: number): Promise<string>;
        getChartData(): Promise<Globals.IChartModel>;
    }

    function chartMixin<D extends IChartDescriptor | ISpreadSheetDescriptor>() {
        function _convertPie(chartModel: Globals.IChartModel<Globals.ChartType.pie> | Globals.IChartModel<Globals.ChartType.doughnut>): Globals.IThematicValue[] {
            return chartModel.chartProperties.parts && chartModel.chartProperties.parts.map(part => ({
                value: part.fillColor,
                pattern: part.name
            }));
        }
        function _convertBar(chartModel: Globals.IChartModel<Globals.ChartType.barHorizontal>|Globals.IChartModel<Globals.ChartType.bar>): Globals.IThematicValue[] {
            return chartModel.chartProperties.series && chartModel.chartProperties.series.map(serie => ({
                value: serie.bar.color,
                pattern: serie.name
            }));
        }
        function _convertRadar(chartModel: Globals.IChartModel<Globals.ChartType.radar>): Globals.IThematicValue[] {
            return chartModel.chartProperties.series && chartModel.chartProperties.series.map(serie => ({
                value: serie.line.color,
                pattern: serie.name
            }));
        }
        const _sequence = Symbol(),
            _data = Symbol(),
            _onAlways = Symbol(),
            _converters: {[key: number]: (chartModel: Globals.IChartModel)=> Globals.IThematicValue[]} = {
                [Globals.ChartType.pie]: (chartModel: Globals.IChartModel<Globals.ChartType.pie>) => _convertPie(chartModel),
                [Globals.ChartType.doughnut]: (chartModel: Globals.IChartModel<Globals.ChartType.doughnut>) => _convertPie(chartModel),
                [Globals.ChartType.barHorizontal]: (chartModel: Globals.IChartModel<Globals.ChartType.barHorizontal>) => _convertBar(chartModel),
                [Globals.ChartType.bar]: (chartModel: Globals.IChartModel<Globals.ChartType.bar>) => _convertBar(chartModel),
                [Globals.ChartType.radar]: (chartModel: Globals.IChartModel<Globals.ChartType.radar>) => _convertRadar(chartModel)
            };
        
        return function <B extends Tools.Constructor<View<D>>>(Base: B) {
            class Derived extends imageMixin(Base) implements IChart {
                private [_sequence]: number;
                private [_data]: Globals.IChartModel;
               
                private [_onAlways](sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
                    if (this[_sequence] === sequence) {
                        let data: IGridData & Globals.IChartMetadata = jqXHR.responseJSON;

                        delete this[_data];
                        if (data) {
                            data.chartProperties.type = Globals.chartType(<any>data.chartProperties.type);
                            this[_data] = {
                                chartDataTransposed: data.chartDataTransposed,
                                chartProperties: data.chartProperties,
                                subtitles: {
                                    columnHeaders: data.columnHeaders.items.map(item => item.name), 
                                    rowHeaders: data.rowHeaders && data.rowHeaders.items.map(item => item.name)
                                },
                                data: data.items
                            }
                        }
                        this.fireEvent(<any>EventType.chart);
                    }
                }

                public getChartData(): Promise<Globals.IChartModel> {
                    return this[_data] ? Promise.resolve(this[_data]) : new Promise(async resolve => {
                        this.notify(<any>EventType.chart, (/*event: Tools.IEvent*/)=> resolve(this[_data]));
                        if (!this[_sequence]) {
                            let promise = this.createRequest<{metadata: boolean}>(),
                                request;

                            this[_sequence] = promise[0];
                            request = await promise[1];
                            request.options.always = this[_onAlways].bind(this);
                            request.options.data.metadata = true;
                            request.call();
                        }
                    });
                }
                
                public getLegendInfo(): Promise<Globals.ILegendInfo> {
                    return this.getChartData().then((chartModel: Globals.IChartModel) => {
                        if (chartModel) {
                            let properties = chartModel.chartProperties,
                                converter = properties && _converters[properties.type],
                                classes = converter && converter(chartModel);
                            return classes && {
                                type: Globals.LegendType.fillColor,
                                property: {
                                    thematic: {
                                        title: properties.title && properties.title.text,
                                        classes: classes
                                    }
                                }
                            };
                        }
                    });
                }

                public invalidate() {
                    delete this[_sequence];
                    delete this[_data];
                    super.invalidate();
                }

                public clone(dashboard: IDashboard): Derived {
                    let clone = <Derived> super.clone(dashboard);
                    this[_data] && (clone[_data] = this[_data]);
                    return clone;
                }
            }
            return Derived;
        };
    }
     
    const Chart = chartMixin<IChartDescriptor>()(View);
    
    export interface ISpreadSheet extends IChart, IGrid {
        readonly descriptor: ISpreadSheetDescriptor;
    }
    
    const SpreadSheet = chartMixin<ISpreadSheetDescriptor>()<Tools.Constructor<Sheet<ViewType.spreadSheet>>>(Sheet);

    interface IReportReplacement {
        id: string;
        type: Globals.ReportObjectType;
    }
    
    export interface IReportTextReplacement extends IReportReplacement {
        value: string;
    }
    
    export interface IReportGridReplacement extends IReportReplacement  {
        content: Globals.IContextSheet;
    }
    
    export interface IReportDashboardViewReplacement extends IReportReplacement  {
        renderer: RendererType;
        view: string;
    }
    
    export interface IContextReport {
        id: string;
        pageFilter?: {
            show?: string;
            hide?: string;
        },
        objects?: {
            [key: string]: {
                content: any;
            }
        }
    }
    
    export interface IReportContentData {
        readonly tokens: {
            [key: string]: string;
        }
    }
    
    export interface IReportRequestOptions extends Rest.IRestRequestOptions {
        pageFilter?: {
            show?: string;
            hide?: string;
        }
        replacements?: IReportReplacement[];
    }
    
    export interface IReport extends IView {
        readonly descriptor: IReportDescriptor;
        getImage(width: number, height: number, page: number): Promise<string>;
        getReportData(): Promise<IReportContentData>;
        getRequest<T2 = any>(options?: IReportRequestOptions): Promise<Rest.IAjaxRequest<T2>>;
    }
    
    const _replacements: {[key: number]: (item: IReportReplacement) => any } = {
        [Globals.ReportObjectType.text]: (item: IReportTextReplacement): any => ({text: item.value}),
        [Globals.ReportObjectType.grid]: (item: IReportGridReplacement): any => item.content,
        [Globals.ReportObjectType.dashboardView]: (item: IReportDashboardViewReplacement): any => ({
            renderer: rendererType(item.renderer),
            view: item.view
        })
    };
    
    class Report extends View<IReportDescriptor> implements IReport {
        protected _sequence: number;
        protected _data: IReportContentData;
        private [_cache]: ImageCache;

        public createRequest<T2 = any>(path: string = '', options?: Rest.IRestRequestOptions): [number, Promise<Rest.IAjaxRequest<T2>>] {
            return this.dashboard.createRequest<T2>(`/reports/${this.id}${path}`, options);
        }

        public getRequest<T2 = any>(options?: IReportRequestOptions): Promise<Rest.IAjaxRequest<T2>> {
            let promise = this.createRequest<T2>(void 0, options);
            return promise[1].then((request: Rest.IAjaxRequest<T2>)=> {
                let pageFilter: string;
                if (options && (pageFilter = (options.pageFilter && (options.pageFilter.show || options.pageFilter.hide))) || options.replacements) {
                    let data: IDashboardContextData = request.options.data;
                    let context = data.context || (data.context = {});
                    let reports = context.reports || (context.reports = []);
                    let report: IContextReport = {id: this.id};

                    reports.push(report);
                    if (pageFilter) {
                        report.pageFilter = options.pageFilter;
                    }
                    if (options.replacements) {
                        let replacements: {
                            [key: string]: {
                                content: any;
                            }
                        } = report.objects = {},
                        h: (item: IReportReplacement) => any;

                        for (let item of options.replacements) {
                            (h = _replacements[item.type]) && (replacements[item.id] = {content: h(item)});
                        }
                    }
                }                
                return request;
            });
        }
        
        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            if (sequence === this._sequence) {
                this._data = jqXHR.responseJSON;
                this.fireEvent(<any>EventType.report);
            }
        }
               
        public getReportData(): Promise<IReportContentData> {
            return this._data ? Promise.resolve(this._data) : new Promise(async resolve => {
                this.notify(<any>EventType.report, (/*event: Tools.IEvent*/)=> resolve(this._data));
                if (!this._sequence) {
                    let promise = this.createRequest('/content'),
                        request: Rest.IAjaxRequest;

                    this._sequence = promise[0];
                    request = await promise[1];
                    request.options.always = this._onAlways.bind(this);
                    request.call();
                }              
            });
        }
        
        public invalidate():void {
            super.invalidate();
            delete this[_cache];
            delete this._sequence;
            delete this._data;
        }
        
        public clone(dashboard: IDashboard): Report {
            let clone = <Report> super.clone(dashboard);
            this._data && (clone._data = this._data);
            return clone;
        }
        
        public getImage(width: number, height: number, page?: number, quality?: number): Promise<string> {
            return page >= 0 && this._requestImage(this[_cache] || (this[_cache] = new ImageCache()), width, height, {page: page, quality: quality});
        }
    }
    
    interface ViewForViewType {
        [ViewType.map]: IMapView;
        [ViewType.detailedSheet]: IDetailedSheet;
        [ViewType.aggregatedSheet]: IAggregatedSheet;
        [ViewType.chart]: IChart;
        [ViewType.spreadSheet]: ISpreadSheet;
        [ViewType.report]: IReport;
    }
    
    const viewFactory: {
        readonly [key in keyof ViewDescriptorForViewType]: (dashboard: IDashboard, descriptor: ViewDescriptorForViewType[key]) => ViewForViewType[key];
    } = {
        [ViewType.unknown]: (dashboard: IDashboard, descriptor: IViewDescriptor) => new View(dashboard, descriptor),
        [ViewType.map]: (dashboard: IDashboard, descriptor: IMapDescriptor) => new MapView(dashboard, descriptor),
        [ViewType.detailedSheet]: (dashboard: IDashboard, descriptor: IDetailedSheetDescriptor) => new DetailedSheet(dashboard, descriptor),
        [ViewType.aggregatedSheet]: (dashboard: IDashboard, descriptor: IAggregatedSheetDescriptor) => new Sheet<ViewType.aggregatedSheet>(dashboard, descriptor),
        [ViewType.chart]: (dashboard: IDashboard, descriptor: IChartDescriptor) => new Chart(dashboard, descriptor),
        [ViewType.spreadSheet]: (dashboard: IDashboard, descriptor: ISpreadSheetDescriptor) => new SpreadSheet(dashboard, descriptor),
        [ViewType.detailedChart]: (dashboard: IDashboard, descriptor: IChartDescriptor) => new Chart(dashboard, descriptor),
        [ViewType.report]: (dashboard: IDashboard, descriptor: IReportDescriptor) => new Report(dashboard, descriptor)
    };

    export function view<T extends keyof ViewDescriptorForViewType = any>(dashboard: IDashboard, descriptor: ViewDescriptorForViewType[T]): ViewForViewType[T] {
        let h = <(dashboard: IDashboard, descriptor: ViewDescriptorForViewType[T]) => ViewForViewType[T]>viewFactory[descriptor.type];
        return h && h(dashboard, descriptor);
    }
    
     export function reportTemplate(dashboard: IDashboard, descriptor: IReportTemplateDescriptor): IReportTemplate {
        return new ReportTemplate(dashboard, descriptor);
    }
}