/**
 * Created by jean.rennes on 16/04/2019.
 */
///<reference path="Global.ts" />

namespace AFC.Dashboards {
    export const enum ZoneType {
        unknown,
        radius,
        isodistance,
        isochrone,
        predefined,
        administrative,
        selection,
        dynamicMarket,
        surrounding,
        bulkMail,
        subset,
        subsetUnion,
        outOfZone
    }

    
    enum ZoneTypeLookup {
        asteropDashboardRadiusZone = ZoneType.radius,
        asteropDashboardIsodistanceZone = ZoneType.isodistance,
        asteropDashboardIsochroneZone = ZoneType.isochrone,
        asteropDashboardPrefinedZone = ZoneType.predefined,
        asteropDashboardAdministrativeZone = ZoneType.administrative,
        asteropDashboardSelectionZone = ZoneType.selection,
        asteropDashboardDynamicMarketZone = ZoneType.dynamicMarket,
        asteropDashboardSurroundingZone = ZoneType.surrounding,
        asteropDashboardBulkMailZone = ZoneType.bulkMail,
        asteropDashboardSubset = ZoneType.subset,
        asteropDashboardSubsetUnion = ZoneType.subsetUnion,
        asteropDashboardOutOfZone = ZoneType.outOfZone
    };

    abstract class ZoneBaseDescriptor<T extends ZoneType> implements IZoneBaseDescriptor<T> {
        public readonly id: string;
        public readonly name: string;        
        public readonly type: T;

        constructor(data: IZoneBaseData) {
            this.id = data.id || '';
            this.name = data.name;
            this.type = (<any>ZoneTypeLookup)[data.type];
        }
    }
    
    class ZoneDescriptor<T extends ZoneType.unknown | ZoneType.radius | ZoneType.isodistance | ZoneType.isochrone | ZoneType.predefined | ZoneType.administrative | ZoneType.selection | ZoneType.dynamicMarket | ZoneType.surrounding | ZoneType.bulkMail> extends ZoneBaseDescriptor<T> implements IZoneDescriptor<T> {
        public readonly properties: ReadonlyArray<IDashboardProperty>;
        public readonly geographicalLevels: IGeographicalLevels;
        public readonly dashboard: IDashboardDescriptor;
        public readonly cluster: string;
        public readonly sites: {
            columns: ReadonlyArray<Data.IDBColumn>;
        };
        public readonly dataNodes: IDataNode[];
        public readonly hasCannibalization: boolean;

        constructor(dashboard: IDashboardDescriptor, data: IZoneData) {
            super(data);
            this.properties = data.properties;
            this.geographicalLevels = data.geographicalLevels;
            this.dashboard = dashboard;
            this.cluster = data.cluster;
            data.sites?.columns && (this.sites = {
                columns: Data.mapDataColumns(data.sites)
            });
            this.dataNodes = data.dataNodes;
            !data.noCannibalization && (this.hasCannibalization = true);
        }
        
        public static buildData(configuration: Partial<IZoneConfiguration>): Partial<IContextZone> {
            let data: Partial<IContextZone> = {};
            configuration.type && (data.type = (<any>ZoneTypeLookup)[configuration.type]);
            configuration.geographicalLevels && (data.geographicalLevels = configuration.geographicalLevels);
            configuration.properties && (data.properties = configuration.properties);
            return data;
        }

        public createRequest<T2 = any>(path: string = ''): Rest.IAjaxRequest<T2> {
            return this.dashboard.createRequest<T2>(`/zones/${this.id}${path}`);
        }
    }

//---------------------------------------------------------------------------

    interface IZonePartitionData {
        readonly id: string;
        readonly name: string;
        readonly subsets: ReadonlyArray<IZoneSubsetData>;
        readonly districtingTable: string;
        readonly districtingMode: string;
    }

//---------------------------------------------------------------------------

    interface IRadiusAreaData extends IZoneData {
        sitesTable: ISitesTable;
        bounds: readonly number[];
        outOfZoneExtraBound: number;
        unit: string;
        useCentroid: boolean;
        forceSurroundingToZero: boolean;
        perSiteConfiguration: string;
        readonly partition: IZonePartitionData;
    }

    class RadiusAreaDescriptor extends ZoneDescriptor<ZoneType.radius> implements IRadiusAreaDescriptor {
        public readonly sitesTable: ISitesTable;
        public readonly bounds: readonly number[];
        public readonly outOfZoneExtraBound: number;
        public readonly unit: TradeArea.LengthUnit;
        public readonly useCentroid: boolean;
        public readonly forceSurroundingToZero: boolean;
        public readonly perSiteConfiguration: string;
        public readonly partition: ZonePartition;

        constructor(dashboard: IDashboardDescriptor, data: IRadiusAreaData) {
            super(dashboard, data);
            this.sitesTable = data.sitesTable;
            this.bounds = data.bounds;
            this.outOfZoneExtraBound = data.outOfZoneExtraBound;
            this.unit = TradeArea.lengthUnit(data.unit);
            this.useCentroid = !!data.useCentroid;
            this.forceSurroundingToZero = !!data.forceSurroundingToZero;
            data.perSiteConfiguration && (this.perSiteConfiguration = data.perSiteConfiguration);
            data.partition && (this.partition = new ZonePartition(data.partition));
        }

        public static buildData(configuration: Partial<IRadiusAreaConfiguration>): Partial<IContextRadius> {
            let data: Partial<IContextRadius> = ZoneDescriptor.buildData(configuration);
            configuration.sitesTable && (data.sitesTable = configuration.sitesTable);
            configuration.bounds && (data.bounds = configuration.bounds);
            (configuration.outOfZoneExtraBound !== void 0) && (data.outOfZoneExtraBound = configuration.outOfZoneExtraBound);
            (configuration.unit !== void 0) && (data.unit = <string>TradeArea.lengthUnit(configuration.unit));
            (configuration.useCentroid !== void 0) && (data.useCentroid = configuration.useCentroid);
            (configuration.forceSurroundingToZero !== void 0) && (data.forceSurroundingToZero = configuration.forceSurroundingToZero);
            configuration.perSiteConfiguration && (data.perSiteConfiguration = configuration.perSiteConfiguration);
            return data;
        }
    }

//---------------------------------------------------------------------------

    interface ITravelTimeAreaData extends IZoneData {
        sitesTable: ISitesTable;
        bounds: ReadonlyArray<number>;
        outOfZoneExtraBound: number;
        modeOfTransport: string;
        anchorThreshold: number;
        mode: string;
        tollFreeOnly: boolean;
        reverseMode: boolean;
        forceSurroundingToZero: boolean;
        perSiteConfiguration: string;
        readonly partition: IZonePartitionData;
    }

//---------------------------------------------------------------------------

    abstract class TravelTimeAreaDescriptor<T extends ZoneType.isodistance | ZoneType.isochrone> extends ZoneDescriptor<T> implements ITravelTimeAreaDescriptor {
        public readonly sitesTable: ISitesTable;
        public readonly bounds: ReadonlyArray<number>;
        public readonly outOfZoneExtraBound: number;
        public readonly modeOfTransport: TradeArea.ModeOfTransport;
        public readonly anchorThreshold: number;
        public readonly mode: TradeArea.TravelMode;
        public readonly tollFreeOnly: boolean;
        public readonly reverseMode: boolean;
        public readonly forceSurroundingToZero: boolean;
        public readonly perSiteConfiguration: string;
        public readonly partition: ZonePartition;

        constructor(dashboard: IDashboardDescriptor, data: ITravelTimeAreaData) {
            super(dashboard, data);
            this.sitesTable = data.sitesTable;
            this.bounds = data.bounds;
            this.outOfZoneExtraBound = data.outOfZoneExtraBound;
            this.modeOfTransport = TradeArea.modeOfTransport(data.modeOfTransport);
            this.anchorThreshold = data.anchorThreshold;
            this.mode = (data.mode !== void 0) ? TradeArea.travelMode(data.mode) : TradeArea.TravelMode.boundary;
            this.tollFreeOnly = !!data.tollFreeOnly;
            this.reverseMode = !!data.reverseMode;
            this.forceSurroundingToZero = !!data.forceSurroundingToZero;
            data.perSiteConfiguration && (this.perSiteConfiguration = data.perSiteConfiguration);
            data.partition && (this.partition = new ZonePartition(data.partition));
        }

        public static buildData(configuration: Partial<ITravelTimeAreaConfiguration>): Partial<IContextTravelTime> {
            let data: Partial<IContextTravelTime> = ZoneDescriptor.buildData(configuration);

            configuration.sitesTable && (data.sitesTable = configuration.sitesTable);
            configuration.bounds && (data.bounds = configuration.bounds);
            (configuration.outOfZoneExtraBound !== void 0) && (data.outOfZoneExtraBound = configuration.outOfZoneExtraBound);
            (configuration.modeOfTransport !== void 0) && (data.modeOfTransport = TradeArea.modeOfTransport(configuration.modeOfTransport));
            (configuration.anchorThreshold !== void 0) && (data.anchorThreshold = configuration.anchorThreshold);
            (configuration.mode !== void 0) && (data.mode = TradeArea.travelMode(configuration.mode));
            (configuration.tollFreeOnly !== void 0) && (data.tollFreeOnly = configuration.tollFreeOnly);
            (configuration.reverseMode !== void 0) && (data.reverseMode = configuration.reverseMode);
            (configuration.forceSurroundingToZero !== void 0) && (data.forceSurroundingToZero = configuration.forceSurroundingToZero);
            configuration.perSiteConfiguration && (data.perSiteConfiguration = configuration.perSiteConfiguration);
            return data;
        }
    }

//---------------------------------------------------------------------------

    interface IIsodistanceAreaData extends ITravelTimeAreaData {
        unit: string;
    }

//---------------------------------------------------------------------------

    class IsodistanceAreaDescriptor extends TravelTimeAreaDescriptor<ZoneType.isodistance> implements IIsodistanceAreaDescriptor {
        public readonly unit: TradeArea.LengthUnit;

        constructor(dashboard: IDashboardDescriptor, data: IIsodistanceAreaData) {
            super(dashboard, data);
            this.unit = TradeArea.lengthUnit(data.unit);
        }

        public static buildData(configuration: Partial<IIsodistanceAreaConfiguration>): Partial<IContextTravelTime> {
            let data: Partial<IContextTravelTime> = TravelTimeAreaDescriptor.buildData(configuration);
            (configuration.unit !== void 0) && (data.unit = TradeArea.lengthUnit(configuration.unit));
            return data;
        }
    }

//---------------------------------------------------------------------------

    interface IIsochroneAreaData extends ITravelTimeAreaData {
        unit: string;
    }

//---------------------------------------------------------------------------

    class IsochroneAreaDescriptor extends TravelTimeAreaDescriptor<ZoneType.isochrone> implements IIsochroneAreaDescriptor {
        public readonly unit: TradeArea.TimeUnit;

        constructor(dashboard: IDashboardDescriptor, data: IIsochroneAreaData) {
            super(dashboard, data);
            this.unit = TradeArea.timeUnit(data.unit);
        }

        public static buildData(configuration: Partial<IIsochroneAreaConfiguration>): Partial<IContextTravelTime> {
            let data: Partial<IContextTravelTime> = TravelTimeAreaDescriptor.buildData(configuration);
            (configuration.unit !== void 0) && (data.unit = TradeArea.timeUnit(configuration.unit));
            return data;
        }
    }

//---------------------------------------------------------------------------

    interface IPredefinedAreaData extends IZoneData {
        sitesTable: ISitesTable;
        areaTable: string;
        siteCodeColumn: string;
        geographicalCodeColumn: string;
        partitionColumn: string;
        partition: IZonePartitionData;
    }

//---------------------------------------------------------------------------

    class PrefinedAreaDescriptor extends ZoneDescriptor<ZoneType.predefined> implements IPredefinedAreaDescriptor {
        public readonly sitesTable: ISitesTable;
        public readonly areaTable: string;
        public readonly siteCodeColumn: string;
        public readonly geographicalCodeColumn: string;
        public readonly partitionColumn: string;
        public readonly partition: ZonePartition;

        constructor(dashboard: IDashboardDescriptor, data: IPredefinedAreaData) {
            super(dashboard, data);
            this.sitesTable = data.sitesTable;
            this.areaTable = data.areaTable;
            this.siteCodeColumn = data.siteCodeColumn;
            this.geographicalCodeColumn = data.geographicalCodeColumn;
            this.partitionColumn = data.partitionColumn;
            data.partition && (this.partition = new ZonePartition(data.partition));
        }

        public static buildData(configuration: Partial<IPredefinedAreaConfiguration>): Partial<IContextPredefinedArea> {
            let data: Partial<IContextPredefinedArea> = ZoneDescriptor.buildData(configuration);

            configuration.sitesTable && (data.sitesTable = configuration.sitesTable);
            configuration.areaTable && (data.areaTable = configuration.areaTable);
            configuration.siteCodeColumn && (data.siteCodeColumn = configuration.siteCodeColumn);
            configuration.geographicalCodeColumn && (data.geographicalCodeColumn = configuration.geographicalCodeColumn);
            configuration.partitionColumn && (data.partitionColumn = configuration.partitionColumn);
            return data;
        }
    }

//---------------------------------------------------------------------------

    class AdministrativeAreaDescriptor extends ZoneDescriptor<ZoneType.administrative> implements IAdministrativeAreaDescriptor {
    }

//---------------------------------------------------------------------------

    interface ISurroundingAreaData extends IZoneData {
        sitesTable: ISitesTable;
    }

//---------------------------------------------------------------------------

    class SurroundingAreaDescriptor extends ZoneDescriptor<ZoneType.surrounding> implements ISurroundingAreaDescriptor {
        public readonly sitesTable: ISitesTable;

        constructor(dashboard: IDashboardDescriptor, data: ISurroundingAreaData) {
            super(dashboard, data);
            this.sitesTable = data.sitesTable;
        }
        
        public static buildData(configuration: Partial<ISurroundingAreaConfiguration>): Partial<IContextSurroundingArea> {
            let data: Partial<IContextSurroundingArea> = ZoneDescriptor.buildData(configuration);
            configuration.sitesTable && (data.sitesTable = configuration.sitesTable);
            return data;
        }        
    }
    
//---------------------------------------------------------------------------

    interface IBulkMailAreaData extends IZoneData {
        sitesTable: ISitesTable;
        readonly partition: IZonePartitionData;
        readonly scores: ReadonlyArray<IBulkMailAreaScore>;
        readonly target: IBulkMailAreaTarget;
    }
    
//---------------------------------------------------------------------------

    class BulkMailAreaDescriptor extends ZoneDescriptor<ZoneType.bulkMail> implements IBulkMailAreaDescriptor {
        public readonly sitesTable: ISitesTable;
        public readonly partition: ZonePartition;
        public readonly scores: ReadonlyArray<IBulkMailAreaScore>;
        public readonly target: IBulkMailAreaTarget;
        
        constructor(dashboard: IDashboardDescriptor, data: IBulkMailAreaData) {
            super(dashboard, data);
            this.sitesTable = data.sitesTable;
            data.partition && (this.partition = new ZonePartition(data.partition));
            this.scores = data.scores;
            this.target = data.target;
        }
        
        public static buildData(configuration: Partial<IBulkMailAreaConfiguration>): Partial<IContextBulkMailArea> {
            let data: Partial<IContextBulkMailArea> = ZoneDescriptor.buildData(configuration);

            configuration.sitesTable && (data.sitesTable = configuration.sitesTable);
            configuration.scores && (data.scores = configuration.scores);
            configuration.target && (data.target = configuration.target);
            return data;
        }        
    }

//---------------------------------------------------------------------------

    class SubsetDescriptor extends ZoneBaseDescriptor<ZoneType.subset | ZoneType.subsetUnion | ZoneType.outOfZone> implements ISubsetDescriptor {
        public readonly value: string;

        constructor(data: IZoneSubsetData) {
            super(data);
            this.value = data.value;
        }
    }
    
//---------------------------------------------------------------------------

    const _reaffectStorageLookup: {[key: string]: ZoneReaffectStorage} = {
        none: ZoneReaffectStorage.none,
        incremental: ZoneReaffectStorage.incremental,
        complete: ZoneReaffectStorage.complete,
        editable: ZoneReaffectStorage.editable
    }

    class ZonePartition implements IZonePartition {
        public readonly id: string;
        public readonly name: string;
        public readonly districtingTable: string;
        public readonly districtingMode: ZoneReaffectStorage;
        public readonly subsets: ReadonlyArray<SubsetDescriptor>;
        
        constructor(data: IZonePartitionData) {
            this.id = data.id;
            this.name = data.name;
            this.districtingTable = data.districtingTable;
            this.districtingMode = _reaffectStorageLookup[data.districtingMode] || (data.districtingTable ? ZoneReaffectStorage.incremental : ZoneReaffectStorage.none);
            this.subsets = data.subsets.map(data => new SubsetDescriptor(data));
        }
    }
   
//---------------------------------------------------------------------------

    interface ZoneDataForZoneType {
        [key: number]: IZoneData,
        [ZoneType.radius]: IRadiusAreaData,
        [ZoneType.isodistance]: IIsodistanceAreaData,
        [ZoneType.isochrone]: IIsochroneAreaData,
        [ZoneType.predefined]: IPredefinedAreaData,
        [ZoneType.administrative]: IZoneData,
//        [ZoneType.selection]: IZoneData,
//        [ZoneType.dynamicMarket]: IDynamicMarketAreaData,
        [ZoneType.surrounding]: ISurroundingAreaData,
        [ZoneType.bulkMail]: IBulkMailAreaData
    }
        
    export interface ZoneDescriptorForZoneType {
        [key: number]: IZoneDescriptor,
        [ZoneType.radius]: IRadiusAreaDescriptor,
        [ZoneType.isodistance]: IIsodistanceAreaDescriptor,
        [ZoneType.isochrone]: IIsochroneAreaDescriptor,
        [ZoneType.predefined]: IPredefinedAreaDescriptor,
        [ZoneType.administrative]: IAdministrativeAreaDescriptor,
//        [ZoneType.selection]: IZoneDescriptor<ZoneType.selection>,
//        [ZoneType.dynamicMarket]: IZoneDescriptor<ZoneType.dynamicMarket>,
        [ZoneType.surrounding]: ISurroundingAreaDescriptor,
        [ZoneType.bulkMail]: IBulkMailAreaDescriptor
    }


    const _factory: {
        readonly [key: string]: {
            new <T extends keyof ZoneDataForZoneType>(dashboard: IDashboardDescriptor, data: ZoneDataForZoneType[T]): ZoneDescriptorForZoneType[T];
        }
    } = {
        asteropDashboardRadiusZone: RadiusAreaDescriptor,
        asteropDashboardIsodistanceZone: IsodistanceAreaDescriptor,
        asteropDashboardIsochroneZone: IsochroneAreaDescriptor,
        asteropDashboardPrefinedZone: PrefinedAreaDescriptor,
        asteropDashboardAdministrativeZone: AdministrativeAreaDescriptor,
//        asteropDashboardSelectionZone: SelectionAreaDescriptor,
//            asteropDashboardDynamicMarketZone: DynamicMarketZoneConfiguration,
        asteropDashboardSurroundingZone: SurroundingAreaDescriptor,
        asteropDashboardBulkMailZone: BulkMailAreaDescriptor
    };

    export function zoneDescriptor<T extends keyof ZoneDataForZoneType = any>(dashboard: IDashboardDescriptor, data: ZoneDataForZoneType[T]): ZoneDescriptorForZoneType[T] {
        let ctor: {new (dashboard: IDashboardDescriptor, data: IZoneData): IZoneDescriptor} = _factory[data.type] || ZoneDescriptor;
        return new ctor(dashboard, data);
    }

//---------------------------------------------------------------------------

    const _converterFactory: {readonly [key in keyof ZoneDataForZoneType]?: (configuration: IZoneConfiguration)=> Partial<IContextZone>} = {
        [ZoneType.radius]: RadiusAreaDescriptor.buildData,
        [ZoneType.isodistance]: IsodistanceAreaDescriptor.buildData,
        [ZoneType.isochrone]: IsochroneAreaDescriptor.buildData,
        [ZoneType.predefined]: PrefinedAreaDescriptor.buildData,
        [ZoneType.administrative]: AdministrativeAreaDescriptor.buildData,
        [ZoneType.surrounding]: SurroundingAreaDescriptor.buildData,
        [ZoneType.bulkMail]: BulkMailAreaDescriptor.buildData
    };

//---------------------------------------------------------------------------

    export function buildContext(base: IZoneDescriptor, configuration: IZoneConfiguration): IContextZone {
        let data: any,
            converter0 = _converterFactory[base.type],
            converter1 = _converterFactory[configuration.type || base.type];

        if (converter0 && converter1) {
            let configuration0: Partial<IZoneConfiguration>  = Object.create(base);                                                                 // ugly trick ...
            configuration0.geographicalLevels = {detailed: base.geographicalLevels.detailed.id, aggregated: base.geographicalLevels.aggregated.id}; // to handle geographical levels
            configuration0.properties = Object.entries(base.properties).reduce((acc: {[key: string]: any}, [key, value]) => (acc[key] = value[2], acc), {}); // and properties

            let converted0: {[key: string]: any;} = converter0(configuration0),
                converted1: {[key: string]: any;} = converter1(configuration);

            for (let key in converted1) {
                if (JSON.stringify(converted1[key]) !== JSON.stringify(converted0[key])) {
                    (data || (data = {}))[key] = converted1[key];
                }
            }
        }
        return data as IContextZone;
    }
    
//---------------------------------------------------------------------------

    export class ZonePartitionDescriptor {
        public readonly id: string;
        public readonly name: string;
        public readonly districtingTable: string;
        public readonly subsets: readonly ISubsetDescriptor[];

        constructor(data: IZonePartitionData) {
            this.id = data.id;
            this.name = data.name;
            this.subsets = data.subsets.map(data=> new SubsetDescriptor(data));
            this.districtingTable = data.districtingTable;
       }
   }    
}