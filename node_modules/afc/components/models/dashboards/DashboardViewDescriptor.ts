/**
  * Created by jean.rennes on 17/04/2019.
*/
///<reference path="Global.ts" />
///<reference path="DashboardDescriptor.ts" />
///<reference path="../globals/Grid.ts" />

namespace AFC.Dashboards {
    const enum EventType {
        map = Tools.EventType.UserEvent + 1,
        chart,
        grid,
        sheet,
        report
    }

    export const enum ViewType {
        unknown = 0,
        map,
        detailedSheet,
        aggregatedSheet,
        chart,
        spreadSheet,
        detailedChart,
        report = 100
    }
    
    export const enum ChartType {
        undefined,	
        bar,
        invertedBar,
        lines,
        symbol,
        stackedBar,
        stackedInvertedBar,
        stackedLines,
        stackedSymbol,
        pie,
        pied3d,
        doughnut,
        doughnut3d,
        scatterLines,
        scatterSymbol,
        scatterString,
        boxPlot,
        bubble,
        bubbleAsymetric,
        radar,
        radarFill,
        barHorizontal,
        stackedBarHorizontal,
        linesHorizontal,
        stackedLinesHorizontal,
        symbolHorizontal,
        stackedSymbolHorizontal
    }

    export const enum SpreadSheetDisplayType {
        grid,
        chart
    }    

    export const enum LayerType {
        undefined,
        thematic,
        outline,
        symbol,
        label,
        graph
    }

    export const enum DataSourceKind {
        unknown = 1,
        zoneUnits,
        itemInfo,
        filteredTable,
        sites,
        cannibalization,
        cannibalizationSites,
        DMAImpactedSites,
        subset,
        subsetUnion,
        outOfZone,
        siteFilteredTable
    }
    
    interface IViewDataBase {
        readonly id: string;
        readonly name: string;
        readonly properties: ReadonlyArray<IDashboardProperty>;
    }

    export interface IViewData extends IViewDataBase {
        readonly type: string;
    }

    interface IMapViewData extends IViewData {
        readonly layerCount: number;
        readonly mapTemplate: string;
    }

    interface IChartData extends IViewData {
        readonly chartType: string;
    }

    interface ISpreadSheetData extends IChartData {
        readonly displayType: string;
    }

    export interface IReportData extends IViewDataBase {
    }
    
    export interface IReportTemplateDescriptor {
        readonly id: string;
        readonly name: string;
        readonly kind: string;
    }
    
    class ViewDescriptor<T extends ViewType> extends Tools.EventSink implements IViewDescriptor {
        public readonly id: string;
        public readonly name: string;
        public readonly type: T;
        public readonly properties: ReadonlyArray<IDashboardProperty>;
        public readonly dashboard: IDashboardDescriptor;
        
        constructor(dashboard: IDashboardDescriptor, type: T, data: IViewDataBase) {
            super();
            this.id = data.id;
            this.name = data.name;
            this.type = type;
            this.properties = data.properties;
            this.dashboard = dashboard;
        }

        public createRequest<T2 = any>(path: string = ''): Rest.IAjaxRequest<T2> {
            return this.dashboard.createRequest<T2>(`/views/${this.id}${path}`);
        }
    }

    const stringToMapType: {[key: string]: LayerType} = {
        ZM_MAP_LAYER_THEMATIC: LayerType.thematic,
        ZM_MAP_LAYER_OUTLINE: LayerType.outline,
        ZM_MAP_LAYER_SYMBOL: LayerType.symbol,
        ZM_MAP_LAYER_LABEL: LayerType.label
    };

    enum DataSourceKindLookup {
        unknown = DataSourceKind.unknown,
        zoneUnits = DataSourceKind.zoneUnits,
        itemInfo = DataSourceKind.itemInfo,
        filteredTable = DataSourceKind.filteredTable,
        sites = DataSourceKind.sites,
        cannibalization = DataSourceKind.cannibalization,
        cannibalizationSites = DataSourceKind.cannibalizationSites,
        DMAImpactedSites = DataSourceKind.DMAImpactedSites,
        subset = DataSourceKind.subset,
        subsetUnion = DataSourceKind.subsetUnion,
        outOfZone = DataSourceKind.outOfZone,
        siteFilteredTable = DataSourceKind.siteFilteredTable
    }
    
    export function dataSourceKind(value: string): DataSourceKind;
    export function dataSourceKind(value: DataSourceKind): string;
    export function dataSourceKind(value: DataSourceKind|string): DataSourceKind|string {
        return (<any>DataSourceKindLookup)[value];
    }

    interface ILayerData {
        readonly type: string;
        readonly zone: string;
        readonly dataSourceKind: string;
        readonly selectable: boolean;
        readonly hidden: boolean;
        readonly hiddenClasses: boolean;
        readonly zoomOnLayer: boolean;
        readonly layer: any;
        readonly dataNodes: {readonly[key: string]: Readonly<string>;};
    }
    
    export interface IMapLayerDescriptor<K extends Globals.LayerType.polygon | Globals.LayerType.line | Globals.LayerType.symbol = any> {
        readonly name: string;
        readonly type: LayerType;
        readonly zone: string;
        readonly dataSourceKind: DataSourceKind;
        readonly hiddenClasses: boolean;
        readonly zoomOnLayer: boolean;
        readonly template: Readonly<Globals.IMapVectorLayerMetaData<K>>;
        readonly dataNodes: Readonly<{[key: string]: string}>;
    }

    class LayerDescriptor implements IMapLayerDescriptor {
        protected _type: LayerType;
        public readonly zone: Readonly<string>;
        public readonly dataSourceKind: DataSourceKind;
        public readonly selectable: boolean;
        public readonly hidden: boolean;
        public readonly hiddenClasses: boolean;
        public readonly zoomOnLayer: boolean;
        public readonly template: Readonly<Globals.IMapVectorLayerMetaData>;
        public readonly dataNodes: Readonly<{readonly [key: string]: string}>;

        constructor(data: ILayerData, template: Readonly<Globals.IMapVectorLayerMetaData>) {
            this._type = stringToMapType[data.type] || LayerType.undefined;
            this.zone = data.zone;
            this.dataSourceKind = dataSourceKind(data.dataSourceKind) || DataSourceKind.unknown;
            this.selectable = data.selectable;
            this.hidden = data.hidden;
            this.hiddenClasses = data.hiddenClasses;
            this.zoomOnLayer = data.zoomOnLayer;
            this.template = template;
            this.dataNodes = data.dataNodes;
        }

        public get name(): string {
            return this.template.name;
        }

        public get type(): LayerType {
            return this._type;
        }
    }

    export interface IMapDescriptor extends IViewDescriptor {
        readonly mapTemplate: string;
        readonly layerCount: number;
        readonly type: ViewType.map;
        getLayer(indice: number): Promise<IMapLayerDescriptor>;
    }

    class MapDescriptor extends ViewDescriptor<ViewType.map> implements IMapDescriptor {
        protected _layers: LayerDescriptor[];
        protected _sequence: number;
        public readonly layerCount: number;
        public readonly mapTemplate: string;
        
        constructor(dashboard: IDashboardDescriptor, data: IMapViewData) {
            super(dashboard, ViewType.map, data);
            this.layerCount = data.layerCount;
            this.mapTemplate = data.mapTemplate;
        }

        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            if (sequence === this._sequence) {
                let layersData: readonly ILayerData[] = jqXHR.responseJSON || [];
                
                Promise.all(layersData.map(layerData => Globals.convertMapLayerMetaData<Globals.IMapVectorLayerMetaData>(layerData.layer, this.dashboard.restModel.globals)))
                    .then((results: Globals.IMapVectorLayerMetaData[]) => {
                        this._layers = layersData.map((layerData, indice) => new LayerDescriptor(layerData, results[indice]));
                        this.fireEvent(<any>EventType.map);
                    });
            }
        }
        
        public getLayer(indice: number): Promise<IMapLayerDescriptor> {
            return this._layers ? Promise.resolve(this._layers[indice]) : new Promise((resolve: (layer: IMapLayerDescriptor)=> void) => {
                this.notify(<any>EventType.map, (/*event: Tools.IEvent*/)=> resolve(this._layers[indice]));
                if (!this._sequence) {
                    let request = this.createRequest(`/layers`);
                    request.options.always = this._onAlways.bind(this);
                    request.options.fail = ()=> false;
                    this._sequence = request.call();
                }
            });
        }
    }
    
    const _sortOrientationLookup: {[key: string]: Globals.SortOrientation} = {
        none: Globals.SortOrientation.none,
        ascending: Globals.SortOrientation.ascending,
        descending: Globals.SortOrientation.descending
    };

    export interface ISheetMetadata<T extends Globals.ITemplateSheet = Globals.ITemplateSheet> {
        readonly id: Readonly<string>;
        readonly sheetProperties: Readonly<T>;
    }

    export interface IDetailedSheetMetadata extends ISheetMetadata<Globals.ITemplateDetailedSheet> {
        readonly dataSourceKind: DataSourceKind;
        readonly zone: Readonly<string>;
        readonly dataNodes: Readonly<{readonly [key: string]: string}>;
        readonly maxRowCount: number;
    }

    export interface IChartMetadata<T extends Globals.ChartType = any> extends Globals.IChartMetadata<T> {
        readonly id: Readonly<string>;
    }

    export interface ISpreadSheetMetadata<T extends Globals.ChartType = any> extends ISheetMetadata, IChartMetadata<T> {
    }

    export interface SheetMetadataForGridType {
        [ViewType.detailedSheet]: IDetailedSheetMetadata;
        [ViewType.aggregatedSheet]: ISheetMetadata;
        [ViewType.spreadSheet]: ISpreadSheetMetadata;
    }
    
    export interface ISheetDescriptor<T extends keyof SheetMetadataForGridType = keyof SheetMetadataForGridType> extends IViewDescriptor {
        getMetadata(): Promise<Readonly<SheetMetadataForGridType[T]>>;
    }
    
    interface ISheetPropertiesCell {
        renderer?: Globals.GridRenderer;
    }

    interface ISheetProperties {
        columnHeaders?: {
            items: ISheetPropertiesCell[];
        };
        items: ISheetPropertiesCell[][];
        rowHeaders?: {
            items: ISheetPropertiesCell[];
        };
    }
    
    interface ISheetInfo {
        sheetProperties: ISheetProperties;
    }
    
    function _convertCell(cell: {renderer: Globals.GridRenderer}): void;
    function _convertCell(cell: {renderer: string|Globals.GridRenderer}): void {
        cell.renderer = cell.renderer ? Globals.gridRender(<any>cell.renderer) : Globals.GridRenderer.text;
    }
    
    export function convertSheetInfo<T extends ISheetProperties>(t: T): T {
        if (t) {
            t.columnHeaders && t.columnHeaders.items.forEach(_convertCell);
            t.items.forEach(row => row.forEach(_convertCell));
            t.rowHeaders && t.rowHeaders.items.forEach(_convertCell);
            return t;
        }
    }
    
    class GridDescriptor<T extends keyof SheetMetadataForGridType> extends ViewDescriptor<T> {
        protected _sequence: number;
        protected _metadata: SheetMetadataForGridType[T];

        protected _bind(metadata: ISheetInfo | Mutable<SheetMetadataForGridType[T]>): SheetMetadataForGridType[T] {
            metadata && (metadata.sheetProperties = convertSheetInfo(metadata.sheetProperties));
            return <SheetMetadataForGridType[T]>metadata;
        }

        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            if (this._sequence === sequence) {
                this.fireEvent(<any>EventType.sheet);
                this._metadata = this._bind(jqXHR.responseJSON);
            }
        }

        public getMetadata(): Promise<Readonly<SheetMetadataForGridType[T]>> {
            return this._metadata ? Promise.resolve(this._metadata) : new Promise((resolve: (metadata: SheetMetadataForGridType[T]) => void) => {
                this.notify(<any>EventType.sheet, (/*event: Tools.IEvent*/)=> resolve(this._metadata));
                if (!this._sequence) {                
                    let request = this.createRequest<{svg: number;}>('/metadata');

                    request.options.data.svg = 1;
                    request.options.always = this._onAlways.bind(this);
                    this._sequence = request.call();
                }
            });
        }
    }
        
    export type IAggregatedSheetDescriptor = ISheetDescriptor<ViewType.aggregatedSheet>;
    
    export type IDetailedSheetDescriptor = ISheetDescriptor<ViewType.detailedSheet>;
    
    interface ISortColumnInfo {
        column: string;
        orientation: string;
    }
    
    interface IDetailedSheetInfo extends ISheetInfo {
        dataSourceKind: string;
        zone: string;
        indicators: {[key: string]: string};
        maxRowCount: number;
        sheetProperties: ISheetProperties&{
            sortColumns: ISortColumnInfo[];
        };
    }
    
    class DetailedSheetDescriptor extends GridDescriptor<ViewType.detailedSheet> implements IDetailedSheetDescriptor {
        protected _bind(metadata: IDetailedSheetInfo|Mutable<IDetailedSheetMetadata>): IDetailedSheetMetadata {
            if (metadata) {
                metadata.dataSourceKind = dataSourceKind(<string>metadata.dataSourceKind);
                metadata.sheetProperties = convertSheetInfo(metadata.sheetProperties);
                metadata.sheetProperties.sortColumns && metadata.sheetProperties.sortColumns.forEach((column: ISortColumnInfo | Mutable<Globals.ISortColumn>) => column.orientation = _sortOrientationLookup[column.orientation] || Globals.SortOrientation.none);
            }
            return <IDetailedSheetMetadata>metadata;
        }
    }     
    
    const _chartTypeLookUp: {readonly [key: string]: ChartType} = {
        undefined: ChartType.undefined,
        bar: ChartType.bar,
        invertedBar: ChartType.invertedBar,
        lines: ChartType.lines,
        symbol: ChartType.symbol,
        stackedBar: ChartType.stackedBar,
        stackedInvertedBar: ChartType.stackedBar,
        stackedLines: ChartType.stackedLines,
        stackedSymbol: ChartType.stackedSymbol,
        pie: ChartType.pie,
        pied3d: ChartType.pied3d,
        doughnut: ChartType.doughnut,
        doughnut3d: ChartType.doughnut3d,
        scatterLines: ChartType.scatterLines,
        scatterSymbol: ChartType.scatterSymbol,
        scatterString: ChartType.scatterString,
        boxPlot: ChartType.boxPlot,
        bubble: ChartType.bubble,
        bubbleAsymetric: ChartType.bubbleAsymetric,
        radar: ChartType.radar,
        radarFill: ChartType.radarFill,
        barHorizontal: ChartType.barHorizontal,
        stackedBarHorizontal: ChartType.stackedBarHorizontal,
        linesHorizontal: ChartType.linesHorizontal,
        stackedLinesHorizontal: ChartType.stackedLinesHorizontal,
        symbolHorizontal: ChartType.symbolHorizontal,
        stackedSymbolHorizontal: ChartType.stackedSymbolHorizontal
    };            
    
    export interface IChartDescriptor extends IViewDescriptor {
        readonly chartType: ChartType;
        //readonly getMetadata(): Promise<IChartMetadata>;
    }
    
    class ChartDescriptor<T extends ViewType.chart | ViewType.detailedChart> extends ViewDescriptor<T> implements IChartDescriptor {
        public readonly chartType: ChartType;

        constructor(dashboard: IDashboardDescriptor, type: T, data: IChartData)  {
            super(dashboard, type, data);
            this.chartType = _chartTypeLookUp[data.chartType];
        }
    }

    export interface ISpreadSheetDescriptor extends IChartDescriptor, ISheetDescriptor<ViewType.spreadSheet> {
        readonly displayType: SpreadSheetDisplayType;
        getMetadata(): Promise<Readonly<ISpreadSheetMetadata>>;
    }

    interface IChartInfo {
        sheetProperties: {
            columnHeaders: {
                items: {value?: string}[];
            };
            rowHeaders?: {
                items: {value?: string}[];
            };
        };
        chartProperties: Globals.IChartProperties;
        chartDataTransposed: boolean;
    }

    function _convertChartInfo<T extends IChartMetadata>(chartInfo: IChartInfo & Mutable<T>): T {
        // TO BE IMPLEMENTED
        /*let sheetProperties;
        if (chartInfo && chartInfo.chartProperties && (sheetProperties = chartInfo.sheetProperties)) {
            chartInfo.subtitles = {
                columnHeaders: sheetProperties.columnHeaders.items.map(item => item.value),
                rowHeaders: sheetProperties.rowHeaders.items.map(item => item.value)
            };
        }*/
        return chartInfo;
    }

    class SpreadSheetDescriptor extends GridDescriptor<ViewType.spreadSheet> implements ISpreadSheetDescriptor {
        public readonly chartType: ChartType;
        public readonly displayType: SpreadSheetDisplayType;
      
        constructor(dashboard: IDashboardDescriptor, data: ISpreadSheetData)  {
            super(dashboard, ViewType.spreadSheet, data);
            this.chartType = _chartTypeLookUp[data.chartType];
            this.displayType = data.displayType === 'chart' ? SpreadSheetDisplayType.chart : SpreadSheetDisplayType.grid;
        }
        
        protected _bind(metadata: ISheetInfo | IChartInfo | Mutable<ISpreadSheetMetadata>): ISpreadSheetMetadata {
            return super._bind(<ISheetInfo>metadata) && _convertChartInfo(<IChartInfo & Mutable<ISpreadSheetMetadata>>metadata);
        }        
    }

    export interface IReportDescriptor extends IViewDescriptor {
        readonly type: ViewType.report;
        getReportMetadata(): Promise<Globals.IReportMetadata>;
    }

    class ReportDescriptor extends ViewDescriptor<ViewType.report> implements IReportDescriptor {
        protected _metadata: Globals.IReportMetadata;
        protected _sequence: number;

        constructor(dashboard: IDashboardDescriptor, data: IReportData) {
            super(dashboard, ViewType.report, data);
        }

        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            if (sequence === this._sequence) {
                (this._metadata = jqXHR.responseJSON) && this._metadata.pages.forEach(page => {
                    page.objects.forEach((item: Mutable<Globals.IReportObject>)=> {
                        item.type = Globals.reportObjectType(<any>item.type);
                        if (item.type === Globals.ReportObjectType.dashboardView) {
                            (<{rendererType: any;}><any>item).rendererType = rendererType((<IDashboardViewReportObject> item).rendererType);
                        } else if (item.type === Globals.ReportObjectType.grid) {
                            (<Globals.IGridReportObject>item).content.items.forEach(row => row.forEach((cell: Mutable<IGridCell>) => cell.renderer = Globals.gridRender(<any>cell.renderer)));
                        }
                    });
                });
                this.fireEvent(<any>EventType.report);
            }
        }

        public createRequest<T = any>(path: string = ''): Rest.IAjaxRequest<T> {
            return this.dashboard.createRequest<T>(`/reports/${this.id}${path}`);
        }

        public getReportMetadata(): Promise<Globals.IReportMetadata> {
            return this._metadata ? Promise.resolve(this._metadata) : new Promise((resolve: (metadata: Globals.IReportMetadata)=> void) => {
                this.notify(<any>EventType.report, (/*event: Tools.IEvent*/)=> resolve(this._metadata));
                if (!this._sequence) {                
                    let request: Rest.IAjaxRequest<{svg: number;}> = this.createRequest();
                    request.options.data.svg = 1;
                    request.options.always = this._onAlways.bind(this);
                    this._sequence = request.call();
                }
            });
        }
    }
    
    interface ViewDataForViewType {
        [key: number]: IViewData;
        [ViewType.map]: IMapViewData;
        [ViewType.detailedSheet]: IViewData;
        [ViewType.aggregatedSheet]: IViewData;
        [ViewType.chart]: IChartData;
        [ViewType.spreadSheet]: ISpreadSheetData;
        [ViewType.detailedChart]: IChartData;
    }
        
    interface ViewDescriptorForViewType {
        [key: number]: IViewDescriptor;
        [ViewType.map]: IMapDescriptor;
        [ViewType.detailedSheet]: IDetailedSheetDescriptor;
        [ViewType.aggregatedSheet]: IAggregatedSheetDescriptor;
        [ViewType.chart]: IChartDescriptor;
        [ViewType.spreadSheet]: ISpreadSheetDescriptor;
        [ViewType.detailedChart]: IChartDescriptor;
    }

    const viewDescriptorFactory: {
        readonly [key: string]: <T extends keyof ViewDescriptorForViewType>(dashboard: IDashboardDescriptor, data: ViewDataForViewType[T]) => ViewDescriptorForViewType[T];
    } = {
        asteropDashboardMap: (dashboard: IDashboardDescriptor, data: IMapViewData) => new MapDescriptor(dashboard, data),
        asteropDashboardDetailedSheet: (dashboard: IDashboardDescriptor, data: IViewData) => new DetailedSheetDescriptor(dashboard, ViewType.detailedSheet, data),
        asteropDashboardAggregatedSheet: (dashboard: IDashboardDescriptor, data: IViewData) => new GridDescriptor<ViewType.aggregatedSheet>(dashboard, ViewType.aggregatedSheet, data),
        asteropDashboardChart: (dashboard: IDashboardDescriptor, data: IChartData) => new ChartDescriptor(dashboard, ViewType.chart, data),
        asteropDashboardSpreadSheet: (dashboard: IDashboardDescriptor, data: ISpreadSheetData) => new SpreadSheetDescriptor(dashboard, data),
        asteropDashboardDetailedChart: (dashboard: IDashboardDescriptor, data: IChartData) => new ChartDescriptor(dashboard, ViewType.detailedChart, data)
    };
    
    export function viewDescriptor<T extends keyof ViewDescriptorForViewType = any>(dashboard: IDashboardDescriptor, data: ViewDataForViewType[T]): ViewDescriptorForViewType[T] {
        let h = viewDescriptorFactory[data.type] || ((dashboard: IDashboardDescriptor, data: IViewData) => new ViewDescriptor(dashboard, ViewType.unknown, data));
        return h(dashboard, data);
    }

    export function reportDescriptor(dashboard: IDashboardDescriptor, data: IReportData): ReportDescriptor {
        return new ReportDescriptor(dashboard, data);
    }
}
