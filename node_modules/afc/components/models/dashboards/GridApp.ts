/**
 * Created by jean.rennes on 22/03/2021.
 */
///<reference path="../../AFC.ts" />

namespace AFC.Dashboards {
    export interface IGridClass {
        readonly color: string;
        readonly padding: string;
        readonly backgroundColor: string;
        readonly fontSize: string;
        readonly textAlign: string;
        readonly verticalAlign: string;
        readonly fontWeight: string;
        readonly fontFamily: string;
        readonly borderStyle: string;
        readonly borderWidth: string;
        readonly borderColor: string;
        readonly textDecoration: string;
        readonly fontStyle: string;
        readonly whiteSpace: string;
    }

    export interface IGridRowHeader {
        readonly name: string;
        readonly text?: string;
        readonly className: string;
        readonly renderer: Globals.GridRenderer;
        readonly height: number;
        readonly image: string;
    }
    
    export interface IGridColumnHeader {
        readonly name: string;
        readonly text?: string;
        readonly className: string;
        readonly renderer: Globals.GridRenderer;
        readonly width: number;
        readonly image: string;
        readonly supportOrdering: boolean;
        readonly type: Data.DataKind;
    }
    
    export interface IGridCell {
        readonly value: any;
        readonly text: string;
        readonly className: string;
        readonly renderer: Globals.GridRenderer;
        readonly image: string;
    }
    
    export interface IGridData {
        classes: {[key: string]: IGridClass},
        rowHeaders: {
            width: number;
            visibility: boolean;
            items: IGridRowHeader[]
        },
        columnHeaders: {
            ordering?: {
                index: number;
                descending: boolean;
            }[]
            height: number;
            visibility: boolean;
            items: IGridColumnHeader[]
        },
        images: {[key: string]: string},
        items: IGridCell[][]
    }   
    
    function _getCell(gridData: IGridData, item: IGridRowHeader | IGridColumnHeader | IGridCell): Mutable<Globals.IGridAppCell> {
        let cell: Mutable<Globals.IGridAppCell> = Object.create((item.className && gridData.classes[item.className]) || null),
            image = item.image;

        cell.renderer = item.renderer;
        if (image) {
            image.charAt(0) === '<' ?
                cell.symbol = image:
                cell.symbol = image;
        }
        return cell;
    }

    function _getHeaderCell(gridData: IGridData, item: IGridRowHeader | IGridColumnHeader): Globals.IGridAppCell {
        let cell: Mutable<Globals.IGridAppCell> = _getCell(gridData, item);
        cell.value = item.name;
        cell.text = item.text || item.name;
        return cell;
    }
    
    export class GridApp implements Globals.IGridApp {
        private readonly _index: {readonly [key: string]: number;};
        public readonly gridData: IGridData;
        public readonly hasRowHeader: boolean;
        public readonly hasColumnHeader: boolean;
        public readonly sortedColumns: Globals.ISortedColumn[];
        
        constructor(gridData: IGridData, allowOrdering: boolean = false, sortedColumns?: Globals.ISortedColumn[]) {
            this.gridData = gridData;
            this.hasRowHeader = gridData.rowHeaders?.visibility;
            this.hasColumnHeader = gridData.columnHeaders?.visibility;
            if (allowOrdering) {
                let index: {[key: string]: number;} = this._index = {};
                gridData.columnHeaders.items.forEach((item, indice) => index[item.name] = indice);
                this.sortedColumns = sortedColumns || [];
            }
        }
        
        public get allowOrdering(): boolean {
            return !!this._index;
        }
        
        public getRowCount(): number {
            return this.gridData.items.length;
        }
        
        public getRowHeader(line: number): Globals.IGridAppCell {
            return _getHeaderCell(this.gridData, this.gridData.rowHeaders.items[line]);
        }
        
        public getRowHeaderWidth(): number {
            return this.gridData.rowHeaders.width;
        }
        
        public getRowHeight(line: number): number {
            return this.gridData.rowHeaders.items[line].height;
        }
        
        public getColumnInfo(column: number): Globals.IGridAppColumnInfo {
            return this.gridData.columnHeaders.items[column];
        }

        public getColumnCount(): number {
            return this.gridData.columnHeaders.items.length;
        }
        
        public getColumnHeader(column: number): Globals.IGridAppCell {
            return _getHeaderCell(this.gridData, this.gridData.columnHeaders.items[column]);
        }
        
        public getColumnHeaderHeight(): number {
            return this.gridData.columnHeaders.height;
        }
        
        public getColumnWidth(column: number): number {
            return this.gridData.columnHeaders.items[column].width;
        }
        
        public getCell(column: number, line: number): Globals.IGridAppCell {
            let item = this.gridData.items[line][column],
                cell = _getCell(this.gridData, item);
            cell.value = cell.value;
            cell.text = item.text;
            return cell;
        }
        
        public getValue(column: string, line: number): number|string {
            let cell = this.gridData.items[line][this._index[column]];
            return cell?.value ?? null;
        }
        
        public getSymbol(key: string): string {
            return this.gridData.images[key];
        }
    }
    
    function _castArray<T>(value: T|T[], fn?: (value: T) => string): string {
        if (value instanceof Array) {
            let str = '';
            for (let i = 0; i < value.length; ++i) {
                i && (str += ' ');
                str += fn ? fn(value[i]) : value[i];
            }
            return str;
        }
        return fn ? fn(<T>value) : <any>value;
    }
    
    class GridAppCell implements Globals.IGridAppCell {
        public readonly value: any;
        public readonly symbol: string;
        public readonly image: string;
        public readonly color: string;
        public readonly backgroundColor: string;
        public readonly renderer: Globals.GridRenderer;
        public readonly padding: string;
        public readonly fontSize: string;
        public readonly textAlign: string;
        public readonly verticalAlign: string;
        public readonly fontWeight: string;
        public readonly fontFamily: string;
        public readonly borderStyle: string;
        public readonly borderWidth: string;
        public readonly borderColor: string;
        public readonly textDecoration: string;
        public readonly fontStyle: string;
        public readonly whiteSpace: string;
        public readonly thematic: Globals.IThematic<number>;
        public readonly text: string;
        public className: string;
        
        constructor(item: Globals.ITemplateSheetColumnHeader | Globals.ITemplateSheetRowHeader | Globals.ITemplateSheetCell, template: Partial<Globals.ITemplateSheetClass>, value: any, text: string, backgroundColor: string) {
            this.value = value;
            this.text = text;
            this.symbol = item.image;
            /*this.image: string;*/
            this.color = Tools.Style.convertRGBAColor(template.color || 0);
            this.backgroundColor = backgroundColor || Tools.Style.convertRGBAColor(template.backgroundColor || 0);
            this.renderer = item.renderer;
            this.padding = _castArray(template.padding, (value: number) => `${value}pt`);
            this.fontSize = `${template.fontSize}pt`;
            this.textAlign = template.align;
            this.verticalAlign = template.verticalAlign;
            this.fontWeight = template.fontWeight;
            this.fontFamily = template.fontFamily;
            this.borderStyle = _castArray(template.borderStyle);
            this.borderWidth = _castArray(template.borderWidth);
            this.borderColor = _castArray(template.borderColor, Tools.Style.convertRGBAColor);
            this.textDecoration = template.textDecoration;
            this.fontStyle = template.fontStyle;
            this.whiteSpace = template.whiteSpace;
        }
    }

    export abstract class MetaGridApp implements Globals.IGridApp {
        public readonly template: Globals.ITemplateSheet;
        public readonly hasRowHeader: boolean;
        public readonly hasColumnHeader: boolean;
        public readonly allowOrdering: boolean;
        public readonly sortedColumns: Globals.ISortedColumn[];
        
        constructor(template: Globals.ITemplateSheet, allowOrdering: boolean, sortedColumns?: Globals.ISortedColumn[]) {
            this.template = template;
            this.hasRowHeader = template.rowHeaders?.visibility;
            this.hasColumnHeader = template.columnHeaders?.visibility;
            if (this.allowOrdering = allowOrdering) {
                this.sortedColumns = sortedColumns || [];
            }
        }
        
        protected _getCellEx(item: Globals.ITemplateSheetColumnHeader | Globals.ITemplateSheetRowHeader | Globals.ITemplateSheetCell, value: any, text: string, backgroundColor?: string, format?: Tools.StringTools.FormatString): GridAppCell {
            if (!text) {
                if (!format) {
                    let kind = Tools.Data.isNumber(item.value) ? Data.DataKind.real : Data.DataKind.character;
                    if (item.format || kind === Data.DataKind.real) {
                        format = new Tools.StringTools.FormatString(item.format, kind);
                    }
                }
                text = format ? format.getFormated(value) : value;            
            }            
            return new GridAppCell(item, (item.className && this.template.classes[item.className]) || {}, value, text, backgroundColor);
        }
        
        public abstract getRowCount(): number;
        
        public abstract getRowHeader(line: number): Globals.IGridAppCell;
        
        public abstract getRowHeaderWidth(): number;
        
        public abstract getRowHeight(line: number): number;
        
        public abstract getColumnInfo(column: number): Globals.IGridAppColumnInfo;

        public getColumnCount(): number {
            return this.template.items[0].length;
        }
        
        public abstract getColumnHeader(column: number): Globals.IGridAppCell;
        
        public getColumnHeaderHeight(): number {
            return this.template.columnHeaders.height;
        }
        
        public getColumnWidth(column: number): number {
            return this.template.columnHeaders.items[column].width;
        }
        
        public abstract getCell(column: number, line: number): Globals.IGridAppCell;
        
        public abstract getValue(column: string, line: number): number|string;
        
        public getSymbol(key: string): string {
            return this.template.images[key];
        }
    }
    
    export class DetailedGridApp extends MetaGridApp {
        private readonly _thematic: (row: ReadonlyArray<any>)=> string;
        private readonly _formats: ReadonlyArray<Tools.StringTools.FormatString>;
        declare public readonly template: Globals.ITemplateDetailedSheet;
        public readonly dataModel: Data.IDataModelBase;
        declare public readonly sortedColumns: Globals.ISortedColumn[];
        public readonly index: ReadonlyArray<number>;
        
        constructor(template: Globals.ITemplateDetailedSheet, data: Partial<Globals.IDetailData>, sortedColumns: Globals.ISortedColumn[]) {
            let thematic = template.thematic,
                columns = thematic && thematic.columns,
                solver: (row: ReadonlyArray<any>) => number,
                formats: Tools.StringTools.FormatString[] = [];
            
            super(template, true);
            this.dataModel = data.dataModel;
            this.index = template.columnHeaders.items.map((header, indice) => {
                let item = template.items[0][indice],
                    pos = data.dataModel.columnIndex[header.column] ?? -1;
                pos !== -1 && item.format && (formats[indice] = new Tools.StringTools.FormatString(item.format, data.dataModel.columns[pos].type));
                return pos;
            });
            this.sortedColumns = sortedColumns;
            if (columns && columns.length === 1) {
                solver = Globals.getMonoThematicSolver(columns[0], thematic.classes, data, data.dataModel.columnIndex);
                solver && (this._thematic = (row: ReadonlyArray<any>) => {
                    let value = solver(row),
                        _class = this.template.thematic.classes[value];
                    return _class && Tools.Style.convertColor(_class.value);
                });
            }
            this._formats = formats;
        }
        
        public getRowCount(): number {
            return this.dataModel.length;
        }
        
        public getRowHeader(line: number): Globals.IGridAppCell {
            return;
        }
        
        public getRowHeaderWidth(): number {
            return;
        }
        
        public getRowHeight(line: number): number {
            return this.template.rowHeaders.items[0].height;
        }
        
        public getColumnInfo(column: number): Globals.IGridAppColumnInfo {
            let info: Mutable<Globals.IGridAppColumnInfo> = Object.create(this.dataModel.columns[this.index[column]] || null);
            info.supportOrdering = true;
            return info;
        }
        
        public getColumnHeader(column: number): Globals.IGridAppCell {
            let item = this.template.columnHeaders.items[column];
            return this._getCellEx(item, item.value, item.text);
        }
        
        public getCell(column: number, line: number): Globals.IGridAppCell {
            let row = this.dataModel.values[line],
                value,
                backgroundColor;
                
            if (row) {
                value = row[this.index[column]];
                backgroundColor = this._thematic && this._thematic(row);
            }
            return this._getCellEx(this.template.items[0][column], value, null, backgroundColor, this._formats[column]);
        }
        
        public getValue(column: string, line: number): number|string {
            let row = this.dataModel.values[line];
            return (row && row[this.dataModel.columnIndex[column]]) ?? null;
        }
    }
}