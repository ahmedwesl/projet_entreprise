/**
 * Created by jean.rennes on 12/10/2015.
 */
///<reference path="Global.ts" />
///<reference path="Dashboard.ts" />
///<reference path="../data/Data.ts" />
///<reference path="../../helpers/Geometry.ts" />
///<reference path="../../helpers/Data.ts" />

namespace AFC.Dashboards {
    export interface IZoneDistrict {
        readonly isRedistricted: boolean;
        getReaffectStorage(): Promise<IReaffectStorage>;
        affect(unit: string, subset: string): Promise<void>;
        applyChanges(unit: string, values: {[key: string]: any}): Promise<void>;
        delete(unit: string): Promise<void>;
        getOwnership(unit: string): Promise<void>;
        reset(): Promise<void>;
    }

    export interface ISites {
        readonly columns: ReadonlyArray<Data.IDBColumn>;
        current: string | number;
    }
    
    export const enum DistrictType {
        base = 0,           // get descriptor, no district parameters
        redistricting,      // district edition request, district get/getData request, no district parameters
        full                // zone configuration, district parameters
    }
    
    export interface IZone<T extends keyof ZoneDescriptorForZoneType = keyof ZoneDescriptorForZoneType> extends Tools.IObservable {
        readonly dashboard: IDashboard;
        readonly reference: ZoneDescriptorForZoneType[T];
        readonly cluster: IZoneCluster;
        readonly id: string;
        readonly name: string; 
        readonly type: ZoneType;
        readonly perSiteConfiguration: string;
        readonly sites: ISites;
        readonly district: IZoneDistrict;
        createRequest<T2 = any>(path?: string, districtType?: DistrictType, options?: Rest.IRestRequestOptions): [number, Promise<Rest.IAjaxRequest<T2>>];
        updateContext(data: IDashboardContextDataBase, reaffectStorage: IReaffectStorage, sitesTable: ISitesTable): void;
        getReaffectStorage(): Promise<IReaffectStorage>;
        configure(configuration?: IZoneConfiguration): void;
        getDescriptor(): Promise<ZoneDescriptorForZoneType[T]>;
        getData(dataSourceKind: DataSourceKind, indicators?: ReadonlyArray<string>): Promise<Data.IDataModelBase>;
        clone(dashboard: IDashboard, cluster: IZoneCluster): IZone<T>;
        invalidate(siteChange?: boolean): void;
    }

    const enum EventType {
        descriptor = Tools.EventType.UserEvent + 1,
        district,
        content
    }
    
    interface IZoneContentData {
        table: {
            columns: ReadonlyArray<any>;
            primaryKey: ReadonlyArray<string>;
            values: any[][];
        };
    }

    function hasOutOfZone(descriptor: IZoneDescriptor): boolean {
        switch (descriptor.type) {
            case ZoneType.radius:
            case ZoneType.isodistance:
            case ZoneType.isochrone:
            case ZoneType.predefined:
                return true;
        }
    }

    function _isRedistrictable(zone: IZone): boolean {
        switch (zone.type) {
            case ZoneType.radius:
            case ZoneType.isodistance:
            case ZoneType.isochrone:
            case ZoneType.predefined:
            case ZoneType.bulkMail:
                return true;
        }
    }

    function _checkSitesTable(zone: IZone, sitesTable: ISitesTable): ISitesTable {
        switch (zone.type) {
            case ZoneType.radius:
            case ZoneType.isodistance:
            case ZoneType.isochrone:
            case ZoneType.surrounding:
            case ZoneType.bulkMail:
                return sitesTable;
        }
    }

/*
    function _getDistrictTable(descriptor: IRadiusAreaDescriptor | IIsodistanceAreaDescriptor | IIsochroneAreaDescriptor | IPredefinedAreaDescriptor | IBulkMailAreaDescriptor): string {
        return descriptor?.partition?.districtingTable;
    }
*/
    interface IDataHolder {
        indicators: string[];
        sequence: number;
        dataModel: Data.IDataModelBase;
    }

    const _descriptor = Symbol(),
        _storage = Symbol();

    function _deleteContent(dataHolder: IDataHolder): void {
        delete dataHolder.dataModel;
        delete dataHolder.sequence;
    }

    class Zone<T extends keyof ZoneDescriptorForZoneType> extends Tools.EventSink<IZone<T>> implements IZone<T> {
        private [_descriptor]: number;
        private [_storage]: symbol;
        protected _type: ZoneType;
        protected _context: IContextZone;
        protected _descriptor: IZoneDescriptor;
        protected _dataHolders: {
            [key: number]: IDataHolder;
        };
        public readonly district: InstanceType<typeof Zone.ZoneDistrict>;
        public readonly sites: ISites;
        public readonly dashboard: IDashboard;
        public readonly reference: ZoneDescriptorForZoneType[T] & {perSiteConfiguration: string};
        public readonly cluster: IZoneCluster;

        public static ZoneDistrict = class /*extends Tools.EventSink*/ implements IZoneDistrict {
            public readonly zone: Zone<any>;
            private [_storage]: IReaffectStorage;

            constructor(zone: Zone<any>) {
                this.zone = zone;
            }
            
            public async getReaffectStorage(): Promise<IReaffectStorage> {
                let reaffectStorage = this[_storage];

                if (!reaffectStorage) {
                    let zone = this.zone;
                    reaffectStorage = await zone.getReaffectStorage() || (this[_storage] = this.zone.dashboard.reaffectStorages.createStorage(<IRadiusAreaDescriptor | IIsodistanceAreaDescriptor | IIsochroneAreaDescriptor | IPredefinedAreaDescriptor | IBulkMailAreaDescriptor>await this.zone.getDescriptor(), ZoneReaffectStorage.editable, [zone]));
                    await reaffectStorage.load();
                }
                return reaffectStorage;
            }

            public get isRedistricted(): boolean {
                return this[_storage]?.isRedistricted(this.zone.cluster.current);
            }

            public async affect(unit: string, subset: string): Promise<void> {
                let reaffectStorage = await this.getReaffectStorage();
                return reaffectStorage?.affect(this.zone.cluster.current, unit, subset);
            }
            
            public async applyChanges(unit: string, values: {[key: string]: any}): Promise<void>{
                let reaffectStorage = await this.getReaffectStorage();
                return reaffectStorage?.applyChanges(this.zone.cluster.current, unit, values);
            }
            
            public async delete(unit: string): Promise<void>{
                let reaffectStorage = await this.getReaffectStorage();
                return reaffectStorage?.delete(this.zone.cluster.current, unit);
            }
            public async getOwnership(unit: string): Promise<void>{
                let reaffectStorage = await this.getReaffectStorage();
                return reaffectStorage?.getOwnership(this.zone.cluster.current, unit);
            }
            public reset(): Promise<void> {
                return this[_storage]?.reset(this.zone.cluster.current);
            }
        }

        protected static _Sites = class implements ISites {
            public readonly zone: Zone<any>;

            constructor(zone: Zone<any>) {
                this.zone = zone;
            }

            public set current(value: number | string) {
                this.zone.cluster.current = value;
            }

            public get current(): number | string {
                return this.zone.cluster.current;
            }
            
            public get columns(): ReadonlyArray<Data.IDBColumn> {
                let descriptor: IZoneDescriptor = this.zone._descriptor || this.zone.reference;
                return descriptor.sites && descriptor.sites.columns ;
            }            
        }

        constructor(dashboard: IDashboard, reference: ZoneDescriptorForZoneType[T], cluster: IZoneCluster) {
            super();
            this.dashboard = dashboard;
            this.reference = <any>reference;
            this.cluster = cluster;
            this.sites = new Zone._Sites(this);
            this.district = new Zone.ZoneDistrict(this);
        }

        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            if (this[_descriptor] === sequence) {
                let data: IZoneData = jqXHR.responseJSON;
                
                data && (this._descriptor = zoneDescriptor(this.reference.dashboard, data));
                this.fireEvent(<any>EventType.descriptor);
            }
        }

        protected _onContentAlways(dataHolder: IDataHolder, kind: DataSourceKind, sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            let data: IZoneContentData,
                dataTable: Data.IDataTable;

            if (dataHolder.sequence === sequence) {
                if ((data = jqXHR.responseJSON) && (dataTable = Data.updateTableData(data.table))) {
                    dataHolder.dataModel = new Data.DataModelBase(dataTable.columns, dataTable.primaryKey, dataTable.values);
                }
                this.fireEvent(<any>EventType.content + kind);
            }
        }

        protected _checkData(kind: DataSourceKind, values?: ReadonlyArray<string>): IDataHolder {
            let dataHolder = (this._dataHolders || (this._dataHolders = {}))[kind];
            
            if (values || !dataHolder) {
                let indicators1 = [...new Set(values)].sort();
                
                if (!dataHolder) {
                    this._dataHolders[kind] = dataHolder = <any>{
                        indicators: indicators1
                    };
                } else if (values) {
                    let indicators0 = dataHolder.indicators,
                        dirty = !indicators0;
                    if (!dirty) {
                        let i = 0, j = 0;
                        for (; i < indicators0.length; ++i) {
                            let str0 = indicators0[i], diff = -1;
                            for (; j < indicators1.length; ++j) {
                                diff = str0.localeCompare(indicators1[j]);
                                if (diff <= 0) {
                                    break;
                                }
                            }
                            if (diff < 0) {
                                indicators1.splice(j, 0, str0);
                                dirty = true;
                            }
                            ++j;
                        }
                        dirty = dirty || (j < indicators1.length);
                    }
                    if (dirty) {
                        _deleteContent(dataHolder);
                        dataHolder.indicators = indicators1;
                    }
                }
            }
            return dataHolder;
        }
        
        protected _isMutable(): boolean {
            switch (this.type) {
                case ZoneType.radius:
                case ZoneType.isodistance:
                case ZoneType.isochrone:
                case ZoneType.predefined:
                    return !!(this._context || this.reference.perSiteConfiguration);
            }
        }

        protected _resetDistrict(): void {
            this.dashboard.reaffectStorages.invalidate(this.district[_storage]);
            delete this.district[_storage];
            delete this[_storage];
        }
        
        public get id(): string {
            return this.reference.id;
        }        

        public get name(): string {
            return this.reference.name;
        }
        
        public get type(): ZoneType {
            return this._type || this.reference.type;
        }
        
        public get perSiteConfiguration(): string {
            return this._context?.perSiteConfiguration || this.reference.perSiteConfiguration;
        }
        
        public createRequest<T2 = any>(path?: string, districtType: DistrictType = DistrictType.base, options?: Rest.IRestRequestOptions): [number, Promise<Rest.IAjaxRequest<T2>>] {
            return this.dashboard.createRequest<T2>(`/zones/${this.id}${path || ''}`, options, districtType);
        }

        public async getReaffectStorage(): Promise<IReaffectStorage> {
            if (_isRedistrictable(this))
                return this.district.hasOwnProperty(_storage) ?
                    this.district[_storage]:
                    new Promise(resolve => {
                        this.notify(<any> EventType.district, ()=> resolve(this.district[_storage]));
                        if (!this[_storage]) {
                            this[_storage] = Symbol();
                            this.getDescriptor().then((descriptor: IRadiusAreaDescriptor | IIsodistanceAreaDescriptor | IIsochroneAreaDescriptor | IPredefinedAreaDescriptor | IBulkMailAreaDescriptor) => {
                                this.district[_storage] = this.dashboard.reaffectStorages.get(descriptor);
                                this.fireEvent(<any> EventType.district);
                            });
                        }
                    });
        }
        
        public updateContext(data: IDashboardContextDataBase, reaffectStorage: IReaffectStorage, sitesTable: ISitesTable): void {
            let replacement = reaffectStorage && reaffectStorage.updateContext(this, data),
                context: IContextZone&{sitesTable?: ISitesTable;};
            
            if ((sitesTable = _checkSitesTable(this, sitesTable)) || this._context || replacement) {
                context = $.extend({id: this.id}, this._context);
                replacement && (context.areaTable = replacement);
                sitesTable && (context.sitesTable = sitesTable);
                (Rest.RestModel.createEntry<{zones: IContextZone[];}>(data, 'context').zones || (data.context.zones = [])).push(context);
            }
        }

        public async getDescriptor(): Promise<ZoneDescriptorForZoneType[T]> {
            let descriptor: ZoneDescriptorForZoneType[T] = this._descriptor || (!this._isMutable() && this.reference);
            return descriptor || new Promise(async resolve => {
                this.notify(<any>EventType.descriptor, (/*event: Tools.IEvent*/) => resolve(this._descriptor));
                if (!this[_descriptor]) {
                    let promise = this.createRequest(),
                        request;
                    
                    this[_descriptor] = promise[0];
                    request = await promise[1];
                    request.options.always = this._onAlways.bind(this);
                    request.call();
                }
            });
        }
        
        public async getData(kind: DataSourceKind, indicators?: ReadonlyArray<string>): Promise<Data.IDataModelBase> {
            let dataHolder = this._checkData(kind, indicators);
            return dataHolder.dataModel || new Promise(async resolve => {
                    this.notify(<any>EventType.content + kind, (/*event: Tools.IEvent*/) => resolve(dataHolder.dataModel));
                    if (!dataHolder.sequence) {
                        let req = this.createRequest<{
                                dataSourceKind: string;
                                indicators: ReadonlyArray<string>;
                                outofZone: boolean;
                        }>('/content', DistrictType.full),
                            results,
                            request,
                            data;
                            
                        results = await Promise.all([this.getDescriptor(), req[1]]),
                        dataHolder.sequence = req[0];
                        request = results[1],
                        data = request.options.data;
                        data.dataSourceKind = dataSourceKind(kind);
                        dataHolder.indicators && (data.indicators = dataHolder.indicators);
                        kind === DataSourceKind.unknown && hasOutOfZone(results[0]) && (data.outofZone = true);
                        request.options.always = this._onContentAlways.bind(this, dataHolder, kind);
                        request.call();
                    }
                });
        }
        
        public configure(configuration?: IZoneConfiguration): void {
            let context = configuration && buildContext(this.reference, configuration);

            this._type = configuration?.type;
            if (JSON.stringify(context) !== JSON.stringify(this._context)) {
                // district table cannot be changed yet
                // (_getDistrictTable(<any> this.reference) !== configuration.districtTable) && this._resetDistrict();
                context ? this._context = context : delete this._context;
                this.invalidate();
                this.dashboard.invalidateViews();
            }
        }

        public invalidate(siteChange?: boolean): void {
            if (siteChange) {
                this._resetDistrict();
                delete this._descriptor;
                delete this[_descriptor];
            }
            this._dataHolders && Object.values(this._dataHolders).forEach(_deleteContent);
            this.fireEvent(Tools.EventType.Dirty);
        }
        
        public clone(dashboard: IDashboard, cluster: IZoneCluster): Zone<T> {
            let clone: Zone<T>  = Reflect.construct(Zone, [dashboard, this.reference, cluster], this.constructor);

            this._type && (clone._type = this._type);
            this._context && (clone._context = this._context);
            this._descriptor && (clone._descriptor = this._descriptor);
            return clone;
        }
    }

//---------------------------------------------------------------------------

    export function zone<T extends keyof ZoneDescriptorForZoneType = any>(dashboard: IDashboard, reference: ZoneDescriptorForZoneType[T], cluster: IZoneCluster): IZone<T> {
        return new Zone<T>(dashboard, reference, cluster);
    }
}