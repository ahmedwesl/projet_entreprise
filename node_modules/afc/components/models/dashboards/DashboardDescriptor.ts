/**
 * Created by jean.rennes on 17/04/2019.
 */
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="Global.ts" />
///<reference path="DashboardView.ts" />
///<reference path="SiteFinder.ts" />

namespace AFC.Dashboards {
    interface IDashboardData {
        readonly id: string;
        readonly name: string;
        readonly properties: ReadonlyArray<IDashboardProperty>;
        readonly levels: ReadonlyArray<Readonly<IGeographicalLevel>>;
    }    
    
    interface IDashboardContentData extends IDashboardData {
        readonly mainCluster: string;
        readonly zones: ReadonlyArray<IZoneData>;
        readonly views: ReadonlyArray<IViewData>;
        readonly reports: ReadonlyArray<IReportData>;
        readonly templates: ReadonlyArray<IReportTemplateDescriptor>;
    }    
    
    export interface IZonesProperties {
        readonly [key: string]: number;
    }

    export interface IDashboardProperties {
        readonly [key: string]: number;
    }

    export interface IViewsProperties {
        readonly [key: string]: number | undefined;
        visible?: number;
        order?: number;
        link?: number;
        iswide?: number;
        redistrict?: number;
        width?: number;
    }

    export interface IDashboardContent {
        readonly zones: ReadonlyArray<IZoneDescriptor>;
        readonly zonesProperties: Readonly<IZonesProperties>;
        readonly views: ReadonlyArray<IViewDescriptor>;
        readonly viewsProperties: Readonly<IViewsProperties>;
        readonly reportTemplates: ReadonlyArray<IReportTemplateDescriptor>;
        readonly mainCluster: string;
    }

    export function propertiesLookup(properties: ReadonlyArray<IDashboardProperty>):{ [s: string]: number; } {
        let index: {[s: string]: number;} = {};
        let property: IDashboardProperty, name: string;

        for (let i = 0, iLength = properties.length; i < iLength; ++i) {
            property = properties[i];
            name = property[1].toLowerCase();
            index[name] = i;
        }
        return index;
    }

    class DashboardContent implements IDashboardContent {
        public readonly mainCluster: string;
        public readonly zones: ReadonlyArray<IZoneDescriptor>;
        public readonly views: ReadonlyArray<IViewDescriptor>;
        public readonly reportTemplates: ReadonlyArray<IReportTemplateDescriptor>;
        protected _zonesProperties: IZonesProperties;
        protected _viewsProperties: IViewsProperties;

        constructor(mainCluster: string, zones: ReadonlyArray<IZoneDescriptor>, views: ReadonlyArray<IViewDescriptor>, reportTemplates: ReadonlyArray<IReportTemplateDescriptor>) {
            this.mainCluster = mainCluster;
            this.zones              = zones;
            this.views              = views;
            this.reportTemplates    = reportTemplates;
        }

        public get zonesProperties(): IZonesProperties {
            return this._zonesProperties || (this._zonesProperties = this.zones.length ? propertiesLookup(this.zones[0].properties): {});
        }

        public get viewsProperties(): IViewsProperties {
            return this._viewsProperties || (this._viewsProperties = this.views.length ? propertiesLookup(this.views[0].properties): {});
        }
    }

    export interface IDashboardDescriptor extends Controls.IListItem {
        readonly levels: ReadonlyArray<Readonly<IGeographicalLevel>>;
        readonly properties: ReadonlyArray<IDashboardProperty>;
        readonly restModel: Rest.RestModel;
        getProperty(value: string): any;
        createRequest<T = any>(path?: string): Rest.IAjaxRequest<T>;
        getContent(): Promise<Readonly<IDashboardContent>>;
    }
    
    class DashboardDescriptor extends Tools.EventSink implements IDashboardDescriptor {
        public readonly dashboards: DashboardsDescriptor;
        public readonly id: string;
        public readonly name: string;
        public readonly levels: ReadonlyArray<IGeographicalLevel>;
        public readonly properties: ReadonlyArray<IDashboardProperty>;
        protected _sequence: number;
        protected _content: IDashboardContent;
        protected _dashboardProperties: IDashboardProperties;
        
        constructor(dashboards: DashboardsDescriptor, data: IDashboardData) {
            super();
            this.dashboards = dashboards;
            this.id = data.id;
            this.name = data.name;
            this.levels = data.levels;
            this.properties = data.properties;
        }

        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            if (this._sequence === sequence) {
                let data: IDashboardContentData = jqXHR.responseJSON,
                    mainCluster: string,
                    zones: IZoneDescriptor[],
                    views: IViewDescriptor[] = [],
                    templates: readonly IReportTemplateDescriptor[] = [];
                 
                if (data) {
                    zones = data.zones && data.zones.map(data => zoneDescriptor(this, data));
                    data.views && data.views.forEach(view => views.push(viewDescriptor(this, view)));
                    data.reports && data.reports.forEach(report => views.push(reportDescriptor(this, report)));
                    mainCluster = data.mainCluster;
                    if (data.templates)
                        templates = data.templates;
                }
                this._content = new DashboardContent(mainCluster || '', zones || [], views, templates);
                this.fireEvent(Tools.EventType.UserEvent);
            }
        }
        
        public get restModel(): Rest.RestModel {
            return this.dashboards.restModel;
        }
        
        public getProperty(value: string): any {
            let dashboardProperties = this._dashboardProperties || (this._dashboardProperties = this.properties.length ? propertiesLookup(this.properties): {}),
                i = dashboardProperties[value.toLowerCase()];
            return (i !== void 0) ? this.properties[i][2] : null;
        }
                
        public createRequest<T = any>(path: string = ''): Rest.IAjaxRequest<T> {
            return this.dashboards.createRequest<T>(`/${this.id}${path}`);
        }

        public getContent(): Promise<Readonly<IDashboardContent>> {
            return this._content ? Promise.resolve(this._content) : new Promise((resolve: (content: IDashboardContent)=> void) => {
                this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/)=> resolve(this._content));
                if (!this._sequence) {
                    let request: Rest.IAjaxRequest = this.createRequest();
                    request.options.always = this._onAlways.bind(this);
                    this._sequence = request.call();
                }
            });
        }
    }

//---------------------------------------------------------------------------

    export class DashboardsDescriptor extends Tools.EventSink {
        public readonly restModel: Rest.RestModel;
        protected _dashboards: ReadonlyArray<IDashboardDescriptor>;
        protected _sequence: number;

        constructor(restModel: Rest.RestModel) {
            super();
            this.restModel = restModel;
        }

        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            if (this._sequence === sequence) {
                let data: ReadonlyArray<IDashboardData> = jqXHR.responseJSON;
                
                data && (this._dashboards = data.map(dashboard => new DashboardDescriptor(this, dashboard)));
                this.fireEvent(Tools.EventType.UserEvent);
            }
        }

        public createRequest<T = any>(path: string = '', options?: Rest.IRestRequestOptions): Rest.IAjaxRequest<T> {
            return this.restModel.createAjaxRequest<T>(`/dashboards${path}`, true, options);
        }

        public getDashboards(): Promise<ReadonlyArray<IDashboardDescriptor>> {
            return this._dashboards ? Promise.resolve(this._dashboards) : new Promise((resolve: (dashboards: ReadonlyArray<IDashboardDescriptor>)=> void) => {
                this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/)=> resolve(this._dashboards));
                if (!this._sequence) {                
                    let request: Rest.IAjaxRequest = this.createRequest();
                    request.options.always = this._onAlways.bind(this);
                    this._sequence = request.call();
                }
            });
        }
    }
};