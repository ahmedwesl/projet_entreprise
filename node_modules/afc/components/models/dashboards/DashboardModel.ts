/**
 * Created by jean.rennes on 23/09/2015.
 */
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="Global.ts" />
///<reference path="DashboardView.ts" />
///<reference path="SiteFinder.ts" />

namespace AFC.Dashboards {
    const _sequence = Symbol();
    
    interface IViewModelEventData extends Tools.IEventData {
        sequence: Symbol;
        data: IDashboardEventData;
        dashboard: IDashboard;
    }
    
    abstract class ViewModel<V extends IView> extends Tools.EventSink implements IViewModel {
        /** @internal */        
        private [_sequence]: Symbol;
        protected _dashboardModel: DashboardModel;
        protected _view: V;
        protected _id: string;
        
        constructor()  {
            super();
            this.on(Tools.EventType.Attach, this._onAttach, this);
        }
        
        protected abstract _filter(view: IView): boolean;
        
        protected _onDirty(event?: Tools.IEvent<DashboardModel, IDashboardEventData>): void {
            let dashboard = this.dashboardModel?.dashboard,
                sequence = this[_sequence] = Symbol();
            
            delete this._view;
            this.fireEvent(Tools.EventType.Attach, <IViewModelEventData>{sequence: sequence, data: event?.data, dashboard: dashboard});
        }

        public setId(value?: string) : boolean {
            if (this._id !== value) {
                this._id = value;
                this._onDirty();
                return true;
            }
        }
        
        public set dashboardModel(value: DashboardModel) {
            if (this._dashboardModel !== value) {
                this._dashboardModel && this._dashboardModel.off(Tools.EventType.Dirty, this._onDirty, this);
                value ? (this._dashboardModel = value).on(Tools.EventType.Dirty, this._onDirty, this) : delete this._dashboardModel;
                this._onDirty();
            }
        }

        public get dashboardModel(): DashboardModel {
            return this._dashboardModel;
        }

        public get id(): string {
            return (this._view && this._view.id) || this._id;
        }

        public get name(): string {
            return this._view && this._view.name;
        }

        public get label(): string {
            return this.name;
        }

        public getView<V2 = V>(): Promise<V2> {
            return this[_sequence] ?
                new Promise(resolve => this.notify(Tools.EventType.Attach, () => resolve(<any>this._view))):
                Promise.resolve(<any>this._view);
        }
                
        public getType(): Promise<ViewType> {
            return this.getView().then(view => view && view.type);
        }

        public get properties(): ReadonlyArray<IDashboardProperty> {
            return this._view && this._view.properties;
        }
        
        public get dashboard(): IDashboard {
            return this.dashboardModel?.dashboard;
        }
        
        protected _onAttach(event: Tools.IEvent<this, IViewModelEventData>): void {
            let data = event.data,
                dashboard = data.dashboard;
            
            if (data.sequence === this[_sequence]) {
                delete this[_sequence];
                this._view = dashboard && <V>Tools.findByIdOrName(this._id, dashboard.views, this._filter.bind(this));
                this.fireEvent(Tools.EventType.Dirty, data.data);
            }
        }

        public release(): void {
            this.dashboardModel?.off(Tools.EventType.Dirty, this._onDirty, this);
        }
        
        public getLegendImage(width: number, height: number, horizontal?: boolean, quality?: number): Promise<string|void> {
            return this._view ? this._view.getLegend(width, height, horizontal, quality) : Promise.resolve();
        }
    }

    export class MapModel extends ViewModel<IMapView> implements IMapModel {
        protected _foreignData: {
            readonly dataModel: Data.IRowCollection & Data.IKeyProvider;
            readonly thematics: Globals.ILayerLegendData;
        }[];
        
        protected _filter(view: IView): boolean {
            return view.type === ViewType.map;
        }

        public setId(value: string): boolean {
            return super.setId(value) && (delete this._foreignData, true);
        }
        
        public setLayerForeignData(indice: number, foreignData?: {readonly dataModel: Data.IRowCollection & Data.IKeyProvider; readonly thematics: Globals.ILayerLegendData;}): void {
            (this._foreignData || (this._foreignData = []))[indice] = foreignData;
        }
        
        public getLayerCount(): Promise<number> {
            return this.getView().then((view: IMapView) => view ? view.descriptor.layerCount : 0);
        }

        public getMapTemplate(): Promise<string> {
            return this.getView().then(view => view && view.descriptor.mapTemplate);
        }

        public async getDescriptors(): Promise<ReadonlyArray<IMapLayerDescriptor>> {
            let view = await this.getView(),
                descriptor = view.descriptor,
                promises: Promise<IMapLayerDescriptor>[] = [];
                
            for (let i = 0; i < descriptor.layerCount; ++i) {
                promises.push(descriptor.getLayer(i));
            }
            return Promise.all(promises);
        }
        
        public async getLayer(indice: number): Promise<Globals.IMapLayerStaticModel> {
            let view = await this.getView(),
                layer = this._foreignData && this._foreignData[indice] ? 
                    Object.assign({descriptor: await view.descriptor.getLayer(indice)}, this._foreignData[indice]):
                    await view.getLayer(indice);
            return layer?.descriptor && new Globals.MapLayerStaticModel(layer.descriptor.template, layer.dataModel, layer.thematics);
        }
        
        public getBbox(): Promise<Tools.Geometry.Rectangle> {
            return this.getView().then(view => view && view.getBbox());
        }
    }

    function _getPosition(value: string): {x: number; y: number;} {
        let regexp: RegExp = /^([a-z]+)([0-9]+)$/;
        let res: RegExpMatchArray = value.toLowerCase().match(regexp);

        if (res && (res.length === 3)) {
            let x: number = 0;

            for (let i: number = 0; i < res[1].length; ++i) {
                x = (x * 26) + res[1].charCodeAt(i) - /* 'a'.charCodeAt(0) */97;
            }
            return {
                x: x,
                y: parseInt(res[2]) - 1
            }
        }
    }
        
    class GridDataSource implements Data.IDataContainer {
        protected readonly _gridData: IGridData;
        
        constructor(gridData: IGridData) {
            this._gridData = gridData;
        }
        
        public getData(key: string, stringify?: boolean): any {
            let position: {x: number; y: number;};
            let items: IGridCell[][];
            let line: IGridCell[];
            
            if (position = _getPosition(key)) {
                if (this._gridData.rowHeaders && this._gridData.rowHeaders.visibility && this._gridData.rowHeaders.items) {
                    position.x -= 1;
                }
                
                if (this._gridData.columnHeaders && this._gridData.columnHeaders.visibility && this._gridData.columnHeaders.items) {
                    if (!position.y) {
                        return position.x < 0 ? '' : this._gridData.columnHeaders.items[position.x].name;
                    }
                    position.y -= 1;
                }
                
                if (position.x < 0) {
                    return this._gridData.rowHeaders.items[position.y].name;
                } else if ((items = this._gridData.items) && (position.y < items.length) && (position.x < (line = items[position.y]).length)) {
                    return stringify ? line[position.x].text : line[position.x].value;
                }
            }
        }
    }

    export class GridModel<V extends IAggregatedSheet | IDetailedSheet | ISpreadSheet = IAggregatedSheet | IDetailedSheet | ISpreadSheet> extends ViewModel<V> implements IGridModel, Data.IDataContainerProvider {
        protected _foreignData: {
            readonly dataModel: Data.IDataModel; 
            readonly thematic: Globals.IThematicData;
        };
        
        public setId(value: string) : boolean {
            return super.setId(value) && (this._releaseForeignData(), true);
        }
        
        protected _onForeignDirty(event: Data.IDataEvent): void {
            let data = event.data;
            if (!data || data.reset || data.items.every(item => item.committed))
                this.fireEvent(Tools.EventType.Dirty);
        }
        
        protected _releaseForeignData() {
            this._foreignData?.dataModel?.off(Tools.EventType.Dirty, this._onForeignDirty, this);
            delete this._foreignData;
        }
        
        public release(): void {
            super.release();
            this._releaseForeignData();
        }
        
        protected _filter(view: IView): boolean {
            return (view.type === ViewType.aggregatedSheet) || (view.type === ViewType.detailedSheet) || (view.type === ViewType.spreadSheet);
        }

        public setForeignData(foreignData?: {
            readonly dataModel: Data.IDataModel; 
            readonly thematic: Globals.IThematicData;
        }): boolean {
            if (foreignData !== this._foreignData) {
                this._releaseForeignData();
                this._foreignData = foreignData;
                this._foreignData?.dataModel?.on(Tools.EventType.Dirty, this._onForeignDirty, this);
                this._onDirty();
                return true;
            }
        }
        
        public getForeignDataModel(): Data.IDataModel {
            return this._foreignData?.dataModel;
        }
        
        public getGridApp(): Promise<Globals.IGridApp> {
            return this.getView<IDetailedSheet>().then(view => {
                if (view) {
                    let data: Globals.IDetailData = this._foreignData;
                    
                    /* Uncomment when trend symbol in metadata are available */
                    /*return view.type === ViewType.detailedSheet ?
                        Promise.all([view.getMetadata(), data || view.getData()]).then(results => new DetailedGridApp(results[0].sheetProperties, results[1], view.sortedColumns)):
                        view.getGridData().then(data => data && new GridApp(data));*/
                        
                    let detailed = view.type === ViewType.detailedSheet;
                    return detailed && data ? 
                        view.getMetadata().then(async metadata => new DetailedGridApp(metadata.sheetProperties, data, await view.getSortedColumns())):
                        view.getGridData().then(async data => data && new GridApp(data, detailed, view.getSortedColumns && await view.getSortedColumns()));
                }
            });
        }
        
        public getDataContainer(): Promise<GridDataSource> {
            return this.getView().then(view => view && view.getGridData().then((data: IGridData) => new GridDataSource(data)));
        }
    }
    
    export function checkChartData(view: IChart | ISpreadSheet): boolean {
        let descriptor: IChartDescriptor | ISpreadSheetDescriptor,
            chartData: boolean = false;
        
        if (view && (descriptor = <IChartDescriptor | ISpreadSheetDescriptor> view.descriptor) && ((descriptor.type === ViewType.chart) || (descriptor.type === ViewType.spreadSheet) || (descriptor.type === ViewType.detailedChart))) {
            switch (descriptor.chartType) {
                case ChartType.pie:
                case ChartType.doughnut:
                case ChartType.barHorizontal:
                case ChartType.bar:
                case ChartType.radar:
                case ChartType.stackedBar:
                case ChartType.stackedBarHorizontal:
                    chartData = true;
                    break;
            }
        }
        return chartData;        
    }
    
    export class ChartModel<V extends IChart | ISpreadSheet | IReport = IChart | ISpreadSheet | IReport> extends ViewModel<V> implements IChartModel, IReportModel {
        protected _filter(view: IView): boolean {
            return (view.type === ViewType.chart) || (view.type === ViewType.report) || (view.type === ViewType.spreadSheet) || (view.type === ViewType.detailedChart);
        }

        public get drawable(): boolean {
            return this._view && ((this._view.type === ViewType.report) || checkChartData(<IChart | ISpreadSheet>this._view));
        }

        public getImage(width: number, height: number, page?: number): Promise<string|void> {
            return this.getView().then(view => view && view.getImage(width, height, page));
        }
        
        public getChartData(): Promise<Globals.IChartModel|void> {
            return this.getView<IChart | ISpreadSheet>().then(view => view && view.getChartData && view.getChartData());
        }

        public getReportMetadata(): Promise<Globals.IReportMetadata|void> {
            return this.getView<IReport>().then(view => view && view.descriptor.getReportMetadata && view.descriptor.getReportMetadata());
        }
        
        public getReportData(): Promise<IReportContentData|void> {
            return this.getView<IReport>().then(view => view && view.getReportData && view.getReportData());
        }
    }

    export class DashboardModel extends Tools.EventSink {
        protected _dashboard: IDashboard;

        constructor(dashboard?: IDashboard) {
            super();
            this.dashboard  = dashboard;
            this.on(Tools.EventType.Attach, this._onAttach, this);
        }

        private _onAttach(event: Tools.IEvent<this, IDashboardEventData>): void {
            this.fireEvent(Tools.EventType.Dirty, event?.data);
        }

        private _onDirty(event: Tools.IEvent<IDashboard, IDashboardEventData>): void {
            this.fireEvent(Tools.EventType.Attach, event?.data);
        }

        public get dashboard(): IDashboard {
            return this._dashboard;
        }

        public set dashboard(dashboard: IDashboard) {
            if (this._dashboard !== dashboard) {
                this.release();
                dashboard && (this._dashboard = dashboard).on(Tools.EventType.Dirty, this._onDirty, this);
                this.fireEvent(Tools.EventType.Attach);
            }
        }
        
        public get id(): string {
            return this._dashboard && this._dashboard.id;
        }

        public get name(): string {
            return this._dashboard && this._dashboard.name;
        }

        public get levels(): ReadonlyArray<IGeographicalLevel> {
            return this._dashboard && this._dashboard.descriptor.levels;
        }

        public get properties(): ReadonlyArray<IDashboardProperty> {
            return this._dashboard && this._dashboard.descriptor.properties;
        }

        public release(): void {
            if (this._dashboard) {
                this._dashboard.off(Tools.EventType.Dirty, this._onDirty, this);
                delete this._dashboard;
                this.fireEvent(Tools.EventType.Attach);
            }
        }
    }
};