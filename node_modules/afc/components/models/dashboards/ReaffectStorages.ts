/**
 * Created by jean.rennes on 24/02/2021.
 */
///<reference path="../../AFC.ts" />

namespace AFC.Dashboards {
    export type ZoneReaffectableType = ZoneType.radius | ZoneType.isodistance | ZoneType.isochrone | ZoneType.predefined | ZoneType.bulkMail;
    
    export type IDescriptorsForReaffect<T extends ZoneReaffectableType = ZoneReaffectableType> = ZoneDescriptorForZoneType[T];

    export interface IReaffectStorage extends Tools.IObservable<IReaffectStorage> {
        readonly id: symbol;
        readonly table: string;
        readonly mode: ZoneReaffectStorage;
        readonly commit: boolean;
        load(): Promise<void>;
        updateContext(zone: IZone, data: IDashboardContextDataBase): string | void;
        isRedistricted(site: number | string): boolean;
        reset(site: number | string): Promise<void>;
        affect(site: number | string, unit: string, subset: string): Promise<void>;
        applyChanges(site: number | string, unit: string, values: {[key: string]: any}): Promise<void>;
        delete(site: number | string, unit: string): Promise<void>;
        getOwnership(site: number | string, unit: string): Promise<void>;
        release(): void;
    }
    
    export interface IReaffectStorages {
        load(): Promise<ReadonlyArray<IReaffectStorage>>;
        createStorage(descriptor: IDescriptorsForReaffect, districtingMode: ZoneReaffectStorage, zones?: ReadonlyArray<IZone>): IReaffectStorage;
        get(descriptor: IDescriptorsForReaffect): IReaffectStorage;
        invalidate(reaffectStorage: IReaffectStorage): void;
    }

    export const enum OperationType {
        reset = 1,
        update,
        getOwnership,
        delete
    }
    
    interface IDistrictRequestEvent {
        value?: {[key: string]: any[];};
        reset?: boolean;
        branch?: string;
        site: number | string;
    }
    
    
    export interface IResetOperation {
        type: OperationType.reset;
        events: IDistrictRequestEvent[];
        getOperation(): {
            type: string;
            events: IDistrictRequestEvent[];
        };
    }
    
    export interface IUpdateOperation {
        readonly pure: boolean;
        type: OperationType.update;
        events: {
            site: any;
            branch?: string;
            units: {[key: string]: string | {[key: string]: any;}};
        }[];
        getOperation(): {
            type: string;
            events: IDistrictRequestEvent[]|{
                site: any;
                branch?: string;
                units: {
                    unit: string;
                    values: {[key: string]: any};
                }[];
            }[];
        };
    };                            

    export interface IOwnershipOperation {
        type: OperationType.getOwnership;
        events: {
            site: any;
            branch?: string;
            units: string[];
        }[];
        getOperation(): {
            type: string;
            events: {
                site: any;
                branch?: string;
                units: string[];
            }[];
        };
    }    

    export interface IDeleteOperation {
        type: OperationType.delete;
        events: {
            site: any;
            branch?: string;
            units: string[];
        }[];
        getOperation(): {
            type: string;
            events: {
                site: any;
                branch?: string;
                units: string[];
            }[];
        };
    }
        
    type Operation = (IUpdateOperation | IResetOperation | IOwnershipOperation | IDeleteOperation) & IOperationImpl;
    
    export type IDistrictOperation = IUpdateOperation | IResetOperation | IOwnershipOperation | IDeleteOperation;
    
    export type IDistrictEvent = Tools.IEvent<IReaffectStorage, IDistrictOperation[]>;
    
    interface IOperationImpl {
        readonly zone: IZone;
        readonly promise: Promise<void>;
        merge(operation: Operation): boolean;
        send(): Promise<void>;
        push(descriptor: IDescriptorsForReaffect, operations: Operation[]): Operation;
    }

    abstract class OperationImpl implements IOperationImpl {
        private _resolve: ()=> void;
        public abstract type: Operation['type'];
        public readonly zone: IZone;
        public readonly promise: Promise<void>;
        
        constructor(zone: IZone, commit: boolean) {
            this.zone = zone;
            this.promise = commit && new Promise(resolve => this._resolve = resolve);
        }
        
        public async send(): Promise<void> {
            let operation = this.getOperation();
            
            if (operation.events.length) {
                let promise = this.zone.createRequest<{operation: ReturnType<Operation['getOperation']>}>('/districting', DistrictType.redistricting),
                    request = await promise[1],
                    data = request.options.data;

                data.operation = {
                    type: operation.type,
                    events: operation.events
                };
                request.options.always = (/*sequence: number, jqXHR: JQuery.jqXHR, textStatus: string*/) => this._resolve();
                request.call();
            } else {
                this._resolve();
            }
            return this.promise;
        }
        
        public merge(operation: Operation): boolean {
            return false;
        }
        
        public abstract getOperation(): ReturnType<Operation['getOperation']>;
        public abstract push(descriptor: IDescriptorsForReaffect, operations: Operation[]): Operation;
    }
    
    function _findEvent<T extends {events: ReadonlyArray<{site: any;branch?: string;}>}>(operation: T, site: number | string, branch: string): number {
        return operation.events.findIndex(event => event.site === site && event.branch === branch);
    }
    
    function _castUpdateValue(event: IUpdateOperation['events'][0]): {[key: string]: any[];} {
        let value: {[key: string]: any[];} = {};
        for (let unit in event.units) {
            let id = <string>event.units[unit];
            (value[id] || (value[id] = [])).push(unit);
        }
        return value;
    }
    
    function _castApplyValue(event: IUpdateOperation['events'][0]): {
        unit: string;
        values: {[key: string]: any};
    }[] {
        let units: ReturnType<typeof _castApplyValue> = [];
        
        for (let unit in event.units) {
            let values = <{[key: string]: any}>event.units[unit];
            units.push({unit: unit, values: values});
        }
        return units;
    }
    
    class UpdateOperation extends OperationImpl implements IUpdateOperation {
        public pure: boolean;
        public events: IUpdateOperation['events'];
        
        constructor(zone: IZone, commit: boolean, site: number | string, branch: string, unit: string, affect: boolean, change: string | {[key: string]: any}) {
            let event: IUpdateOperation['events'][0] = {site: site, units: {}};
            
            super(zone, commit);
            this.pure = affect;
            branch && (event.branch = branch);
            event.units[unit] = change;
            this.events = [event];
        }

        public get type(): OperationType.update {
            return OperationType.update;
        }
                
        public push(descriptor: IDescriptorsForReaffect, operations: Operation[]): Operation {
            let operation = operations.length && <UpdateOperation>operations[operations.length - 1]; // assume type for convenience
            
            if (operation && operation.type === OperationType.update) {
                let pure = operation.pure && this.pure,
                    dataNode: IDataNode,
                    check = (val: string | {[key: string]: any}, pure: boolean): {[key: string]: any} => {
                        let values: {[key: string]: any} = <{[key: string]: any}>val,
                            subset;
                        
                        if (pure) {
                            dataNode || (dataNode = descriptor.dataNodes.find(dataNode => dataNode.qualifier === DataQualifier.partition));
                            subset = descriptor.partition.subsets.find(subset => subset.id === <string>val);
                            values = {[dataNode.name]: subset.value};
                        }
                        return values;
                    },
                    sourceOp: UpdateOperation, targetOp: UpdateOperation;
                    
                if (this.pure) {
                    sourceOp = this;
                    targetOp = operation;
                } else {
                    sourceOp = operation;
                    targetOp = this;
                }

                sourceOp.events.forEach(source => {
                    let index = _findEvent(operation, source.site, source.branch),
                        target;
                        
                    index === -1 ? targetOp.events.push(target = {site: source.site, branch: source.branch, units: {}}) : target = targetOp.events[index];
                    for (let key in source.units) {
                        if (pure) {
                            target.units[key] = source.units[key];  // subset id copy
                        } else {
                            target.units[key] = $.extend(check(target.units[key], targetOp.pure), check(source.units[key], sourceOp.pure));
                        }
                    } 
                });
                operation.pure = pure;
                operation.events = targetOp.events;
            } else {
                operations.push(this);
            }
            return this;
        }
        
        public getOperation(): ReturnType<IUpdateOperation['getOperation']> {
            return this.pure ? {
                type: 'update',
                events: this.events.map(event => ({
                    site: event.site,
                    branch: event.branch,
                    value: _castUpdateValue(event)
                }))
            }:{
                type: 'applyChanges',
                events: this.events.map(event => ({
                    site: event.site,
                    branch: event.branch,
                    units: _castApplyValue(event)
                }))
            };

        }
    }
    
    function _remove(operations: Operation[], operation: IUpdateOperation, position: number, site: number | string, branch: string) {
        let index = _findEvent(operation, site, branch);
        if (index !== -1) {
            operation.events.length === 1 ?
                operations.splice(position, 1):
                operation.events.splice(index, 1);
        }
    }
    
    class ResetOperation extends OperationImpl implements IResetOperation {
        public events: IResetOperation['events'];
        
        constructor(zone: IZone, commit: boolean, site: number | string, branch: string) {
            let event: IResetOperation['events'][0] = {site: site, reset: true};
            
            super(zone, commit);
            branch && (event.branch = branch);
            this.events = [event];
        }

        public get type(): OperationType.reset {
            return OperationType.reset;
        }
                
        public push(descriptor: IDescriptorsForReaffect, operations: Operation[]): Operation {
            this.events = this.events.reduceRight((accumulator, event) => {
                let push = true;
                
                for (let i = operations.length; i > 0; --i) {
                    let operation = operations[i - 1];
                    
                    if (operation.type === OperationType.update) {
                        _remove(operations, operation, i - 1, event.site, event.branch);
                    } else {
                        if (operation.type === OperationType.reset) {
                            push = false;
                            _findEvent(operation, event.site, event.branch) === -1 && operation.events.push(event);
                        }
                        break;
                    }
                }
                push && accumulator.push(event);
                return accumulator;
            }, []);
            this.events.length && operations.push(this);
            return this;
        }
        
        public getOperation(): ReturnType<IResetOperation['getOperation']> {
            return {
                type: 'update',
                events: this.events
            };
        }
        
        public merge(operation: Operation): boolean {
            if (operation && operation.type === OperationType.update && operation.pure) {
                operation.events.forEach(event => {
                    let index = _findEvent(this, event.site, event.branch);
                    index === -1 ?
                        this.events.push(event):
                        this.events[index].value = _castUpdateValue(event);
                });
                return true;
            }
        }        
    }
    
    const _OperationTypeLookup = {
        [OperationType.delete]: 'delete',
        [OperationType.getOwnership]: 'getOwnership'
    }
    
    function _generator<T extends keyof typeof _OperationTypeLookup>(t: T): { 
        new(zone: IZone, commit: boolean, site: number | string, branch: string, value: string): Operation;
        readonly prototype: Operation;
    } {
        class _DerivedOperation extends OperationImpl {
            public readonly type: T;
            public events: IOwnershipOperation['events'];

            constructor(zone: IZone, commit: boolean, site: number | string, branch: string, unit: string) {
                let event: IOwnershipOperation['events'][0] = {site: site, units: [unit]};

                super(zone, commit);
                this.type = t;
                branch && (event.branch = branch);
                this.events = [event];
            }
            
            public push(descriptor: IDescriptorsForReaffect, operations: Operation[]): Operation {
                let operation = operations.length && <_DerivedOperation>operations[operations.length - 1]; // assume type for convenience

                if (operation && operation.type === this.type) {
                    this.events.forEach(event => {
                        let index = _findEvent(operation, event.site, event.branch);
                        index === -1 ? operation.events.push(event) : operation.events[index].units.push(...event.units);
                    });
                } else {
                    operations.push(<Operation>this);
                }
                return <Operation>this;
            }

            public getOperation(): ReturnType<IOwnershipOperation['getOperation']> {
                return {
                    type: _OperationTypeLookup[this.type],
                    events: this.events
                };
            }
        };
        return <any>_DerivedOperation;
    }
    
    const OwnershipOperation = _generator(OperationType.getOwnership);

    const DeleteOperation = _generator(OperationType.delete);
        
    interface IDistrictEventSeed {
        reset?: boolean;
        change?: {
            unit: string;
            pure: true;
            value: string;
            subset: ISubsetDescriptor;
        }|{
            unit: string;
            pure: false;
            value: {[key: string]: any};
            subset?: ISubsetDescriptor;
        };
        delete?: string;
        ownership?: string;
    }
    
    abstract class ReaffectStorage<T extends IDescriptorsForReaffect> extends Tools.EventSink<IReaffectStorage, ReadonlyArray<IDistrictOperation>> implements IReaffectStorage {
        public readonly id: symbol;
        public readonly descriptor: T;
        public readonly partition: IDataNode;
        public readonly storages: ReaffectStorages;
        public commit: boolean;
        private _pendings: Operation[];
        private _zones: ReadonlyArray<IZone<T['type']>>;
        
        constructor(storages: ReaffectStorages, descriptor: T, zones?: ReadonlyArray<IZone<T['type']>>) {
            super();
            this.id = Symbol();
            this.storages = storages;
            this.descriptor = descriptor;
            this.partition = descriptor.dataNodes.find(dataNode => dataNode.qualifier === DataQualifier.partition);
            this.commit = false;
            this._zones = zones;
        }
        
        protected _flush(): void {
            if (this._pendings.length) {
                let operation = this._pendings.shift();
                operation.merge(this._pendings[0]) && this._pendings.shift();
                operation.send().then(() => this._flush());
            } else
                delete this._pendings;
        }
        
        private _commit(zone: IZone, site: number | string, item: IDistrictEventSeed): Operation {
            let branch = zone.dashboard.branch,
                commit: boolean = this.commit && !!this.descriptor.partition.districtingTable,
                operation: Operation;
                
            if (item.delete) {
                operation = new DeleteOperation(zone, commit, site, branch, item.delete);
            } else if (item.ownership) {
                operation = new OwnershipOperation(zone, commit, site, branch, item.ownership);
            } else if (item.reset) {
                operation = new ResetOperation(zone, commit, site, branch);
            } else {
                operation = new UpdateOperation(zone, commit, site, branch, item.change.unit, item.change.pure, item.change.value);
            }
            if (commit) {
                if (this._pendings) {
                    operation.push(this.descriptor, this._pendings);
                } else {
                    this._pendings = [operation];
                    this._flush();
                }
            }
            this.fireEvent(Tools.EventType.Dirty, [operation]);
            return operation;
        }

        private async _update(site: number | string, item: IDistrictEventSeed): Promise<void> {
            let zone = item && this._zones[0],
                operation;
            item = zone && this._apply(zone, site, item);
            if (item) {
                zone.dashboard.invalidateViews(operation = this._commit(zone, site, item));
                this._zones.forEach(zone => zone.invalidate());
                return operation.promise;
            }
        }
        
        /* 
        * For now, the reaffect table is considered not mutable => read it from zone descriptor reference
        * Just in case reaffect table becomes mutable, keep _loadZones async
        */
        protected async _loadZones(): Promise<ReadonlyArray<IZone<T['type']>>> {
            let zones =  this._zones;
            if (!zones) {
                let dashboard = this.dashboard,
                    districtingTable = this.table;
                this._zones = zones = dashboard.zones.filter((zone: IZone<IDescriptorsForReaffect['type']>) => {
                    let partition = zone.reference.partition;
                    return partition && partition.districtingMode !== ZoneReaffectStorage.none && partition.districtingTable === districtingTable;
                });
            }
            return zones;
        }        

        protected abstract _apply(zone: IZone, site: number | string, item: IDistrictEventSeed): IDistrictEventSeed;

        public get table(): string {
            return this.descriptor.partition.districtingTable;
        }
        
        public get mode(): ZoneReaffectStorage {
            return this.descriptor.partition.districtingMode;
        }
        
        public get dashboard(): IDashboard {
            return this.storages.dashboard;
        }
        
        public abstract isRedistricted(site: number | string): boolean;
        public abstract load(): Promise<void>;
        public abstract updateContext(zone: IZone, data: IDashboardContextDataBase): string|void;
        
        public reset(site: number | string): Promise<void> {
            return this._update(site, this.isRedistricted(site) && {reset: true});
        }

        public affect(site: number | string, unit: string, id: string): Promise<void> {
            let subset = this.descriptor.partition.subsets.find(subset => subset.id === id);
            return subset && this._update(site, {change: {unit: unit, pure: true, value: id, subset: subset}});
        }
        
        public getOwnership(site: number | string, unit: string): Promise<void> {
            return this._update(site, {ownership: unit});
        }

        public delete(site: number | string, unit: string): Promise<void> {
            return this._update(site, {delete: unit});
        }
        
        public async applyChanges(site: number | string, unit: string, values: {[key: string]: any}): Promise<void> {
            let keys = Object.keys(values),
                subset,
                change: IDistrictEventSeed['change'];
                
            if (keys.length > 0) {
                if (values.hasOwnProperty(this.partition.name)) {
                    subset = this.descriptor.partition.subsets.find(subset => subset.value === values[this.partition.name]);
                    subset && keys.length === 1 && (change = {unit: unit, pure: true, value: subset.id, subset: subset});
                }
                return this._update(site, {change: change || {unit: unit, pure: false, value: values, subset: subset}});
            }
        }
        
        public abstract release(): void;
    }

    interface IZoneDistrictGet {
        events: ReadonlyArray<IDistrictRequestEvent>;
        branch: string;
        status: number;
    }

    class ReaffectInlineStorage<T extends IDescriptorsForReaffect = IDescriptorsForReaffect> extends ReaffectStorage<T> {
        private _sequence: symbol;
        private _units: {[key: string]: {[key: string]: string;};};
        private _zoneEntries: {
            [key: string] : {
                sites: (number | string)[];
                affected?: IZoneRedistrictData[];
            }
        };
        
        public override release(): void {
            delete this._sequence;
            delete this._units;
            delete this._zoneEntries;
        }
        
        protected _apply(zone: IZone, site: number | string, item: IDistrictEventSeed): IDistrictEventSeed {
            let units = this._units,
                subset;
            
            if (units) {
                if ((item.change && (subset = item.change.subset)) || item.delete) {
                    let entry = units[site] || (units[site] = {});
				
                    if (item.delete) {
                        entry[item.delete] = 'deleted';
                    } else {
                        let unit = item.change.unit;
					
                        item.change.pure || (item = {change: {unit: unit, pure: true, value: subset.id, subset: subset}});
                        entry[unit] = subset.id;
                    }
                } else if (item.reset) {
                    delete units[site];
                    this._sequence = Symbol();
                } else if (item.ownership) {
                    let site2: string;
                
                    if (subset = this.descriptor.partition.subsets.find(subset => subset.type === ZoneType.outOfZone)) {
                        for (site2 in units) {
                            if (site !== site2) {
                                let entry = units[site2];
                                entry[item.ownership] = subset.id;
                            }
                        }
                    }
                } else {
                    item = null;
                }
            }
            if (item) {
                for (let key in this._zoneEntries)
                    delete this._zoneEntries[key].affected;
            }
            return item;
        }
        
        public isRedistricted(site: number | string): boolean {
            let entry;
            return this._units && (entry = this._units[site]) && !!Object.keys(entry).length;
        }
        
        public async load(): Promise<void> {
            return this._units ? void 0 : new Promise(async resolve => {
                this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve());
                if (!this._sequence) {
                    let sym = this._sequence = Symbol(),
                        units: {[key: string]: {[key: string]: string;};} = {},
                        zoneEntries: {[key: string]: {sites: (number | string)[];}} = this._zoneEntries = {},
                        sync = new Tools.Synchronizer(() => {
                            if (sym === this._sequence) {
                                this._units = units;
                                this._zoneEntries = zoneEntries;
                                this.fireEvent(Tools.EventType.UserEvent);
                            }
                        }),
                        h = (zone: IZone, data: IZoneDistrictGet) => {
                            if (sym === this._sequence) {
                                data?.events?.forEach(event => {
                                    let entry: {[key: string]: string;} = units[event.site] = {},
                                        zoneEntry = zoneEntries[zone.id];

                                    zoneEntry.sites.push(event.site);
                                    for (let subset in event.value) {
                                        event.value[subset].forEach(code => (entry[code] = subset));
                                    }
                                });
                            }                            
                        },
                        zones = this.dashboard && await this._loadZones();
                    
                    zones.forEach(zone => {
                        let sites: (string|number)[];
                        if (zone.reference.partition.districtingTable) {
                            let current = zone.cluster.current,
                                branch = this.dashboard.branch,
                                h2 = sync.push((sequence: number, jqXHR: JQueryXHR, textStatus: string) => h(zone, jqXHR.responseJSON));

                            zone.createRequest<{
                                        operation: {
                                            type: 'get';
                                            sites: {
                                                branch?: string;
                                                cannibalization?: boolean;
                                                site: any;
                                            }[];
                                        }
                            }>('/districting', DistrictType.redistricting)[1].then(request => {
                                let site: typeof request.options.data.operation.sites[0] = {
                                    site: current
                                };
                                zone.reference.hasCannibalization && (site.cannibalization = true);
                                branch && (site.branch = branch);
                                request.options.data.operation = {
                                    type: 'get',
                                    sites: [site]
                                };
                                request.options.always = h2;
                                request.call();
                            });
                            sites = [];
                        } else {
                            sites = [zone.cluster.current];
                        }
                        zoneEntries[zone.id] = {sites: sites};
                    });
                    sync.start();
                }
            });
        }
        
        public updateContext(zone: IZone, data: IDashboardContextDataBase): string|void {
            let zoneEntry = this._units && this._zoneEntries[zone.id],
                affected: IZoneRedistrictData[];

            if (zoneEntry) {
                affected = zoneEntry.affected;
                if (!affected) {
                    zoneEntry.affected = affected = [];
                    zoneEntry.sites.forEach(site => {
                        let entry = this._units[site],
                            subset,
                            value: {[key: string]: any[]};

                        for (let code in entry) {
                            subset = entry[code];
                            ((value || (value = {}))[subset] || (value[subset] = [])).push(code);
                        }
                        if (value) {
                            let zoneRedistrictData: Mutable<IZoneRedistrictData> = {
                                zone: zone.id,
                                value: value
                            };
                            (site !== zone.cluster.current) && (zoneRedistrictData.site = site);
                            affected.push(zoneRedistrictData);
                        }
                    });
                }
                affected.length && (data.districting || (data.districting = [])).push(...affected);                
            }
        }
    }
    
    function _applyValues(dataModel: Data.DataModel, site: number | string, unit: string, values: {[key: string]: any}): boolean {
        let key = [site, unit],
            indice = dataModel.lowerKeyBound(key),
            row = dataModel.getRow(indice);
        return row && !dataModel.compareKey(row, key) ? 
            dataModel.modifyAt(indice, values) : 
            dataModel.createAt(indice, Data.createRowFromValues(dataModel, key, values));
    }
    
    async function _getTable(restModel: AFC.Rest.RestModel, name: string): Promise<AFC.Data.IDBTableDefinition> {
        let table = AFC.Tools.Data.splitSQLName(name),
            descriptor = await AFC.Data.getTable(restModel.schema, table.dbName, table.name);
        return descriptor?.getDefinition();
    }
    
    class ReaffectEditableStorage extends ReaffectStorage<IPredefinedAreaDescriptor> {
        private _sequence: symbol;
        private _dataModel: Data.DataModel;
        private _entry: Rest.IDataCreatorEntry;
        private _siteCode: number;
        private _geographicalCode: number;
        private _partition: number;
        private _redistricted: {[key: number|string]: boolean};
        
        private _onRequest(sequence: Symbol, data: Parameters<typeof AFC.Data.updateTableData>[0], resolve: (dataModel: Data.IDataTable)=> any, reject: ()=> any): void {
            sequence === this._sequence ? resolve(data && AFC.Data.updateTableData(data)) : reject();
        }
        
        public override release(): void {
            if (this._entry) {
                this.dashboard.requestBuilder.discardData(this._entry.key);
                delete this._sequence;
                delete this._dataModel;
                delete this._entry;
                delete this._siteCode;
                delete this._geographicalCode;
                delete this._partition;
                delete this._redistricted;
            }
        }
        
        protected _set(site: number | string): void {
            (this._redistricted || (this._redistricted = {}))[site] = true;
        }
        
        protected _apply(zone: IZone, site: number | string, item: IDistrictEventSeed): IDistrictEventSeed {
            let dataModel = this._dataModel;
            
            if (dataModel) {
                if (item.change) {
                    let values = item.change.pure ?
                        {[dataModel.columns[this._partition].name]: item.change.subset.value}:
                        <{[key: string]: any}>item.change.value;
                    
                    _applyValues(dataModel, site, item.change.unit, values) ? this._set(site) : (item = null);
                } else if (item.reset) {
                    // TODO find suitable way to synchronize commit with reload when possible
                    delete this._redistricted;
                    dataModel.setValues([]);
                } else if (item.ownership) {
                    let subset = this.descriptor.partition.subsets.find(subset => subset.type === ZoneType.outOfZone),
                        values = {
                            [dataModel.columns[this._partition].name]: subset.value
                        };
                    
                    values && dataModel.values.forEach((row, indice) => row[this._siteCode] !== site && row[this._geographicalCode] === item.ownership && dataModel.modifyAt(indice, values) && this._set(row[this._siteCode]));
                } else if (item.delete) {
                    dataModel.delete_([site, item.delete]) || (item = null);;
                }
            }
            return item;
        }
        
        public isRedistricted(site: number | string): boolean {
            return this._redistricted && this._redistricted[site];
        }
        
        public async load(): Promise<void> {
            return this._entry ? void 0 : new Promise(async resolve => {
                this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve());
                if (!this._sequence) {
                    let sym = this._sequence = Symbol(),
                        acc: {[key: string]: true} = {},
                        zones = this.dashboard && await this._loadZones(),
                        dataModels;
                    
                    dataModels = await Promise.all(zones.map(zone => {
                        let current = zone.cluster.current;
                        
                        if (!acc[current] || zone.reference.hasCannibalization) {
                            let branch = this.dashboard.branch,
                                districtingTable = zone.reference.partition.districtingTable;

                            acc[current] = true;
                            return Promise.all([
                                districtingTable && zone.createRequest<{
                                    operation: {
                                        type: 'getData';
                                        branch?: string;
                                        sites?: (string|number)[];
                                    }
                                }>('/districting', DistrictType.redistricting)[1].then(request => new Promise<Data.IDataTable>((resolve, reject) => {
                                    let operation: typeof request.options.data.operation = request.options.data.operation = {
                                        type: 'getData',
                                    };
                                    branch && (operation.branch = branch);
                                    zone.reference.hasCannibalization || (operation.sites = [current]);
                                    request.options.always = (sequence: number, jqXHR: JQueryXHR/*, textStatus: string*/) => this._onRequest(sym, jqXHR.responseJSON, resolve, reject);
                                    request.call();
                                })),
                                zone.createRequest<{
                                    dataSourceKind: string;
                                    indicators: ReadonlyArray<string>;
                                }>('/content', DistrictType.redistricting)[1].then(request => new Promise<Data.IDataTable>((resolve, reject) => {
                                    let indicators: string[] = [];
                                
                                    zone.reference.dataNodes.forEach(dataNode => {
                                        if (!dataNode.qualifier || dataNode.qualifier === DataQualifier.code || dataNode.qualifier === DataQualifier.partition) {
                                            indicators.push(dataNode.id);
                                        }
                                    });
                                    request.options.data.dataSourceKind = dataSourceKind(zone.reference.hasCannibalization ? DataSourceKind.cannibalization : DataSourceKind.outOfZone);
                                    request.options.data.indicators = indicators;
                                    request.options.always = (sequence: number, jqXHR: JQueryXHR/*, textStatus: string*/) => this._onRequest(sym, jqXHR.responseJSON?.table, resolve, reject)
                                    request.call();
                                })),
                                districtingTable || _getTable(zone.dashboard.descriptor.restModel, zone.reference.areaTable)
                            ]).then(([districtDataModel, zoneContentDataModel, definition]) => {
                                let key = [zone.reference.siteCodeColumn, zone.reference.geographicalCodeColumn],
                                    dataModel: AFC.Data.DataModel,
                                    values = zoneContentDataModel.values,
                                    siteCode: number,
                                    index: number[],
                                    setDataModel = (d: AFC.Data.DataModel) => {
                                        let columnIndex = d.columnIndex;
                                        
                                        dataModel = d;
                                        index = new Array(dataModel.columns.length).fill(-1);
                                        zone.reference.dataNodes.forEach(dataNode => {
                                            let i = zoneContentDataModel.columns.findIndex(column => column.dataId === dataNode.id);
                                            if (i !== -1) {
                                                switch(dataNode.qualifier) {
                                                    case DataQualifier.code:
                                                        index[columnIndex[zone.reference.geographicalCodeColumn]] = i;
                                                        break;
                                                    case DataQualifier.partition:
                                                        index[columnIndex[zone.reference.partitionColumn]] = i;
                                                        break;
                                                    case void 0:
                                                        index[columnIndex[dataNode.name]] = i;
                                                        break;
                                                }
                                            }
                                        });
                                        siteCode = columnIndex[zone.reference.siteCodeColumn];
                                    },
                                    createRow = (row: ReadonlyArray<any>) => index.map((i, j) => i === -1 ? (j === siteCode ? current : null) : row[i]);
                                
                                if (districtDataModel) {
                                    setDataModel(new AFC.Data.DataModel(districtDataModel.columns, key, districtDataModel.values));
                                    
                                    let localKey = [current],
                                        geographicalCodeColumn = index[dataModel.columnIndex[zone.reference.geographicalCodeColumn]];

                                    dataModel.values.forEach(row => this._set(row[siteCode]));
                                    values.forEach(row => {
                                         localKey[1] = row[geographicalCodeColumn];

                                        let indice = dataModel.lowerKeyBound(localKey),
                                            row0 = dataModel.values[indice];
                                        (!row0 || dataModel.compareKey(row0, localKey)) && dataModel.createAt(indice, createRow(row));
                                    });
                                } else {
                                    setDataModel(new AFC.Data.DataModel((<Data.IDBTableDefinition>definition).columns, key));
                                    dataModel.setValues(values.map(createRow), true);
                                }
                                return dataModel;
                            });
                        }
                    }));
                    if (dataModels) {
                        let dataModel: Data.DataModel = dataModels.reduce((acc, dataModel) => Tools.Data.mergeTables(acc, dataModel)),
                            dataNode: IDataNode,
                            partitionColumn: number,
                            siteCodeColumn: number,
                            geographicalCodeColumn: number;

                        if (dataModel) {
                            dataNode = this.descriptor.dataNodes.find(dataNode => dataNode.qualifier === DataQualifier.partition);
                            partitionColumn = dataNode ? dataModel.columnIndex[dataNode.name] : void 0;
                            siteCodeColumn = partitionColumn !== void 0 && dataModel.columnIndex[this.descriptor.siteCodeColumn];
                            geographicalCodeColumn = siteCodeColumn !== void 0 && dataModel.columnIndex[this.descriptor.geographicalCodeColumn];
                            if (geographicalCodeColumn !== void 0) {
                                this._dataModel = dataModel;
                                this._entry = this.dashboard.requestBuilder.createData(dataModel, true);
                                this._siteCode = siteCodeColumn;
                                this._geographicalCode = geographicalCodeColumn;
                                this._partition = partitionColumn;
                            }
                        }
                    }
                    this.fireEvent(Tools.EventType.UserEvent);
                }
            });
        }
        
        public updateContext(zone: IZone, data: IDashboardContextDataBase): string|void {
            let resource = this._entry;
            if (resource) {
                resource.show = true;
                return resource.key;
            }
        }
    }

    class ReaffectStorages extends Tools.EventSink implements IReaffectStorages {
        private _loaded: Symbol;
        private _storages: IReaffectStorage[];
        private _index: {[key: string]: ReaffectStorage<any>;} = {};
        public readonly dashboard: IDashboard;
        
        constructor(dashboard: IDashboard) {
            super();
            this.dashboard = dashboard;
        }
        
        public async load(): Promise<ReadonlyArray<IReaffectStorage>> {
            return this._storages || new Promise(async resolve => {
                this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve(this._storages));
                if (!this._loaded) {
                    let storages: IReaffectStorage[];

                    this._loaded = Symbol();
                    storages = await Promise.all(this.dashboard.zones.map(zone => zone.getReaffectStorage()));
                    await Promise.all(storages.reduce((acc, reaffectStorage) => {
                        if (reaffectStorage && !acc[reaffectStorage.id]) {
                            acc.push(acc[reaffectStorage.id] = reaffectStorage.load());
                        }
                        return acc;
                    }, <{[key: symbol]: Promise<void>} & Promise<void>[]>[]));
                    this._storages = storages;
                    this.fireEvent(Tools.EventType.UserEvent);
                }
            });
        }

        public createStorage(descriptor: IDescriptorsForReaffect, districtingMode: ZoneReaffectStorage, zones?: ReadonlyArray<IZone>): ReaffectStorage<any> {
            if (descriptor.partition) {
                let reaffectStorage: ReaffectStorage<any> = districtingMode === ZoneReaffectStorage.editable && descriptor.type === ZoneType.predefined ?
                        new ReaffectEditableStorage(this, <IPredefinedAreaDescriptor><any>descriptor, zones):
                        new ReaffectInlineStorage(this, descriptor, zones),
                    storages = this._storages;

                storages && zones && zones.forEach(zone => storages[this.dashboard.zones.indexOf(zone)] = reaffectStorage);
                return reaffectStorage;
            }                
        }

        public get(descriptor: IDescriptorsForReaffect): ReaffectStorage<any> {
            let reaffectStorage: ReaffectStorage<any>,
                partition = descriptor.partition,
                districtingTable: string;
            
            if ((districtingTable = partition?.districtingTable) && partition.districtingMode !== ZoneReaffectStorage.none) {
                reaffectStorage = this._index[districtingTable];
                if (!reaffectStorage) {
                    reaffectStorage = this.createStorage(descriptor, partition.districtingMode);
                    reaffectStorage.commit = true;
                    this._index[districtingTable] = reaffectStorage;
                }
            }
            return reaffectStorage;
        }
        
        public invalidate(reaffectStorage: IReaffectStorage): void {
            if (reaffectStorage && this._index[reaffectStorage.table]) {
                reaffectStorage.release();
                delete this._loaded;
                delete this._storages;
            }
        }
    }
    
    export function reaffectStorages(dashboard: IDashboard): IReaffectStorages {
        return new ReaffectStorages(dashboard);
    }
}