/**
 * Created by jean.rennes on 20/01/2021.
 */
///<reference path="Global.ts" />

namespace AFC.PhotoManager {
    const c_Header                  = 'base64,';
    const c_builtInStoreCodeTagName = "CODE_MAG";

    interface ITag {
    }
    interface ITagValue {
        id      : string,
        alias?  : string,
        ordinal?: number,
    }
    interface IPictureTagValue {
        name    : string,
        alias?  : string,
        ordinal?: number,
        value   : ITagValue,
    }
    interface ITagValueRequest {
        name:           string,
        value:          any,
    }
    interface IPictureFormat {
        id:             string,
        width:          number,
        height:         number,
    }
    interface IAlbum {
        id:             string,
        name:           string,
        description:    string
    }
    interface IPicture {
        id:             string,
        name:           string,
        title:          string,
        album:          string,
        creationDate:   Date,
        width:          number,
        height:         number,
        location?:      GeoJSON.Point,
        formats?:       IPictureFormat[],
        tags:           IPictureTagValue[],
    }

    interface IAlbumOperation {
        album?:         string,
        picture?:       string,
        operation:      string,
        tags:           ITagValueRequest[],
    }
    interface IPictureUploadResult {
        error?:         string,
        picture?:       IPicture
    }
    interface IPictureDeleteResult {
        success:        boolean
    }
    
    export interface IPicturesSource {
        deletePicture(picture: Picture) : Promise<boolean>;
        setPictureTagsValues(picture: Picture, tags: ITagValueRequest[]) : Promise<Picture>;
        addPicture(file: File, tags: ITagValueRequest[], pictureToReplace?: Picture) : Promise<Picture>;
        getPictures(tags: ITagValueRequest[]): Promise<Picture[]>;
        getFirstPicture(tags: ITagValueRequest[]) : Promise<Picture>;
        getPicture(pictureId: string) : Promise<Picture>;
    }
            
    const _sequence     = Symbol();

    export class Picture  extends Tools.EventSink {
        public readonly restModel: Rest.RestModel;
        protected _imagesServer: AFC.ServerInfo.ImagesServerInfoProvider;
        protected _picture: IPicture;
        protected _data: {[name: string]: string};
        protected [_sequence]: number;

        constructor(restModel: Rest.RestModel, imagesServer: AFC.ServerInfo.ImagesServerInfoProvider, picture: IPicture) {
            super();
            this[_sequence]     = 0;
            this.restModel      = restModel;
            this._picture       = picture;
            this._data          = {};
            this._imagesServer  = imagesServer;
        }

        public get tags() {
            return this._picture.tags;
        }
        public set tags(tags: ITagValueRequest[]) {
            this._picture.tags = tags;
        }

        public get id() {
            return this._picture.id;
        }
        public get name() {
            return this._picture.name;
        }
        public get title() {
            return this._picture.title;
        }
        public get creationDate() {
            return this._picture.creationDate;
        }
        public get album() {
            return this._picture.album;
        }
        public getTagValue(name: string) : string {
            let value = "";
            for (let t = 0; t < this._picture.tags.length; t++) {
                if (this._picture.tags[t].name.toLowerCase() == name.toLowerCase())
                    return this._picture.tags[t].value.id;
            }
            return "";
        }
        public getData(pictureFormat?: string) : Promise<string> {
            let _this = this;

            if (pictureFormat == null || pictureFormat == "")
                pictureFormat = "original";
            
                if (this._data != null && this._data[pictureFormat] != null)
                    return Promise.resolve(this._data[pictureFormat]);
                return new Promise(async (resolve: (base64: string) => void) => {
                this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve(this._data[pictureFormat]));
                if (!_this[_sequence]) {   
                    this._imagesServer.getServerInfo().then(serverInfo => {
                        let options = {
                            format: AFC.Rest.RestFormat.native,
                            data: {pictureformat: pictureFormat},
                            baseURL: ""
                        };
                        if (serverInfo && serverInfo.url && serverInfo.url !== "")
                            options.baseURL = serverInfo.url;
                     
                        let request: Rest.IAjaxRequest = this.restModel.createAjaxRequest<Rest.IRequestBody>(`/images/pictures/${this.id}`, true, options);
                        request.options.encoding = "base64";
                        request.options.always = (sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                            this._data[pictureFormat] = `data:${jqXHR.getResponseHeader("content-type")};base64,${jqXHR.responseText}`;
                            this.fireEvent(Tools.EventType.UserEvent);
                        };
                        if (!_this[_sequence]) {   
                            _this[_sequence] = request.call();
                        }
                    });
                }
            });
        }
    }

    export class Album  extends Tools.EventSink implements IAlbum {
        public readonly restModel: Rest.RestModel;
        protected _imagesServer: AFC.ServerInfo.ImagesServerInfoProvider;
        protected _album: IAlbum;
        
        constructor(restModel: Rest.RestModel, imagesServer: AFC.ServerInfo.ImagesServerInfoProvider, album: IAlbum) {
            super();
            this.restModel      = restModel;
            this._album         = album;
            this. _imagesServer = imagesServer;
        }

        public get id(): string {
            return this._album ? this._album.id : "";
        }
        public get name(): string {
            return this._album ? this._album.name : "";
        }
        public get description(): string {
            return this._album ? this._album.description : "";
        }
        public deletePicture(picture: Picture) : Promise<boolean> {
            return new Promise(async (resolve: (result: boolean) => void) => {
                this._imagesServer.getServerInfo().then(serverInfo => {
                    let options = null;
                    if (serverInfo && serverInfo.url && serverInfo.url !== "")
                        options = {baseURL: serverInfo.url};

                    let request = this.restModel.createAjaxRequest<IAlbumOperation & Rest.IRequestBody>(`/images/albums/${this.id}`, true, options);    
                    let data    = request.options.data;
                    
                    data.operation  = "delete";
                    data.picture    = picture.id;
                    request.options.always = (sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                        let result: IPictureDeleteResult = jqXHR.responseJSON;
                        resolve(result.success);
                    };
                    request.call();
                });
            });
        }
        public setPictureTagsValues(picture: Picture, tags: ITagValueRequest[]) : Promise<Picture> {
            return new Promise(async (resolve: (result: Picture) => void) => {
                this._imagesServer.getServerInfo().then(serverInfo => {
                    let options = null;
                    if (serverInfo && serverInfo.url && serverInfo.url !== "")
                        options = {baseURL: serverInfo.url};
                    let request = this.restModel.createAjaxRequest<IAlbumOperation & Rest.IRequestBody>(`/images/albums/${this.id}`, true, options);    
                    let data    = request.options.data;
                    
                    data.operation  = "settags";
                    data.picture    = picture.id;
                    data.tags       = tags;
                    request.options.always = (sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                        let result: IPicture = jqXHR.responseJSON;
                        resolve(new Picture(this.restModel, this._imagesServer, result));
                    };
                    request.call();
                });
            });
        }
        public uploadPicture(file: File, tags: ITagValueRequest[], pictureToReplace?: Picture) : Promise<Picture> {
            return new Promise(async (resolve: (result: Picture) => void) => {
                let reader = new FileReader();

                //await new Promise(f => setTimeout(f, 10000));
                
                reader.onloadend = event => {
                    let content: string,
                        index: number,
                        request,
                        data;
                    
                    if ((event.loaded === event.total) && event.loaded && ((index = (content = <string>reader.result).indexOf(c_Header)) !== -1)) {
                        this._imagesServer.getServerInfo().then(serverInfo => {
                            let options = null;
                            if (serverInfo && serverInfo.url && serverInfo.url !== "")
                                options = {baseURL: serverInfo.url};
                            request = this.restModel.createAjaxRequest<AFC.Globals.IUploadCommand & IAlbumOperation & Rest.IRequestBody>(`/images/albums/${this.id}`, true, options);
                            
                            data = request.options.data;
                            data.type           = "";
                            data.mimeType       = file.type;
                            data.name           = file.name;
                            data.size           = file.size;
                            data.lastModified   = new Date(file.lastModified);
                            data.content        = content.substr(index + c_Header.length);
                            data.operation      = pictureToReplace ? "update" : "create";
                            data.tags           = tags;
                            if (pictureToReplace)
                                data.picture = pictureToReplace.id;
                            request.options.always = (sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                                let result: IPictureUploadResult = jqXHR.responseJSON;
                                resolve(new Picture(this.restModel, this._imagesServer, result.picture));
                            };
                            request.call();
                        });
                    } else {
                        resolve(null);
                    }
                };       

                reader.readAsDataURL(file); 
            });
        }

        public queryPictures(tags: ITagValueRequest[]): Promise<Picture[]> {
            return new Promise(async (resolve: (pictures: Picture[]) => void) => {
                this._imagesServer.getServerInfo().then(serverInfo => {
                    let options = null;
                    if (serverInfo && serverInfo.url && serverInfo.url !== "")
                        options = {baseURL: serverInfo.url};
                    let request: Rest.IAjaxRequest = this.restModel.createAjaxRequest<Rest.IRequestBody & IAlbumOperation>('/images/pictures', true, options);
                    let data = request.options.data;
                    
                    data.operation  = "search";
                    data.tags       = tags;
                    data.album      = this.id;
                    request.options.always = (sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                        let result: IPicture[] = jqXHR.responseJSON;
                        resolve(result.map(picture => new Picture(this.restModel, this._imagesServer, picture)));
                    };
                    request.call();
                });
            });
        }
    }

    export class PhotoManager extends Tools.EventSink  {
        public readonly restModel: Rest.RestModel;
        protected _imagesServer: AFC.ServerInfo.ImagesServerInfoProvider;
        protected _albums: Album[];
        protected [_sequence]: number;

        constructor(restModel: Rest.RestModel) {
            super();
            this[_sequence]     = 0;
            this.restModel      = restModel;
            this._imagesServer  = new AFC.ServerInfo.ImagesServerInfoProvider(restModel);
        }
        public get albums(): Promise<ReadonlyArray<Album>> {
            return this._albums ? Promise.resolve(this._albums) : new Promise(async (resolve: (albumns: ReadonlyArray<Album>) => void) => {
                this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve(this._albums));
                if (!this[_sequence]) {   
                    this._imagesServer.getServerInfo().then(serverInfo => {
                        let options = null;
                        if (serverInfo && serverInfo.url && serverInfo.url !== "")
                            options = {baseURL: serverInfo.url};
                        
                        let request: Rest.IAjaxRequest = this.restModel.createAjaxRequest<Rest.IRequestBody>('/images/albums', true, options);

                        request.options.always = (sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                            let data: IAlbum[] = jqXHR.responseJSON;
                            this._albums = data ? data.map(item => new Album(this.restModel, this._imagesServer, item)) : [];
                            this.fireEvent(Tools.EventType.UserEvent);
                        };
                        this[_sequence] = request.call();
                    });
                }
            });
        }
        public getAlbum(albumName: string) : Promise<Album> {
            let _this = this;
            return new Promise(async (resolve: (albumn: Album) => void) => {
                _this.albums.then(albums => {
                    let filteredAlbums = albums.filter(album => {
                        return album.name.toLowerCase() == albumName.toLowerCase();
                    });
                    let album = null;
    
                    if (filteredAlbums && filteredAlbums.length > 0)
                        album = filteredAlbums[0];
                    resolve(album);
                });
            });
        }
        public queryPictures(albumName: string, tags: ITagValueRequest[]) : Promise<Picture[]> {
            let _this = this;
            return new Promise(async (resolve: (pictures: Picture[]) => void) => {
                _this.getAlbum(albumName).then(album => {
                    if (album)
                        album.queryPictures(tags).then(pictures => {resolve(pictures);});
                    else
                        resolve([]);
                });
            });
        }
    }

    export class StorePictures extends Tools.EventSink implements IPicturesSource  {
        public readonly restModel: Rest.RestModel;
        protected _sequence: number;
        protected _photoManager: PhotoManager;
        protected _pictures: Picture[];
        protected _album: string;
        protected _storeCodeTagValue: string;
        protected _imagesServer: AFC.ServerInfo.ImagesServerInfoProvider;

        constructor(restModel: Rest.RestModel) {
            super();
            this.restModel      = restModel;
            this._photoManager  = new PhotoManager(restModel);
            this.reset();
        }

        public set album(albumName: string) {
            if (this._album != albumName) {
                this._album = albumName;
                this.reset();
            }
        }
        public get album() : string {
            return this._album;
        }

        public get albumObject() : Promise<Album> {
            return this._photoManager.getAlbum(this.album);
        }

        public set store(store: AFC.Data.IStore) {
            let storeCode = "";
            if (store)
                storeCode = store.identifier;
            if (!storeCode || storeCode == "") {
                if (store.key && store.key.length == 1)
                    storeCode = store.key[0];
            }
            this.storeCode = storeCode;
        }
        public set storeCode(storeCode: any) {
            let tagValue = storeCode.toString();
            if (this._storeCodeTagValue != tagValue) {
                this._storeCodeTagValue = tagValue;
                this.reset();
            }
        }
        public getPictures(tags: ITagValueRequest[]) : Promise<Picture[]> {
            let _this = this;
            
            if (this._storeCodeTagValue == null || this._storeCodeTagValue == "")
                return Promise.resolve(null);
            return new Promise(async (resolve: (pictures: Picture[]) => void) => {
                if (!this._pictures) {
                    this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve(this._filterPictures(tags)));

                    if (!this._sequence) {
                        let sequence    = Date.now();
                        this._sequence  = sequence;

                        //this._photoManager.getAlbum(this.album).then(album => {
                        _this.albumObject.then(album => {
                            if (album) {
                                album.queryPictures([{name: c_builtInStoreCodeTagName, value:_this._storeCodeTagValue}]).then(pictures => {
                                    if (sequence == _this._sequence) {
                                        _this._pictures = pictures;
                                        this.fireEvent(Tools.EventType.UserEvent);
                                    }
                                });
                            } else {
                                if (sequence == _this._sequence) {
                                    _this._pictures = [];
                                    this.fireEvent(Tools.EventType.UserEvent);
                                }
                            }
                        });
                    }
                } else
                    resolve(this._filterPictures(tags));
            });
        }
        getPicture(pictureId: string) : Promise<Picture> {
            let _this = this;
            
            return new Promise(async (resolve: (picture: Picture) => void) => {
                _this.getPictures([]).then(pictures => {
                    let pic = pictures.find(picture => picture.id == pictureId);
                    resolve(pic);
                });
            });
        }
        public getFirstPicture(tags: ITagValueRequest[]) : Promise<Picture> {
            let _this = this;
            
            return new Promise(async (resolve: (picture: Picture) => void) => {
                _this.getPictures(tags).then(pictures => {
                    let picture = null;

                    if (pictures && pictures.length > 0) {
                        pictures.sort(function(p1, p2) {
                            if (p1.creationDate == p2.creationDate)
                                return 0;
                            else if (p1.creationDate > p2.creationDate)
                                return -1;
                            return 1;
                        });
                        picture = pictures[0];
                    }
                    resolve(picture);
                });
            });
        }
        public addPicture(file: File, tags: ITagValueRequest[], pictureToDelete?: Picture) : Promise<Picture> {
            let _this = this;
            
            return new Promise(async (resolve: (picture: Picture) => void) => {
                this._photoManager.getAlbum(this.album).then(album => {
                    let fullTags = [...tags];
                    fullTags.push({name: c_builtInStoreCodeTagName, value:_this._storeCodeTagValue});

                    album.uploadPicture(file, fullTags, pictureToDelete).then(picture => {
                        if (picture)
                            this._pictures.push(picture);
                        if (pictureToDelete)
                            this._pictures = this._pictures.filter(p => p.id != pictureToDelete.id);
                        resolve(picture);
                    });
                });
            });
        }
        public deletePicture(picture: Picture) : Promise<boolean> {
            return new Promise(async (resolve: (success: boolean) => void) => {
                this._photoManager.getAlbum(this.album).then(album => {
                    this.getPictures([]).then(pictures => {
                        album.deletePicture(picture).then(success => {
                            if (success)
                                this._pictures = this._pictures.filter(p => p.id != picture.id);
                            resolve(success);
                        });
                    });
                });
            });
        }
        public setPictureTagsValues(picture: Picture, tags: ITagValueRequest[]) : Promise<Picture> {
            return new Promise(async (resolve: (success: Picture) => void) => {
                this._photoManager.getAlbum(this.album).then(album => {
                    this.getPictures([]).then(pictures => {
                        album.setPictureTagsValues(picture, tags).then(newPicture => {
                            picture.tags = newPicture.tags;
                            resolve(picture);
                        });
                    });
                });
            });
        }
        
        _filterPictures(tags: ITagValueRequest[]) : Picture[] {
            if (tags && tags.length > 0) {
                return this._pictures.filter(picture => {
                    for (let t = 0; t < tags.length; t++) {
                        if (picture.getTagValue(tags[t].name).toLowerCase() != tags[t].value.toLowerCase())
                            return false;
                    }
                    return true;
                });
            }
            return this._pictures;
        }
        reset() {
            this._sequence  = 0;
            this._pictures  = null;
        }
    }
}