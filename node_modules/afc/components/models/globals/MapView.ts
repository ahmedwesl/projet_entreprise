/**
 * Created by jean.rennes on 10/03/2016.
 */
///<reference path="Global.ts" />
///<reference path="Symbol.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="../data/Data.ts" />
///<reference path="../data/Filter.ts" />
///<reference path="../../views/Global.ts" />
///<reference path="../../helpers/Geometry.ts" />
///<reference path="../../helpers/Data.ts" />
///<reference path="../../helpers/Cartographer.ts" />

namespace AFC.Globals {
    class MapEventData implements IMapEventData {
        public layers: IMapEventDataLayer[];
        
        constructor(layer?: IMapEventDataLayer) {
            layer && (this.layers = [layer]);
        }

        public concat(d: IMapEventData): MapEventData {
            if (d.layers && d.layers.length) {
                if (this.layers) {
                    let e: {[key: number]: Tools.IEventData} = {};
                    
                    this.layers.forEach(item => e[item.indice] = item.data);
                    d.layers.forEach(item => e[item.indice] ? e[item.indice].concat(item.data) : this.layers.push(item));
                } else {
                    this.layers = d.layers;
                }
            }
            return this;
        }

        public onDispatch(): MapEventData {
            if (this.layers) {
                this.layers.forEach(item => item.data && item.data.onDispatch&&item.data.onDispatch());
            }
            return this;
        }
    }

    export interface IConverterOptions {
        allow?(row: ReadonlyArray<any>): boolean;
        toBBox?(row: ReadonlyArray<any>): boolean;
    };

    interface IMapLayerEventData extends Tools.IEventData {
        visibility?: boolean;
        data?: Data.IDataModelEventData;
        style?: boolean;
        filter?: boolean;
    }
            
    export type IMapLayerEvent = Tools.IEvent<IMapLayerModel, IMapLayerEventData>;
    
    class MapLayerModelEventData implements IMapLayerEventData {
        public visibility: boolean;
        public data: Data.IDataModelEventData;
        public style: boolean;
        public filter: boolean;
        
        constructor(reset: boolean, visibility?: boolean, data?: Data.IDataModelEventData, filter?: boolean, style?: boolean) {
            if (reset) {
                this.data = new Data.DataEventData(void 0, true);
            } else {
                this.visibility = visibility;
                this.data = data;
                this.style = style;
                this.filter = filter;
            }
        }
        
        public concat(d: IMapLayerEventData): MapLayerModelEventData {
            if (!this.data || !this.data.reset) {
                if (d.data) {
                    if (d.data.reset) {
                        this.data = d.data;
                        return this;
                    }
                    this.data = this.data ? this.data.concat(d.data) : d.data;
                }
                d.visibility && (this.visibility = true);
                d.style && (this.style = true);
                d.filter && (this.filter = true);
            }
            return this;
        }
    }
    export const mapLayerModelEventData = (reset: boolean, visibility?: boolean, data?: Data.IDataModelEventData, filter?: boolean, style?: boolean)=> new MapLayerModelEventData(reset, visibility, data, filter, style);
    
    export abstract class MapLayerModel<K extends DrawableLayerType, D extends IMapLayerModelData> extends Tools.AutoSubscribeForwarder implements IMapLayerModel<K> {
        protected _template: IMapVectorLayerMetaData<K>;
        protected _thematics: ILayerLegendData;
        protected _clustering: boolean;
        protected _clusteringMaxZoom: number;
        protected _filter: GeoJSONFilterOverride;
        protected _options: GeoJSONOptionOverrides;
        protected _hidden: boolean;
        public abstract isTiled: boolean;
        public minZ: number;
        public maxZ: number;
        public selectable: boolean;
        public abstract data: D;
        public override: IMapLayerModel['override'];

        constructor(template: IMapVectorLayerMetaData<K>, thematics: ILayerLegendData) {
            super();
            this._template = template;
            this.minZ = template.minZ;
            (template.maxZ !== void 0) && (this.maxZ = template.maxZ - 1);
            this._hidden = !!template.hidden;
            this.selectable = !!template.selectable;
            this._thematics = thematics;
            (template.type === LayerType.symbol) && (this._clustering = (<ISymbolProperties>template.properties).clustering ? (<ISymbolProperties> template.properties).clustering.value : true);
        }
        
        public get name(): string {
            return this._template.name;
        }
        
        public get type(): K {
            return this._template.type;
        }
        
        public get properties(): ILayerProperties {
            return this._template.properties;
        }
        
        public get symbolFactory(): SymbolFactory {
            return this._template.symbolFactory; 
        }
        
        public get tooltips(): ReadonlyArray<{
            readonly id: string;
            readonly name: string;
            readonly format?: string;
        }> {
            return this._template.tooltips;
        }
        
        public set filter(filter: GeoJSONFilterOverride) {
            if (filter !== this._filter) {
                this.fireEvent(Tools.EventType.Attach, new MapLayerModelEventData(false, false, void 0, true));
                this._filter = filter;
            }
        }
        
        public get filter(): GeoJSONFilterOverride {
            return this._filter;
        }
        
        public set options(options: GeoJSONOptionOverrides) {
            if (options !== this._options) {
                if ((this._options && this._options.coordsToLatLng) !== (options && options.coordsToLatLng)) {
                    this.fireEvent(Tools.EventType.Attach, new MapLayerModelEventData(true));
                } else if (this.type === LayerType.symbol ? 
                    (this._options && this._options.pointToLayer) !== (options && options.pointToLayer):
                    (this._options && this._options.style) !== (options && options.style)
                ) {
                    this.fireEvent(Tools.EventType.Attach, new MapLayerModelEventData(false, false, void 0, false, true));
                }
                this._options = options;
            }
        }

        public get options(): GeoJSONOptionOverrides {
            return this._options;
        }

        public set hidden(value: boolean) {
            value = !!value;
            if (this._hidden !== value) {
                this._hidden = value;
                this.fireEvent(Tools.EventType.Attach, new MapLayerModelEventData(false, true));
            }
        }

        public get hidden(): boolean {
            return this._hidden;
        }
                
        public get legend(): ILayerLegendData {
            return this._thematics;
        }
        
        public set clustering(value: boolean) {
            this._clustering = !!value;
        }

        public get clustering(): boolean {
            return this._clustering && (this.type === LayerType.symbol);
        }

        public set clusteringMaxZoom(value: number) {
            this._clusteringMaxZoom = value;
        }

        public get clusteringMaxZoom(): number {
            return this._clusteringMaxZoom;
        }
    }
    
    class MapLayerData extends Data.FilterModel<Data.IRowCollection & Data.IKeyProvider> implements IStaticModelData {
        protected _geometryIndice: number;
        public readonly name: string;

        constructor(name: string) {
            super();
            this.name = name;
        }
        
        public get geometryIndice(): number {
            return this._geometryIndice;
        }

        public set dataModel(value: Data.IRowCollection & Data.IKeyProvider) {
            super.dataModel = value;
            this._geometryIndice = Tools.Data.findFirstGeometry(value.columns);
        }

        public get dataModel(): Data.IRowCollection & Data.IKeyProvider {
            return super.dataModel;
        }
    }
    
    export class MapLayerStaticModel<K extends DrawableLayerType = DrawableLayerType> extends MapLayerModel<K, IStaticModelData> implements IMapLayerStaticModel<K, IStaticModelData> {
        protected _geoJSON: GeoJSON.GeoJsonObject;
        protected _converter: IConverterOptions;
        public readonly data: IStaticModelData;
        public readonly isTiled: false;

        constructor(template: IMapVectorLayerMetaData<K>, dataModel?: Data.IRowCollection & Data.IKeyProvider, thematics?: ILayerLegendData) {
            const data = new MapLayerData(template?.table?.name || Tools.Data.generateRndString(10));

            super(template, thematics);
            this._setForwards([{
                type: Tools.EventType.Attach,
                targetType: Tools.EventType.Dirty,
                observable: this.data = data,
                callback: this._onDirty
            }]);
            dataModel && (this.dataModel = dataModel);
        }
        
        protected _onDirty(e: Data.IDataEvent): void {
            delete this._geoJSON;
            this.fireEvent(Tools.EventType.Attach, new MapLayerModelEventData(false, false, e.data));
        }

        public set dataModel(dataModel: Data.IRowCollection & Data.IKeyProvider) {
            if (dataModel !== this.data.dataModel) {
                this.data.dataModel = dataModel;
                delete this._geoJSON;
            }
        }

        public set thematics(value: ILayerLegendData) {
            this._thematics = value;
            delete this._geoJSON;
        }
                        
        public set converter(value: IConverterOptions) {
            this._converter = value;
            delete this._geoJSON;
        }
        
        public set hidden(value: boolean) {
            super.hidden = value;
            delete this._geoJSON;
        }

        public get hidden(): boolean {
            return super.hidden;
        }

        public clone(): MapLayerStaticModel<K> {
            let clone: MapLayerStaticModel<K> = Reflect.construct(MapLayerStaticModel, [this._template, this.data?.dataModel, this.legend], this.constructor);
            clone._geoJSON = this._geoJSON;
            clone._clustering = this._clustering;
            clone.override = this.override;
            clone.clusteringMaxZoom = this.clusteringMaxZoom;
            this._converter && (clone._converter = this._converter);
            return clone;
        }
        
        public get geoJSON(): GeoJSON.GeoJsonObject {
            return this._geoJSON || (this._geoJSON = Tools.Cartographer.getGeoJSONFromCollection(this.data, this.data.geometryIndice, this.type, this._converter));
        }
        
        public refresh(): void {
            delete this._geoJSON;
            this.fireEvent(Tools.EventType.Attach, new Data.DataEventData(void 0, true));
        }
    }
    
    function _getLegendInfo(layer: IMapLayerModel, prop: string, _type: LegendType): ILegendInfo {
        let legend: ILegendInfo;
        let properties: {[key: string]: ILayerProperty} = <any>layer.properties;
        let property: ILayerProperty;
        let datas: {[key: string]: ILegendData} = <any>layer.legend;
        let data: ILegendData;

        if (properties && datas && (property = properties[prop]) && (data = datas[prop])) {
            legend = {
                type: _type,
                property: <Required<ILayerProperty>>property,
                data: data
            };
        }
        return legend;
    }
    
    export class MapModel extends Tools.EventSink {
        protected _layers: IMapLayerModel[] = [];

        constructor() {
            super();
            this.on(Tools.EventType.Attach, this._onAttach, this);
        }

        protected _onAttach(event: IMapEvent): void {
            this.fireEvent(Tools.EventType.Dirty, event.data);
        }

        protected _onDirty(event: IMapLayerEvent): void {
            let layer: IMapLayerModel = event.target;
            let i: number = this._layers.indexOf(layer);

            if (i !== -1) {
                let data = event.data;
                this.fireEvent(Tools.EventType.Attach, new MapEventData({data: data.data, layer: layer, indice: i, style: data.style, filter: data.filter, visibility: data.visibility}));
            }
        }

        public static getLegendInfo(layer: IMapLayerModel): ILegendInfo {
            let legend: ILegendInfo;

            switch (layer.type) {
                case LayerType.symbol:
                    legend = _getLegendInfo(layer, 'fillColor', LegendType.fillColor) ||
                        _getLegendInfo(layer, 'size', LegendType.size) ||
                        _getLegendInfo(layer, 'icon', LegendType.icon);
                    break;
                case LayerType.polygon:
                    legend = _getLegendInfo(layer, 'fillColor', LegendType.fillColor);
                    break;
            }
            return legend;
        }
        
        public get layers(): IMapLayerModel[] {
            return this._layers;
        }
        
        public addLayer(layer: IMapLayerModel): void {
            this._layers.push(layer);
            layer.on(Tools.EventType.Attach, this._onDirty, this);
            this.fireEvent(Tools.EventType.Dirty, new MapEventData());
        }
        
        public clearLayers(): void {
            this._layers.forEach(layer=>{
                layer.off(Tools.EventType.Attach, this._onDirty, this);
            });
            this._layers = [];
            this.fireEvent(Tools.EventType.Dirty, new MapEventData());
        }
    }

    let LayerTypeLookup: {[key: string]: LayerType} =  {
        asteropLayerUnknown: LayerType.unknown,
        asteropLayerPolygon: LayerType.polygon,
        asteropLayerLine: LayerType.line,
        asteropLayerSymbol: LayerType.symbol,
        asteropLayerLabel: LayerType.label,
        asteropLayerPie: LayerType.pie,
        asteropLayerOlap: LayerType.olap,
        asteropLayerRaster: LayerType.raster,
        asteropLayerMXD: LayerType.mxd
    }
    
    export function layerType(value: LayerType): string;
    export function layerType(value: string): LayerType;
    export function layerType(value: LayerType|string): LayerType|string {
        return (<any>LayerTypeLookup)[value];
    }

    const _sequence = Symbol();

    interface IMapLayerMetaDataInternal {
        readonly name: string;        
        readonly type: string;
        readonly properties: ILayerProperties;
        readonly tooltips: ReadonlyArray<{
            readonly id: string;
            readonly name: string;
        }>;
        readonly minScale: number;
        readonly maxScale: number;
        readonly minZ: number;
        readonly maxZ: number;
        readonly grayScale?: boolean;
        readonly selectable?: boolean;
        readonly hidden?: boolean;
        readonly table?: ICompoundTable & {
                readonly columns: ReadonlyArray<{
                    name: string;
                    type: string;
                    alias?: string;
                    size?: number;
                    isPseudoColumn?: boolean;
                }>;
            readonly primaryKey?: ReadonlyArray<string>;
        };
        readonly symbolFactory?: SymbolFactory;
    }
    
    export function convertMapLayerMetaData<T extends Globals.IMapLayerMetaData = Globals.IMapLayerMetaData>(value: IMapLayerMetaDataInternal, globals: GlobalsDescriptor): Promise<IMapLayerMetaData> {
        return new Promise(async (resolve: (mapViews: IMapLayerMetaData) => void) => {
            let metadata: Mutable<T>&{symbolFactory: SymbolFactory;table: {columns: ReadonlyArray<Data.IDBColumn>}} = <any>value;
            
            if (value) {
                ((metadata.type = layerType(value.type) || LayerType.unknown) === LayerType.symbol) && !!((<ISymbolProperties> metadata.properties).icon) && (metadata.symbolFactory = await globals.getSymbolFactory());
                metadata.table && (metadata.table.columns = Data.mapDataColumns(value.table));
            }
            resolve(metadata || <any> {type: LayerType.unknown});
        });
    }
    
    export interface IMapLayerContent {
        table: Data.IRowCollection & Data.IKeyProvider;
        legend: ILayerLegendData;
    };    
    
    export class MapLayerDescriptor extends Tools.EventSink implements Controls.IListItem {
        public readonly id: string;
        public readonly name: string;
        public readonly type: LayerType;
        public readonly filterable: true;
        public readonly mapView: MapViewDescriptor;
        /** @internal */
        private [_sequence]: number;
        protected _seqData: number;
        protected _seqLegend: number;
        protected _globals: GlobalsDescriptor;
        protected _metadata: IMapLayerMetaData;
        protected _legend: ILayerLegendData;
        protected _content: IMapLayerContent;

        constructor(globals: GlobalsDescriptor, descriptor: MapViewDescriptor, data: {id: string, name: string}, type: LayerType) {
            super();
            this._globals = globals;
            this.mapView = descriptor;
            this.id = data.id;
            this.name = data.name;
            this.type = type;
            this.filterable = true;
        }

        public createRequest<T = any>(path?: string, bypassContext?: boolean, options?: Rest.IRestRequestOptions): Rest.IAjaxRequest<T> {
            return this.mapView.createRequest<T>(`/layers/${this.id}${path || ''}`, bypassContext, options);
        }
        
        protected _onDataDone(metadata: IMapLayerMetaData, sequence: number, jqXHR?: JQueryXHR, textStatus?: string): void {
            if (this._seqData === sequence) {
                let data: IMapLayerData = jqXHR?.responseJSON,
                    dataTable: Data.IDataTable,
                    dataModel: Data.DataModel;

                data && (dataTable = Data.updateTableData(data.table)) && (dataModel = new Data.DataModel(dataTable.columns, dataTable.primaryKey, dataTable.values));
                isVectorLayer(metadata) && (this._content = {
                    table: dataModel,
                    legend: this._legend = data.legend
                });
                this.fireEvent(Tools.EventType.UserEvent + 1);
                this.fireEvent(Tools.EventType.UserEvent + 2);
            }
        }        
        
        protected _onLegendDone(sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            if (this._seqLegend === sequence) {
                this._legend = <ILayerLegendData>jqXHR.responseJSON;
                this.fireEvent(Tools.EventType.UserEvent + 1);
            }
        }        
        
        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            if (this[_sequence] === sequence) {
                convertMapLayerMetaData(jqXHR.responseJSON, this._globals).then(metadata => {
                    this._metadata = metadata;
                    this.fireEvent(Tools.EventType.UserEvent);
                });
            }
        }
        
        public getMetadata<T extends IMapLayerMetaData = IMapLayerMetaData>(): Promise<T> {
            return this.hasOwnProperty('_metadata') ? Promise.resolve(<T>this._metadata) : new Promise((resolve: (metadata: T)=> void) => {
                this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve(<T>this._metadata));
                if (!this[_sequence]) {
                    let request: Rest.IAjaxRequest = this.createRequest();

                    request.options.always = this._onAlways.bind(this);
                    this[_sequence] = request.call();
                }
            });
        }
        
        public getLegendData(): Promise<ILayerLegendData> {
            return this.hasOwnProperty('_legend') ? Promise.resolve(this._legend) : new Promise((resolve: (legend: ILayerLegendData)=> void) => {
                this.notify(Tools.EventType.UserEvent + 1, (/*event: Tools.IEvent*/) => resolve(this._legend));
                if (!this._seqLegend) {
                    let request: Rest.IAjaxRequest = this.createRequest('/legend', false);

                    request.options.always = this._onLegendDone.bind(this);
                    this._seqLegend = request.call();
                }
            });
        }
        
        public getContent(): Promise<Readonly<IMapLayerContent>> {
            return this._content ? Promise.resolve(this._content) : new Promise((resolve: (content: IMapLayerContent)=> void) => {
                this.notify(Tools.EventType.UserEvent + 2, (/*event: Tools.IEvent*/) => resolve(this._content));
                if (!this._seqData) {
                    this._seqData = this._seqLegend = -1;
                    delete this._legend;
                    this.getMetadata().then(metadata => {
                        if (metadata.type !== LayerType.unknown) {
                            let request: Rest.IAjaxRequest = this.createRequest('/content', false);

                            request.options.always = this._onDataDone.bind(this, metadata);
                            this._seqData = this._seqLegend = request.call();
                        } else {
                            this._onDataDone(metadata, -1);
                        }
                    });
                }
            });
        }
        
        public invalidate(): void {
            delete this._seqData;
            delete this._content;
            delete this._seqLegend;
            delete this._legend;
        }
    }

    export interface IMapViewMetadata {
        grayLevelsEnabled?: boolean;
        layers: ReadonlyArray<MapLayerDescriptor>;
    }

    export class MapViewDescriptor extends Tools.EventSink implements Controls.IListItem {
        public readonly id: string;
        public readonly name: string;
        public readonly globals: GlobalsDescriptor;
        protected _metadata: IMapViewMetadata;
        /** @internal */
        private [_sequence]: number;

        constructor(d: GlobalsDescriptor, i: IMapViewDescriptor) {
            super();
            this.id = i.id;
            this.name = i.name;
            this.globals = d;
        }

        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            if (this[_sequence] === sequence) {
                let data: {
                        grayLevelsEnabled: boolean;
                        layers: ReadonlyArray<{
                            id: string,
                            name: string,
                            type: string
                        }>
                    } = jqXHR.responseJSON;
                
                this._metadata = <any>{
                    layers: data?.layers ? data.layers.map(item => new MapLayerDescriptor(this.globals, this, item, layerType(item.type))) : [],
                };
                data && data.grayLevelsEnabled && (this._metadata.grayLevelsEnabled = true);
                this.fireEvent(Tools.EventType.UserEvent);
            }
        }

        public createRequest<T = any>(path: string = '', bypassContext?: boolean, options?: Rest.IRestRequestOptions): Rest.IAjaxRequest<T> {
            return this.globals.createAjaxRequest<T>(`/mapviews/${this.id}${path}`, bypassContext, options);
        }

        public getMetadata(): Promise<Readonly<IMapViewMetadata>> {
            return this._metadata ? Promise.resolve(this._metadata) : new Promise((resolve: (metadata: IMapViewMetadata)=> void) => {
                this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve(this._metadata));
                if (!this[_sequence]) {                
                    let request: Rest.IAjaxRequest = this.createRequest();

                    request.options.always = this._onAlways.bind(this);
                    this[_sequence] = request.call();
                }
            });
        }
        
        public invalidate():void {
            delete this[_sequence];
            delete this._metadata;
        }
    }

    const c_ImageLoading: number = 100;

    export class GlobalsDescriptor extends Tools.EventSink {
        public readonly restModel: Rest.RestModel;
        protected _mapViews: MapViewDescriptor[];
        /** @internal */
        protected [_sequence]: number;
        protected symbols: SymbolFactory;
        protected _symbolSequence: number;
        protected _levels: IGeographicalLevels;
        protected _levelsSequence: number;

        constructor(restModel: Rest.RestModel) {
            super();
            this.restModel = restModel;
        }

        public invalidate():void {
            let mapViews: MapViewDescriptor[] = this._mapViews;

            this.fireEvent(Tools.EventType.Dirty);
            if (mapViews) {
                delete this._mapViews;
                delete this[_sequence];
                delete this.symbols;
                delete this._symbolSequence;
                mapViews.forEach((item:MapViewDescriptor)=> item.invalidate());
            }
        }

        public createAjaxRequest<T = any>(path: string = '', bypassContext?: boolean, options?: Rest.IRestRequestOptions): Rest.IAjaxRequest<T> {
            return this.restModel.createAjaxRequest<T>(`/globals${path}`, bypassContext, options);
        }

        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            if (this[_sequence] === sequence) {
                let data: IMapViewDescriptor[] = jqXHR.responseJSON;
                this._mapViews = data ? data.map(item => new MapViewDescriptor(this, item)) : [];
                this.fireEvent(Tools.EventType.UserEvent);
            }
        }

        public getMapViews(): Promise<ReadonlyArray<MapViewDescriptor>> {
            return this._mapViews ? Promise.resolve(this._mapViews) : new Promise((resolve: (mapViews: ReadonlyArray<MapViewDescriptor>) => void) => {
                this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve(this._mapViews));
                if (!this[_sequence]) {                
                    let request: Rest.IAjaxRequest = this.createAjaxRequest('/mapviews');
                    request.options.always = this._onAlways.bind(this);
                    this[_sequence] = request.call();
                }
            });
        }

        protected _onSymbolRestDone(sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            if (this._symbolSequence === sequence) {
                let data: ISymbolDescriptor = jqXHR.responseJSON;
                
                if (data) {
                    let iToLoad: number = data.images ? data.images.length : 0,
                        iLoading: number = 1;
                    const widths: number[] = [],
                        heights: number[] = [],
                        onEnd = () => {
                            if (iToLoad === 0) {
                                this.symbols = new SymbolFactory(data, widths, heights);
                                this.fireEvent(Tools.EventType.UserEvent+1);
                            } else if (--iLoading === 0) {
                                loadNext();
                            }
                        },
                        loadNext = () => {
                            const offset: number = data.images.length - iToLoad;

                            iLoading = Math.min(iToLoad, c_ImageLoading);
                            iToLoad -=  iLoading;
                            for (let i: number = 0; i < iLoading; ++i) {
                                const img: HTMLImageElement = new Image(),
                                    j = offset + i;
                                img.onload = () => {
                                    widths[j] = img.width;
                                    heights[j] = img.height;
                                    onEnd();
                                };
                                img.onerror = img.onabort = onEnd;
                                img.src = data.images[j];
                            }
                        };
                    onEnd();
                    widths.length = heights.length = iToLoad;
                }
            }
        }

        public getSymbolFactory(): Promise<SymbolFactory> {
            return this.symbols ? Promise.resolve(this.symbols) : new Promise(resolve => {
                this.notify(Tools.EventType.UserEvent + 1, (/*event: Tools.IEvent*/) => resolve(this.symbols));
                if (!this._symbolSequence) {
                    let request: Rest.IAjaxRequest = this.createAjaxRequest('/symbols');
                    request.options.always = this._onSymbolRestDone.bind(this);
                    this._symbolSequence = request.call();
                }
            });
        }
        
        protected _onLevelsRestDone(sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            if (this._levelsSequence === sequence) {
                let data: IGeographicalLevels = jqXHR.responseJSON;
                
                data && (this._levels = data);
                this.fireEvent(Tools.EventType.UserEvent+2);
            }
        }

        public getGeographicalLevels(): Promise<IGeographicalLevels> {
            return this._levels ? Promise.resolve(this._levels) : new Promise(resolve => {
                this.notify(Tools.EventType.UserEvent + 2, (/*event: Tools.IEvent*/) => resolve(this._levels));
                if (!this._levelsSequence) {
                    let request: Rest.IAjaxRequest = this.createAjaxRequest('/levels');
                    request.options.always = this._onLevelsRestDone.bind(this);
                    this._levelsSequence = request.call();
                }
            });
        }        
    }

    export interface IMapLayerDrawingInfo<T extends IMapLayerMetaData = IMapLayerMetaData> {
        descriptor: Globals.MapLayerDescriptor;
        map: Readonly<IMapViewMetadata>;
        layer: Readonly<T>;
        thematics?: Readonly<Globals.ILayerLegendData>;
    }
    
    export function isVectorLayer(metadata: {readonly type: LayerType}): boolean {
        switch (metadata.type) {
            case LayerType.polygon:
            case LayerType.line:
            case LayerType.symbol:
                return true;
        }
    }

    export async function getMapLayerDrawingInfo<T extends IMapLayerMetaData = IMapLayerMetaData>(globals: GlobalsDescriptor, mapViewName: string, mapLayerName: string): Promise<IMapLayerDrawingInfo<T>|undefined> {
        let mapView: MapViewDescriptor = Tools.findByIdOrName<MapViewDescriptor>(mapViewName, await globals.getMapViews()),
            mapViewMetadata: Readonly<IMapViewMetadata> = mapView && await mapView.getMetadata(),
            descriptor = mapViewMetadata && Tools.findByIdOrName<MapLayerDescriptor>(mapLayerName, mapViewMetadata.layers);
        return descriptor && Promise.all([descriptor.getMetadata(), descriptor.getLegendData()]).then(([layer, thematics]: [T, ILayerLegendData]) => ({
            descriptor: descriptor,
            map: mapViewMetadata,
            layer: layer,
            thematics: thematics
        }));
    }
};