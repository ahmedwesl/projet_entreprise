/**
 * Created by jean.rennes on 17/03/2016.
 */
///<reference path="Global.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="../../helpers/Tools.ts" />

namespace AFC.Globals {
    export interface ISymbolDescriptor {
        brands: string[];
        types: string[];
        symbols: string[];
        images: string[];
        index:{
            keys: number[];
            values: number[];
        };
    }

    export interface ISymbol {
        url: string;
        width: number;
        height: number;
    }

    function _compare0(collator: Intl.Collator, brands: ReadonlyArray<string>, i0: number, str1: string): number {
        return collator.compare(brands[i0], str1);
    }

    function _compare1(collator: Intl.Collator, brands: ReadonlyArray<string>, i0: number, i1: number): number {
        return _compare0(collator, brands, i0, brands[i1]);
    }

    export class SymbolFactory {
        private _data: Readonly<ISymbolDescriptor>;
        private _reverse: {readonly [key: string]: number};
        private _index: ReadonlyArray<number>;
        private _widths: ReadonlyArray<number>;
        private _heights: ReadonlyArray<number>;

        constructor(descriptor: ISymbolDescriptor, widths: ReadonlyArray<number>, heights: ReadonlyArray<number>) {
            let reverse: {[key: string]: number} = this._reverse = {};
            let collator: Intl.Collator = new Intl.Collator(void 0, {sensitivity: 'base'});
            
            descriptor.symbols.forEach((item, indice) => reverse[item.toLowerCase()] = indice);
            this._data = descriptor;
            (this._index = this._data.brands.map((item, indice) => indice)).sort(_compare1.bind(null, collator, this._data.brands));
            this._widths = widths;
            this._heights = heights;
        }

        public get brands(): ReadonlyArray<string> {
            return this._data.brands;
        }

        public get businessCodes(): ReadonlyArray<string> {
            return this._data.types;
        }

        public indexOf(brand: string): number {
            let brands: string[] = this._data.brands;
            let collator: Intl.Collator = new Intl.Collator(void 0, {sensitivity: 'base'});
            let i: number = Tools.lower_bound(this._index, brand, _compare0.bind(null, collator, brands));
            return (i < this._index.length) && (_compare0(collator, brands, this._index[i], brand) === 0) ? i : -1;
        }

        public symbols(brand: string): {readonly [key: string]: string;} {
            if (brand) {
                let i: number = this.indexOf(brand);
                let s: {[key: string]: string};

                if (i !== -1) {
                    let keys: number[] = this._data.index.keys;
                    let j: number = Tools.lower_bound(keys, this._index[i]);

                    while((j < keys.length) && (keys[j] === this._index[i])) {
                        let _type: number = this._data.index.values[j]&0xFFFF;
                        let symbol: number = this._data.index.values[j]>>16;

                        ++j;
                        (s || (s = {}))[this._data.types[_type]] = this._data.symbols[symbol];
                    }
                }
                return s;
            }
        }

        public symbol(symbol: string): Readonly<ISymbol> {
            if (symbol) {
                let i: number = this._reverse[symbol.toLowerCase()];
                if (i !== void 0) {
                    let s: string = this._data.images[i];
                    let width: number = this._widths[i];

                    return {url: s, width: width, height: this._heights[i]};
                }
            }
        }
    }
}