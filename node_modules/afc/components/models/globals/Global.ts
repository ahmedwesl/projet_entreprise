/**
 * Created by jean.rennes on 10/03/2016.
 */
///<reference types="leaflet" />
 
namespace AFC.Globals {
    export const enum LayerType {
        raster = -1,
        unknown = 0,
        polygon,
        line,
        symbol,
        pie,
        label,
        olap = 100,
        mxd = 200
    }

    export interface IGeoJsonProperties {
        data: ReadonlyArray<any>;
    };

    export type GeoJSONFeature<P extends IGeoJsonProperties = IGeoJsonProperties> = GeoJSON.Feature<GeoJSON.GeometryObject, P>;

    export type GeoJSONFilterOverride = (visible: boolean, feature: GeoJSONFeature)=> boolean;
        
    export interface GeoJSONOptionOverrides extends L.LayerOptions {
        style: L.PathOptions | ((options: L.LayerOptions, feature: GeoJSONFeature) => L.PolylineOptions);
        pointToLayer?(options: L.LayerOptions, point: GeoJSON.Feature<GeoJSON.Point>, latlng: L.LatLng): L.Layer;
        onEachFeature?(options: L.LayerOptions, feature: GeoJSONFeature, layer: L.Layer): void;
        coordsToLatLng?(options: L.LayerOptions, coords: [number, number] | [number, number, number]): L.LatLng;        
    }
    
    export interface IThematicValue<T = any> {
        readonly value: T;
        readonly pattern: string;
    }

    export interface IThematic<T = any> {
        readonly title: string;
        readonly columns: ReadonlyArray<string>;
        readonly classes: ReadonlyArray<IThematicValue<T>>;
    }
    
    export interface ILayerProperty<V = any, T extends IThematic<V> = IThematic<V>, C extends string = string> {
        readonly value: V;
        readonly column?: C;
        readonly thematic?: T;
    }

    export interface IShadowValue {
        readonly dx: number;
        readonly dy: number;
        readonly hardness: number;
        readonly transparency: number;
        readonly color: number;
    }

    export interface ILayerProperties {
        readonly transparency?: ILayerProperty<number>;
        readonly color?: ILayerProperty<number>;
        readonly visibility?: ILayerProperty<boolean, never>;
        readonly shadow?: ILayerProperty<IShadowValue, never, never>;
    }

    export interface ISymbolProperties extends ILayerProperties {
        readonly fillColor?: ILayerProperty<number>;
        readonly size?: ILayerProperty<number>;
        readonly icon?: ILayerProperty<string, never>;
        readonly clustering?: ILayerProperty<boolean, never>;
    }

    export interface IPolygonProperties extends ILayerProperties {
        readonly fillColor?: ILayerProperty<number>;
        readonly weight?: ILayerProperty<number>;
        readonly pattern?: ILayerProperty<number>;
        readonly patternBkColor?: ILayerProperty<number>;
        readonly patternAngle?: ILayerProperty<number>;
        readonly patternSpacing?: ILayerProperty<number>;
    }

    export interface IPolyLineProperties extends ILayerProperties {
        readonly weight?: ILayerProperty<number>;
    }

    export interface ICompoundTable {
        readonly name: string;
        readonly relations?: ReadonlyArray<ITableRelation>;
    };
    
    interface ITableRelation {
        readonly sourceKey: ReadonlyArray<string>;
        readonly targetKey: ReadonlyArray<string>;
        readonly target: ICompoundTable;
    };

    export interface ILayerPropertiesForLayerType {
        [LayerType.polygon]: IPolygonProperties;
        [LayerType.line]: IPolyLineProperties;
        [LayerType.symbol]: ISymbolProperties;
    }

    export type DrawableLayerType = keyof ILayerPropertiesForLayerType;

    export interface IMapLayerMetaData<P extends ILayerProperties = ILayerProperties> {
        readonly name: string;        
        readonly type: LayerType;
        readonly properties: P;
        readonly minScale: number;
        readonly maxScale: number;
        readonly minZ: number;
        readonly maxZ: number;
        readonly grayLevels?: boolean;
        readonly selectable?: boolean;
        readonly hidden?: boolean;
    }

    export interface IMapVectorLayerMetaData<K extends DrawableLayerType = DrawableLayerType> extends IMapLayerMetaData<ILayerPropertiesForLayerType[K]> {
        readonly type: K;
        readonly tooltips?: ReadonlyArray<{
            readonly id: string;
            readonly name: string;
            readonly shortId?: string;
            readonly format?: string;
        }>;
        readonly table?: ICompoundTable & Readonly<Data.IDBTableDefinition>;
        readonly symbolFactory?: SymbolFactory;
    }

    export interface IRasterProvider {
        readonly name: string;
        readonly host: string;
        readonly path: string;
        readonly external?: boolean;
        readonly secure?: boolean;
        readonly port?: number;
        readonly subdomains?: ReadonlyArray<string>;
    }

    export interface IMapRasterLayerMetaData extends IMapLayerMetaData {
        readonly type: LayerType.raster;
        readonly provider: IRasterProvider;
    }

    export interface IClassInfo {
        [key: string]: {
            text: string;
            value: number|string;
        };
    }

    export interface IThematicData {
        readonly classes: ReadonlyArray<IClassInfo>;
    }
                
    export interface ILegendData {
        readonly thematic: IThematicData;
    }
    
    export interface ILayerLegendData {
        readonly color?: ILegendData;
    }

    export interface ISymbolLegendData extends ILayerLegendData {
        readonly fillColor?: ILegendData;
        readonly size?: ILegendData;
        readonly icon?: ILegendData;
    }

    export interface IPolygonLegendData extends ILayerLegendData {
        readonly fillColor?: ILegendData;
        readonly transparency?: ILegendData;
        readonly weight?: ILegendData;
    }

    export interface IPolyLineLegendData extends ILayerLegendData {
        readonly weight?: ILegendData;
    }

    export interface ILayerLegendDataMap {
        [LayerType.symbol]: ISymbolLegendData;
        [LayerType.polygon]: IPolygonLegendData;
        [LayerType.line]: IPolyLineLegendData;
    }
    
    export interface IMapLayerData {
        table: {
            columns: {
                name: string;
                alias: string;
                dataId: string;
                type: string;
                size: number;
            }[];
            primaryKey?: string[];
            values: any[][];
        };
        legend?: ILayerLegendData;
    }

    export interface IMapViewDescriptor {
        id: string;
        name: string;
    }

    export interface IMapLayerModelData extends Data.IKeyProvider, Data.IColumnIndexProvider, Data.IRowCollection {
        readonly name: string;
        readonly geometryIndice: number;
        filter: (row: ReadonlyArray<any>, dataModel: IMapLayerModelData)=> boolean;
    }
        
    export interface IMapLayerModel<K extends DrawableLayerType = DrawableLayerType, D extends IMapLayerModelData = IMapLayerModelData> extends Tools.IObservable {
        readonly name: string;
        readonly type: K;
        readonly legend: ILayerLegendData;
        readonly isTiled: boolean;
        readonly symbolFactory: SymbolFactory;
        readonly properties: ILayerProperties;
        readonly data: D;
        readonly tooltips: ReadonlyArray<{
            readonly id: string;
            readonly name: string;
            readonly format?: string;
        }>;
        minZ: number;
        maxZ: number;
        hidden: boolean;
        clustering: boolean;
        clusteringMaxZoom: number;
        options: GeoJSONOptionOverrides;
        filter: GeoJSONFilterOverride;
        selectable: boolean;
        override: {
            properties: {
                readonly fillColor?: ILayerProperty<number>;
                readonly pattern?: ILayerProperty<number>;
                readonly patternBkColor?: ILayerProperty<number>;
                readonly patternAngle?: ILayerProperty<number>;
                readonly patternSpacing?: ILayerProperty<number>;
            },
            legendData: ILegendData
        };
    }

    export interface ITileFeatureProperties<K extends DrawableLayerType = DrawableLayerType> extends IGeoJsonProperties {
        compoundData?: ReadonlyArray<any>;
        layer?: LayerForLayerType<K, ITileFeatureProperties<K>>;
        count: number;        
    }

    export interface ITileLayerProvider<K extends DrawableLayerType = DrawableLayerType> {
        requestTiles(layer: ITileLayer<K>, tiles: ReadonlyArray<string>, callback: (tiles: ReadonlyArray<string>, rows: ReadonlyArray<any>[])=> any): void;
    }

    export interface ITileVectorModel<K extends DrawableLayerType = DrawableLayerType, P extends ITileLayerProvider<K> = ITileLayerProvider<K>> extends IMapLayerModelData, Data.IRowCollection, Tools.IObservable {
        readonly provider: P;
        readonly entities: ReadonlyArray<GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>>;
        dispatchChange: () => any;
        lowerBound(geometry: GeometryForLayerType[K], row: ReadonlyArray<any>): {
            readonly feature: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>;
            insert(): boolean;
        };
        find(key: ReadonlyArray<any>): number;
        remove(entity: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>): boolean;
        compareKey(row: ReadonlyArray<any>, key: ReadonlyArray<any>): number;
        empty(): void;
    } 

    export interface IMapLayerTiledModel<K extends DrawableLayerType = DrawableLayerType, D extends ITileVectorModel<K> = ITileVectorModel<K>> extends IMapLayerModel<K, D> {
        readonly isTiled: true;
        data: D;
        minNativeZ: number;
        maxNativeZ: number;
    }

    export interface IStaticModelData extends IMapLayerModelData, Data.IRowCollection {
        dataModel: Data.IRowCollection & Data.IKeyProvider;
    }

    export interface IMapLayerStaticModel<K extends DrawableLayerType = DrawableLayerType, D extends IStaticModelData = IStaticModelData> extends IMapLayerModel<K, D> {
        readonly geoJSON: GeoJSON.GeoJsonObject;
        readonly isTiled: false;        
        clone(): void;
    }
    
    export interface ILegendModel extends Tools.IObservable {
        getLegendImage(width: number, height: number, horizontal: boolean, quality?: number): Promise<string|void>;
        readonly getLegendInfo?: ()=> Promise<Globals.ILegendInfo|void>;
    }
    
    export interface IMapEventDataLayer {
        data: Data.IDataModelEventData;
        layer: IMapLayerModel;
        indice: number;
        visibility: boolean;
        style: boolean;
        filter: boolean;
    };

    export interface IMapEventData extends Tools.IEventData {
        layers: IMapEventDataLayer[];
    }

    export interface IMapEvent extends Tools.IEvent {
        data?: IMapEventData;
    }
            
    export const enum LegendType {
        fillColor,
        size,
        icon
    }
    
    export interface ILegendInfo {
        type: LegendType;
        property: {
            thematic: {
                readonly title?: string;
                readonly classes: ReadonlyArray<IThematicValue>;
            }
        };
        data?: Globals.ILegendData;
    }
        
    export interface IGeographicalLevels {
        readonly hierarchies: ReadonlyArray<ReadonlyArray<string>>;
        readonly levels: {
            readonly [key: string]: {
                readonly name: string,
                readonly table: string,
                readonly bookmarkColumn: string,
                readonly codeColumn: string,
                readonly nameColumn: string,
                readonly mappings: {
                    readonly [key: string]: {
                        readonly table: string,
                        readonly column: string,
                        readonly upperColumn: string,
                        readonly bookmark: boolean
                    }
                }
            }
        };
    }    
    
    export const enum ProgressStatus {
        unknown,
        notStarted,
        inProgress,
        completed,
        registered
    }
    const ProgressStatusLookup: {[key: string]: ProgressStatus} = {
        asteropTaskUnknown: ProgressStatus.unknown,
        asteropTaskNotStarted: ProgressStatus.notStarted,
        asteropTaskInProgress: ProgressStatus.inProgress,
        asteropTaskCompleted: ProgressStatus.completed,
        asteropTaskRegistered: ProgressStatus.registered,
    };
    
    export function progressStatus(value: string): ProgressStatus {
        return ProgressStatusLookup[value];
    }
        
    export interface IProgressData {
        title?: string;
        step?: string;
        tid: string;
        completed: number;
	progress?: string;
	uid?: number;
	status: ProgressStatus;
    }
}