/**
 * Created by jean.rennes on 17/03/2016.
 */
///<reference path="Global.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="../../helpers/Tools.ts" />

namespace AFC.Globals {
    export interface IBBSScriptResult {
        result: number;
        outValue?: any;
    }

    interface IBBSScriptContextData extends Dashboards.IMultiDashboardContextData {
        uri: string;
        plugin?: string;
        function?: string;
        parameters?: ReadonlyArray<any> | {[key: string]: any;}
    }

    class Data  {
        public readonly entry: Rest.IDataCreatorEntry;

        constructor(entry: Rest.IDataCreatorEntry) {
            this.entry  = entry;
        }

        public toJSON(): Object {
            return this.entry && {
                id: this.entry.key,
                type: 'table'
            }
        }
    }

    class Dashboard  {
        public readonly dashboard: Dashboards.IDashboard;
        private _id: string;
        private _reports: Array<string>

        constructor(dashboard: Dashboards.IDashboard, reports?: Array<string>) {
            this.dashboard  = dashboard;
            this._reports   = reports;
        }

        public async updateBody(data: IBBSScriptContextData, indice: number): Promise<string> {
            let id = this._id = `d${indice}`,
                contexts = (Rest.RestModel.createEntry<IBBSScriptContextData['context']>(data, 'context').dashboardCreations || (data.context.dashboardCreations = {}));
            contexts[id] = await this.dashboard.getContextDashboard();
            if (this._reports)
                contexts[id].reports = this._reports;
            return id;
        }

        public toJSON(): Object {
            return this._id && {
                id: `dashboardCreations:${this._id}`,
                type: 'dashboard'
            }
        }
    }

    export class BBSScript extends Tools.EventSink {
        private _tid:                       string;
        private _uid:                       number;
        private _result:                    IBBSScriptResult;
        private _sequenceRun:               number;
        private _dashboards:                Dashboard[];
        private _builder:                   Rest.DataCreator;
        public readonly uri:                string;
        public readonly callFunction:       string;
        public readonly parameters:         ReadonlyArray<any> | {[key: string]: any;};
        public readonly plugin:             string;                  
        public readonly restModel:          Rest.RestModel;
        
        constructor(retModel: Rest.RestModel, uri: string, callfunction: string, parameters: ReadonlyArray<any> | {[key: string]: any;}, plugin?: string) {
            super();
            
            this.restModel         = retModel;
            this.uri               = uri;
            this.callFunction      = callfunction;
            this.parameters        = parameters;
            this.plugin             = plugin;
            
            this._uid               = -1;
            this._tid               = null;
        }
        
        public createDataParameter(creation: Data.IDataCreation): any {
            return new Data((this._builder || (this._builder = new Rest.DataCreator())).createData(creation));
        }

        public createDashboardParameter(dashboard: Dashboards.IDashboard, reports?: Array<string>): any {
            let parameter = new Dashboard(dashboard, reports);
            (this._dashboards || (this._dashboards = [])).push(parameter);
            return parameter;
        }

        public async getRequest(options?: Rest.IRestRequestOptions): Promise<Rest.IAjaxRequest<IBBSScriptContextData>> {
            let opt     = $.extend({useProgressInfo: true, builder: this._builder}, options);
            let request = this.restModel.globals.createAjaxRequest<IBBSScriptContextData>('/scripting/run', !this._builder, opt);
            let data    = request.options.data;
            
            this._dashboards && await Promise.all(this._dashboards.map((dashboard, indice) => dashboard.updateBody(data, indice)));
            data.uri = this.uri;
            data.plugin = this.plugin;
            this._tid = request.progressId;
            if (this.callFunction)
                data.function = this.callFunction;
            if (this.parameters)
                data.parameters = this.parameters;
            return Promise.resolve(request);
        }
        
        public async run() : Promise<IBBSScriptResult> {
            return this._result || new Promise<IBBSScriptResult>(async (resolve, reject) => {
                this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve(this._result));
                if (this._sequenceRun === void 0) {
                    this._sequenceRun = -1;
                    let runningState = await this.getRunningState();
                                        
                    if ((runningState === AFC.Globals.ProgressStatus.completed)
                        || (runningState === AFC.Globals.ProgressStatus.unknown)
                        || (runningState === AFC.Globals.ProgressStatus.notStarted)) {
                        let runRequest = await this.getRequest();
                        
                        this._sequenceRun = runRequest.sequence;
                        runRequest.options.always  = (sequence: number, jqXHR: JQueryXHR, textStatus: string) => {
                            if (sequence === this._sequenceRun) {
                                this._result = <IBBSScriptResult>jqXHR.responseJSON;
                                this.fireEvent(Tools.EventType.UserEvent);
                            }
                        };
                        runRequest.call();
                    } else {
                        delete this._sequenceRun;
                        reject();
                    }
                }
            });
        }
        
        public getRunningState() : Promise<AFC.Globals.ProgressStatus> {
            let promise: Promise<AFC.Globals.ProgressStatus> = new Promise<AFC.Globals.ProgressStatus>((resolve, reject) => {
               if (this._tid) {
                    let data: {tid: string; wait: number; uid?: number};
                    let progressRequest = this.restModel.createAjaxRequest('/progress');
                                        
                    let h: (sequence: number, jqXHR: JQueryXHR, textStatus: string) => void = (sequence: number, jqXHR: JQueryXHR, textStatus: string)=> {
                        let progressData = <{status: string, uid: number}>jqXHR.responseJSON;
                        let status       = AFC.Globals.ProgressStatus.unknown;
                        
                        if (progressData != undefined) {
                            status       = AFC.Globals.progressStatus(progressData.status);
                            this._uid  = progressData.uid;
                        }
                        resolve(status);
                    };
                    data = {tid: this._tid, wait: 1000};
                    if (this._uid >= 0)
                        data.uid = this._uid;
                
                    progressRequest.options.always = h;
                    progressRequest.options.data = data;
                    progressRequest.call();
                }
                else
                    resolve(ProgressStatus.notStarted);
            });
            
            return promise;
        }
    }
}