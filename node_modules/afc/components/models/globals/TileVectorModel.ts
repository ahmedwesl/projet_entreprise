/**
 * Created by jean.rennes on 29/07/2020.
 */
///<reference path="Global.ts" />
///<reference path="Symbol.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="../data/Data.ts" />
///<reference path="../../views/Global.ts" />
///<reference path="../../helpers/Geometry.ts" />
///<reference path="../../helpers/Data.ts" />
///<reference path="../../helpers/Cartographer.ts" />

namespace AFC.Globals {
    export class TileLayerProvider<K extends DrawableLayerType> extends Rest.RequestBuilder implements ITileLayerProvider<K> {
        public readonly descriptor: Globals.MapLayerDescriptor;

        constructor(mapLayerDescriptor: Globals.MapLayerDescriptor, base?: Rest.IContextModifier) {
            super(base || mapLayerDescriptor.mapView.globals.restModel);
            this.descriptor = mapLayerDescriptor;
        }
                   
        public requestTiles(layer: ITileLayer<K>, tiles: ReadonlyArray<string>, callback: (tiles: ReadonlyArray<string>, rows: any[][])=> any): void {
            this.load().then(() => {
                let request = this.descriptor.createRequest<{ keys: ReadonlyArray<string> }>('/tiles', false, {builder: this}),
                    data = request.options.data;
                
                data.keys = tiles;
                request.options.always = (sequence: number, jqXHR: JQueryXHR, textStatus: string)=> {
                    let data: {values: any[][]} = jqXHR.responseJSON;
                    callback(tiles, data && Data.updateDataRows(layer.tiledModel.data.columns, data.values));
                };
                request.call();
            });
        }
    }
    
    function _makeSingle(column: number): (row: ReadonlyArray<any>) => any {
        return (row: ReadonlyArray<any>) => row[column];
    }
    
    function _makeMultiple(columns: ReadonlyArray<number>): (row: ReadonlyArray<any>) => ReadonlyArray<any> {
        return (row: ReadonlyArray<any>) => columns.map(indice => row[indice]);
    }
    
    class EventSink extends Tools.EventSinkMixin(Data.RowComparator) {
        private _timeout: number = null;
        public dispatchChange: ()=> any;
        public readonly getCodeForContext: (row: ReadonlyArray<any>) => any;
        public readonly getKeyFromContext: (code: any) => ReadonlyArray<any>;

        constructor(primaryKey: ReadonlyArray<string>, columnIndex: { readonly [key: string]: any }) {
            const keys = primaryKey.map((item: string) => columnIndex[item]);

            super(keys);
            if (keys.length === 1) {
                this.getCodeForContext = _makeSingle(keys[0]);
                this.getKeyFromContext = (code: any) => [code];
            } else {
                this.getCodeForContext = _makeMultiple(keys);
                this.getKeyFromContext = (code: ReadonlyArray<any>) => code;
            }
        }

        protected _register(): void {
            this.dispatchChange || (this.dispatchChange = () => {
                (this._timeout !== null) && clearTimeout(this._timeout);
                this._timeout = setTimeout(() => {
                    this.fireEvent(Tools.EventType.Attach, new Data.DataEventData(void 0, true));
                    this._timeout = null;
                }, 300);
            });
        }
        
        public once(type: Tools.EventType, callback: (event: Tools.IEvent)=> any, callbackref: any, context: any): void {
            this._register();
            super.once(type, callback, callbackref, context);
        }

        public on(type: Tools.EventType, callback: (event: Tools.IEvent)=> any, context?: any):void {
            this._register();
            super.on(type, callback, context);
        }
    }
    
    interface ILayerListener {
        attach(mapLayerTiledModel: IMapLayerTiledModel): void;
        detach(): void;
    }
    
    export class TileVectorModel<K extends DrawableLayerType, P extends ITileLayerProvider<K> = ITileLayerProvider<K>> extends EventSink implements ITileVectorModel<K, P>, ILayerListener {
        private static _Bookmark = class<K extends DrawableLayerType, P extends ITileLayerProvider<K>> {
            public feature: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>;
            public insert: ()=> boolean;
            
            constructor(model: TileVectorModel<K, P>, geometry: GeometryForLayerType[K], row: ReadonlyArray<any>) {
                let container = model._getRowContainer(row),
                    visible = model.entities === container,
                    position = model._lowerBound(container, row),
                    insert = ()=> (++this.feature.properties.count,false);
                this.insert = (this.feature = model._match(container, position, row)) ? 
                    insert:
                    ()=> {
                        let feature = Tools.Cartographer.feature(geometry, {data: row, count: 1});
                        model._insert(container, position, this.feature = feature);
                        this.insert = insert;
                        return visible;
                    }
            }
        };
        
        private _mapLayerTiledModel: IMapLayerTiledModel;
        private _hidden: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>[];
        private _filter: (row: ReadonlyArray<any>, dataModel: this)=> boolean;
        public readonly provider: P;
        public readonly name: string;
        public readonly geometryIndice: number;
        public readonly columns: ReadonlyArray<Data.IDBColumnDefinition>;
        public readonly primaryKey: ReadonlyArray<string>;
        public readonly columnIndex: { readonly [key:string]: number; };
        public entities: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>[];

        constructor({ provider, name, geometryIndice, columns, primaryKey }: { provider: P, name: string, geometryIndice: number, columns: ReadonlyArray<Data.IDBColumnDefinition>, primaryKey: ReadonlyArray<string> }) {
            const columnIndex = Data.getColumnIndex(columns);

            super(primaryKey, columnIndex);
            this.provider = provider;
            this.name = name;
            this.geometryIndice = geometryIndice;
            this.columns = columns;
            this.primaryKey = primaryKey;
            this.columnIndex = columnIndex;
            this.empty();
        }

        protected _lowerBound(container: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>[], row: ReadonlyArray<any>): number {
            return Tools.lower_bound(container, row, (feature: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>, row: ReadonlyArray<any>) => this.compareRow(feature.properties.data, row));
        }
        
        protected _match(container: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>[], i: number, row: ReadonlyArray<any>): GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>> {
            return (i < container.length) && !this.compareRow(container[i].properties.data, row) ? container[i] : null;
        }
        
        protected _insert(container: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>[], indice: number, entity: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>): void {
            container.splice(indice, 0, entity);
        }

        protected _remove(container: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>[], indice: number): void {
            container.splice(indice, 1);
        }
        
        protected _getRowContainer(row: ReadonlyArray<any>): GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>[] {
            return this._filter && !this._filter(row, this) ? this._hidden : this.entities;
        }
            
        protected _onDirty(event: Globals.IMapLayerEvent): void {
            this.notify(Tools.EventType.Attach + 1, () => {
                let data = event.data,
                    items;

                if (data.filter || (items = data.data && data.data.items)) {
                    this.fireEvent(Tools.EventType.Dirty, data.filter ? new Data.DataEventData(items, true) : data.data);
                }
            });
            this.fireEvent(Tools.EventType.Attach + 1); // wait a little for the layer attach event to reach the MapModel ...
        }
        
        public attach(mapLayerTiledModel: IMapLayerTiledModel): void {
            this.detach();
            //(this._mapLayerTiledModel = mapLayerTiledModel).on(Tools.EventType.Attach, this._onDirty, this);
            this._mapLayerTiledModel = mapLayerTiledModel;
        }
        
        public detach(): void {
            if (this._mapLayerTiledModel) {
                //this._mapLayerTiledModel.off(Tools.EventType.Attach, this._onDirty, this);
                delete this._mapLayerTiledModel;
            }
        }
        
        /*public fireLayerEvent(item?: Data.IDataEventItem, reset?: boolean): ReturnType<EventSink['fireEvent']> {
            let dataEventData = item && new Data.DataEventData([item]);
            return this._mapLayerTiledModel.fireEvent(Tools.EventType.Attach, mapLayerModelEventData(false, false, dataEventData, reset));
        }*/
        
        public fireLayerEvent(items?: Data.IDataEventItem[], reset?: boolean): ReturnType<EventSink['fireEvent']> {
            let dataEventData = items && new Data.DataEventData(items);

            if (reset || items) {
                this.notify(Tools.EventType.Attach + 1, () => {
                    this.fireEvent(Tools.EventType.Dirty, reset ? new Data.DataEventData(items, true) : dataEventData);
                });
                this.fireEvent(Tools.EventType.Attach + 1); // wait a little for the layer attach event to reach the MapModel ...
            }
            return this._mapLayerTiledModel.fireEvent(Tools.EventType.Attach, mapLayerModelEventData(false, false, dataEventData, reset));
        }        
                    
        public lowerBound(geometry: GeometryForLayerType[K], row: ReadonlyArray<any>): ReturnType<ITileVectorModel<K>['lowerBound']> {
            return new TileVectorModel._Bookmark<K, P>(this, geometry, row);
        }
        
        public remove(feature: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>): boolean {
            if (--feature.properties.count === 0) {
                let row = feature.properties.data,
                    container = this._getRowContainer(row),
                    i = this._lowerBound(container, row);

                if (this._match(container, i, row)) {
                    this._remove(container, i);
                }
                return true;
            }
        }
        
        public empty(): void {
            this._hidden = [];
            this.entities = [];
        }
        
        public get length(): number {
            return this.entities.length;
        }
        
        public getRow(index: number): ReadonlyArray<any> {
            let feature = this.entities[index];
            return feature && feature.properties.data;
        }
        
        public indexOf(row: ReadonlyArray<any>): number {
            let i: number = this._lowerBound(this.entities, row);
            return this._match(this.entities, i, row) ? i : -1;
        }
        
        public find(key: ReadonlyArray<any>): number {
            let i = Tools.lower_bound(this.entities, key, (feature: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>, key: ReadonlyArray<any>) => this.compareKey(feature.properties.data, key)),
                entity = this.entities[i];
            return entity && !this.compareKey(entity.properties.data, key) ? i : -1;
        }        

        public set filter(value: (row: ReadonlyArray<any>, dataModel: IMapLayerModelData) => boolean) {
            if (this._filter !== value) {
                let hidden = this._hidden;
                
                this._hidden = [];
                this._filter = value;
                if (value) {
                    let entities = this.entities;
                    this.entities = [];
                    entities.forEach(entity => this._getRowContainer(entity.properties.data).push(entity));
                }
                hidden.forEach(entity => {
                    let row = entity.properties.data,
                        container = this._getRowContainer(row);
                    this._insert(container, this._lowerBound(container, row), entity);
                });
                this.fireLayerEvent(void 0, true);
            }
        }
        
        public get filter(): (row: ReadonlyArray<any>, dataModel: IMapLayerModelData)=> boolean {
            return this._filter;
        }        
    }    

    export function tileVectorModel<K extends DrawableLayerType, P extends ITileLayerProvider>(provider: P, columns: ReadonlyArray<Data.IDBColumnDefinition>, primaryKey: ReadonlyArray<string>, name: string, geometryIndice: number): TileVectorModel<K, P> | undefined {
        return new TileVectorModel({
            provider,
            name,
            geometryIndice,
            columns: columns,
            primaryKey: primaryKey
        });
    }

    type EventType = Data.DataEventType.create | Data.DataEventType.modify | Data.DataEventType.delete_;

    interface IEventEntry {
        readonly type: EventType | Data.DataEventType.none;
        readonly row: ReadonlyArray<any>;
        readonly oldRow?: ReadonlyArray<any>;
        readonly skip?: boolean;
        apply(model: Data.IKeyProvider, layer: ITileLayer, tiles: ReadonlyArray<string>, rows: ReadonlyArray<any>[]): void;
        append(columns: ReadonlyArray<Data.IDBColumn>, event: Readonly<Event>): IEventEntry;
        revert(model: Parameters<typeof Data.modifyRowWithValues>[0]): Data.IDataEventItem;
    }

    abstract class Event implements IEventEntry {
        public readonly type: EventType;
        public committed: boolean;
        public row: ReadonlyArray<any>;
        public rectangle: Tools.Geometry.Rectangle;
        public oldRow: ReadonlyArray<any>;
        
        constructor(eventType: EventType, committed: boolean, row: ReadonlyArray<any>, rectangle: Tools.Geometry.Rectangle) {
            this.type = eventType;
            this.committed = committed;
            this.row = row;
            this.rectangle = rectangle;
        }
        
        public abstract apply(model: Data.IKeyProvider, layer: ITileLayer, tiles: ReadonlyArray<string>, rows: ReadonlyArray<any>[]): void;
        public abstract append(columns: ReadonlyArray<Data.IDBColumn>, event: Readonly<Event>): Event;
        public abstract commit(model: Parameters<typeof Data.modifyRowWithValues>[0], values?: Data.IModificationEventValues): ReadonlyArray<any>;
        public abstract revert(model: Parameters<typeof Data.modifyRowWithValues>[0]): Data.IDataEventItem;
    }
    
    class CreateEvent extends Event {
        constructor(committed: boolean, row: ReadonlyArray<any>, rectangle: Tools.Geometry.Rectangle, eventType?: EventType) {
            super(eventType || Data.DataEventType.create, committed, row, rectangle);
            this.oldRow = null;
        }
                
        public apply(model: Data.IKeyProvider, layer: ITileLayer, tiles: ReadonlyArray<string>, rows: ReadonlyArray<any>[]) {
            layer.intersect(tiles, this.rectangle) && rows.push(this.row);
        }
        
        public getValues(columns: ReadonlyArray<Data.IDBColumn>): Data.IModificationEventValues {
            let values: Data.IModificationEventValues = {};
            
            columns.forEach((column, indice) => {
                if (column.index === -1) {
                    values[column.name] = this.row[indice];
                }
            });
            return values;
        }
        
        public append(columns: ReadonlyArray<Data.IDBColumn>, event: Readonly<Event>): Event {
            if (event.type !== Data.DataEventType.delete_) {
                // creation + modification = creation
                this.committed = event.committed;
                this.row = event.row;
                this.rectangle = event.rectangle;
                return this;
            }
        }
        
        public commit(model: Parameters<typeof Data.modifyRowWithValues>[0], values?: Data.IModificationEventValues): ReadonlyArray<any> {
            let modifiedRow = !this.committed && values && Data.modifyRowWithValues(model, this.row, values);
            
            this.committed = true;
            return modifiedRow && (this.row = modifiedRow);
        }
        
        public revert(model: Parameters<typeof Data.modifyRowWithValues>[0]): Data.IDataEventItem {
            return {
                type: Data.DataEventType.delete_,
                row: this.row,
                committed: true
            };
        }
    }

    class DeleteEvent extends Event {
        constructor(committed: boolean, row: ReadonlyArray<any>, rectangle: Tools.Geometry.Rectangle) {
            super(Data.DataEventType.delete_, committed, row, rectangle);
            this.oldRow = row;
        }
                
        public apply(model: Data.IKeyProvider, layer: ITileLayer, tiles: ReadonlyArray<string>, rows: ReadonlyArray<any>[]) {
            if (layer.intersect(tiles, this.rectangle)) {
                for (let i = 0; i < rows.length; ++i) {
                    if (!model.compareRow(this.row, rows[i])) {
                        rows.splice(i, 1);
                        break;
                    }
                }
            }
        }

        public append(columns: ReadonlyArray<Data.IDBColumn>, event: Readonly<Event>): Event {
            // should never happen
            return this;
        }
        
        public commit(model: Parameters<typeof Data.modifyRowWithValues>[0], values?: Data.IModificationEventValues): ReadonlyArray<any> {
            this.committed = true;
            return;
        }
        
        public revert(model: Parameters<typeof Data.modifyRowWithValues>[0]): Data.IDataEventItem {
            return {
                type: Data.DataEventType.create,
                row: this.row,
                committed: true
            };
        }
    }

    class ModifyEvent extends CreateEvent {
        private _delete: DeleteEvent;
        private _geometryIndice: number;

        constructor(committed: boolean, row: ReadonlyArray<any>, oldRow: ReadonlyArray<any>, rectangle: Tools.Geometry.Rectangle, geometryIndice: number) {
            let oldRectange = Tools.Geometry.getBoundRect(oldRow[geometryIndice]);
            
            super(committed, row, rectangle, Data.DataEventType.modify);
            this.oldRow = oldRow;
            this.rectangle.some((item, indice) => item !== oldRectange[indice]) && (this._delete = new DeleteEvent(void 0, oldRow, oldRectange));
            this._geometryIndice = geometryIndice;
        }
        
        public apply(model: Data.IKeyProvider, layer: ITileLayer, tiles: ReadonlyArray<string>, rows: ReadonlyArray<any>[]) {
            if (this._delete) {
                this._delete.apply(model, layer, tiles, rows);
                super.apply(model, layer, tiles, rows);
            } else if (layer.intersect(tiles, this.rectangle)) {
                for (let i = 0; i < rows.length; ++i) {
                    if (!model.compareRow(this.row, rows[i])) {
                        rows[i] = this.row;
                        break;
                    }
                }
            }
        }
        
        public getValues(columns: ReadonlyArray<Data.IDBColumn>): Data.IModificationEventValues {
            let values: Data.IModificationEventValues;
            
            columns.forEach((column, indice) => {
                if ((column.index === -1) && !Tools.Data.equalValue(column.type, this.row[indice], this.oldRow[indice])) {
                    (values || (values = {}))[column.name] = this.row[indice];
                }
            });
            return values;
        }

        public append(columns: ReadonlyArray<Data.IDBColumn>, event: Readonly<Event>): Event {
            let oldRect = this._delete && this._delete.rectangle;
            
            if (event.type === Data.DataEventType.delete_)
                return new DeleteEvent(event.committed, this.oldRow, oldRect || this.rectangle);  // modification + deletion = deletion

            // modification + modification = modification
            let row = event.row,
                oldRow = this.oldRow,
                modification: boolean,
                geometryIndice = this._geometryIndice;
                
            columns.some((column, indice) => {
                if (column.index === -1) {
                    let geometry = (indice === geometryIndice),
                        equal;
                        
                    if (geometry || !modification) {
                        equal = Tools.Data.equalValue(column.type, row[indice], oldRow[indice]);
                        equal || (modification = true);
                        geometry && equal && (delete this._delete);
                    }
                    return modification && (indice >= geometryIndice);
                }
            });
            if (modification) {
                this.committed = event.committed;
                this.rectangle = event.rectangle;
                this.oldRow = oldRow;
                return this;
            }
        }
        
        public revert(model: Parameters<typeof Data.modifyRowWithValues>[0]): Data.IDataEventItem {
            return {
                type: Data.DataEventType.modify,
                row: this.oldRow,
                committed: true
            };
        }
    }
        
    class CommitableEntry implements IEventEntry {
        private _committed: Event;
        private _sent: Event;
        private _pending: Event;
        private _sequence: number;
        public rollback: boolean;
        public row: ReadonlyArray<any>;
        public oldRow: ReadonlyArray<any>;
        
        constructor(event: Event) {
            this._pending = event;
            this.oldRow = event.oldRow;
            this.row = event.row;
        }
        
        public get type(): EventType | Data.DataEventType.none {
            return (this._pending && this._pending.type) || (this._sent && this._sent.type) || (this._committed && this._committed.type) || Data.DataEventType.none;
        }

        public pending(): Event {       // ready to commit
            if (!this._sent)
                return this._pending;
        }
                
        public get skip(): boolean {
            return !(this._sent || this._pending);
        }
                
        public startTransaction(sequence: number): void {
            this._sequence = sequence;
            this._sent = this._pending;
            delete this._pending;
        }
        
        public endTransaction(sequence: number, model: Parameters<typeof Data.modifyRowWithValues>[0], values?: Data.IModificationEventValues): Data.IDataEventItem {
            let sent,
                modifiedRow;
                
            if ((sequence === this._sequence) && (sent = this._sent)) {
                delete this._sent;
                (modifiedRow = sent && sent.commit(model, values)) && (this.row = modifiedRow);
                this._committed = this._committed ? this._committed.append(model.columns, sent) : sent;
                if (!this._pending) {
                    return {
                        type: modifiedRow ? Data.DataEventType.modify : Data.DataEventType.none,
                        row: modifiedRow || this.row,
                        committed: true
                    };
                }
            }            
        }
        
        public apply(model: Data.IKeyProvider, layer: ITileLayer, tiles: ReadonlyArray<string>, rows: ReadonlyArray<any>[]): void {
            this._sent && this._sent.apply(model, layer, tiles, rows);
            this._pending && this._pending.apply(model, layer, tiles, rows);
        }
        
        public append(columns: ReadonlyArray<Data.IDBColumn>, event: Event): IEventEntry {
            this._pending = this._pending ? this._pending.append(columns, event) : event;
            this.row = event.row;
            return this;
        }
        
        public revert(model: Parameters<typeof Data.modifyRowWithValues>[0]): Data.IDataEventItem {
            let row = this.row = this.oldRow || this.row,
                dataEventType = Data.DataEventType.none;
            
            this.rollback = true;
            switch(this.type) {
                case Data.DataEventType.create:
                    dataEventType = Data.DataEventType.delete_;
                    break;
                case Data.DataEventType.modify:
                    dataEventType = Data.DataEventType.modify;
                    break;
                case Data.DataEventType.delete_:
                    dataEventType = Data.DataEventType.create;
                    break;
                    
            }
            delete this._committed;
            delete this._sent;
            delete this._pending;
            return {
                type: dataEventType,
                row: row,
                committed: true
            };
        }
    }
    
    class EventStack<K extends DrawableLayerType, P extends ITileLayerProvider<K>> extends Tools.EventSink implements ITileLayerProvider<K> {
        private _dirty: boolean;
        private _sequence: number;
        private _timeout: number;
        public readonly model: TileVectorModel<K, P>;
        public readonly provider: P;
        public readonly target: string;
        public readonly updates: Data.Updates;
        public readonly session: string;
        public readonly events: IEventEntry[];
        public readonly descriptor: Data.HistoricizedTableDescriptor;
        
       constructor(tileVectorModel: TileVectorModel<K, P>, descriptor: Data.TableDescriptor, target: string, updates: Data.Updates, session: string) {
            super();
            this.model = tileVectorModel;
            this.provider = tileVectorModel.provider;
            this.target = target;
            this.updates = updates;
            this.session = session;
            this.events = [];
            descriptor.isHistoricized && (this.descriptor = <Data.HistoricizedTableDescriptor>descriptor);
        }
        
        protected _onUpdateRow(sequence: number, eventType: EventType, code: any, values?: Data.IModificationEventValues): Data.IDataEventItem {
            let model = this.model,
                key = model.getKeyFromContext(code),
                i = Tools.lower_bound(this.events, key, (event: IEventEntry, row: ReadonlyArray<any>) => model.compareKey(event.row, key)),
                event = <CommitableEntry>this.events[i];
            
            if (event && !model.compareKey(event.row, key)) {
                let item: Data.IDataEventItem = event.endTransaction(sequence, model, values);
                
                (event.type ===  Data.DataEventType.none) && this.events.splice(i, 1);
                item && this.model.fireLayerEvent([item]);
                return item;
            }
        }
        
        protected _onUpdate(sequence: number, results: Data.IUpdateCommandResult[]) {
            let events;
            
            delete this._sequence;
            if (results && results[0] && (events = results[0].events)) {
                events.creations && events.creations.forEach(creation => this._onUpdateRow(sequence, Data.DataEventType.create, creation.code, creation.values));
                events.modifications && events.modifications.forEach(modification => this._onUpdateRow(sequence, Data.DataEventType.modify, modification.code, modification.values));
                events.deletions && events.deletions.forEach(deletion => this._onUpdateRow(sequence, Data.DataEventType.delete_, deletion));
            }
            this._commit();
        }
        
        protected _onRollback(rollbacks: CommitableEntry[], events: Data.IDBHistoryEvent[]) {
            let model = this.model;
            
            delete this._sequence;
            rollbacks.forEach(entry => {
                entry.rollback = false;
                if (entry.type === Data.DataEventType.none) {
                    let row = entry.row,
                        i = Tools.lower_bound(this.events, row, (event: IEventEntry, row: ReadonlyArray<any>) => model.compareRow(event.row, row)),
                        event0 = this.events[i];

                    event0 && !model.compareRow(row, event0.row) && this.events.splice(i, 1);
                }
            });
        }

        protected _commit() {
            if (this._dirty) {
                let model = this.model,
                    events: Data.IModificationEvents = {},
                    filtered, rollbacks: CommitableEntry[]; 

                delete this._dirty;
                delete this._timeout;
                filtered = <CommitableEntry[]>this.events.filter((entry: CommitableEntry) => {
                    if (entry.rollback) {
                        (rollbacks || (rollbacks = [])).push(entry);
                    } else if (!entry.rollback) {
                        let event = <ModifyEvent>entry.pending();   // dirty cast to lure typescript transpiler
                        
                        if (event) {
                            let code = model.getCodeForContext(event.row);
                            switch (event.type) {
                                case Data.DataEventType.create: 
                                    (events.creations || (events.creations = [])).push({code: code, values: event.getValues(model.columns)});
                                    break;
                                case Data.DataEventType.modify:
                                    let values = event.getValues(model.columns);
                                    values && (events.modifications || (events.modifications = [])).push({code: code, values: values});
                                    break;
                                case Data.DataEventType.delete_:
                                    (events.deletions || (events.deletions = [])).push(code);
                                    break;
                            }
                            return true;
                        }
                    }
                });
                
                let sequence: number;
                if (rollbacks) {
                    let keys = rollbacks.map(entry => model.getKeyFromRow(entry.row)),
                        session = this.session;
                        
                    sequence = this.descriptor.rollbackEvents(keys, events => this._onRollback(rollbacks, events), session && {session: session, filter: {session: session}});
                } else if (filtered.length) {
                    sequence = this.updates.run([{
                        table: this.target,
                        events: events,
                        session: this.session
                    }], results => this._onUpdate(sequence, results));
                }
                this._sequence = sequence;
                filtered.forEach(event => event.startTransaction(sequence));
            }
        }
        
        protected _prune(): void {
            this._dirty = true;
            if (!this._sequence) {
                this._timeout && clearTimeout(this._timeout);
                this._timeout = setTimeout(() => this._commit(), 200);
            }
        }

        protected _insert(event: Event): Event {
            let model = this.model,
                i = Tools.lower_bound(this.events, event.row, (event: IEventEntry, row: ReadonlyArray<any>) => model.compareRow(event.row, row)),
                event0 = this.events[i];

            if (!event0 || model.compareRow(event.row, event0.row)) {
                let entry: IEventEntry = this.updates ? new CommitableEntry(event) : event;
                this.events.splice(i, 0, entry);
            } else {
                let e = event0.append(model.columns, event);
                e ? this.events[i] = e : this.events.splice(i, 1);
            }
            return event;
        }
        
        public push(eventType: EventType, row: ReadonlyArray<any>, oldRow: ReadonlyArray<any>): Data.IDataEventItem {
            let geometryIndice: number = this.model.geometryIndice, 
                rectangle: Tools.Geometry.Rectangle = Tools.Geometry.getBoundRect(row[geometryIndice]),
                committed = !this.updates,
                event: Event;
            
            switch (eventType) {
                case Data.DataEventType.create: 
                    event = new CreateEvent(committed, row, rectangle);
                    break;
                case Data.DataEventType.modify:
                    event = new ModifyEvent(committed, row, oldRow, rectangle, geometryIndice);
                    break;
                case Data.DataEventType.delete_:
                    event = new DeleteEvent(committed, row, rectangle);
                    break;
            }
            committed || this._prune();
            return this._insert(event);
        } 
        
        public dropEvents(key: ReadonlyArray<any>): Data.IDataEventItem {
            if (!this.updates || this.descriptor) {
                let model = this.model,
                    i = Tools.lower_bound(this.events, key, (event: IEventEntry, row: ReadonlyArray<any>) => model.compareKey(event.row, key)),
                    event = this.events[i];

                if (event && !model.compareKey(event.row, key)) {
                    let item = event.revert(model);
                    
                    this.updates ? this._prune() :  this.events.splice(i, 1);
                    item && this.model.fireLayerEvent([item]);
                    return item;
                }
            }
        }       
        
        public requestTiles(layer: ITileLayer<K, TileVectorModel<K, P>>, tiles: ReadonlyArray<string>, callback: (tiles: ReadonlyArray<string>, rows: ReadonlyArray<any>[])=> any): void {
            let model = this.model;
                
            this.provider.requestTiles(layer, tiles, (tiles: ReadonlyArray<string>, rows: ReadonlyArray<any>[]) => {
                this.events.forEach(event => event.skip || event.apply(model, layer, tiles, rows));
                callback(tiles, rows);
            });
        }
    }

    export interface IEventInfo extends AFC.Data.IDataItemStoreData {
        readonly eventType: EventType;
        getInitialData(column: string): ReadonlyArray<any> | undefined;
    }
 
    const _type = "{7C60520F-FC53-413D-97F9-BE0F18A44F5C}";
    
    interface IEventInfoRow extends Array<any> {
        __pos: number;
    }
    
    interface IIndexedTable<P extends ITileLayerProvider<LayerType.symbol>> extends AFC.Data.IIndexedTable {
        readonly definition: EventStackEx<P>;
    }
    
    class EventInfo<P extends ITileLayerProvider<LayerType.symbol>> implements IEventInfo {
        protected _values: IEventInfoRow;
        public readonly content: IIndexedTable<P>;
        public readonly store: Data.IReadonlyStore;
        
        constructor(content: IIndexedTable<P>, values: IEventInfoRow) {
            this.content = content;
            this.store = new Data.ReadonlyStore(this.content, this._values = values);
        }

        public get key(): ReadonlyArray<any> {
            return this.store.key;
        }
                
        public get eventType(): EventType {
            return this.store.getData(_type);
        }
        
        public getInitialData(column: string): ReadonlyArray<any> | undefined {
            let eventStack = this.content.definition,
                event = eventStack.events[this._values.__pos],
                oldRow = event.oldRow;
            return oldRow && oldRow[eventStack.model.columnIndex[column]];
        }
    }
    
    class EventStackEx<P extends ITileLayerProvider<LayerType.symbol>> extends EventStack<LayerType.symbol, P> implements Data.IRowCollection, Data.IKeyProvider, Data.IColumnIndexProvider, Data.IDataSource<IEventInfo> {
        public readonly columns: ReadonlyArray<Data.IDBColumnDefinition>;
        public readonly primaryKey: ReadonlyArray<string>;
        public readonly columnIndex: { [key:string]: number; };
        protected _values: ReadonlyArray<ReadonlyArray<any>>;
        protected _content: IIndexedTable<P>;
        
        constructor(tileVectorModel: TileVectorModel<LayerType.symbol, P>, descriptor: Data.TableDescriptor, definition: Data.IDBTableDefinition, target: string, updates: Data.Updates, session: string) {
            let index = Data.getColumnIndex(definition.columns),
                columns: Data.IDBColumnDefinition[] = tileVectorModel.columns.map(column => definition.columns[index[column.name]] || column);
            super(tileVectorModel, descriptor, target, updates, session);       
            columns.push(new Data.DBColumnDefinition(_type, AFC.Data.DataKind.integer, -1, 4, "type", true));
            this.columns = columns;
            this.primaryKey = tileVectorModel.primaryKey;
            this.columnIndex = Data.getColumnIndex(columns);
        }
        
        protected _fire<T extends Data.IDataEventItem>(item: T): T {
            if (item && (item.type !== Data.DataEventType.none)) {
                delete this._values;
                // should be more clever someday
                this.fireEvent(Tools.EventType.Dirty, new Data.DataEventData(void 0, true));
                return item;
            }
        }
        
        protected _onUpdateRow(sequence: number, eventType: EventType, code: any, values?: Data.IModificationEventValues): Data.IDataEventItem {
            return this._fire(super._onUpdateRow(sequence, eventType, code, values));
        }        
        
        protected _insert(event: Event): Event {
            return this._fire(super._insert(event));
        }        

        public dropEvents(key: ReadonlyArray<any>): Data.IDataEventItem {
            return this._fire(super.dropEvents(key));
        }

        // Data.IDataModelBase
        public get values(): ReadonlyArray<ReadonlyArray<any>> {
            if (!this._values) {
                let values: IEventInfoRow[] = this._values = [];
                this.events.forEach((event, indice) => {
                    if (event.type !== Data.DataEventType.none) {
                        let row = <IEventInfoRow>event.row.slice(0);
                        row.__pos = indice;
                        row.push(event.type);
                        values.push(row);
                    }
                });
            }
            return this._values;
        }

        public get length(): number {
            return this.values.length;
        }
        
        public getRow(index: number): ReadonlyArray<any> {
            return this.values[index];
        }
        
        public item(index: number): Data.IDataItemContainer<IEventInfo> {
            let row = <IEventInfoRow>this.values[index];
            
            if (row) {
                return {
                    dataItem: new EventInfo(this._content || (this._content = {
                            definition: this,
                            columnIndex: this.columnIndex,
                            geometryIndice: this.model.geometryIndice
                        }),
                    row),
                    dataItemIndex: index
                };
            }
        }
        
        public indexOf(row: ReadonlyArray<any>): number {
            let values = this.values,
                i: number = Tools.lower_bound(values, row, (row0: ReadonlyArray<any>, row1: ReadonlyArray<any>) => this.model.compareRow(row0, row1));
            return this.model.compareRow(values[i], row) ? -1 : i;
        }

        public getKeyFromRow(row: ReadonlyArray<any>): ReadonlyArray<any> {
            return this.model.getKeyFromRow(row);
        }

        public compareKey(row: ReadonlyArray<any>, key: ReadonlyArray<any>): number {
            return this.model.compareKey(row, key);
        }

        public compareRow(row0: ReadonlyArray<any>, row1: ReadonlyArray<any>): number {
            return this.model.compareRow(row0, row1);
        }
    }
    
    class EditableTileVectorModel<K extends DrawableLayerType, P extends ITileLayerProvider<K>, S extends EventStack<K, P>> extends EventSink implements ITileVectorModel<K>, Data.IDataEditor, ILayerListener {
        public readonly tileVectorModel: TileVectorModel<K, P>;
        public readonly geometryIndice: number;
        public readonly provider: S;
        
        constructor({ model, provider }: { model: TileVectorModel<K, P>, provider: S }) {
            super(model.primaryKey, model.columnIndex);
            (this.tileVectorModel = model).on(Tools.EventType.Dirty, (e: Data.IDataEvent) => this.fireEvent(Tools.EventType.Dirty, e.data && new Data.DataEventData(e.data.items, e.data.reset)));
            this.geometryIndice = model.geometryIndice;
            this.provider = provider;
        }

        public attach(mapLayerTiledModel: IMapLayerTiledModel): void {
            this.tileVectorModel.attach(mapLayerTiledModel);
        }

        public detach(): void {
            this.tileVectorModel.detach();
        }

        private _apply(eventType: EventType, row: ReadonlyArray<any>, oldRow?: ReadonlyArray<any>): void {
            let item = this.provider.push(eventType, row, oldRow);
            item && this.tileVectorModel.fireLayerEvent([item]);
        }

        public get name(): string {
            return this.tileVectorModel.name;
        }

        public get columns(): ReadonlyArray<Data.IDBColumnDefinition> {
            return this.tileVectorModel.columns;
        }
        
        public get primaryKey(): ReadonlyArray<string> {
            return this.tileVectorModel.primaryKey;
        }

        public get columnIndex(): { readonly [key:string]: number; } {
            return this.tileVectorModel.columnIndex;
        }

        public get length(): number {
            return this.tileVectorModel.length;
        }
        
        public getRow(index: number): ReadonlyArray<any> {
            return this.tileVectorModel.getRow(index);
        }
        
        public get entities(): ReadonlyArray<GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>> {
            return this.tileVectorModel.entities;
        }
        
        public indexOf(row: ReadonlyArray<any>): number {
            return this.tileVectorModel.indexOf(row);
        }
        
        public find(key: ReadonlyArray<any>): number {
            return this.tileVectorModel.find(key);
        }

        public lowerBound(geometry: GeometryForLayerType[K], row: ReadonlyArray<any>) {
            return this.tileVectorModel.lowerBound(geometry, row);
        }
        
        public remove(entity: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>): boolean {
            return this.tileVectorModel.remove(entity);
        }

        public empty(): void {
            this.tileVectorModel.empty();
        }
        
        public create(key: ReadonlyArray<any>, values: {[key: string]: any}): any {
            this._apply(Data.DataEventType.create, Data.createRowFromValues(this, key, values));
        }
        
        public modify(key: ReadonlyArray<any>, values: {[key: string]: any}): any {
            let i = Tools.lower_bound(this.entities, key, (feature: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>, key: ReadonlyArray<any>)=> this.compareKey(feature.properties.data, key)),
                row = this.getRow(i);
            if (row && !this.compareKey(row, key)) {
                let modifiedRow = Data.modifyRowWithValues(this, row, values);
                modifiedRow && this._apply(Data.DataEventType.modify, modifiedRow, row);
            }
        }
        
        public delete_(key: ReadonlyArray<any>): void {
            let i = Tools.lower_bound(this.entities, key, (feature: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>, key: ReadonlyArray<any>)=> this.compareKey(feature.properties.data, key)),
                row = this.getRow(i);
            if (row && !this.compareKey(row, key)) {
                this._apply(Data.DataEventType.delete_, row);
            }
        }
        
        public dropEvents(key: ReadonlyArray<any>): void {
            this.provider.dropEvents(key);
        }
        
        public set filter(value: (row: ReadonlyArray<any>, dataModel: IMapLayerModelData)=> boolean) {
            this.tileVectorModel.filter = value;
        }

        public get filter(): (row: ReadonlyArray<any>, dataModel: IMapLayerModelData)=> boolean {
            return this.tileVectorModel.filter;
        }
    }

    class MapLayerTiledModel<K extends DrawableLayerType, D extends ITileVectorModel<K> & Tools.IObservable & ILayerListener> extends MapLayerModel<K, D> implements IMapLayerTiledModel<K, D> {
        private _data: D;
        public readonly isTiled: true;
        public minNativeZ: number;
        public maxNativeZ: number;
        
        constructor(template: IMapVectorLayerMetaData<K>, thematics: ILayerLegendData, data: D) {
            super(template, thematics);
            this.isTiled = true;
            this.data = data;
        }
        
        public set data(value: D) {
            if (this._data !== value) {
                if (this._data) {
                    this._data.detach();
                    delete this._data;
                }
                if (value) {
                    value.attach(this);
                    this._data = value;
                }
            }
        }
        
        public get data(): D {
            return this._data;
        }
    }
    
    export type ITileLayerProviderImpl<K extends DrawableLayerType = DrawableLayerType> = ITileLayerProvider<K> & Rest.RequestBuilder;

    export type IMapLayerTiledModelImpl<K extends DrawableLayerType = DrawableLayerType> = IMapLayerTiledModel<K, TileVectorModel<K, ITileLayerProviderImpl<K>>>;
    
    export function mapLayerTiledModel<K extends DrawableLayerType = DrawableLayerType>(mapLayerDescriptor: Globals.MapLayerDescriptor, template: IMapVectorLayerMetaData<K>, thematics: ILayerLegendData, data?: TileVectorModel<K, ITileLayerProviderImpl<K>>): IMapLayerTiledModelImpl<K> {
        const definition = template.table,
            columns = definition.columns;
        return new MapLayerTiledModel(
            template,
            thematics,
            data || tileVectorModel<K, TileLayerProvider<K>>(new TileLayerProvider(mapLayerDescriptor), columns, definition.primaryKey, definition.name, Tools.Data.findFirstGeometry(columns)));
    }
    
    const _readOnlyStoreVectorModel = Data.readOnlyStoreSourceMixin(TileVectorModel<LayerType.symbol, ITileLayerProvider<LayerType.symbol>>);

    export function readOnlyStoreVectorModel<P extends ITileLayerProvider<LayerType.symbol>>(content: Data.ITableResourceContent<AFC.Data.HistoricizedTableDescriptor>, provider: P, definition: Readonly<Data.IDBTableDefinition>, name: string, geometryIndice: number): ITileVectorModel<LayerType.symbol, P> & Data.IReadonlyStoreSource & { getStoreFromRow(row?: ReadonlyArray<any>): AFC.Data.ReadonlyStore | undefined } {
        const columns = content.definition.columns;
        return definition.primaryKey && <any>new _readOnlyStoreVectorModel({
            content: $.extend({}, content, { 
                columnIndex: Data.getColumnIndex(columns),
                geometryIndice: Tools.Data.findFirstGeometry(columns)
            }),
            provider,
            name,
            geometryIndice,
            columns: definition.columns,
            primaryKey: definition.primaryKey
        });
    }

    const _storeVectorModel = Data.storeSourceMixin(EditableTileVectorModel<LayerType.symbol, ITileLayerProvider<LayerType.symbol>, EventStackEx<ITileLayerProvider<LayerType.symbol>>>);

    export function storeVectorModel(content: Data.IStoreTableResourceContent, model: TileVectorModel<LayerType.symbol>, /* target table */target?: string, session?: string): ITileVectorModel<LayerType.symbol, ITileLayerProvider<LayerType.symbol> & Data.IRowCollection & Data.IKeyProvider & Data.IColumnIndexProvider & Tools.IObservable & Data.IDataSource<IEventInfo>> & Data.IDataEditor & Data.IStoreSource & { getStoreFromRow(row?: ReadonlyArray<any>): AFC.Data.Store | undefined } {
        const descriptor = content.descriptor,
            updates: Data.Updates = target && new Data.Updates(descriptor.database.schema.restModel);
        return new _storeVectorModel({
                content,
                provider: new EventStackEx(model, descriptor, content.definition, target, updates, session),
                model
            });
    }
    
    const _vectorModel = Symbol();
    
    class CompoundTileLayerProvider<K extends DrawableLayerType> extends TileLayerProvider<K>  {
        private _additionalColumns: ReadonlyArray<number>;
        public readonly template: IMapVectorLayerMetaData<K>;
        public readonly dataModel: Data.IDataModel;
        public [_vectorModel]: TileVectorModel<K, CompoundTileLayerProvider<K>>;
        
        constructor(mapLayerDescriptor: Globals.MapLayerDescriptor, reference: Readonly<Data.IDBTableDefinition>, dataModel: Data.IDataModel, name: string, template: IMapVectorLayerMetaData<K>, base?: Rest.IContextModifier) {
            let additionalColumns: number[] = [],
                columns0 = reference.columns,
                columns1: Data.IDBColumn[] = columns0.slice(0),
                metadata: Mutable<IMapVectorLayerMetaData<K>> = Object.create(template);
            
            super(mapLayerDescriptor, base);
            dataModel.columns.forEach((column1, indice) => {
                if (columns0.every(column0 => column0.alias !== column1.alias)) {
                    additionalColumns.push(indice);
                    columns1.push(column1);
                }  
            });
            
            this._additionalColumns = additionalColumns;
            metadata.name = name;
            metadata.table = {
                name: name,
                columns: columns1,
                primaryKey: reference.primaryKey
            };
            this.template = metadata;
            (this.dataModel = dataModel).on(Tools.EventType.Dirty, this._onDirty, this);
        }
        
        private _onDirty(event: Data.IDataEvent): void {
            let items: Data.IDataEventItem[],
                reset: boolean,
                data = event.data;
                
            if (data) {
                reset = data.reset;
                !reset && data.items && (data.items.some(item => {
                    if (item.type !== Data.DataEventType.none) {
                        let key = this.dataModel.getKeyFromRow(item.row),
                            indice = this[_vectorModel].find(key);
                        if (indice !== -1) {
                            let row0 = this[_vectorModel].entities[indice].properties.data,
                                row1 = row0.slice(0, row0.length - this._additionalColumns.length),
                                value = item.type !== Data.DataEventType.delete_;
                            this._additionalColumns.forEach(indice => row1.push(value ? item.row[indice] : null));
                            (items || (items = [])).push({
                                type: Data.DataEventType.modify,
                                row: row1,
                                committed: true
                            });
                        }
                    }
                }));
            }
            this[_vectorModel].fireLayerEvent(items, reset);
        }
        
        public requestTiles(layer: ITileLayer<K>, tiles: ReadonlyArray<string>, callback: (tiles: ReadonlyArray<string>, rows: any[][])=> any): void {
            super.requestTiles(layer, tiles, (tiles: ReadonlyArray<string>, rows: any[][])=> {
                let model: IMapLayerModelData;
                
                rows && (model = layer.tiledModel.data) && rows.forEach(row => {
                    let key = model.getKeyFromRow(row),
                        i = this.dataModel.find(key),
                        compoundRow = this.dataModel.values[i];
                    this._additionalColumns.forEach(indice => row.push(compoundRow ? compoundRow[indice] : null));
                });
                callback(tiles, rows);
            });
        }
    }
    
    export function compoundMapLayerTiledModel<K extends DrawableLayerType = DrawableLayerType>(mapLayerDescriptor: Globals.MapLayerDescriptor, reference: Readonly<Data.IDBTableDefinition>, thematics: ILayerLegendData, dataModel: Data.IDataModel, template: IMapVectorLayerMetaData<K>, name: string, zooms: {readonly minZ: number; readonly maxZ: number;}): IMapLayerTiledModelImpl<K> {
        let provider = new CompoundTileLayerProvider<K>(mapLayerDescriptor, reference, dataModel, name, template),
            definition = provider.template.table,
            columns = definition.columns,
            data = tileVectorModel<K, CompoundTileLayerProvider<K>>(provider, columns, definition.primaryKey, name, Tools.Data.findFirstGeometry(columns)),
            mapLayerTiledModel = new MapLayerTiledModel(provider.template, thematics, provider[_vectorModel] = data);
        
        zooms.minZ && (mapLayerTiledModel.minZ = zooms.minZ);
        zooms.maxZ && (mapLayerTiledModel.maxZ = zooms.maxZ);
        return mapLayerTiledModel;
    }
}