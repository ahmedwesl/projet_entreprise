/**
 * Created by jean.rennes on 10/12/2020.
 */
///<reference path="../../helpers/Tools.ts" />
///<reference path="DataSource.ts" />
///<reference path="Index.ts" />

namespace AFC.Data {
    export interface IDataContainerChecker<T extends IDataContainer = IDataContainer> {
        check(dataContainer: T, column: IDBColumnDefinition, dirty: boolean, value: string, callback: (valid: boolean, message?: Readonly<ICheckMessage>)=> any): void;
    }
    
    export class CheckMessage implements Readonly<ICheckMessage> {
        public readonly column: IDBColumnDefinition;
        public readonly message: string;
        public readonly type: CheckMessageType;
        
        constructor(column: IDBColumnDefinition | null, value: any, messageType: CheckMessageType = CheckMessageType.error) {
            this.column = column;
            this.message = value;
            this.type = messageType;
        }
    }

    class DataRecordEventData implements IDataRecordEventData {
        public readonly columns: Data.IDBColumn[];

        constructor(column: Data.IDBColumn) {
            this.columns = [column];
        }

        public concat(storeEventData: IDataRecordEventData): IDataRecordEventData {
            storeEventData.columns.forEach(column=> {
                (this.columns.indexOf(column) === -1) && this.columns.push(column);
            });
            return this;
        }
    }
    
    export class RecordOverrides<T extends IDataContainer = IDataContainer> {
        public readonly columns: ReadonlyArray<IDBColumnDefinition>;
        public values: ReadonlyArray<any>;
        protected _override: any[];
        protected _states: boolean[];
        protected _messages: Readonly<ICheckMessage>[];
        protected _sink: Tools.EventSink;
        protected _sinks: Tools.EventSink[];
        
        constructor(columns: ReadonlyArray<IDBColumnDefinition>, values: ReadonlyArray<any>) {
            this.columns = columns;
            this.reset(values);
        }
        
        public get(indice: number): any {
            let value: any = this._override[indice];
            return (value === void 0) ? this.values[indice] : value;
        }
                
        public set(indice: number, value: any): IDataRecordEventData {
            let column: IDBColumnDefinition = this.columns[indice];
            
            if (column !== void 0) {
                if (column.index !== -1)
                    console.log('Cannot modify bookmark');
                else if (column.readOnly)
                    console.log('Cannot modify read only column');
                else {
                    if (!Tools.Data.equalValue(column.type, value, this.get(indice))) {
                        this._override[indice] = value;
                        delete this._messages[indice];
                        delete this._states[indice];
                        if (this._sinks[indice]) {
                            delete this._sinks[indice];
                            delete this._sink;
                        }
                        return new DataRecordEventData(column);
                    }
                }
            }
        }
        
        public isDirty(indice: number): boolean {
            return this._override.hasOwnProperty(indice);
        }
        
        public check(container: T,
                checker: IDataContainerChecker<T>,
                column: IDBColumnDefinition, 
                indice: number
        ): Promise<[/*column:*/ IDBColumnDefinition, /*dirty:*/ boolean, /*value:*/ any, /*valid:*/ boolean, /*message:*/ Readonly<ICheckMessage>, /*indice:*/ number]> {
            return new Promise((resolve, reject) => {
                const dirty: boolean = this.isDirty(indice),
                    value: any = dirty ? this._override[indice] : this.values[indice],
                    event: number = Tools.EventType.UserEvent + indice + 1,
                    states = this._states,
                    messages = this._messages,
                    sinks = this._sinks;
                let sink: Tools.EventSink = sinks[indice];

                if (sink) {
                    states.hasOwnProperty(indice) && sink.fireEvent(event, [states[indice], messages[indice]]);
                } else {
                    const final = (valid: boolean, message: Readonly<ICheckMessage>) => {
                        states[indice] = valid;
                        message ? (messages[indice] = message) : delete messages[indice];
                        sink.fireEvent(event, [valid, message]);
                    };

                    sinks[indice] = sink = this._sink || (this._sink = new Tools.EventSink(this));
                    (value !== void 0) && (column.nullable || (value !== null)) && Tools.Data.isValid(column.type, value) ?
                        checker.check(container, column, dirty, value, final) : 
                        final(false, new CheckMessage(column, `La valeur de la colonne [${column.alias}] est incorrecte.`));
                }
                sink.notify(event, (event: Tools.IEvent<any, [boolean, Readonly<ICheckMessage>]>) => {
                    const data = sink === sinks[indice] && event.data;
                    data ? resolve([column, dirty, value, data[0], data[1], indice]) : reject();
                });
            });
        }

        public reset(values: ReadonlyArray<any>) {
            delete this._sink;
            this.values = values;
            this._override = [];
            this._states = [];
            this._messages = [];
            this._sinks = [];
        }
        
        public invalidate(columns: ReadonlyArray<number>) {
            const sinks = this._sinks;

            delete this._sink;
            columns.forEach((indice: number)=> {
                const column = this.columns[indice];
                if (column.index === -1 && !column.readOnly) {
                    delete this._states[indice];
                    delete this._messages[indice];
                    delete sinks[indice];
                    this.isDirty(indice) || (this._override[indice] = this.values[indice]);   // force dirty flag
                }
            });
        }
    }

    export class DataRecord extends Tools.EventSink implements IDataContainer {
        protected _override: RecordOverrides;
        protected _valid: boolean;
        protected _committable: boolean;
        protected _messages: ReadonlyArray<ICheckMessage>;        
        protected _events: {[key: string]: any};
        public readonly dataModel: IDataModel;
        public readonly setData: (name: string, value: any)=> boolean;
        
        public static checkColumn<T extends DataRecord = DataRecord>(dataRecord: T, checker: IDataContainerChecker<T>, column: string, callback: (column: IDBColumnDefinition, dirty: boolean, value: any, valid: boolean, message: Readonly<ICheckMessage>, indice: number)=> any): void {
            let indice: number = dataRecord.dataModel.columnIndex[column];
            (indice !== void 0) && dataRecord._override.check(dataRecord, checker, dataRecord.dataModel.columns[indice], indice).then(result => callback(...result));            
        }
        
        public static check<T extends DataRecord = DataRecord>(dataRecord: T, checker: IDataContainerChecker<T>, callback: (valid: boolean, committable: boolean, messages: ReadonlyArray<ICheckMessage>, events: {[key: string]: any})=>any): void {
            if (dataRecord._valid !== void 0) {
                callback(dataRecord._valid, dataRecord._committable, dataRecord._messages, dataRecord._events);
            } else {
                delete dataRecord._messages;
                delete dataRecord._events;
                Promise.all(dataRecord.dataModel.columns.map((column: IDBColumnDefinition, indice: number) => dataRecord._override.check(dataRecord, checker, column, indice))).then(results=> {
                    let messages: ICheckMessage[],
                        events: {[key: string]: any},
                        global: boolean = true,
                        committable = results.every(([column, dirty, value, valid, message, indice]: [column: IDBColumnDefinition, dirty: boolean, value: any, valid: boolean, message: Readonly<ICheckMessage>, indice: number]) => {
                            message && (messages || (messages = [])).push(message);
                            dirty && !Tools.Data.equalValue(column.type, value, dataRecord._override.values[indice]) && ((events || (events = {}))[column.name] = value);
                            global = valid && global;
                            return valid || !dirty;
                        });
                    callback(dataRecord._valid = global, dataRecord._committable = committable, messages && (dataRecord._messages = messages), events && (dataRecord._events = events));
                });
            }
        }
        
        public static commit<T extends DataRecord = DataRecord>(dataModel: IDataModel, dataContainer: T, checker: IDataContainerChecker<T>, callback: (valid: boolean, committed: boolean, messages?: ReadonlyArray<ICheckMessage>, events?: {[key: string]: any})=> void): void {
            let final = (valid: boolean, committed: boolean, messages: ReadonlyArray<ICheckMessage>, events?: {[key: string]: any})=> callback && callback(valid, committed, messages, events);
            /*if (dataContainer._closed) {
                return final(false);
            }*/
            DataRecord.check(dataContainer, checker, (valid: boolean, committable: boolean, messages: ReadonlyArray<ICheckMessage>, events: {[key: string]: any})=> {
                if (committable && events) {
                    let key = dataContainer.dataModel.getKeyFromRow(dataContainer._override.values),
                        compare = (item: IDataEventItem) => item.committed && !dataModel.compareKey(item.row, key),
                        h = (event: IDataEvent)=> {
                            if (event.data.reset || event.data.items.some(compare)) {
                                let row = dataModel.getRow(dataModel.find(key));
                                row && dataContainer._override.reset(row);
                                final(valid, committable, messages, events);
                            } else {
                                dataModel.notify(Tools.EventType.Dirty, h);
                            }
                        };
                    dataModel.notify(Tools.EventType.Dirty, h);
                    /*dataContainer._created ? dataModel.create(key, events) :*/ dataModel.modify(key, events);
                } else {
                    final(valid, committable, messages);
                }
            });
        }
        
        constructor(dataModel: IDataModel, row: ReadonlyArray<any>) {
            super();
            this.dataModel = dataModel;
            this._override = new RecordOverrides(dataModel.columns, row.slice(0));
            this._valid = true;
            dataModel.modify && (this.setData = (name: string, value: any) => {
                let indice = this.dataModel.columnIndex[name],
                    dataRecordEventData = this._override.set(indice, value);
                if (dataRecordEventData) {
                    delete this._valid;
                    this.fireEvent(Tools.EventType.Dirty, dataRecordEventData);
                    return true;
                }
            });
        }
        
        public getColumn(name: string): IDBColumn {
            return this.dataModel.columns[this.dataModel.columnIndex[name]];
        }
        
        public getData(name: string, stringify?: boolean): any {
            let i: number = this.dataModel.columnIndex[name];
            let column: IDBColumn = this.dataModel.columns[i];
            let value: any;
            
            if (column) {
                value = this._override.get(i);
                if (stringify && (column.type === Data.DataKind.real)) {
                    value = Math.round(<number>value * 100) / 100;
                }
            }
            return value;
        }
    }
}