/**
 * Created by jean.rennes on 17/02/2021.
 */
///<reference path="../../helpers/Tools.ts" />

namespace AFC.Data {
    export class DataModelView<T extends IFilteredDataModel = IFilteredDataModel> extends Tools.EventSink implements IFilteredDataModel {
        public readonly columns: ReadonlyArray<IDBColumn>;
        public readonly primaryKey: ReadonlyArray<string>;
        public readonly columnIndex: { readonly [key: string]: number; };
        public readonly dataModel: T;

        constructor(dataModel: T, mapping: {[key: string]: string;}) {
            super();
            (this.dataModel = dataModel).on && dataModel.on(Tools.EventType.Dirty, this._onDirty, this);
            this.columns = dataModel.columns.map((column: IDBColumnDefinition) =>
                mapping[column.name] && column.name !== mapping[column.name] ? 
                    new DBColumnDefinition(mapping[column.name], column.type, column.index, column.size, column.alias, column.readOnly, column.qualifiers, column.geographicalLevel, column.isSearchable):
                    column
            );
            dataModel.primaryKey && (this.primaryKey = dataModel.primaryKey.map(name => mapping[name] || name));
            this.columnIndex = getColumnIndex(this.columns);
        }

        protected _onDirty(event: IDataEvent): void {
            this.fireEvent(Tools.EventType.Dirty, event.data);
        }
        
        protected _mapValues(values: {[key: string]: any}): {[key: string]: any} {
            let out: {[key: string]: any} = {},
                name, index;
            
            for (name in values) {
                (((index = this.columnIndex[name])) !== void 0) && (out[this.dataModel.columns[index].name] = values[name]);
            }
            return out;
        }

        public getRow(index: number): ReadonlyArray<ReadonlyArray<any>> {
            return this.dataModel.getRow(index);
        }
                
        public get values(): ReadonlyArray<ReadonlyArray<any>> {
            return this.dataModel.values;
        }

        public get length(): number {
            return this.dataModel.length;
        }
        
        public item(index: number): IDataItemContainer {
            return this.dataModel.item && this.dataModel.item(index);
        }
        
        public getKeyFromRow(row: any[]): ReadonlyArray<any> {
            return this.dataModel.getKeyFromRow(row);
        }

        public compareKey(row: ReadonlyArray<any>, key: ReadonlyArray<any>): number {
            return this.dataModel.compareKey(row, key);
        }
                        
        public compareRow(row0: ReadonlyArray<any>, row1: ReadonlyArray<any>): number {
            return this.dataModel.compareRow(row0, row1);
        }
        
        public create(key: any[], values: {[key: string]: any}): boolean {
            return this.dataModel.create && this.dataModel.create(key, this._mapValues(values));
        }
        
        public modify(key: any[], values: {[key: string]: any}): boolean {
            return this.dataModel.modify && this.dataModel.modify(key, this._mapValues(values));
        }
        
        public delete_(key: any[]): void {
            this.dataModel.delete_ && this.dataModel.delete_(key);
        }
        
        public indexOf(row: ReadonlyArray<any>): number {
            return this.dataModel.indexOf ? this.dataModel.indexOf(row) : -1;
        }
        
        public find(key: ReadonlyArray<any>): number {
            return this.dataModel.find ? this.dataModel.find(key) : -1;
        }
    }
}