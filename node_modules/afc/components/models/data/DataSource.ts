/**
 * Created by jean.rennes on 27/01/2016.
 */
///<reference path="../../helpers/EventSink.ts" />

namespace AFC.Data {
const _dataSource = Symbol(),
    _where = Symbol();

    class DataSourceIterator<T extends Tools.Constructor<{}>> implements Iterator<IDataItemContainer<T>, null> {
        private readonly [_dataSource]: IDataSource<T>;
        private [_where]: number;

        constructor(dataSource: IDataSource<T>) {
            this[_dataSource] = dataSource;
            this[_where] = 0;
        }

        public next(): IteratorResult<IDataItemContainer<T>, null> {
            let dataSource = this[_dataSource];
            return (this[_where] < dataSource.length) ?
                {
                    value: dataSource.item(this[_where]++)
                }: {
                    value: null,
                    done: true
                };
        }
    }

    export function DataSourceMixin<T extends Tools.Constructor<{}>>(Base: T) {
        abstract class DataSourceBase extends Base implements IDataSource<T>, Iterable<IDataItemContainer<T>> {
            public abstract get columns(): ReadonlyArray<IDBColumn>;
            public abstract get values(): ReadonlyArray<ReadonlyArray<any>>;

            public get length(): number {
                return this.values && this.values.length;
            }

            public item(index: number): AFC.Data.IDataItemContainer<T> {
                return {
                    dataItem: <T>Tools.Data.mapRow(this.columns, this.values[index]),
                    dataItemIndex: index
                };
            }

            public [Symbol.iterator](): Iterator<IDataItemContainer<T>, null> {
                return new DataSourceIterator<T>(this);
            }    
        }
        return DataSourceBase;
    }
    
    export const DataSource: Tools.Constructor<Tools.EventSink&IDataSource> = DataSourceMixin(Tools.EventSink);
    export type DataSource = typeof DataSource;
}