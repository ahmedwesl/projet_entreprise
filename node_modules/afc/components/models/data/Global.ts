/**
 * Created by jean.rennes on 13/10/2015.
 */
namespace AFC.Data {
    export const enum DataKind {
        unknown,
        character,
        real,
        integer,
        bool,
        date,
        time,
        timestamp,
        currency,
        blob,
        dynamic,
        formula,
        rectangle,
        point = 0x100000,
        line = 0x200000,
        polygon = 0x400000,
        geometry = 0x700000
    }

    export const enum TableType {
        undef,
        table,
        view,
        query,
        compound,
        cubeView,
        memory,
        filter,
        seamless,
        history,
        synonym
    }
    
    export const enum CreationType {
        query = 1,
        modification,
        embedded,
        historyView
    }

    export const enum Qualifier {
        identifier = 1,		// store code, unit code, ...
        mainAddress,
        address,		// secondary address (ADDRESS2, ...)
        zipCode,
        city,
        country,
        totalSurface,           // total store's surface (SURF_VENTE)
        surface,		// secondary surface (SURF_ALIM, SURF_TEX, SURF_BRICO, ...)
        symbol,
        brand,			// enseigne
        businessCode,           // code_type
        revenue,		// CA_REEL
        changes			// encoded modifications applied on a row from an historized table
    }

    export interface IDataCreation {
        readonly type?: CreationType;
    }

    export interface IQueryCreation extends IDataCreation {
        readonly type: CreationType.query;
        commandText: string;
        parameters?: { [key: string]: number | boolean | string | GeoJSON.GeometryObject};
    }

    export type IModificationEventValues = {[key: string]: any};

    export interface IModificationEventInfo {
        code: any;
        values: IModificationEventValues;
    }

    export interface IModificationEvents {
        fullDeletion?: boolean;
        creations?: IModificationEventInfo[];
        modifications?: IModificationEventInfo[];
        deletions?: (number|string|ReadonlyArray<number|string>)[];
    }

    export interface IModificationCreation extends IDataCreation {
        readonly type?: CreationType.modification;
        readonly reference: string;
        readonly events?: IModificationEvents;
        readonly branchInfo?: IDBHistoryBranchInfo;
    }

    export interface IDBColumn {
        readonly name: string;
        readonly alias: string;
        readonly dataId: string;
        readonly type: DataKind;
        readonly size: number;
        readonly index: number;
        readonly nullable: boolean;
        readOnly?: boolean;
        toJSON(): any;
    }

    export interface IDBColumnDefinition extends IDBColumn {
        qualifiers?: Qualifier[];
        geographicalLevel?: string;
        isSearchable?: boolean;
    }

    export interface IDBTableDefinition  {
        columns: ReadonlyArray<IDBColumnDefinition>;
        primaryKey?: ReadonlyArray<string>;
    }
    
    export interface IDataTable {
        readonly columns: ReadonlyArray<IDBColumn>;
        readonly primaryKey?: ReadonlyArray<string>;
        readonly values: ReadonlyArray<ReadonlyArray<any>>;
    }

    export const enum DataEventType {   
        // order is important
        none    = 0,
        create  = 0x1,
        modify  = 0x2,
        delete_ = 0x4,
        drop    = 0x8,
        reset   = 0x10,
    }

    export interface IKeyProvider {
        readonly columns: ReadonlyArray<IDBColumn>;
        readonly primaryKey: ReadonlyArray<string>;
        getKeyFromRow(row: ReadonlyArray<any>): ReadonlyArray<any>;
        compareKey(row: ReadonlyArray<any>, key: ReadonlyArray<any>): number;
        compareRow(row0: ReadonlyArray<any>, row1: ReadonlyArray<any>): number;
    }

    export interface IColumnIndexProvider {
        readonly columnIndex: { 
            readonly [key:string]: number;
        }
    }
        
    export interface IRowCollection {
        readonly length: number;
        indexOf(row: ReadonlyArray<any>): number;
        getRow(index: number): ReadonlyArray<any>;
    }
        
    export interface IDataItemContainer<T = {readonly [key: string]: any}> {
        readonly dataItem: T;
        readonly dataItemIndex: number;
    }
           
    export interface IDataSource<T = {readonly [key: string]: any}> {
        readonly length: number;
        item(index: number): IDataItemContainer<T>;
    }

    export interface IReadonlyStore extends IDataContainer {
        readonly tableDefinition: IDBTableDefinition;
        readonly key: ReadonlyArray<any>;
        readonly geometry: GeoJSON.Point|null;
        readonly identifier: string|null;
        readonly mainAddress: string|null;
        readonly address: string|null;
        readonly zipCode: string|null;
        readonly city: string|null;
        readonly country: string|null;
        readonly totalSurface: number|null;
        readonly surface: number|null;
        readonly symbol: string|null;
        readonly brand: string|null;
        readonly businessCode: string|null;
        readonly revenue: number|null;
        readonly changes: string|null;
        getData(column: string, stringify?: boolean): any;
        hasQualifier(qualifier: Qualifier): boolean;
        getQualifiedColumn(qualifier: Qualifier): IDBColumn;
        getColumn(name: string): IDBColumn;
    }

    export const enum CheckMessageType {
        error,
        info,
        confirm,
        user
    }
    
    export interface ICheckMessage {
        column: IDBColumnDefinition; 
        message: string;
        type: CheckMessageType;
    }

    export interface IStore extends IReadonlyStore, Tools.IObservable {
        readonly tableDescriptor: TableDescriptor;
        readonly exist: boolean;
        geometry: GeoJSON.Point|null;
        identifier: string|null;
        mainAddress: string|null;
        address: string|null;
        zipCode: string|null;
        city: string|null;
        country: string|null;
        totalSurface: number|null;
        surface: number|null;
        symbol: string|null;
        brand: string|null;
        businessCode: string|null;
        revenue: number|null;
        readonly changes: string|null;
        getOldData(column: string): any;
        setData(column: string, value: any): boolean;
        isDirty(columns?: ReadonlyArray<string>): boolean;
        checkColumn(column: string, callback: (column: IDBColumnDefinition, dirty: boolean, value: any, valid: boolean, message: Readonly<ICheckMessage>, indice: number)=>any): void;
        check(callback: (valid: boolean, messages?: ReadonlyArray<Readonly<ICheckMessage>>)=>any): void;
        commit(callback?: (valid: boolean, messages?: ReadonlyArray<Readonly<ICheckMessage>>)=>any): void;
        close(): void;
        getState(): IReadonlyStore;
        invalidate(columns?: ReadonlyArray<string>): void;
    }
        
    export interface IDataItemStoreData<S extends IReadonlyStore = IReadonlyStore> {
        readonly key: ReadonlyArray<any>;
        readonly store: S;
    }
    
    export interface IReadonlyStoreSource<T extends IDataItemStoreData = IDataItemStoreData> extends IDataSource<T> {
        hasQualifier(qualifier: Qualifier): boolean;
        getQualifiedColumn(qualifier: Qualifier): IDBColumnDefinition;
        readonly fullName: string;
        readonly geometry: IDBColumnDefinition;
    }

    export interface IDataEditor {
        create(key: ReadonlyArray<any>, values: {[key: string]: any}): any;
        modify(key: ReadonlyArray<any>, values: {[key: string]: any}): any;
        delete_(key: ReadonlyArray<any>): void;
    }
    
    export interface IStoreSource<T extends IDataItemStoreData<IStore> = IDataItemStoreData<IStore>> extends IReadonlyStoreSource<T>, IDataEditor {
        check: (storeSource: IStoreSource, store: Store, column: IDBColumnDefinition, dirty: boolean, value: string, callback: (valid: boolean, message?: Readonly<ICheckMessage>) => void) => void;
        createStore(code?: any): Store;
        dropEvents: (key: ReadonlyArray<any>)=> void;
    }
    
    export interface IDataModelBase extends IDataTable, IDataSource {
        readonly primaryKey?: ReadonlyArray<string>;
        readonly columnIndex: { [key:string]: number; };
    }
    
    export interface IDataModel extends IDataModelBase, IKeyProvider, Tools.IObservable, IRowCollection, IDataEditor {
        readonly primaryKey: ReadonlyArray<string>;
        indexOf(row: ReadonlyArray<any>): number;
        find(key: ReadonlyArray<any>): number;
    }

    export interface IDataModelViewFilter {
        session?: string;
    }

    export interface IDataModelView extends IDataModel, IDataCreation {
        branch?: string;
        branchInfo?: IDBHistoryBranchInfo;
        session: string;
        getVariations(): {row: ReadonlyArray<any>[], old: ReadonlyArray<any>[]};
        dropEvents(key: ReadonlyArray<any>, filter?: IDataModelViewFilter): void;
    }

    export interface IEmbeddedCreation extends IDataCreation {
        readonly type: CreationType.embedded;
        columns: ReadonlyArray<IDBColumn>;
        primaryKey?: ReadonlyArray<string>;
        values: ReadonlyArray<ReadonlyArray<any>>;
    }

    export interface IHistory {
        readonly stamp?: number;
        readonly refreshStamp?: number;
        readonly session?: string;
    }

    export interface IHistoryView extends IDataCreation {
        reference: string;
        history: IHistory;
        branch?: string;
    }
    
    export interface IDataEventItem {
        readonly type: DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none;
        readonly row: ReadonlyArray<any>;
        readonly committed: boolean;
    }

    export interface IDataModelEventData<I extends IDataEventItem = IDataEventItem> extends Tools.IEventData {
        reset?: boolean;
        items?: I[];
    }
    
    export type IDataEvent<I extends IDataEventItem = IDataEventItem> = Tools.IEvent<IDataModelBase & Tools.IObservable, Data.IDataModelEventData<I>>;

    export interface IDataRecordEventData extends Tools.IEventData {
        columns: ReadonlyArray<Data.IDBColumn>;
    }

    export interface IDataRecordEvent extends Tools.IEvent {
        target: IStore;
        data: IDataRecordEventData;
    }

    export interface IDataContainer {
        getData: (key: string, stringify?: boolean)=> any;
    };
        
    export interface IDataContainerProvider extends Tools.IObservable {
        getDataContainer: ()=> Promise<IDataContainer>;
    };
    
    export interface IFilterable<M extends Data.IRowCollection = Data.IRowCollection> {
        filter: ((row: ReadonlyArray<any>, dataModel: M) => boolean) | undefined;
    }
}