/**
 * Created by jean.rennes on 22/06/2018.
 */
///<reference path="../../helpers/EventSink.ts" /> 
///<reference path="../rest/RestModel.ts" />

namespace AFC.Data {
    export interface ITableResourceContent<T extends TableDescriptor = TableDescriptor> {
        readonly resource: string;
        readonly descriptor: T;
        readonly definition: IDBTableDefinition;
        readonly history?: IHistory;
    }

    export interface ISessionProvider {
        getSession(): string;
    }

    export interface ITableResource {
        readonly dbName: string;
        readonly name: string;
        readonly session: string;
        refreshStamps(): void;
        reset(rest: AFC.Rest.RestModel, dbName: string, name: string): this;
        load(): Promise<ITableResourceContent>;
        release(): void;        
    }
    
    class TableResource extends Tools.EventSink implements ITableResource {
        private _session: ISessionProvider;
        private _schema: SchemaDescriptor;
        private _dbName: string;
        private _name: string;
        private _content: Partial<Mutable<ITableResourceContent<HistoricizedTableDescriptor>>>;
        private _resource: Rest.ResourceSubstitute;
        private _sequence: number;

        constructor(sessionProvider: ISessionProvider) {
            super();
            this._session = sessionProvider;
        }

        public get dbName(): string {
            return this._content ? this._content.descriptor.database.name : this._dbName;
        }

        public get name(): string {
            return this._content ? this._content.descriptor.name : this._name;
        }

        public get session(): string {
            return this._session?.getSession();
        }

        public refreshStamps(): void {
            let content = this._content;
            
            if (content) {
                content.history = null;
                delete this._sequence;
            }
        }
                    
        public reset(rest: AFC.Rest.RestModel, dbName: string, name: string): this {
            delete this._sequence;
            delete this._content;
            this._schema = rest.schema;
            this._dbName = dbName;
            this._name = name;
            return this;
        }

        protected _updateHistory(content: Partial<Mutable<ITableResourceContent<HistoricizedTableDescriptor>>>): Promise<void> {
            let descriptor = content.descriptor;

            return descriptor.isHistoricized && new Promise(resolve => {
                this._sequence = descriptor.requestStamps((stamp: number, refreshStamp: number/*, sequence: number*/)=> {
                    let restModel = descriptor.database.schema.restModel,
                        resource = this._resource || (this._resource = restModel.pushModifier(new Rest.ResourceSubstitute(restModel, content.descriptor.fullName)));

                    resource.create(new HistoryView(descriptor.fullName, content.history = {
                        stamp: stamp,
                        refreshStamp: refreshStamp,
                        session: this.session
                    }));
                    content.resource = resource.replacement;
                    resolve();
                });
            });
        } 

        public async load(): Promise<ITableResourceContent> {
            let content = this._content || (this._content = {});
            
            return content.descriptor && (content.history || !content.descriptor.isHistoricized) ?
                <ITableResourceContent>content :
                new Promise(async (resolve, reject) => {
                    this.notify(Tools.EventType.UserEvent, () => content ? resolve(<ITableResourceContent>content) : reject());
                    if (!this._sequence) {
                        let promises = [],
                            descriptor: HistoricizedTableDescriptor;
                        
                        if (!content.definition) {
                            this._sequence = -1;
                            descriptor = <HistoricizedTableDescriptor>await getTable(this._schema, this._dbName, this._name);
                            content.descriptor = descriptor;
                            content.resource = descriptor.fullName;
                            promises[1] = descriptor.getDefinition().then(definition => {
                                content.definition = definition;
                            });
                        }
                        promises[0] = this._updateHistory(content);
                        await Promise.all(promises);
                        this.fireEvent(Tools.EventType.UserEvent);
                    }
                });
        }

        public release(): void {
            let resource = this._resource;
            
            if (resource) {
                resource.release();
                delete this._resource;
            }
            delete this._content;
            delete this._sequence;
        }
    }
    
    export const tableResource = (sessionProvider?: ISessionProvider): ITableResource => new TableResource(sessionProvider);
    
    const _resource = Symbol();
    
    export abstract class ResourceLoader<T extends ITableResourceContent = ITableResourceContent> extends Tools.EventSink {
        constructor(resource: ITableResource) {
            super();
            this[_resource] = resource;
        }

        public async getMetadata(): Promise<T> {
            let content = await this[_resource].load(),
                ref: T,
                history,
                refresh = true;
                
            if (!content) 
                throw '';
            
            if (ref) {
                history = content.history;
                refresh = history && (history.stamp !== ref.history.stamp || history.refreshStamp !== ref.history.refreshStamp || history.session !== ref.history.session);
            } else {
                this._content = ref = <T>{};
            }
            refresh && $.extend(ref, content);
            return ref;
        }

        public get tableResource(): ITableResource {
            return this[_resource];
        }

        public clone(): ResourceLoader {
            let clone: ResourceLoader<T> = Reflect.construct(ResourceLoader, [this[_resource]], this.constructor);
            clone._content = this._content;
            return clone;
        } 
        
        protected _content: T;
        /** @internal */        
        private [_resource]: ITableResource;        
    }    
}