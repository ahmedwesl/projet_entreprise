/**
 * Created by jean.rennes on 13/02/2017.
 */
///<reference path="../../helpers/Tools.ts" />

namespace AFC.Data {
    export interface IScenarioCreation {
        [key: string]: any;
    }

    export interface IScenarioModification {
        oldValues: {[key: string]: any};
        values: {[key: string]: any};
    }

    export interface IScenarioDeletion {
        [key: string]: any;
    }

    type EventType = DataEventType.create | DataEventType.modify | DataEventType.delete_;

    const _storeSource = Symbol(),
        _store =  Symbol(),
        _items = Symbol(),
        _creations =  Symbol(),
        _modifications =  Symbol(),
        _deletions = Symbol();

    class EventInfo implements Globals.IEventInfo {
        constructor(eventType: EventType, storeSource: StoreSource, values: ReadonlyArray<any>, oldValues: ReadonlyArray<any> | undefined) {
            this.eventType = eventType;
            this.values = values;
            this.oldValues = oldValues;
            this[_storeSource] = storeSource;
        }

        public get store(): Data.IReadonlyStore {
            return this[_store] || (this[_store] = this[_storeSource].getStoreFromRow(this.values));
        }

        public get key(): ReadonlyArray<any> {
            return this.store.key;
        }

        public getInitialData(column: string): ReadonlyArray<any> | undefined {
            const oldRow = this.oldValues;
            return oldRow && oldRow[this[_storeSource].columnIndex[column]];
        }

        public readonly eventType: EventType;
        public readonly values: ReadonlyArray<any>;
        public readonly oldValues: ReadonlyArray<any> | undefined;
        /** @internal */
        private [_store]: Data.IReadonlyStore;
        /** @internal */
        private readonly [_storeSource]: StoreSource;
    }

    function _build(storeSource: StoreSource, variations: {row: ReadonlyArray<any>[], old: ReadonlyArray<any>[]}): EventInfo[] {
        let infos: EventInfo[] = [];
        variations && variations.row.forEach((values: ReadonlyArray<any>, i: number)=> {
            let old: ReadonlyArray<any> | undefined = variations.old[i],
                eventType: EventType = old ? DataEventType.modify : DataEventType.create;
            
            if (!values) {
                values = old;
                eventType = DataEventType.delete_;
            }
            values && infos.push(new EventInfo(eventType, storeSource, values, old));
        });
        return infos;
    }

    function _translate(columns: ReadonlyArray<IDBColumn>, row: ReadonlyArray<any>):{[key: string]: any} {
        let values: {[key: string]: any} = {};
        
        columns.forEach((item, indice)=>values[item.name]=row[indice]);
        return values;
    }

    function _getModification(columns: ReadonlyArray<IDBColumn>, row: ReadonlyArray<any>, old: ReadonlyArray<any>): IScenarioModification {
        let oldValues: {[key: string]: any};
        let values: {[key: string]: any} = {};

        columns.forEach((item, indice)=>{
            ((values[item.name]=row[indice])!==old[indice])&&((oldValues || (oldValues = {}))[item.name]=old[indice]);
        });
        return oldValues ? {values: values, oldValues: oldValues} : void 0;
    }

    export class Scenario extends Tools.EventSink implements IRowCollection, IKeyProvider, IDataSource<Globals.IEventInfo> {
        constructor(storeSource: StoreSource, model: IDataModelView) {
            super();
            this.model = model;
            this[_items] = _build(storeSource, model.getVariations());
            (this.source = storeSource).on(Tools.EventType.Dirty, this._onDirty, this);
        }

        protected _onDirty(event: Data.IDataEvent): void {
            this[_items] = _build(this.source, this.model.getVariations());
            delete this[_creations];
            delete this[_modifications];
            delete this[_deletions];
            this.fireEvent(Tools.EventType.Dirty, new Data.DataEventData(void 0, true));
        }

        public get creations(): ReadonlyArray<IScenarioCreation> {
            return this[_creations] || (this[_creations] = this._filter(DataEventType.create, _translate));
        }

        public get modifications(): ReadonlyArray<IScenarioModification> {
            return this[_modifications] || (this[_modifications] = this._filter(DataEventType.modify, _getModification));
        }

        public get deletions(): ReadonlyArray<IScenarioDeletion> {
            return this[_deletions] || (this[_deletions] = this._filter(DataEventType.delete_, _translate));
        }

        private _filter<T>(type: EventType, converter: (columns: ReadonlyArray<IDBColumn>, row: ReadonlyArray<any>, old: ReadonlyArray<any>) => T): ReadonlyArray<T> {
            const columns = this.columns;
            return this[_items].filter(info => info.eventType === type).map(info => converter(columns, info.values, info.oldValues));
        }

        /* IRowCollection */
        public get length(): number {
            return this[_items].length;
        }

        public indexOf(row: ReadonlyArray<any>): number  {
            return this[_items].findIndex(info => !compareKey(info.values, row));
        }

        public getRow(index: number): ReadonlyArray<any> {
            const info = this[_items][index];
            return info && info.values;
        }

        /* IKeyProvider */
        public get columns(): ReadonlyArray<IDBColumn> {
            return this.model.columns;
        }

        public get primaryKey(): ReadonlyArray<string> {
            return this.model.primaryKey;
        }

        public getKeyFromRow(row: ReadonlyArray<any>): ReadonlyArray<any> {
            return this.model.getKeyFromRow(row);
        }

        public compareKey(row: ReadonlyArray<any>, key: ReadonlyArray<any>): number {
            return this.model.compareKey(row, key);
        }

        public compareRow(row0: ReadonlyArray<any>, row1: ReadonlyArray<any>): number {
            return this.model.compareRow(row0, row1);
        }

        /* IDataSource */
        public item(index: number): IDataItemContainer<Globals.IEventInfo> {
            const info = this[_items][index];
            return info && {
                dataItem: info,
                dataItemIndex: index
            };
        }

        public dropEvents(key: ReadonlyArray<any>): void {
            this.model.dropEvents(key);
        }
        
        /** @internal */
        private [_items]: ReadonlyArray<EventInfo>;
        /** @internal */
        private [_creations]: ReadonlyArray<IScenarioCreation>;
        /** @internal */
        private [_modifications]: ReadonlyArray<IScenarioModification>;
        /** @internal */
        private [_deletions]: ReadonlyArray<IScenarioDeletion>;

        public readonly source: StoreSource;
        public readonly model: IDataModelView;
    }
}