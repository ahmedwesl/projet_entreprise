/**
 * Created by jean.rennes on 27/01/2016.
 */
///<reference path="../../helpers/Tools.ts" />
///<reference path="DataSource.ts" />
///<reference path="Index.ts" />

namespace AFC.Data {
    interface IHistorizedDataEventItemBase<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none> extends IDataEventItem {
        readonly branch: number;
        readonly type: T;
    }
    
    export type IHistorizedDataEventItem<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none = DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none> = 
        T extends DataEventType.create | DataEventType.modify ?
            IHistorizedDataEventItemBase<T> & { readonly values: {readonly [key: string]: any}; } :
            IHistorizedDataEventItemBase<T>;
    
    interface IDataModelArray extends Array<any> {
        __pos: number;
    }
    
    interface IHistorizedDataEventItemBaseEx<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none> extends Mutable<IHistorizedDataEventItemBase<T>> {
        row: IDataModelArray;
    }
    
    type IHistorizedDataEventItemEx<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none = DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none> = 
        T extends DataEventType.create | DataEventType.modify ?
            IHistorizedDataEventItemBaseEx<T> & { values: {readonly [key: string]: any}; } :
            IHistorizedDataEventItemBaseEx<T>;
            
    type IHistorizedDataEventInfo<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none = DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none> = IHistorizedDataEventItemEx<T> & {
        stamp: number;
        session: number;
    }

    interface IDataEventSeedBase<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none | DataEventType.drop | DataEventType.reset> {
        type: T;
        branch: number;
        session: number;
    }
    
    type IDataEventDropSeed = IDataEventSeedBase<DataEventType.drop> & { 
        filter: IDataModelViewFilter;
        key: ReadonlyArray<any>;
    };

    interface IDataEventUpdateSeedBase<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none> extends IDataEventSeedBase<T> {
        info?: IHistorizedDataEventInfo<T>;
        key: ReadonlyArray<any>;
    }

    type IDataEventUpdateSeed<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none = DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none> = 
        T extends DataEventType.create | DataEventType.modify ? 
            IDataEventUpdateSeedBase<T> & { values: {[key: string]: any}; } : 
            IDataEventUpdateSeedBase<T>;
        
    type ISeed<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none | DataEventType.drop | DataEventType.reset = DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none | DataEventType.drop | DataEventType.reset> =
        T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none ? IDataEventUpdateSeed<T> : 
        T extends DataEventType.drop ? IDataEventDropSeed : 
        IDataEventSeedBase<DataEventType.reset>;
    
    interface ISeedsEvent extends Tools.IEvent {
        data: ISeed[];
    }
    
    class ModifiedArray extends Array implements IDataModelArray {
        public __pos: number;

        constructor(pos: number, row?: IDataModelArray) {
            super();
            this.__pos = pos;
            if (row) {
                this.length = row.length;
                row.forEach((item: any, i: number)=>this[i] = item);
            }
        }

        public clone(): ModifiedArray {
            return Reflect.construct(ModifiedArray, [this.__pos, this], this.constructor);
        }
    }

    function _mergeSeed(next: ISeed<DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none>, seed: ISeed<DataEventType.create | DataEventType.modify | DataEventType.delete_>): void {
        if (next.type === DataEventType.delete_) {
            if (seed.type === DataEventType.create) {
                (<any>next).type = DataEventType.none;
            }
        }
        else {
            (<any>next).type = seed.type; 
            if ((<any>seed).values) {   // creation or modification
                let values: {[key: string]: any} = (<any>next).values;
                
                (<any>next).values = (<any>seed).values;
                for (let i in values) {
                    (<any>next).values[i] = values[i];
                }
            }
        }
    }

    export class DataEventData implements IDataModelEventData {
        public reset: boolean;
        public items: IDataEventItem[];

        constructor(items?: IDataEventItem[], reset?: boolean) {
            reset ? (this.reset = true) : items && (this.items = items);
        }

        public concat(d: IDataModelEventData): DataEventData {
            if (d.reset) {
                this.reset = true;
                delete this.items;
            }
            else if (!this.reset) {
                d.items && (this.items = this.items ? this.items.concat(d.items) : d.items);
            }
            return this;
        }
    }
    
    interface IDataEventData extends DataEventData {
        items: IHistorizedDataEventItemEx[];
    }

    export class DBColumn implements IDBColumn {
        public readonly name: string;
        public readonly alias: string;
        public readonly dataId: string;
        public readonly type: DataKind;
        public readonly size: number;
        public readonly index: number;
        public readonly nullable: boolean;
        public readonly readOnly: boolean;

        constructor(name: string, type: DataKind, index: number, size?: number, alias?: string, readOnly?: boolean, nullable: boolean = true, dataId?: string) {
            this.name = name;
            this.type = type;
            this.index = index;
            this.size = size || 0;
            this.alias = alias || name;
            this.nullable = nullable;
            readOnly && (this.readOnly = readOnly);
            dataId && (this.dataId = dataId);
        }
        
        public toJSON(): any {
            let o: {name: string, type: string, size?: number, alias?: string} = {
                name: this.name,
                type: dataKind(this.type)
            }
            this.size && (o.size = this.size);
            this.alias && (o.alias = this.alias);
            return o;
        }
    }

    const _creationTypeLookup: {[key: number]: string;} = {
        [CreationType.query]: 'asteropTableTypeQuery',
        [CreationType.modification]: 'asteropTableTypeModification',
        [CreationType.embedded]: 'asteropTableTypeEmbedded',
        [CreationType.historyView]: 'asteropTableTypeHistoryView'
    };

    abstract class DataCreation implements IDataCreation {
        public abstract get type(): CreationType;

        public toJSON(): any {
            return {type: _creationTypeLookup[this.type]};
        }
    }

    export class QueryCreation extends DataCreation implements IQueryCreation {
        public commandText: string;
        public parameters?: { [key: string]: number | boolean | string | GeoJSON.GeometryObject};

        constructor(commandText: string, parameters?: { [key: string]: number | boolean | string | GeoJSON.GeometryObject}) {
            super();
            this.commandText = commandText;
            this.parameters = parameters;
        }

        public get type(): CreationType.query {
            return CreationType.query;
        }

        public toJSON(): any {
            let o: IQueryCreation = super.toJSON();
            o.commandText = this.commandText;
            o.parameters = this.parameters;
            return o;
        }
    }

    export class ModificationCreation extends DataCreation implements IModificationCreation {
        public readonly reference: string;
        public readonly events: IModificationEvents;
        public readonly branchInfo: IDBHistoryBranchInfo;

        constructor(reference: string, events: IModificationEvents, branchInfo?: IDBHistoryBranchInfo) {
            super();
            this.reference = reference;
            this.events = events;
            this.branchInfo = branchInfo;
        }

        public get type(): CreationType.modification {
            return CreationType.modification;
        }

        public toJSON(): any {
            let o: Mutable<IModificationCreation> = super.toJSON();
            o.reference = this.reference;
            o.events = this.events;
            o.branchInfo = this.branchInfo;
            return o;
        }
    }

    export class EmbeddedCreation extends DataCreation implements IEmbeddedCreation {
        public columns: ReadonlyArray<IDBColumn>;
        public primaryKey: ReadonlyArray<string>;
        public values: ReadonlyArray<ReadonlyArray<any>>;

        constructor(columns: ReadonlyArray<IDBColumn>, primaryKey: ReadonlyArray<string>, values: ReadonlyArray<ReadonlyArray<any>>) {
            super();
            this.columns = columns;
            this.primaryKey = primaryKey;
            this.values = values;
        }

        public get type(): CreationType.embedded {
            return CreationType.embedded;
        }

        public toJSON(): any {
            let o: IEmbeddedCreation = super.toJSON();
            o.columns = this.columns;
            o.primaryKey = this.primaryKey;
            o.values = this.values;
            return o;
        }
    }

    export function isValidHistory(history: IHistory): boolean {
        return history && <boolean>((history.stamp !== void 0) || (history.refreshStamp !== void 0) || history.session);
    }

    export class HistoryView extends DataCreation implements IHistoryView {
        public readonly reference: string;
        public readonly history: IHistory;
        public readonly branch: string;

        constructor(reference: string, history?: IHistory, branch?: string) {
            super();
            this.reference = reference;
            isValidHistory(history) && (this.history = history);
            this.branch = branch;
        }

        public get type(): CreationType.historyView {
            return CreationType.historyView;
        }

        public toJSON(): any {
            let o: IHistoryView = super.toJSON();
            o.reference = this.reference;
            this.history && (o.history = this.history);
            o.branch = this.branch;
            return o;
        }
    }

    export function mapDataColumns(definition: {
        columns: ReadonlyArray<{
            name: string;
            type: string;
            alias?: string;
            dataId?: string;
            size?: number;
            isPseudoColumn?: boolean;
            notNullable?: boolean;
        }>;
        primaryKey?: ReadonlyArray<string>;
    }): IDBColumn[] {
        return definition.columns.map(column => new DBColumn(column.name, dataKind(column.type), definition.primaryKey ? definition.primaryKey.indexOf(column.name) : -1, column.size, column.alias, column.isPseudoColumn, !column.notNullable, column.dataId));
    }

    export function updateDataRows(columns: ReadonlyArray<IDBColumn>, rows: any[][]): any[][] {
        rows && columns.forEach((column, indice) => {
            switch (column.type) {
                case DataKind.date:
                case DataKind.time:
                case DataKind.timestamp:
                    rows.forEach(row => row[indice] && (row[indice] = new Date(row[indice])));
            }
        });
        return rows;
    }
    
    export function updateTableData(data: {
            columns: ReadonlyArray<{
                name: string;
                type: string;
                alias?: string;
                dataId?: string;
                size?: number;
                isPseudoColumn?: boolean;
                notNullable?: boolean;
            }>;
            primaryKey?: ReadonlyArray<string>;
            values?: any[][]
        }): IDataTable {
        let dataTable: Mutable<IDataTable> = <any>data;
        data?.columns && updateDataRows(dataTable.columns = mapDataColumns(data), data.values);
        return dataTable;
    }

    export function compareKey(key0: ReadonlyArray<any>, key1: ReadonlyArray<any>): number {
        let iLength: number = key0.length,
            ret: number = iLength - key1.length;

        for (let i: number = 0; !ret&&(i < iLength); ++i) {
            ret = compareValue(key0[i], key1[i]);
        }
        return ret;
    }
    
    export function getColumnIndex(columns: ReadonlyArray<IDBColumn>): { [key:string]: number; } {
        let columnIndex: { [key:string]: number; } = {};
        columns.forEach((item: IDBColumn, i: number) => columnIndex[item.name] = columnIndex[item.alias] = i);
        return columnIndex;
    }
    
    abstract class DataModelBaseEx extends DataSource implements IDataModelBase, IDataCreation {
        public readonly columns: ReadonlyArray<IDBColumn>;
        public readonly columnIndex: { readonly [key:string]: number; };
        public values: ReadonlyArray<ReadonlyArray<any>>;
        public abstract primaryKey: ReadonlyArray<string>;

        constructor(columns: ReadonlyArray<IDBColumn>, values?: ReadonlyArray<ReadonlyArray<any>>) {
            super();
            this.columnIndex = getColumnIndex(this.columns = columns);
            values && (this.values = values);
        }

        public get type(): CreationType {
            return CreationType.embedded;
        }

        public toJSON(): any {
            return EmbeddedCreation.prototype.toJSON.call(this);
        }
    }

    export class DataModelBase extends DataModelBaseEx {
        public readonly primaryKey: ReadonlyArray<string>;

        constructor(columns: ReadonlyArray<IDBColumn>, primaryKey?: ReadonlyArray<string>, values?: ReadonlyArray<ReadonlyArray<any>>) {
            super(columns, values);
            primaryKey && (this.primaryKey = primaryKey);
        }
    }

   interface ITable {
        readonly columns: ReadonlyArray<IDBColumn>;
        readonly columnIndex: { readonly [key: string]: number; };        
    }

    function _createRow(model: ITable, key: ReadonlyArray<any>, row: any[], values: {[key: string]: any}, newValues?: {[key: string]: any}): boolean {
        return model.columns.every((column: IDBColumn, indice: number) => {
            let value: any;

            if (column.index === -1) {
                if ((value = values[column.name]) !== void 0) {
                    newValues&&(newValues[column.name] = value);
                } else {
                    value = null;
                }
            } else {
                value = key[column.index];
            }

            if (Tools.Data.isValid(column.type, value)) {
                row[indice] = value;
                return true;
            }
        });
    }
        
    function _compareValue(indice: number, column: IDBColumn, row: ReadonlyArray<any>, value: any): boolean {
        return column && (column.index === -1) && Tools.Data.isValid(column.type, value) && !Tools.Data.equalValue(column.type, row[indice], value);
    }
    
    function _fillRow(model: ITable, row: any[], values: {[key: string]: any}, oldValues?: {[key: string]: any}, newValues?: {[key: string]: any}): boolean {
        let name: string, indice: number, value: any;
        let changed: boolean = false, column;

        for (name in values) {
           if (_compareValue(indice = model.columnIndex[name], column = model.columns[indice], row, value = values[name])) {
                oldValues && (oldValues[name] = row[indice]);
                newValues && (newValues[name] = value);
                row[indice] = value;
                changed = true;
            }
        }
        return changed;
    }
    
    interface IModel {
        readonly columns: ReadonlyArray<IDBColumn>;
        readonly columnIndex: { readonly [key: string]: number; };
    }
    
    export function createRowFromValues(model: IModel, key: ReadonlyArray<any>, values: {[key: string]: any}, newValues?: {[key: string]: any}): ReadonlyArray<any> {
        let row: any[] = new Array(model.columns.length);
        _createRow(model, key, row, values, newValues);
        return row;
    }
    
    export function modifyRowWithValues(model: IModel, row: ReadonlyArray<any>, values: {[key: string]: any}, oldValues?: {[key: string]: any}, newValues?: {[key: string]: any}): ReadonlyArray<any> {
        let copy: any[] = row.slice();
        return _fillRow(model, copy, values, oldValues, newValues) && copy;
    }
    
    export class DataModel extends DataModelBaseEx implements IDataModel {
        protected _index: UniqueIndex;
        protected _primaryKey: ReadonlyArray<number>;

        constructor(columns: ReadonlyArray<IDBColumn>, primaryKey: ReadonlyArray<string>, values?: ReadonlyArray<ReadonlyArray<any>>) {
            super(columns);
            this._primaryKey = primaryKey.map((item: string) => this.columnIndex[item]);
            this.setValues(values, true);
        }

        public get primaryKey(): ReadonlyArray<string> {
            let columns: ReadonlyArray<IDBColumn> = this.columns;
            return this._primaryKey && this._primaryKey.map((i: number) => columns[i].name);
        }
        
        public setValues(values?: ReadonlyArray<ReadonlyArray<any>>, noFire?: boolean): void {
            this._index = new UniqueIndex(this._primaryKey, values || []);
            this.values = this._index.values;
            noFire || this.fireEvent(Tools.EventType.Dirty, new DataEventData(void 0, true));
        }
          
        public getKeyFromRow(row: ReadonlyArray<any>): ReadonlyArray<any> {
            return this._index?.getKeyFromRow(row);
        }

        public compareKey(row: ReadonlyArray<any>, key: ReadonlyArray<any>): number {
            return this._index?.compareKey(row, key);
        }

        public compareRow(row0: ReadonlyArray<any>, row1: ReadonlyArray<any>): number {
            return this._index?.compareRow(row0, row1);
        }

        /** @internal */
        public lowerKeyBound(key: ReadonlyArray<any>): number {
            return this._index?.lowerKeyBound(key);
        }
         
        /** @internal */
        public createAt(i: number, row: ReadonlyArray<any>): true {
            this._index.insert(i, row);
            this.fireEvent(Tools.EventType.Dirty, new DataEventData([{
                type: DataEventType.create,
                row: row,
                committed: true
            }]));
            return true;
        }
        
        public create(key: ReadonlyArray<any>, values: {[key: string]: any}): boolean {
            let i: number = this.lowerKeyBound(key),
                row0: ReadonlyArray<any> = this.values[i],
                row: any[];
            return (!row0 || this._index.compareKey(row0, key)) && _createRow(this, key, row = [], values) && this.createAt(i, row);
        }
        
        /**
         * AFC Internal method, ignore readonly 
         */
         /** @internal */
        public modifyAtEx(i: number, row: ReadonlyArray<any>): void {
            let row0 = <any[]>this.values[i];
            
            this.columns.some((column, indice) => _compareValue(indice, column, row0, row[indice])) && this.fireEvent(Tools.EventType.Dirty, new DataEventData([{
                type: DataEventType.modify,
                row: (<ReadonlyArray<any>[]>this.values)[i] = row,
                committed: true
            }]));
        }

        /** @internal */
        public modifyAt(i: number, values: {[key: string]: any}): boolean {
            let row: any[];
            
            if ((i !== -1) && _fillRow(this, row = <any[]>this.values[i], values)) {
                this.fireEvent(Tools.EventType.Dirty, new DataEventData([{
                    type: DataEventType.modify,
                    row: row,
                    committed: true
                }]));
                return true;
            }
        }
                
        public modify(key: ReadonlyArray<any>, values: {[key: string]: any}): boolean {
            let i: number = this.find(key);
            return this.modifyAt(i, values);
        }

        /** @internal */
        public deleteAt(i: number): void {
            this.fireEvent(Tools.EventType.Dirty, new DataEventData([{
                type: DataEventType.delete_,
                row: this.values[i],
                committed: true
            }]));
            this._index.delete_(i);
        }
        
        public delete_(key: ReadonlyArray<any>): boolean {
            let i: number = this.find(key);
            return (i !== -1) && (this.deleteAt(i), true);
        }

        public indexOf(row: ReadonlyArray<any>): number {
            return this._index ? this._index.indexOf(row) : -1;
        }
        
        public find(key: ReadonlyArray<any>): number {
            return this._index ? this._index.find(key) : -1;
        }
        
        public getRow(index: number): ReadonlyArray<any> {
            return this.values && this.values[index];
        }
    }
    
    class DataModelMap {
        protected _counter: number;
        protected _dict: any;
        
        constructor() {
            this._counter = 1;
            this._dict = {};
        }
        
        public add(value: string): number {
            return (this._dict[value] || (this._dict[this._dict[++this._counter] = value] = this._counter));
        }
        
        public remove(value: number|string): void {
            let v = this._dict[value];
            
            delete this._dict[v];
            delete this._dict[value];
        }
        
        public get(value: string): number;
        public get(value: number): string;
        public get(value: number|string): number|string {
            return this._dict[value];
        }        
    }
        
    const _rows = Symbol(),
        _dropInfo = Symbol(),
        _reset = Symbol(),
        _refreshRow = Symbol(),
        _refreshRows = Symbol();
    abstract class BranchBaseEx extends DataSource implements IDataModelView {
        protected readonly _pool: Pool;
        protected readonly _map: DataModelMap;
        protected readonly _branch: number;
        protected _dispatcher: EventDispatcher;
        protected _dataModel: DataModelRef;
        protected _session: number;
        protected _index: UniqueIndex;
        /** @internal */
        public [_rows]: {[key: number]: ModifiedArray};

        constructor(pool: Pool, map: DataModelMap, branch: number) {
            super();
            this._pool = pool;
            this._map = map;
            this._branch = branch;
            this.on(Tools.EventType.Attach, this._onAttach, this);
        }

        protected static _ready(branch: BranchBaseEx, callback: ()=> any): void {
            branch._index ? callback() : branch.notify(Tools.EventType.Dirty, callback);
        }

        public static getIndex(branch: BranchBaseEx): UniqueIndex {
            return branch._index;
        }

        public static cloneIndex(branch: BranchBaseEx): UniqueIndex {
            return branch._index.clone();
        }

        public static branchNb(branch: BranchBaseEx): number {
            return branch._branch;
        }

        public static sessionNb(branch: BranchBaseEx): number {
            return branch._session;
        }

        protected _init(dataModel: DataModelRef, dispatcher: EventDispatcher) {
            this._dataModel = dataModel;
            this._dispatcher = dispatcher;
            this._refresh();
        }

        protected abstract _getReferenceRow(pos: number): IDataModelArray;
        
        protected abstract _createIndex(): UniqueIndex;

        protected _createInternal(i: number, key: ReadonlyArray<any>, values: {[key: string]: any}, pos: number = this._dataModel.create(), filteredValues?: {[key: string]: any}): ModifiedArray {
            let row: ModifiedArray = new ModifiedArray(pos);
            
            if (_createRow(this._dataModel, key, row, values, filteredValues)) {
                this._index.insert(i, row);
                this[_rows][row.__pos] = row;
                return row;
            }
        }

        protected _create(key: ReadonlyArray<any>, values: {[key: string]: any}, committed: boolean, pos?: number): IHistorizedDataEventInfo {
            let filteredValues: {[key: string]: any};
            let i: number = this._index.lowerKeyBound(key);

            if (i < this.values.length && (!this._index.compareKey(this.values[i], key))) {
                return;
            }
            let row: ModifiedArray = this._createInternal(i, key, values, pos, filteredValues = {});
            return row && <any>{
                type: DataEventType.create,
                row: row,
                values: filteredValues,
                committed: committed
            };
        }

        protected _modifyInternal(i: number, values: {[key: string]: any}, oldValues?: {[key: string]: any}, filteredValues?: {[key: string]: any}): ModifiedArray {
            let ref: IDataModelArray = <IDataModelArray>this.values[i];
            let pos: number = ref.__pos;
            let row: ModifiedArray = this[_rows][pos] || new ModifiedArray(pos, ref);

            if (_fillRow(this, row, values, oldValues, filteredValues)) {
                this._index.modify(i, this[_rows][pos] = row);
                return row;
            }
        }

        protected _modify(key: ReadonlyArray<any>, values: {[key: string]: any}, committed: boolean, oldValues?: {[key: string]: any}): IHistorizedDataEventInfo {
            let i: number = this._index.find(key);

            if (i === -1) {
                return;
            }      
            let filteredValues: {[key: string]: any};
            let row: ModifiedArray = this._modifyInternal(i, values, oldValues, filteredValues = {});
            return row && <any>{
                type: DataEventType.modify,
                row: row,
                values: filteredValues,
                committed: committed
            };
        }

        protected _deleteInternal(i: number): IDataModelArray {
            let ref: IDataModelArray = <IDataModelArray>this.values[i];
            
            this[_rows][ref.__pos] = void 0;
            this._index.delete_(i);
            return ref;
        }

        protected _delete(key: ReadonlyArray<any>): IHistorizedDataEventInfo {
            let i: number = this._index.find(key);

            if (i === -1) {
                return;
            }      
            return <any>{
                type: DataEventType.delete_,
                row: this._deleteInternal(i),
                committed: true
            };
        }

        protected _restoreRow(sample: IDataModelArray, reference?: IDataModelArray): number {
            let i: number = this._index.lowerBound(sample);

            if (reference) {
                if ((i >= this._index.values.length) || this._index.compareRow(this._index.values[i], sample)) {
                    this._index.insert(i, reference);
                } else
                    this._index.modify(i, reference);
            }
            else if ((i < this._index.values.length) && !this._index.compareRow(this._index.values[i], sample)) {
                this._index.delete_(i);
            }
            return i;
        }

        /** @internal */
        protected [_refreshRow](sample: IDataModelArray, committed: boolean, defaultEvent?: IHistorizedDataEventItemEx): IHistorizedDataEventItemEx {
            let e: IHistorizedDataEventItemEx;
            let pos: number = sample.__pos;
            let modified: boolean = this[_rows].hasOwnProperty(<any>pos);
            let reference: IDataModelArray = this._getReferenceRow(pos);
            let branch = this._branch;

            if (modified) {
                let old: ModifiedArray = this[_rows][pos];
                let values: {[key: string]: any;};          
                let info: IHistorizedDataEventInfo;
                
                if (reference) {
                    let columns = this.columns;
                    
                    values = {};
                    for (let s in this.columnIndex) {
                        if (columns[this.columnIndex[s]].name === s)
                            values[s] = reference[this.columnIndex[s]];
                    }
                }
                for (let j: number = 0; (j < this._dispatcher.dataEvents.length); ++j) {
                    info = this._dispatcher.dataEvents[j];
                    if ((info.branch === branch) && (info.row.__pos === pos)) {
                        if (info.type === DataEventType.create) {
                            values = $.extend({}, info.values);
                        } else if ((info.type === DataEventType.modify) && values) {
                            $.extend(values, info.values);
                        } else {
                            values = void 0;
                            break;
                        }
                    }
                }
                if (values) {
                    if (old) {
                        let filteredValues = {};
                        
                        if (_fillRow(this, old, values, null, filteredValues)) {
                            e = {
                                committed: committed,
                                type: DataEventType.modify,
                                row: old,
                                values: filteredValues,
                                branch: branch
                            };
                        }
                    } else {
                        e = this._create(this.getKeyFromRow(sample), values, committed, pos);
                    }
                } else if (old) {
                    this._restoreRow(sample);
                    e = {
                        committed: true,
                        type: DataEventType.delete_,
                        row: old,
                        branch: branch
                    };
                    defaultEvent ? this[_rows][pos] = void 0 : delete this[_rows][pos];   // delete modification if it's not a case of propagation (case of propagation = event from trunk -> branch)
                }
            } else {
                this._restoreRow(sample, reference);
                e = defaultEvent;
            }
            return e;
        }

        protected _dropEvent(key: ReadonlyArray<any>, filter: IDataModelViewFilter): IHistorizedDataEventItemEx {
            let h: (info: IHistorizedDataEventInfo) => boolean;
            
            if (filter && (filter.session !== void 0)) {
                let session = this._map.get(filter.session);
                if (session !== void 0) {
                    h = (info: IHistorizedDataEventInfo) => (info.session !== session);
                }
            }
            else {
                h = (/*info: IDataEventInfo*/)=> false;
            }
            
            return this[_dropInfo](key, h);
        }

        protected _refresh(): void {
            delete this._index;
            delete this[_rows];
            if (this._dataModel) {
                this.fireEvent(Tools.EventType.Attach);
            }
        }

        protected _onAttach(): void {
            if (this._dataModel.values) {
                this._index = this._createIndex();
                this[_rows] = {};
                this.fireEvent(Tools.EventType.Dirty, new DataEventData(void 0, true));
            }
        }

        /** @internal */
        public [_reset](): void {
            throw new Error();      // not implemented !!!
        }
        
        public getRow(pos: number): IDataModelArray {
            return this[_rows].hasOwnProperty(<any>pos) ? this[_rows][pos] : this._getReferenceRow(pos);
        }

        public applySeeds(seeds: (IDataEventUpdateSeed|IDataEventDropSeed)[], stamp: number, committed: boolean): IDataEventData {
            let events: IHistorizedDataEventItemEx[];
            let i: number = 0;
            let eventData: DataEventData;

            seeds.forEach(seed => {
                let info: IHistorizedDataEventInfo, e: IHistorizedDataEventItemEx;

                switch(seed.type) {
                    case DataEventType.create:
                        info = this._create(seed.key, seed.values, committed);
                        break;
                    case DataEventType.modify:
                        info = this._modify(seed.key, seed.values, committed);
                        break;
                    case DataEventType.delete_:
                        info = this._delete(seed.key);
                        break;
                    case DataEventType.drop:
                        e = this._dropEvent(seed.key, seed.filter);
                        break;
                }

                if (info) {
                    info.stamp = stamp;
                    info.branch = this._branch;
                    info.session = seed.session;
                    (<IDataEventUpdateSeed>seed).info = info;
                    this._dispatcher.dataEvents.push(info);
                    e = info;
                }
                if (e) {
                    (events || (events = [])).push(e);
                    seeds[i++] = seed;
                }
            });
            seeds.length = i;
            events && this.fireEvent(Tools.EventType.Dirty, eventData = new DataEventData(events));
            return <IDataEventData>eventData;
        }

        public set session(value: string) {
            let oldSession = this._session;
            if (oldSession) {
                delete this._session;
                this._map.remove(oldSession);
                if (this._dataModel) {
                    this._dispatcher.dataEvents = this._dispatcher.dataEvents.filter(item => item.branch !== this._branch || !item.session || item.session === this._session);                
                }
            }
            if (value !== void 0) {
                this._session = this._map.add(value);
            }
        }

        public get session(): string {
            return this._session ? this._map.get(this._session): void 0;
        }

        public get columns(): ReadonlyArray<IDBColumn> {
            return this._dataModel && this._dataModel.columns;
        }

        public get primaryKey(): ReadonlyArray<string> {
            return this._dataModel && this._dataModel.primaryKey;
        }

        public get values(): ReadonlyArray<any>[] {
            return this._index && this._index.values;
        }

        public get columnIndex(): { [key:string]:number; } {
            return this._dataModel && this._dataModel.columnIndex;
        }

        public get type(): CreationType {
            return CreationType.embedded;
        }

        public getKeyFromRow(row: ReadonlyArray<any>): ReadonlyArray<any> {
            return this._index && this._index.getKeyFromRow(row);
        }

        public compareKey(row: ReadonlyArray<any>, key: ReadonlyArray<any>): number {
            return this._index && this._index.compareKey(row, key);
        }

        public compareRow(row0: ReadonlyArray<any>, row1: ReadonlyArray<any>): number {
            return this._index && this._index.compareRow(row0, row1);
        }

        public create(key: ReadonlyArray<any>, values: {[key: string]: any}): void {
            this._dataModel && this._dispatcher.pushEvent({
                type: DataEventType.create,
                key: key,
                values: values,
                branch: this._branch,
                session: this._session
            });
        }

        public modify(key: ReadonlyArray<any>, values: {[key: string]: any}): void {
            this._dataModel && this._dispatcher.pushEvent({
                type: DataEventType.modify,
                key: key,
                values: values,
                branch: this._branch,
                session: this._session
            });                
        }

        public delete_(key: ReadonlyArray<any>): void {
            this._dataModel && this._dispatcher.pushEvent({
                type: DataEventType.delete_,
                key: key,
                branch: this._branch,
                session: this._session
            });                
        }

        public find(key: ReadonlyArray<any>): number {
            return this._index.find(key);
        }

        public indexOf(row: ReadonlyArray<any>): number {
            return this._index.indexOf(row);
        }

        /** @internal */        
        public [_dropInfo](key: ReadonlyArray<any>, h: (info: IHistorizedDataEventInfo) => boolean): IHistorizedDataEventItemEx {
            let lastInfo: IHistorizedDataEventInfo;
            
            this._dispatcher.dataEvents = this._dispatcher.dataEvents.filter((info: IHistorizedDataEventInfo) => {
                let b: boolean = true;
                if ((info.branch === this._branch) && !this._index.compareKey(info.row, key)) {
                    (b = h(info))||(lastInfo = info);
                }
                return b;
            });
            return lastInfo && this[_refreshRow](lastInfo.row, true);
        }
        
        public dropEvents(key: ReadonlyArray<any>, filter: IDataModelViewFilter): void {
            this._dataModel && this._dispatcher.pushEvent({
                type: DataEventType.drop,
                key: key,
                branch: this._branch,
                session: this._session,
                filter: filter
            });
        }

        public reset(allSession: boolean): void {
            this._dataModel && this._dispatcher.pushEvent({
                type: DataEventType.reset,
                branch: this._branch,
                session: allSession ? void 0 : this._session
            });
        }
        
        public toJSON(): any {
            return EmbeddedCreation.prototype.toJSON.call(this);
        }

        public getVariations(): {row: IDataModelArray[], old: IDataModelArray[]} {
            let row: IDataModelArray,
                reference: IDataModelArray,
                variations: {row: IDataModelArray[], old: IDataModelArray[]};
            
            for (let pos in this[_rows]) {
                row = this[_rows][pos];
                reference = this._getReferenceRow(parseInt(pos));
                if ((!row !== !reference) ||
                    (row && this.columns.some((column: IDBColumn, indice: number) => !Tools.Data.equalValue(column.type, row[indice], reference[indice])))) {
                    if (variations) {
                        variations.row.push(row);
                        variations.old.push(reference);
                    } else {
                        variations = { row: [row], old: [reference] };
                    }
                }
            }
            return variations;
        }
    }
    
    export class Pool {
        protected readonly _map: DataModelMap;
        public trunk: TrunkModel;
        public branches: BranchModel[];
       
        constructor(map: DataModelMap) {
            this._map = map;
            this.branches = [];
        }

        public dispatchSeeds(branch: number, seeds: (IDataEventUpdateSeed|IDataEventDropSeed)[], stamp: number, commit: boolean = false): IDataEventData {
            let event: IDataEventData,
                committed: boolean = !commit;
            
            if (branch) {
                let model: BranchModel = this.findBranch(branch);
                
                model && (event = model.applySeeds(seeds, stamp, committed));
            } else {
                event = this.trunk.applySeeds(seeds, stamp, committed);
                event && event.items && this.branches.forEach(branch => branch[_refreshRows](event.items));
            }
            return event;
        }

        public findBranch(b: number): BranchModel {
            for (let branch of this.branches) {
                if (BranchBaseEx.branchNb(branch) === b) {
                    return branch;
                }
            }
        }

        public attach(viewModel: BranchModel): void {
            this.branches.push(viewModel);
        }
        
        public detach(viewModel: BranchModel): void {
            let i: number = this.branches.indexOf(viewModel);
            (i > -1) && this.branches.splice(i, 1);
        }       
    }

    export class EventDispatcher extends Tools.EventSink {
        public readonly pool: Pool;
        public stamp: number;
        public dataEvents: IHistorizedDataEventInfo[];
        
        constructor(eventTarget: any, pool: Pool) {
            super(eventTarget);
            this.pool = pool;
            this.stamp = 0;
            this.dataEvents = [];
            this.on(Tools.EventType.Internal, this._onEvents, this);
        }
        
        protected _filterResetEvents(seeds: ISeed[]): ISeed<DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.drop>[] {
            let resets: Map<number, {[key: number]: ISeed<DataEventType.reset>}> = new Map,
                i = seeds.length,
                out: ISeed<DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.drop>[] = [],
                seed,
                branch,
                session,
                reset,
                fires: number[];

            while(i--) {
                seed = seeds[i];
                if (seed.type !== DataEventType.none) {
                    branch = seed.branch;
                    session = seed.session || 0;
                    if (seed.type === DataEventType.reset) {
                        resets.has(branch) ? reset = resets.get(branch) : resets.set(branch, reset = {});
                        reset[session] = seed;
                    } else if (!reset || !(reset[0] || reset[session])) {
                        out.push(seed);
                    }
                }
            }

            resets.forEach((reset, branch) => {
                let fire = false,
                    session: number;
                    
                for (let key in reset) {
                    session = reset[key].session;
                    this.dataEvents = this.dataEvents.filter(dataEvent => dataEvent.branch !== branch || (session && (dataEvent.session !== session)) || (fire = true, false));
                }
                fire && (fires || (fires = [])).push(branch);
            });
            
            fires && fires.some(branch => {
                let model = branch ? this.pool.findBranch(branch) : this.pool.trunk;
                
                if (model) {
                    model[_reset]();
                    if (!branch) {
                        // trunk has been modified
                        this.pool.branches.forEach(model => model[_reset]());
                        return true;
                    }
                }                
            });
            return out.reverse();
        }
        
        protected _onEvents(e: ISeedsEvent): void {
            let stamp: number = this.stamp++;
            let seeds = e.data;
            let i: number;

            if (seeds && (i = seeds.length)) {
                let filteredSeeds: ISeed<DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.drop>[] = this._filterResetEvents(seeds),
                    seed: ISeed<DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.drop>,
                    next: ISeed<DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none>,
                    drop: IDataEventDropSeed;
                let pendings: (IDataEventUpdateSeed|IDataEventDropSeed)[];
                let committed: (b: boolean) => void = b => {
                    if (next) {
                        drop && (pendings || (pendings = [])).push(drop);
                        (next.type !== DataEventType.none) && (pendings || (pendings = [])).push(next);
                        if (b && pendings) {
                            this.pool.dispatchSeeds(next.branch, pendings, stamp);
                            pendings = void 0;
                        }
                    }
                };
                
                filteredSeeds.sort((a, b)=> compareKey(a.key, b.key));
                while (i--) {
                    seed = filteredSeeds[i];
                    if (!next || (next.branch !== seed.branch) || (next.session !== seed.session) || compareKey(next.key, seed.key)) {
                        committed(next && (next.branch !== seed.branch));
                        next = {
                            type: DataEventType.none,
                            key: seed.key,
                            branch: seed.branch,
                            session: seed.session
                        };
                        drop = void 0;
                    }
                    !drop && ((seed.type === DataEventType.drop) ? drop = seed : _mergeSeed(next, seed));
                }
                committed(true);
            }
        }
        
        public pushEvent(e: ISeed<DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.drop | DataEventType.reset>): void {
            this.fireEvent(Tools.EventType.Internal, [e]);
        }        
    }

    class DataModelRef extends DataModelBaseEx {
        protected _primaryKey: ReadonlyArray<number>;
        declare public readonly values: ReadonlyArray<IDataModelArray>;
        protected _cnt: number;
        
        constructor(columns: ReadonlyArray<IDBColumn>, primaryKey: ReadonlyArray<string>, values: ReadonlyArray<any>[]) {
            values.forEach((row: IDataModelArray, i: number)=>{row.__pos = i;});
            super(columns, values);
            this._primaryKey = primaryKey.map((item: string) => this.columnIndex[item]);   
            this._cnt = 0;
        }
       
        public get primaryKey(): ReadonlyArray<string> {
            let columns: ReadonlyArray<IDBColumn> = this.columns;
            return this._primaryKey && this._primaryKey.map((i: number) => columns[i].name);
        }
        
        public getKeyForContext(row: IDataModelArray): any {
            return (this._primaryKey.length === 1) ? row[this._primaryKey[0]] : this._primaryKey.map(i => row[i]);
        }

        public createContextInfo(row: IDataModelArray, old?: IDataModelArray): IModificationEventInfo {
            let indice: number, column: IDBColumn;
            let values: IModificationEventValues;
            let value: any;

            for(let name in this.columnIndex) {
                indice = this.columnIndex[name];
                column = this.columns[indice];
                if (column && (column.index === -1) && !column.readOnly && column.name === name) {
                    value = row[indice];
                    if (old ? (value !== old[indice]) : (value !== void 0)) {
                        (values || (values = {}))[name] = value; 
                    }
                }
            }
            return values && {code: this.getKeyForContext(row), values: values};
        }

        public createIndex(): UniqueIndex {
            return new UniqueIndex(this._primaryKey, this.values);
        }
        
        public getKeyFromRow(row: ReadonlyArray<any>): ReadonlyArray<any> {
            return this._primaryKey.map((i: number) => row[i]);
        }
        
        public create(): number {
            return --this._cnt;
        }
    }
    
    class TrunkModel extends BranchBaseEx {
        declare protected _branch: never;
        declare protected _pool: Pool;
        declare protected _dataModel: DataModelRef;
        declare protected _session: number;
        /** @internal */
        public [_rows]: {[key: number]: ModifiedArray};
        
        constructor(pool: Pool, map: DataModelMap) {
            super(pool, map, 0);
        }

        protected _getReferenceRow(pos: number): IDataModelArray {
            return this._dataModel.values[pos];
        }

        protected _createIndex(): UniqueIndex {
            return this._dataModel.createIndex();
        }

        public get branch(): string {
            return;
        }
    }

    class BranchModel extends BranchBaseEx {
        public branchInfo: IDBHistoryBranchInfo;
        
        constructor(pool: Pool, map: DataModelMap, dataModel: DataModelRef, dispatcher: EventDispatcher, branch: string) {
            super(pool, map, map.add(branch));
            super._init(dataModel, dispatcher);
            pool.attach(this);
        }

        protected _createIndex(): UniqueIndex {
            return BranchBaseEx.cloneIndex(this._pool.trunk);
        }

        protected _getReferenceRow(pos: number): IDataModelArray {
            return this._pool.trunk.getRow(pos);
        }

        public get branch(): string {
            return this._map.get(this._branch);
        }

        /** @internal */
        public [_refreshRows](dataEvents: ReadonlyArray<IHistorizedDataEventItemEx>): IHistorizedDataEventItemEx[] {
            let events2: IHistorizedDataEventItemEx[];

            dataEvents && dataEvents.forEach(dataEvent => {
                let e2: IHistorizedDataEventItemEx = this[_refreshRow](dataEvent.row, dataEvent.committed, dataEvent);

                e2 && (events2 || (events2 = [])).push(e2);
            });
            events2 && this.fireEvent(Tools.EventType.Dirty, new DataEventData(events2));
            return events2;
        }

        public release(): void {
            this._pool.detach(this);
        }
    }

    export class DataRecordProvider extends Tools.AutoSubscribeForwarder implements IDataContainerProvider {
        protected readonly _dataModel: IDataModel;
        protected _index: UniqueIndex;
        protected _key: any[];
        protected _record: DataRecord;
        
        constructor(dataModel: IDataModel) {
            super();
            this._dataModel = dataModel;
            this._record = null;
            this._setForwards([{
                type: Tools.EventType.Dirty,
                observable: dataModel,
                callback: this._onDirty
            }]);
        }
        
        protected _onDirty(e: IDataEvent): void {
            let data: IDataModelEventData = e.data,
                index: UniqueIndex,
                row: ReadonlyArray<any>;
            
            if (data && this._key && (index = this.index) && (data.reset || data.items.some(item => {
                    let b: boolean = index.compareKey(item.row, this._key) === 0;
                    
                    b && (row = item.row);
                    return b;
                }))) {
                row ? this._record = new DataRecord(this._dataModel, row) : delete this._record;
                this.fireEvent(Tools.EventType.Dirty);
            }
        }

        protected get index(): UniqueIndex {
            let index = this._index;
            
            if (!index && this._key) {
                this._index = index = this._dataModel instanceof BranchBaseEx ?
                    BranchBaseEx.getIndex(<BranchBaseEx>this._dataModel):
                    new UniqueIndex(this._dataModel.primaryKey.map((name: string) => Tools.indexOf(this._dataModel.columns, (column: IDBColumn) => column.name === name)), this._dataModel.values);
            }
            return index;
        }
                        
        public set key(value: any[]) {
            if (compareKey(this._key||[], value||[])) {
                delete this._record;
                this._key = value;
                this.fireEvent(Tools.EventType.Dirty);
            }
        }
        
        public getDataContainer(): Promise<IDataContainer> {
            let index: UniqueIndex;
            if ((index = this.index) && (this._record === void 0)) {
                let i: number = this._index.find(this._key);
                this._record = i === -1 ? null : new DataRecord(this._dataModel, this._index.values[i]);
            }
            return Promise.resolve(this._record);
        }
    }
    
    class HistorizedModelBase extends TrunkModel {
        constructor(pool: Pool, map: DataModelMap) {
            super(pool, map);
            pool.trunk = this;
        }
        
        protected _getBranch(s: string): BranchModel {
            return this.findBranch(s) || new BranchModel(this._pool, this._map, this._dataModel, this._dispatcher, s);
        }

        public initFrom(columns: ReadonlyArray<IDBColumn>, primaryKey: ReadonlyArray<string>, rows?: any[][]): void {
            let dataModelRef = new DataModelRef(columns, primaryKey, rows),
                dispatcher = new EventDispatcher(dataModelRef, this._pool);
            super._init(dataModelRef, dispatcher);
        }
        
        public ready(): Promise<void> {
            return new Promise(resolve => BranchBaseEx._ready(this, resolve));
        }

        public findBranch(s: string): BranchModel {
            let b: number = this._map.get(s);
            return b && this._pool.findBranch(b);
        }
        
        public getBranch(s: string): Promise<BranchModel> {
            let branch = this._getBranch(s);
            return new Promise(resolve => BranchBaseEx._ready(branch, ()=> resolve(branch)));
        }

        public releaseBranch(s: string): void {
            let branch: BranchModel = this.findBranch(s);
            branch && branch.release();
        }

        public generateEvents(s?: string): Data.IModificationEvents {
            //let branch: BranchModel = this.findBranch(s);
            let branch: BranchBaseEx = s ? this.findBranch(s) : this;
            
            if (branch) {
                let scn: {row: IDataModelArray[], old: IDataModelArray[]} = branch.getVariations();
                if (scn) {
                    let events: IModificationEvents = {};

                    scn.row.forEach((row: IDataModelArray, i: number)=>{
                        let old: IDataModelArray = scn.old[i];

                        if (row) {
                            let info: IModificationEventInfo = this._dataModel.createContextInfo(row, old);
                            
                            if (info) {
                                if (old) {
                                    (events.modifications || (events.modifications = [])).push(info);
                                } else {
                                    (events.creations || (events.creations = [])).push(info);
                                }
                            }
                        } else if (old) {
                            (events.deletions || (events.deletions = [])).push(this._dataModel.getKeyForContext(old));
                        }
                    });
                    return events;
                }
            }
        }
        
        public appendEvents(events: IModificationEvents, commit: boolean, branch: string, session: string): void {
            if (events.fullDeletion) {
                throw new Error();
            } else if (this._dataModel) {
                let b: BranchBaseEx = branch ? this._getBranch(branch) : this;
                
                if (b) {
                    let converter: (key: any)=>any[] = key=>key instanceof Array ? key : [key];
                    let pendings: IDataEventUpdateSeed[];
                    let branchNb: number = BranchBaseEx.branchNb(b);
                    let sessionNb: number;
                    
                    if (session) {
                        sessionNb = this._map.get(session);
                    }

                    events.creations && events.creations.forEach((o: IModificationEventInfo) => {
                        (pendings || (pendings = [])).push({
                            type: DataEventType.create,
                            key: converter(o.code),
                            branch: branchNb,
                            session: sessionNb,
                            values: o.values
                        });
                    });
                    events.modifications && events.modifications.forEach((o: IModificationEventInfo)=> {
                        (pendings || (pendings = [])).push({
                            type: DataEventType.modify,
                            key: converter(o.code),
                            branch: branchNb,
                            session: sessionNb,
                            values: o.values
                        });
                    });
                    events.deletions && events.deletions.forEach((o: any)=> {
                        (pendings || (pendings = [])).push({
                            type: DataEventType.delete_,
                            key: converter(o),
                            branch: branchNb,
                            session: sessionNb,
                        });
                    });
                    
                    if (pendings) {
                        let pool: CommitPool = <CommitPool>this._pool;
                        let stamp: number = this._dispatcher.stamp++;
                        b.once(Tools.EventType.Attach, () => pool.dispatchSeeds(branchNb, pendings, stamp, commit), this, this);
                    }
                }
            }
        }        
    }

    interface IHistorizedCommand {
        run(): number;
    }
    
    interface IHistorizedParameters {
        branch: number;
        session: number;
        creations?: IHistorizedDataEventInfo[],
        modifications?: IHistorizedDataEventInfo[],
        deletions?: IHistorizedDataEventInfo[]
    }

    function _compareFilter(filter0: IDataModelViewFilter, filter1: IDataModelViewFilter): boolean {
        return (filter0 && filter0.session) === (filter1 && filter1.session);
    }

    function _exclude(content: ITableResourceContent, values: IModificationEventValues): IModificationEventValues {
        let v: IModificationEventValues = {},
            key: string;
        
        for (key in values) {
            let column = content.definition.columns.find(column => column.name === key);
            if (column && !column.readOnly) {
                v[key] = values[key];
            }
        }
        return v;
    }

    export interface IHistorizedModelRemote {
        confirmUpdate?: (pendings: IUpdateCommandResult) => Promise<boolean>;
        onUpdate: (results: ReadonlyArray<Data.IUpdateCommandResult>, force: boolean) => void;
    }

    function _isInteractive(result: IUpdateCommandResult) {
        let status;
        return result.result || ((status = result.status) && (status.warnings?.length || status.errors?.length));
    }

    interface ICommandSeeds {
        branch: number;
        creations?: IDataEventUpdateSeed<DataEventType.create>[];
        modifications?: IDataEventUpdateSeed<DataEventType.modify>[];
        deletions?: IDataEventUpdateSeed<DataEventType.delete_>[];
    }
    
    interface IResultForType {
        [DataEventType.create]: IModificationEvents['creations'][0],
        [DataEventType.modify]: IModificationEvents['modifications'][0],
        [DataEventType.delete_]: IModificationEvents['deletions'][0]
    }

    class CommitPool extends Pool {
        public descriptor: HistoricizedTableDescriptor;
        public updates: Updates;
        public resources: Rest.DataResource<Updates>[];
        public content: ITableResourceContent;
        public readonly remote: IHistorizedModelRemote;
        protected _pendings: (IDataEventUpdateSeed|IDataEventDropSeed)[];
        protected _sequence: number;

        protected static _getKeyForContext(key: ReadonlyArray<any>): any {
            return (key.length === 1) ? key[0] : key;
        }
        
        protected static _UpdateCommand = class _UpdateCommand implements IHistorizedCommand {
            protected _pool: CommitPool;
            protected _callback: (command: _UpdateCommand, commandSeeds: ICommandSeeds[], results: IUpdateCommandResult[])=>any;
            public readonly seeds: ISeed<DataEventType.create | DataEventType.modify | DataEventType.delete_>[];
            public readonly force: boolean;

            constructor(pool: CommitPool, callback: (command: _UpdateCommand, commandSeeds: ICommandSeeds[], results: IUpdateCommandResult[])=>any, seeds: ISeed<DataEventType.create | DataEventType.modify | DataEventType.delete_>[], force?: boolean) {
                this._pool = pool;
                this._callback = callback;
                this.seeds = seeds;
                this.force = force;
            }
            
            public run(): number {
                let index: {[key: string]: Rest.DataResource<Updates>};
                let iTable: number = 0;
                let commands: IUpdateCommand[] = [];
                let commandSeeds: ICommandSeeds[] = [];
                let parameters: IHistorizedParameters[] = [];
                let history: IHistory = this._pool.content.history;
                
                for (let i: number = 0; i < this.seeds.length;) {
                    let seed: ISeed = this.seeds[i];
                    let branch: number = seed.branch;
                    let session: number = seed.session;
                    let sessionString: string = this._pool._map.get(session);
                    let events: IModificationEvents = {};
                    let resource: string;
                    let command: IUpdateCommand;
                    let parameter: IHistorizedParameters = {
                        branch: branch,
                        session: session
                    };
                    let seeds: ICommandSeeds = {
                        branch: branch
                    };
                    
                    do {
                        switch(seed.type) {
                            case DataEventType.create:
                                (events.creations || (events.creations = [])).push({ code: CommitPool._getKeyForContext(seed.key), values: _exclude(this._pool.content, seed.info.values)});
                                (parameter.creations || (seeds.creations = [], parameter.creations = [])).push(seed.info);
                                seeds.creations.push(seed);
                                break;
                            case DataEventType.modify:
                                (events.modifications || (events.modifications = [])).push({code: CommitPool._getKeyForContext(seed.key), values: _exclude(this._pool.content, seed.info.values)});
                                (parameter.modifications || (seeds.modifications = [], parameter.modifications = [])).push(seed.info);
                                seeds.modifications.push(seed);
                                break;
                            case DataEventType.delete_:
                                (events.deletions || (events.deletions = [])).push(CommitPool._getKeyForContext(seed.key));
                                (parameter.deletions || (seeds.deletions = [], parameter.deletions = [])).push(seed.info);
                                seeds.deletions.push(seed);
                                break;
                        }
                    } while ((++i < this.seeds.length) && ((seed = this.seeds[i]).branch === branch) && (seed.session === session));
                    
                    if (!branch && history && (sessionString === history.session)) {
                        resource = this._pool.content.resource;
                    }
                    if (!resource) {
                        let key: string = `${branch}|${session}`;
                        let dataResource: Rest.DataResource<Updates> = (index || (index = {}))[key];
                        let resources: Rest.DataResource<Updates>[] = this._pool.resources;
                        let descriptor: HistoricizedTableDescriptor = this._pool.descriptor;
                        let name: string = Tools.Data.makeSQLName(descriptor.database.name, descriptor.name);
                        let localHistory: PartialMutable<IHistory> = history ? {
                            stamp: history.stamp,
                            refreshStamp: history.refreshStamp
                        } : {};
                        
                        session && (localHistory.session = sessionString);
                        (iTable < resources.length) ? dataResource = resources[iTable]: resources.push(dataResource = new Rest.DataResource<Updates>());
                        ++iTable;
                        dataResource.create(this._pool.updates, new HistoryView(name, history, branch ? this._pool._map.get(branch) : void 0));
                        index[key] = dataResource;
                        resource = dataResource.id;
                    }
                    command = {
                        table: resource,
                        events: events
                    };
                    sessionString && (command.session = sessionString);
                    parameters.push(parameter);
                    commandSeeds.push(seeds);
                    commands.push(command);
                }
                return this._pool.updates.run(commands, this._callback.bind(this._pool, this, commandSeeds), this.force);
            }
        }
        
        protected static _DropCommand = class implements IHistorizedCommand {
            protected _pool: CommitPool;
            protected _callback: ()=>any;
            protected _branch: number;
            protected _session: number;
            protected _keys: any[][];
            protected _filter: IDataModelViewFilter;

            constructor(pool: CommitPool, callback: ()=>any, branch: number, session: number, filter: IDataModelViewFilter, seeds: IDataEventDropSeed[]) {
                this._pool = pool;
                this._callback = callback;
                this._branch = branch;
                this._session = session;
                this._keys = seeds.map(seed => CommitPool._getKeyForContext(seed.key));
                this._filter = filter;
            }

            public run(): number {
                let filter: IDBHistoryEventsFilter;
                let options: {session?: string, filter?: IDBHistoryEventsFilter};

                if (this._session) {
                    let session: string = this._pool._map.get(this._session);                    
                    options = {session: session};
                }
                this._branch && (filter = {branches: [this._pool._map.get(this._branch)]});
                if (this._filter) {
                    this._filter.session && ((filter || (filter = {})).session = this._filter.session);
                }
                filter && ((options || (options = {})).filter = filter);
                return this._pool.descriptor.rollbackEvents(this._keys, this._callback.bind(this._pool), options);
            }
        }
 
        constructor(map: DataModelMap, remote: IHistorizedModelRemote) {
            super(map);
            this.remote = remote;
        }
 
        protected _onCommand(): void {
            delete this._sequence;
            this._runCommand();
        }
        
        protected _updateRow(branch: BranchBaseEx, info: IHistorizedDataEventInfo<DataEventType.create | DataEventType.modify>, modification: IModificationEventInfo): IHistorizedDataEventItemEx {
            $.extend(info.values, modification.values);
            info.committed = true;
            return branch[_refreshRow](info.row, true) || <IHistorizedDataEventItemEx>{row: info.row, type: DataEventType.none, committed: true};
        }
        
        protected async _onInteractive({force}: InstanceType<typeof CommitPool._UpdateCommand>, pendings: ISeed<DataEventType.create | DataEventType.modify | DataEventType.delete_>[][], results: IUpdateCommandResult[]): Promise<void> {
            let retry: ISeed<DataEventType.create | DataEventType.modify | DataEventType.delete_>[][],
                rollback: ISeed<DataEventType.create | DataEventType.modify | DataEventType.delete_>[][];
            
            if (!force && results && this.remote?.confirmUpdate) {
                for (let indice = 0, result; indice < results.length; ++indice) {
                    (_isInteractive(result = results[indice]) && await this.remote.confirmUpdate(result) ?
                            (retry || (retry = [])):
                            (rollback || (rollback = [])))
                        .push(pendings[indice]);
                }
            } else {
                rollback = pendings;
            }
            
            rollback?.forEach(seeds => {
                // roll back
                let branchId: number = seeds[0].branch,
                    branch: BranchBaseEx = branchId ? this.findBranch(branchId) : this.trunk;
                    
                if (branch) {
                    seeds.sort((seed0, seed1) => compareKey(seed0.key, seed1.key));
                    for (let i = 0, j: number; i < seeds.length; i = j) {
                        let dataEvents: IHistorizedDataEventItemEx[],
                            dataEvent,
                            dataEventData: IDataEventData,
                            key = seeds[i].key;

                        for (j = i; j < seeds.length && !compareKey(key, seeds[j].key); ++j);
                        dataEvent = branch[_dropInfo](key, (info: IHistorizedDataEventInfo) => {
                            for (let k = i; k < j; ++k) {
                                if (info === seeds[k].info)
                                    return false;
                            }
                            return true;
                        });     // return true if kept
                        dataEvent && (dataEvents || (dataEvents = [])).push(dataEvent);
                        if (dataEvents) {
                            branch.fireEvent(Tools.EventType.Dirty, dataEventData = <IDataEventData>(new DataEventData(dataEvents)));
                            branchId || this.branches.forEach(branch => branch[_refreshRows](dataEvents));
                        }
                    }
                }
            });
            
            if (retry) {
                // force update
                let command = new CommitPool._UpdateCommand(this, this._onUpdate, retry.flat(), true);
                this._sequence = command.run();
            }            
        }
        
        protected _onUpdate(command: InstanceType<typeof CommitPool._UpdateCommand>, commandSeeds: ICommandSeeds[], results: IUpdateCommandResult[] = []): void {
            let pendings: ISeed<DataEventType.create | DataEventType.modify | DataEventType.delete_>[][],
                remote = this.remote;
            
            commandSeeds.forEach((parameter: ICommandSeeds, indice: number) => {
                let result: IUpdateCommandResult = results[indice];

                let branch: BranchBaseEx = parameter.branch ? this.findBranch(parameter.branch) : this.trunk;
                let dataEvents: IHistorizedDataEventItemEx[];

                if (branch) {
                    let check = <T extends DataEventType.create | DataEventType.modify | DataEventType.delete_>(
                                seeds: ReadonlyArray<IDataEventUpdateSeed<T>>,
                                resultInfos: ReadonlyArray<IResultForType[T]> = [],
                                writer?: (seed: IDataEventUpdateSeed, result: IResultForType[T]) => void
                            ) => seeds?.forEach((seed, indice) => {
                                let result = resultInfos[indice];
                                result ?
                                    writer?.(seed, result):
                                    ((pendings || (pendings = []))[indice] || (pendings[indice] = [])).push(seed);
                            }),
                        writer = (seed: ISeed<DataEventType.create | DataEventType.modify>, resultInfo: IModificationEventInfo) => {
                            let dataEvent: IHistorizedDataEventItemEx = this._updateRow(branch, seed.info, resultInfo);
                            dataEvent && (dataEvents || (dataEvents = [])).push(dataEvent);
                        },
                        events = result?.events || {};

                    check(parameter.creations, events.creations, writer);
                    check(parameter.modifications, events.modifications, writer);
                    check(parameter.deletions, events.deletions);

                    if (dataEvents) {
                        let dataEventData: IDataEventData = <IDataEventData>(new DataEventData(dataEvents));

                        branch.fireEvent(Tools.EventType.Dirty, dataEventData);
                        parameter.branch || this.branches.forEach(branch => branch[_refreshRows](dataEvents));
                    }
                }
            });
            remote?.onUpdate(results, command.force);
            pendings ?
                this._onInteractive(command, pendings, results): // async call
                this._onCommand();
        }
        
        protected _runCommand(): void {
            if (this._pendings) {
                let command: IHistorizedCommand;
                let seed: ISeed;
                let i: number;

                if (this._pendings[0].type === DataEventType.drop) {
                    let branch: number = this._pendings[0].branch;
                    let session: number = this._pendings[0].session;
                    let filter: IDataModelViewFilter = this._pendings[0].filter;
                    
                    for (i = 0; (i < this._pendings.length) && ((seed = this._pendings[i]).type === DataEventType.drop) && (seed.branch === branch) && (seed.session === session) && _compareFilter(seed.filter, filter); ++i);
                    command = new CommitPool._DropCommand(this, this._onCommand, branch, session, filter, <IDataEventDropSeed[]>this._pendings.splice(0, i));
                } else {
                    for (i = 0; (i < this._pendings.length) && ((seed = this._pendings[i]).type & 0x7); ++i);
                    command = new CommitPool._UpdateCommand(this, this._onUpdate, <ISeed<DataEventType.create | DataEventType.modify | DataEventType.delete_>[]>this._pendings.splice(0, i));
                }
                this._pendings.length || (delete this._pendings);
                this._sequence = command.run();
            }
        }

        public get commit(): boolean {
            return !!this.descriptor;
        }

        public override dispatchSeeds(branch: number, seeds: (IDataEventUpdateSeed|IDataEventDropSeed)[], stamp: number, commit: boolean = this.commit): IDataEventData {
           let events: IDataEventData = super.dispatchSeeds(branch, seeds, stamp, commit);

           if (commit && this.descriptor && events) {
               seeds.sort((a: ISeed, b: ISeed)=> (b.type - a.type) || (a.session - b.session));   // drops first (other type should be unaffected)
               if (this._pendings)
                   this._pendings.concat(seeds);
               else {
                   this._pendings = seeds;
                   this._runCommand();
               }
           }
           return events;
       }
    }
        
    
    function _clearColumn(branch: BranchBaseEx, column: number, fire?: boolean): void {
        for (let key in branch[_rows]) {
            branch[_rows][key][column] = null;
        }
        fire && branch.fireEvent(Tools.EventType.Dirty, new DataEventData(void 0, true));
    }
    
    export class HistorizedModel extends HistorizedModelBase {
        constructor(remote?: IHistorizedModelRemote) {
            let map = new DataModelMap();
            super(new CommitPool(map, remote), map);
        }
               
        public initFrom(columns: ReadonlyArray<IDBColumn>, primaryKey: ReadonlyArray<string>, rows?: any[][], content?: ITableResourceContent): void {
            let pool: CommitPool = <CommitPool>this._pool;
            let descriptor: HistoricizedTableDescriptor = <HistoricizedTableDescriptor>content?.descriptor;
            
            super.initFrom(columns, primaryKey, rows);
            delete pool.descriptor;
            if (descriptor && descriptor.isHistoricized) {
                pool.descriptor = descriptor;
                pool.content = content;
                pool.updates = new Updates(descriptor.database.schema.restModel);
                pool.resources = [];
            }
        }

        /** @internal */
        /** Nullify all rows value for the specified columns without history */
        public clearColumns(columns: ReadonlyArray<IDBColumn>): void {
            let fire = true;
            
            columns.forEach(column => {
                let i = this.columnIndex[column.name];
                
                if (i !== void 0) {
                    this._dataModel.values.forEach(row => (<any>row)[i] = null);
                    _clearColumn(this, i, fire);
                    this._pool.branches.forEach((branch: BranchBaseEx) => _clearColumn(branch, i, fire));
                    fire = false;
                }
            });
        }
        
        /** @internal */
        /** Nullify all rows value for all branches for the specified columns without history and event emission */
        public clearBranchesColumnsSilent(columns: ReadonlyArray<IDBColumn>): void {
            columns.forEach(column => {
                let i = this.columnIndex[column.name];
                
                if (i !== void 0) {
                    this._pool.branches.forEach((branch: BranchBaseEx) => _clearColumn(branch, i));
                }
            });
        }
        
        /** @internal */
        /** Apply values to the selected branch without history and event emission */
        public applyValuesSilent(dataModel: IDataModel, columns: ReadonlyArray<IDBColumn>, branch?: string): void {
            const branchBase: BranchBaseEx = branch ? this.findBranch(branch) : this;
                
            if (branchBase && columns.length) {
                dataModel.values.forEach(ref => {
                    const row = <IDataModelArray>branchBase.values[branchBase.indexOf(ref)];
                    if (row) {
                        columns.forEach(column => {
                            let i = branchBase.columnIndex[column.name];
                            if (i !== void 0) {
                                row[i] = ref[dataModel.columnIndex[column.name]]
                            }
                        });
                    }
                });
            }
        }
    }
}