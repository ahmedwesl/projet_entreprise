/**
 * Created by jean.rennes on 19/05/2016.
 */
///<reference path="Global.ts" />
///<reference path="Data.ts" />
///<reference path="../rest/RestModel.ts" />

namespace AFC.Data {
    export const enum DBOpenStatus {
        open,
        failed,
        closed
    }

    export const enum HistoryEventType {
        none,
        backup,
        creation,
        modification,
        deletion,
        cancel
    }

    export const enum HistoryBranchStatus {
        none = 0,
        archive,
        remove
    }
        
    export interface IDBHistoryEventsFilter {
        stamp?: number;
        refreshStamp?: number;
        age?: number;
        authors?: string[];
        session?: string;
        branches?: (string|number)[];
    }

    export interface IDBHistoryEvent {
        id: string;
        type: HistoryEventType;
        author: string;
        eventDate: Date;
        dateOfEffect: Date;
        data: IModificationEventInfo;
    }

    export interface IDBHistoryBranchInfo {
        properties?: Application.JSONValue;
        description?: string;
        rating?: number;
    }

    export interface IDBHistoryBranchBase extends IDBHistoryBranchInfo {
        id: string;
        author: string;
        creationDate: Date;
        status?: HistoryBranchStatus;
        name?: string;
        bbox?: number[];
    }

    export interface IDBHistoryBranchRow extends IDBHistoryBranchBase {
        values?: {[key: string]: any}[];
    }

    export interface IDBHistoryBranchesFilter {
        ids?: [string, ...string[]]
        authors?: [string, ...string[]];
        age?: number;
        proximity?: {
            location: [number, number];
            distance: number;
        };
        timeReference?: Date;
    }
    
    export type IDBHistoryBranchesFilters = IDBHistoryBranchesFilter | IDBHistoryBranchesFilter[];

    export interface IDBHistoryDataSelector {
        columns: string[];
        history?: IHistory;
        fromProperties: string;
    }

    export interface IDBHistoryBranch extends IDBHistoryBranchBase {
        events: IDBHistoryEvent[];
    }

    interface ITableBase {
        name: string;
        alias: string;
        type: string;
        interactiveMode?: boolean;
        isHistorized?: boolean;
        stamp?: number;
        refreshStamp?: number;
    }

    interface ITable extends ITableBase {
        primaryKey?: string[];
        columns: {
            name: string;
            alias: string;
            type: string;
            size: number;
            isPseudoColumn: boolean;
            qualifiers: string[];
            geographicalLevel: string;
            isSearchable: boolean;
        }[];
        readOnly?: boolean;
    }

    interface IDatabase {
        id: string;
        name: string;
        status: string;
        error?: string;
        readOnly?: boolean;
        noCache?: boolean;
    }

    enum QualifierLookup {
        identifier = <number>Qualifier.identifier,
        mainAddress = Qualifier.mainAddress,
        address = Qualifier.address,
        zipCode = Qualifier.zipCode,
        city = Qualifier.city,
        country = Qualifier.country,
        totalSurface = Qualifier.totalSurface,
        surface = Qualifier.surface,
        symbol = Qualifier.symbol,
        brand = Qualifier.brand,
        businessCode = Qualifier.businessCode,
        revenue = Qualifier.revenue,
        changes = Qualifier.changes
    }

    export function qualifier(value: Qualifier): keyof typeof AFC.Data.Qualifier;
    export function qualifier(value: string): Qualifier;
    export function qualifier(value: string|Qualifier): keyof typeof AFC.Data.Qualifier|Qualifier {
        return (<any>QualifierLookup)[value];
    }

    export class DBColumnDefinition extends DBColumn implements IDBColumnDefinition {
        public readonly qualifiers: Qualifier[];
        public readonly geographicalLevel: string;
        public readonly isSearchable: boolean;

        constructor(name: string, type: DataKind, index: number, size?: number, alias?: string, readOnly?: boolean, qualifiers?: Qualifier[], geographicalLevel?: string, isSearchable?: boolean) {
            super(name, type, index, size, alias, readOnly);
            qualifiers && (this.qualifiers = qualifiers);
            geographicalLevel && (this.geographicalLevel = geographicalLevel);
            isSearchable && (this.isSearchable = isSearchable);
        }
    }

    enum DataKindLookup {
        asteropDataKindUnknown = DataKind.unknown,
        asteropDataKindCharacter = DataKind.character,
        asteropDataKindReal = DataKind.real,
        asteropDataKindInteger = DataKind.integer,
        asteropDataKindBool = DataKind.bool,
        asteropDataKindDate = DataKind.date,
        asteropDataKindTime = DataKind.time,
        asteropDataKindTimestamp = DataKind.timestamp,
        asteropDataKindCurrency = DataKind.currency,
        asteropDataKindBlob = DataKind.blob,
        asteropDataKindDynamic = DataKind.dynamic,
        asteropDataKindFormula = DataKind.formula,
        asteropDataKindPoint = DataKind.point,
        asteropDataKindLine = DataKind.line,
        asteropDataKindPoly = DataKind.polygon,
        asteropDataKindGeometry = DataKind.geometry,
        asteropDataKindRect = DataKind.rectangle
    }

    export function dataKind(value: DataKind): string;
    export function dataKind(value: string): DataKind;
    export function dataKind(value: string|DataKind): string|DataKind {
        return (<any>DataKindLookup)[value];
    }

    const _tableTypeLookup: {[key: string]: TableType;} = {
        TABLETYPE_UNDEF: TableType.undef,
        TABLETYPE_TABLE: TableType.table,
        TABLETYPE_VIEW: TableType.view,
        TABLETYPE_QUERY: TableType.query,
        TABLETYPE_COMPOUND: TableType.compound,
        TABLETYPE_CUBEVIEW: TableType.cubeView,
        TABLETYPE_MEMORY: TableType.memory,
        TABLETYPE_FILTER: TableType.filter,
        TABLETYPE_SEAMLESS: TableType.seamless,
        TABLETYPE_HISTORY: TableType.history,
        TABLETYPE_SYNONYM: TableType.synonym
    }

    export class TableDescriptor extends Tools.EventSink implements Controls.IListItem {
        protected _sequence: number;
        protected _definition: IDBTableDefinition & {stamp?: number; refreshStamp?: number;};
        public readonly database: DatabaseDescriptor;
        public readonly name: string;
        public readonly alias: string;
        public readonly type: TableType;
        public readonly interactiveMode: boolean;

        constructor(d: DatabaseDescriptor, i: ITableBase) {
            super();
            this.database = d;
            this.name = i.name;
            this.alias = i.alias;
            this.type = _tableTypeLookup[i.type];
            i.interactiveMode && (this.interactiveMode = true);
        }


        public get id(): string {
            return this.name;
        }

        public get fullName(): string {
            return `[${this.database.name}].[${this.name}]`;
        }

        public get isHistoricized(): boolean {
            return false;
        }

        public invalidate(): void {
            delete this._sequence;
            delete this._definition;
            this.fireEvent(Tools.EventType.Dirty);
        }

        public createAjaxRequest<T = any>(path: string = '', bypassContext?: boolean, options?: Rest.IRestRequestOptions): Rest.IAjaxRequest<T> {
            return this.database.createAjaxRequest<T>(`/${this.name}${path}`, bypassContext, options);
        }

        protected _onRestAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            let data: ITable = jqXHR.responseJSON;

            if (this._sequence === sequence) {
                if (data) {
                    let definition: IDBTableDefinition & {stamp?: number; refreshStamp?: number;} = this._definition = {
                        columns: data.columns.map(column => new DBColumnDefinition(
                            column.name,
                            dataKind(column.type),
                            data.primaryKey ? data.primaryKey.indexOf(column.name) : -1,
                            column.size,
                            column.alias,
                            column.isPseudoColumn,
                            column.qualifiers && column.qualifiers.map(value => (qualifier(value))),
                            column.geographicalLevel,
                            column.isSearchable
                        ))
                    };
                    data.primaryKey && (definition.primaryKey = data.primaryKey);
                    (data.stamp !== void 0) && (definition.stamp = data.stamp);
                    (data.refreshStamp !== void 0) && (definition.refreshStamp = data.refreshStamp);
                } else
                    delete this._sequence;
                this.fireEvent(Tools.EventType.UserEvent);
            }
        }

        public getDefinition(): Promise<IDBTableDefinition> {
            return this._definition ? Promise.resolve(this._definition) : new Promise(resolve => {
                this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve(this._definition));
                if (!this._sequence) {
                    let request: Rest.IAjaxRequest = this.createAjaxRequest();
                    request.options.always = this._onRestAlways.bind(this);
                    this._sequence = request.call();
                }
            });
        }
    }

    let HistoryEventTypeLookup: {[key: string]: HistoryEventType} = {
        none: HistoryEventType.none,
        backup: HistoryEventType.backup,
        creation: HistoryEventType.creation,
        modification: HistoryEventType.modification,
        deletion: HistoryEventType.deletion,
        cancel: HistoryEventType.cancel
    }

    function _fetchEvent(event: {eventDate: string|Date, dateOfEffect: string|Date, type: string|HistoryEventType}): IDBHistoryEvent {
        event.eventDate = new Date(<string>event.eventDate);
        event.dateOfEffect = new Date(<string>event.dateOfEffect);
        event.type = HistoryEventTypeLookup[event.type];
        return <IDBHistoryEvent>event;
    }

    enum HistoryBranchStatusLookup {
        none    = HistoryBranchStatus.none,
        archive = HistoryBranchStatus.archive,
        remove  = HistoryBranchStatus.remove
    }

    export function historyBranchStatus(value: HistoryBranchStatus): string;
    export function historyBranchStatus(value: string): HistoryBranchStatus;
    export function historyBranchStatus(value: string|HistoryBranchStatus): string|HistoryBranchStatus {
        return (<any>HistoryBranchStatusLookup)[value];
    }
    
    function _fetchBranch<T extends IDBHistoryBranchBase>(branch: {creationDate: string | Date, status: string|HistoryBranchStatus, events?: any[]}): T {
        branch.creationDate = new Date(<string>branch.creationDate);
        branch.status = historyBranchStatus(<string>branch.status);
        branch.events && branch.events.forEach(_fetchEvent);
        return <T>branch;
    }

    export class HistoricizedTableDescriptor extends TableDescriptor {
        public get isHistoricized(): boolean {
            return true;
        }

        public requestStamps(callback: (stamp: number, refreshStamp: number, sequence: number)=> void): number {
            let onAlways: (sequence: number, jqXHR: JQueryXHR, textStatus: string)=> any;
            
            if (this._definition) {
                onAlways = (sequence: number, jqXHR: JQueryXHR, textStatus: string)=> {
                    let data: ITable = jqXHR.responseJSON || {};
                    callback(data.stamp, data.refreshStamp, sequence);
                };
            } else {
                this.notify(Tools.EventType.UserEvent, () => callback(this._definition && this._definition.stamp, this._definition && this._definition.refreshStamp, this._sequence));
                this._sequence || (onAlways = this._onRestAlways.bind(this));
            }
            if (onAlways) {
                let request: Rest.IAjaxRequest = this.createAjaxRequest();

                request.options.always = onAlways;
                this._sequence = request.call();
            }
            return this._sequence;
        }

        private _doSingleOperation(operation: {type: string;}): Promise<IDBHistoryBranchBase> {
            return new Promise((resolve, reject) => {
                let request: Rest.IAjaxRequest = this.createAjaxRequest('/branches');
                request.options.always = (sequence: number, jqXHR: JQueryXHR, textStatus: string)=> {
                    let data: any[] = jqXHR.responseJSON;
                    data instanceof Array && data.length ? resolve(_fetchBranch<IDBHistoryBranchBase>(data[0])) : reject();
                };
               (<{operation: {type: string;}}>request.options.data).operation = operation;
                request.call();
            });
        }

        public insertBranch(options?: {properties?: Application.JSONValue, description?: string, rating?: number, status?: HistoryBranchStatus}): Promise<IDBHistoryBranchBase> {
            let operation: {
                type: "insert",
                properties?: Application.JSONValue;
                description?: string;
                rating?: number;
                status?: string;
            } = {
                type: "insert"
            };
            if (options) {
                options.properties == null || (operation.properties = options.properties);
                options.description == null || (operation.description = options.description);
                options.rating == null || (operation.rating = options.rating);
                options.status && (operation.status = historyBranchStatus(options.status));
            }
            return this._doSingleOperation(operation);
        }

        public deleteBranch(name: string): Promise<IDBHistoryBranchBase> {
            let operation: {type: "delete"; name: string;} = {type: "delete", name: name};
            return this._doSingleOperation(operation);
        }

        public updateBranch(name: string, {properties, description, rating, status}: {properties?: Application.JSONValue, description?: string, rating?: number, status?: HistoryBranchStatus}): Promise<IDBHistoryBranchBase> {
            let operation: {
                type: "update",
                name: string,
                properties?: Application.JSONValue;
                description?: string;
                rating?: number;
                status?: string;
            } = {
                type: "update",
                name: name
            };
            properties === void 0 || (operation.properties = properties);
            description === void 0 || (operation.description = description);
            rating === void 0 || (operation.rating = rating);
            status === void 0 || (operation.status = historyBranchStatus(status));
            return this._doSingleOperation(operation);
        }

        public selectBranches(options?: {filter?: IDBHistoryBranchesFilters, dataSelector?: IDBHistoryDataSelector}): Promise<IDBHistoryBranchRow[]> {
            return new Promise((resolve, reject) => {
                let request: Rest.IAjaxRequest = this.createAjaxRequest('/branches');
                request.options.always = (sequence: number, jqXHR: JQueryXHR, textStatus: string)=> {
                    let data: any[] = jqXHR.responseJSON;
                    data instanceof Array ? (data.forEach(_fetchBranch), resolve(<IDBHistoryBranchRow[]>data)): reject();
                };

                let data: {
                    operation: {
                        type: string;
                        filter?: IDBHistoryBranchesFilters;
                        dataSelector?: IDBHistoryDataSelector;
                    }
                } = <any>request.options.data;
                data.operation = {type: "select"};
                if (options) {
                    (options.filter !== void 0) && (data.operation.filter = options.filter);
                    (options.dataSelector !== void 0) && (data.operation.dataSelector = options.dataSelector);
                }
                request.call();
            });
        }

        public getBranchInfo(id: string, history?: IHistory): Promise<IDBHistoryBranch> {
            return new Promise((resolve, reject) => {
                let request: Rest.IAjaxRequest = this.createAjaxRequest(`/branches/${id}`);
                request.options.always = (sequence: number, jqXHR: JQueryXHR, textStatus: string)=> {
                    let data: any = jqXHR.responseJSON;
                    data ? resolve(_fetchBranch<IDBHistoryBranch>(data)) : reject();
                };
                isValidHistory(history) && ((<{history: IHistory}><any>request.options.data).history = history);
                request.call();
            });
        }

        public rollbackEvents(codes: any[], callback: (e: IDBHistoryEvent[])=> any, options?: {session?: string, filter?: IDBHistoryEventsFilter}): number {
            if (codes.length > 0) {
                let request: Rest.IAjaxRequest<{
                        operation: {
                            type: string;
                            codes: any[];
                            session?: string;
                            filter?: IDBHistoryEventsFilter;
                        }
                    }> = this.createAjaxRequest('/events'),
                    data = request.options.data;
                    
                request.options.always = (sequence: number, jqXHR: JQueryXHR, textStatus: string)=> {
                    let data: any[] = jqXHR.responseJSON;
                    let v: IDBHistoryEvent[];
                    if (data instanceof Array) {
                        data.forEach(_fetchEvent);
                        v = <IDBHistoryEvent[]>data;
                    }
                    callback(v);
                };
                
                data.operation = {type: "rollback", codes: codes};
                if (options) {
                    options.session && (data.operation.session = options.session);
                    (options.filter !== void 0) && (data.operation.filter = options.filter);
                }
                return request.call();
            }
        }
    }

    let DBOpenStatusLookup: {[key: string]: DBOpenStatus} = {
        open: DBOpenStatus.open,
        failed: DBOpenStatus.failed,
        closed: DBOpenStatus.closed
    };

    export type DatabaseInfoItem = {
        description: string;
        version: string;
    };
    export type DatabaseInfoVersion = {
        title: string;
        items: DatabaseInfoItem[];
    };
    export type DatabaseInfo = IDatabase & {versions: DatabaseInfoVersion[];};
    
    export class DatabaseDescriptor extends Tools.EventSink implements Controls.IListItem {
        protected _tables: TableDescriptor[];
        protected _sequence: number;
        public readonly schema: SchemaDescriptor;
        public readonly id: string;
        public readonly name: string;
        public readonly status: DBOpenStatus;
        public readonly error: string;
        public readonly readOnly: boolean;
        public readonly noCache: boolean;

        constructor(schema: SchemaDescriptor, database: IDatabase) {
            super();
            this.schema = schema;
            this.id = database.id;
            this.name = database.name;
            this.status = DBOpenStatusLookup[database.status];
            (database.error !== void 0) && (this.error = database.error);
            this.readOnly = !!database.readOnly;
            this.noCache = !!database.noCache;
        }

        public invalidate(): void {
            let tables: TableDescriptor[] = this._tables;

            this.fireEvent(Tools.EventType.Dirty);
            if (tables) {
                delete this._tables;
                delete this._sequence;
                tables.forEach((item: TableDescriptor)=>{item.invalidate();})
            }
        }

        public createAjaxRequest<T = any>(path: string = '', bypassContext?: boolean, options?: Rest.IRestRequestOptions): Rest.IAjaxRequest<T> {
            return this.schema.createAjaxRequest<T>(`/${this.id}${path}`, bypassContext, options);
        }

        private _onRestAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            let data = this._sequence === sequence && jqXHR.responseJSON;
            
            this._tables = data && (data instanceof Array) ? data.map(item => item.isHistorized ? new HistoricizedTableDescriptor(this, item) : new TableDescriptor(this, item)) : null;
            this.fireEvent(Tools.EventType.UserEvent);
        }

        public getTables(): Promise<ReadonlyArray<TableDescriptor>> {
            return new Promise((resolve, reject) => {
                let sequence = this._sequence,
                    h = () => sequence === this._sequence && this._tables ? resolve(this._tables) : reject();
                
                if (this._tables !== void 0) {
                    h();
                } else {
                    this.notify(Tools.EventType.UserEvent, h);
                    if (!sequence) {
                        let request: Rest.IAjaxRequest = this.createAjaxRequest();
                        request.options.always = this._onRestAlways.bind(this);
                        this._sequence = sequence = request.call();
                    }
                }
            });
        }
        
        public getInfo(): Promise<DatabaseInfo> {
            return new Promise(resolve => {
                let request: Rest.IAjaxRequest<{operation: {type: string;}}> = this.createAjaxRequest();

                request.options.data.operation = {type: 'info'};
                request.options.always = (sequence: number, jqXHR: JQueryXHR, textStatus: string)=> {
                    let database: DatabaseInfo = jqXHR.responseJSON;
                    resolve(database);
                };
                request.call();
            });
        }
        
        public refresh(): void {
            delete this._sequence;
            delete this._tables;
        }
    }

    export class SchemaDescriptor extends Tools.EventSink {
        public readonly restModel: Rest.RestModel;
        private _databases: DatabaseDescriptor[];
        private _sequence: number;

        constructor(restModel: Rest.RestModel) {
            super();
            this.restModel = restModel;
        }

        public invalidate(): void {
            let databases: DatabaseDescriptor[] = this._databases;

            this.fireEvent(Tools.EventType.Dirty);
            if (databases) {
                delete this._databases;
                delete this._sequence;
                databases.forEach((item: DatabaseDescriptor)=>{item.invalidate();})
            }
        }

        public createAjaxRequest<T = any>(path: string = '', bypassContext?: boolean, options?: Rest.IRestRequestOptions): Rest.IAjaxRequest<T> {
            return this.restModel.createAjaxRequest<T>(`/databases/schema${path}`, bypassContext, options);
        }

        private _onRestAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void {
            let data: any = jqXHR.responseJSON;

            if (this._sequence === sequence) {
                this._databases = data && (data instanceof Array) ? data.map((item: IDatabase)=> new DatabaseDescriptor(this, item)) : [];
                this.fireEvent(Tools.EventType.UserEvent);
            }
        }

        public getDatabases(): Promise<ReadonlyArray<DatabaseDescriptor>> {
            return this._databases ? Promise.resolve(this._databases) : new Promise(resolve => {
                this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve(this._databases));
                if (!this._sequence) {
                    let request: Rest.IAjaxRequest = this.createAjaxRequest();
                    request.options.always = this._onRestAlways.bind(this);
                    this._sequence = request.call();
                }
            });
        }
    }

    export function getDatabase(schema: SchemaDescriptor, dbName: string): Promise<DatabaseDescriptor> {
        return schema.getDatabases().then((databases: ReadonlyArray<DatabaseDescriptor>) => Tools.findByIdOrName<DatabaseDescriptor>(dbName, databases));
    }

    export async function getTable(schema: SchemaDescriptor, dbName: string, tableName: string): Promise<TableDescriptor> {
        let database = await getDatabase(schema, dbName),
            tables;
        if (database && (tables = await database.getTables())) {
            return tables.find(table => tableName === table.name || tableName === table.alias);
        }
    }
}