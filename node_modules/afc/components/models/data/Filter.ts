/**
 * Created by jean.rennes on 27/06/2016.
 */
///<reference path="../../helpers/Tools.ts" />

namespace AFC.Data {
    export interface IFilteredDataModel extends IKeyProvider, IRowCollection, Partial<IColumnIndexProvider>, Partial<Tools.IObservable>, Partial<IDataEditor> {
        readonly values?: ReadonlyArray<ReadonlyArray<any>>;
        dropEvents?(key: ReadonlyArray<any>): void;
        find?(key: ReadonlyArray<any>): number;
        item?(index: number): IDataItemContainer;
        createStore?(): AFC.Data.IStore;
    }
    
    interface IIndex {
        readonly length: number;
        values: ReadonlyArray<ReadonlyArray<any>>;
        getRow(index: number): ReadonlyArray<any>;
        indexOf(row: ReadonlyArray<any>): number;
        find(key: ReadonlyArray<any>): number;
    }

    class FilterIndex extends UniqueIndex implements IIndex {
        public get length(): number {
            return this.values.length;
        }

        public getRow(index: number): ReadonlyArray<any> {
            return this.values[index];
        }
    }

    function _getValues(dataModel: IKeyProvider & IRowCollection, filter?: (row: ReadonlyArray<any>)=> boolean): ReadonlyArray<any>[] {
        const values: ReadonlyArray<any>[] = [];

        for (let i = 0, iLength = dataModel.length, row; i < iLength; ++i) {
            row = dataModel.getRow(i);
            (!filter || filter(row)) && values.push(row);
        }
        return values;
    }

    class FillerIndex implements IIndex {
        public readonly filterModel: FilterModel;
        public readonly model: IFilteredDataModel;
        protected _values: ReadonlyArray<ReadonlyArray<any>>;

        constructor(filterModel: FilterModel, model: IFilteredDataModel) {
            this.filterModel = filterModel;
            this.model = model;
        }

        public get length(): number {
            const model = this.model;
            return model ? model.length : 0;
        }

        public getRow(index: number): ReadonlyArray<any> {
            const model = this.model;
            return model && model.getRow(index);
        }

        public get values(): ReadonlyArray<ReadonlyArray<any>> {
            return this._values || (this._values = this.model && (this.model.values || _getValues(this.model)));
        }
        
        public indexOf(row: ReadonlyArray<any>): number {
            const model = this.model;
            return model ? model.indexOf(row) : -1;
        }

        public find(key: ReadonlyArray<any>): number {
            const model = this.model;
            return model ? 
                (model.find ? model.find(key) : this.indexOf(createRowFromValues(this.filterModel, key, {}))):
                -1;
        }
    }

    function _setModel<T extends IFilteredDataModel = IFilteredDataModel>(this: FilterModel, dataModel: T) {
        let forwards: Tools.IForward[] = [];

        if (dataModel) {
            this._dataModel = dataModel;
            dataModel.on && forwards.push({
                type: Tools.EventType.Dirty,
                callback: this._onDirty,
                observable: <Tools.IObservable>dataModel
            });
        } else {
            delete this._dataModel;
        }
        this._setForwards(forwards);
    }

    export class FilterModel<T extends IFilteredDataModel = IFilteredDataModel> extends Tools.AutoSubscribeForwarder implements IDataModel {
        protected _columnIndex: { readonly [key:string]: number; };
        protected _dataModel: T;
        protected _filter: (row: ReadonlyArray<any>, self: this)=> boolean;
        protected _index: IIndex;

        constructor(filter?: (row: ReadonlyArray<any>, self: FilterModel<T>)=> boolean, dataModel?: T) {
            super();
            this._filter = filter;
            _setModel.call(this, dataModel);
        }

        protected _getIndex(): IIndex {
            let index = this._index;

            if (!index) {
                const dataModel: IKeyProvider & IRowCollection = this._dataModel,
                    filter = dataModel && this._filter;

                if (filter) {
                    const values: ReadonlyArray<any>[] = _getValues(dataModel, row => filter(row, this)),
                        columnIndex = this.columnIndex;
                    index = new FilterIndex(this.primaryKey.map(name => columnIndex[name]), values);
                } else {
                    index = new FillerIndex(this, dataModel);
                }
                this._index = index;
            }
            return index;
        }
        
        protected _filterEvent(item: IDataEventItem, a: IDataEventItem[]): void {
            switch (item.type) {
                case DataEventType.create:
                case DataEventType.delete_:
                case DataEventType.none:
                    this._filter(item.row, this) && a.push(item);
                    break;
                case DataEventType.modify:
                    a.push({
                        type: DataEventType.delete_,
                        row: item.row,
                        committed: item.committed
                    });
                    this._filter(item.row, this) && a.push({
                        type: DataEventType.create,
                        row: item.row,
                        committed: item.committed
                    });
                default:
                    break;
            }
        }
        
        protected _onDirty(event: IDataEvent): void {
            let data: IDataModelEventData = event.data;
            
            delete this._index;
            if (data && (data.reset || data.items)) {
                if (data.reset) {
                    this.fireEvent(Tools.EventType.Dirty, new DataEventData(void 0, true));
                } else {
                    let a: IDataEventItem[];
                    
                    if (this._filter) {
                        a = [];
                        data.items.forEach((item: IDataEventItem) => this._filterEvent(item, a));
                    } else {
                        a = data.items;
                    }
                    a.length && this.fireEvent(Tools.EventType.Dirty, new DataEventData(a));
                }
            }
        }

        public set filter(filter: (row: ReadonlyArray<any>, self: this)=> boolean) {
            if (this._filter !== filter) {
                delete this._index;                
                this._filter = filter;
                this.fireEvent(Tools.EventType.Dirty, new DataEventData(void 0, true));
            }
        }

        public get filter(): (row: ReadonlyArray<any>, self: this)=> boolean {
            return this._filter;
        }
                
        public set dataModel(dataModel: T) {
            if (this._dataModel !== dataModel) {
                delete this._index;
                delete this._columnIndex;
                _setModel.call(this, dataModel);
                this.fireEvent(Tools.EventType.Dirty, new DataEventData(void 0, true));
            }
        }

        public get dataModel(): T {
            return this._dataModel;
        }
        
        public get columns(): ReadonlyArray<IDBColumn> {
            return this._dataModel && this._dataModel.columns;
        }
        
        public get primaryKey(): ReadonlyArray<string> {
            return this._dataModel && this._dataModel.primaryKey;
        }

        public get length(): number {
            return this._getIndex().length;
        }
        
        public getRow(index: number): ReadonlyArray<ReadonlyArray<any>> {
            return this._getIndex().getRow(index);
        }
                
        public get values(): ReadonlyArray<ReadonlyArray<any>> {
            return this._getIndex().values;
        }

        public item(index: number): IDataItemContainer {
            let dataModel = this._dataModel;
            if (dataModel) {
                let item = dataModel.item ?
                    dataModel.item(this._filter ? dataModel.indexOf(this.values[index]) : index):
                    Tools.Data.mapRow(this.columns, this._getIndex().getRow(index));
                return item && {
                    dataItem: item.dataItem,
                    dataItemIndex: index
                };
            }
        }
        
        public get columnIndex(): { readonly [key:string]: number; } {
            return this._dataModel && (this._columnIndex || (this._columnIndex = this._dataModel.columnIndex || Data.getColumnIndex(this.columns)));
        }
        
        public getKeyFromRow(row: any[]): ReadonlyArray<any> {
            return this._dataModel && this._dataModel.getKeyFromRow(row);
        }

        public compareKey(row: ReadonlyArray<any>, key: ReadonlyArray<any>): number {
            return this._dataModel && this._dataModel.compareKey(row, key);
        }
                        
        public compareRow(row0: ReadonlyArray<any>, row1: ReadonlyArray<any>): number {
            return this._dataModel && this._dataModel.compareRow(row0, row1);
        }
        
        public create(key: any[], values: {[key: string]: any}): boolean {
            let dataModel = this._dataModel;
            
            delete this._index;
            return dataModel && dataModel.create && dataModel.create(key, values);
        }
        
        public modify(key: any[], values: {[key: string]: any}): boolean {
            let dataModel = this._dataModel;
            
            delete this._index;
            return dataModel && dataModel.modify && dataModel.modify(key, values);
        }
        
        public delete_(key: any[]): void {
            let dataModel = this._dataModel;
            
            delete this._index;
            dataModel && dataModel.delete_ && dataModel.delete_(key);
        }

        public dropEvents(key: ReadonlyArray<any>): void {
            let dataModel = this._dataModel;
            
            delete this._index;
            return dataModel && dataModel.dropEvents && dataModel.dropEvents(key);
        }

        public indexOf(row: ReadonlyArray<any>): number {
            return this._getIndex().indexOf(row);
        }
        
        public find(key: ReadonlyArray<any>): number {
            return this._getIndex().find(key);
        }
        
        public refresh(): void {
            delete this._index;
            this.fireEvent(Tools.EventType.Dirty, new DataEventData(void 0, true));
        }

        public createStore(): AFC.Data.IStore {
            let dataModel = this._dataModel;
            return dataModel && dataModel.createStore && dataModel.createStore();
        }
    }
}