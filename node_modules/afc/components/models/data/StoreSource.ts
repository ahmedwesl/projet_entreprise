/**
 * Created by jean.rennes on 22/06/2018.
 */
///<reference path="Global.ts" />
///<reference path="DataSource.ts" />
///<reference path="Data.ts" />
///<reference path="Scenario.ts" />
///<reference path="TableResource.ts" />
///<reference path="../tradearea/DMAConfig.ts" />

namespace AFC.Data {
    export interface IIndexedTable {
        readonly definition: IDBTableDefinition;
        readonly columnIndex: {[key: string]: number;};
        readonly geometryIndice: number;
        qualifiers?: {
            [key: number]: number;
        };
    }

    export interface IStoreTableResourceContent extends ITableResourceContent, IIndexedTable {
        readonly descriptor: AFC.Data.HistoricizedTableDescriptor;
    }
    
    interface ISourceParametersData extends Tools.IObservable {
        readonly columnIndex: { [key:string]: number; };
        indexOf(key: ReadonlyArray<any>): number;
        getRow(index: number): ReadonlyArray<any>;
        compareKey: (row: ReadonlyArray<any>, value: any) => number;
        create(key: ReadonlyArray<any>, values: {[key: string]: any}): any;
        modify(key: ReadonlyArray<any>, values: {[key: string]: any}): any;
        delete_(key: ReadonlyArray<any>): any;
    }
    
    export interface ISourceParameters extends IDataContainerChecker<IStore> {
        readonly data: ISourceParametersData;
    }

    export function findQualifier(content: {
            readonly definition: IDBTableDefinition;
            qualifiers?: {
                [key: number]: number;
            };
        }, qualifier: Qualifier, mute?: boolean): number {
        if (!content.qualifiers) {
            content.qualifiers = {};
            content.definition.columns.forEach((column, i)=> {
                column.qualifiers && column.qualifiers.forEach(qualifier=> content.qualifiers[qualifier] = i);
            });                
        }
        if (content.qualifiers[qualifier] !== void 0) {
            return content.qualifiers[qualifier];
        }
        mute || console.log(`Missing store qualifier '${Data.qualifier(qualifier)}'`)
        return -1;
    };

    function _convert(content: IStoreTableResourceContent, columnIndex: {readonly [key: string]: number}, row: ReadonlyArray<any>): ReadonlyArray<any> {
        let values: any[] = [];

        content.definition.columns.forEach((column, indice) => {
            let i: number = columnIndex[column.name];
            values[indice] = i === void 0 ? null : row[i];
        });
        return values;
    };

    const _key = Symbol();

    export abstract class StoreBase implements IReadonlyStore {
        /** @internal */
        private [_key]: ReadonlyArray<any>;
        public readonly content: IIndexedTable;
        public abstract readonly geometry: GeoJSON.Point;
        public readonly identifier: string;
        public readonly mainAddress: string;
        public readonly address: string;
        public readonly zipCode: string;
        public readonly city: string;
        public readonly country: string;
        public readonly totalSurface: number;
        public readonly surface: number;
        public readonly symbol: string;
        public readonly brand: string;
        public readonly businessCode: string;
        public readonly revenue: number;
        public readonly changes: string;

        constructor(content: IIndexedTable) {
            this.content = content;
        }

        protected _getGeometry(): number {
            if (this.content.geometryIndice !== void 0) {
                return this.content.geometryIndice;
            }
            console.log('Missing store geometry');
        }

        protected _getColumn(column: string): number {
            let content: IIndexedTable = this.content;
            if (content.columnIndex && (content.columnIndex[column] !== void 0)) {
                return content.columnIndex[column];
            }
            console.log('Missing store columns');
        }

        protected _getQualifier(qualifier: Qualifier, mute?: boolean): number {
            return findQualifier(this.content, qualifier);
        }

        protected abstract _getData(indice: number): any;

        public static extend(constructor: {new (...items: any[]): IReadonlyStore}, getProperty: (qualifier: Qualifier)=> PropertyDescriptor) {
            let value: string;
            for (let i: number = Qualifier.identifier; value = qualifier(i); ++i) {
                Object.defineProperty(constructor.prototype, value, getProperty(i));
            }
        }

        public get tableDefinition(): IDBTableDefinition {
            return this.content.definition;
        }

        public get key(): ReadonlyArray<any> {
            return this[_key] || (this[_key] = this.content.definition.primaryKey.map((column: string) => this._getData(this._getColumn(column))));
        }

        public getData(column: string, stringify?: boolean): any {
            return this._getData(this._getColumn(column));
        }

        public hasQualifier(qualifier: Qualifier): boolean {
            return this._getQualifier(qualifier, true) !== -1;
        }

        public getQualifiedColumn(qualifier: Qualifier): IDBColumnDefinition {
            return this.content.definition.columns[this._getQualifier(qualifier)];
        }

        public getColumn(name: string): IDBColumnDefinition {
            return this.content.definition.columns[this._getColumn(name)];
        }
    }

    export class ReadonlyStore extends StoreBase {
        protected _values: ReadonlyArray<any>;
        
        constructor(content: IIndexedTable, values: ReadonlyArray<any>) {
            super(content);
            this._values = values;
        }

        protected _getData(indice: number): any {
            return this._values[indice];
        }
                
        public static propertyDefinition(qualifier: Qualifier): PropertyDescriptor {
            return {
                get: function (this: ReadonlyStore): any {
                    return this._getData(this._getQualifier(qualifier));
                },
                enumerable: true,
                configurable: true
            }                
        }

        public get geometry(): GeoJSON.Point {
            return this._values[this._getGeometry()];
        }
    }
    StoreBase.extend(ReadonlyStore, ReadonlyStore.propertyDefinition);

    export class Store extends Tools.EventSinkMixin(StoreBase) implements IStore {
        protected readonly _parameters: ISourceParameters;
        protected _values: ReadonlyArray<any>;
        protected _override: RecordOverrides;
        protected _closed: boolean;
        protected _created: boolean;
        protected _valid: boolean;
        protected _messages: ReadonlyArray<ICheckMessage>;
        protected _events: {[key: string]: any};
        declare public readonly content: IStoreTableResourceContent;
        declare public identifier: string;
        declare public mainAddress: string;
        declare public address: string;
        declare public zipCode: string;
        declare public city: string;
        declare public country: string;
        declare public totalSurface: number;
        declare public surface: number;
        declare public symbol: string;
        declare public brand: string;
        declare public businessCode: string;
        declare public revenue: number;
        declare public changes: string;

        constructor(content: IStoreTableResourceContent, parameters: ISourceParameters, values: ReadonlyArray<any>) {
            super(content);
            this._parameters = parameters;
            this._values = values;
            this._override = new RecordOverrides(this.content.definition.columns, values);
        }
        
        protected _reset(values: ReadonlyArray<any>): void {
            this._override.reset(this._values = values);
        }
        
        protected _toPositions(columns: ReadonlyArray<string>): ReadonlyArray<number> {
            return columns ? columns.map(column => this._getColumn(column)) : this.content.definition.columns.map((column, indice)=> indice);
        }
        
        protected _getData(indice: number): any {
            return this._override.get(indice);
        }

        protected _set(indice: number, value: any): boolean {
            let dataRecordEventData = this._override.set(indice, value);
            if (dataRecordEventData) {
                delete this._valid;
                this.fireEvent(Tools.EventType.Dirty, dataRecordEventData);
                return true;
            }
        }

        protected _check(parameters: ISourceParameters, callback: (valid: boolean, messages: ReadonlyArray<ICheckMessage>, events: {[key: string]: any})=>any): void {
            if (this._valid !== void 0) {
                callback(this._valid, this._messages, this._events);
            } else {
                delete this._messages;
                delete this._events;
                Promise.all(this.content.definition.columns.map((column: IDBColumnDefinition, indice: number) => this._override.check(this, parameters, column, indice))).then(results=> {
                    let messages: ICheckMessage[],
                        events: {[key: string]: any},
                        valid = results.every(([column, dirty, value, valid, message, indice]: [column: IDBColumnDefinition, dirty: boolean, value: any, valid: boolean, message: Readonly<ICheckMessage>, indice: number]) => {
                            message && (messages || (messages = [])).push(message);
                            dirty && !Tools.Data.equalValue(column.type, value, this._values[indice]) && ((events || (events = {}))[column.name] = value);
                            return valid;
                        });
                    callback(this._valid = valid, messages && (this._messages = messages), events && (this._events = events));
                });
            }
        }
        
        public static propertyDefinition(qualifier: Qualifier): PropertyDescriptor {
            return {
                get: function (this: Store): any {
                    return this._override.get(this._getQualifier(qualifier));
                },
                set: function (this: Store, value: any) {
                    this._set(this._getQualifier(qualifier), value);
                },
                enumerable: true,
                configurable: true
            }                
        }

        public static commit(store: Store, key: ReadonlyArray<any>, parameters: ISourceParameters, callback: (valid: boolean, messages?: ReadonlyArray<ICheckMessage>)=>any): void {
            let final = (valid: boolean, messages?: ReadonlyArray<ICheckMessage>)=> callback && callback(valid, messages);
            let branch = parameters.data;
            if (store._closed) {
                return final(false);
            }
            let h = (valid: boolean, messages: ReadonlyArray<ICheckMessage>, events: {[key: string]: any})=> {
                if (valid) {
                    let compare = (item: IDataEventItem) => {
                        return item.committed && !branch.compareKey(item.row, key);
                    };
                    let h2 = (event: IDataEvent)=> {
                        if (event.data.reset || event.data.items.some(compare)) {
                            let row = branch.getRow(branch.indexOf(store._values));
                            row && store._reset(_convert(store.content, branch.columnIndex, row));
                            final(true);
                        } else {
                            branch.notify(Tools.EventType.Dirty, h2);
                        }
                    };
                    if (events) {
                        branch.notify(Tools.EventType.Dirty, h2);
                        store._created ? branch.create(key, events) : branch.modify(key, events);
                    } else
                        final(true);
                } else {
                    final(false, messages);
                }
            }
            store._check(parameters, h);
        }

        public get tableDescriptor(): TableDescriptor {
            return this.content.descriptor;
        }

        public get exist(): boolean {
            return !(this._created || this._closed);
        }

        public get geometry(): GeoJSON.Point {
            return this._override.get(this._getGeometry());
        }

        public set geometry(value: GeoJSON.Point) {
            this._set(this._getGeometry(), value);
        }

        public getOldData(column: string): any {
            return this._values[this._getColumn(column)];
        }

        public setData(column: string, value: any): boolean {
            return this._set(this._getColumn(column), value);
        }

        public checkColumn(column: string, callback: (column: IDBColumnDefinition, dirty: boolean, value: any, valid: boolean, message: Readonly<ICheckMessage>, indice: number)=>any): void {
            let indice: number = this._getColumn(column);
            (indice !== void 0) && this._override.check(this, this._parameters, this.content.definition.columns[indice], indice).then(result => callback(...result));
        }

        public check(callback: (valid: boolean, messages: ReadonlyArray<ICheckMessage>, events: {[key: string]: any})=>any): void {
            this._check(this._parameters, callback);
        }

        public commit(callback?: (valid: boolean, messages?: ReadonlyArray<ICheckMessage>)=>any): void {
            Store.commit(this, this.key, this._parameters, callback);
        }

        public close(): void {
            if (!this._closed) {
                this._closed = true;
                this._parameters.data.delete_(this.key);
            }
        }
        
        public getState(): IReadonlyStore {
            return new ReadonlyStore(this.content, this.content.definition.columns.map((column: Data.IDBColumnDefinition, indice: number) => this._override.get(indice)));
        }
        
        public invalidate(columns?: ReadonlyArray<string>): void {
            this._override.invalidate(this._toPositions(columns));
        }
        
        public isDirty(columns?: ReadonlyArray<string>): boolean {
            return this._toPositions(columns).some(indice => this._override.isDirty(indice));
        }
    }
    StoreBase.extend(Store, Store.propertyDefinition);

    class ExistingStore extends Store {
        constructor(content: IStoreTableResourceContent, parameters: ISourceParameters, row: ReadonlyArray<any>) {
            super(content, parameters, _convert(content, parameters.data.columnIndex, row));
        }
    }

    class NewStore extends Store {
        constructor(content: IStoreTableResourceContent, parameters: ISourceParameters, key?: ReadonlyArray<any>) {
            let i: number = 0;
            let values: any[] = [];
            content.definition.columns.map((column: IDBColumnDefinition, indice: number)=> {
                let value: any = column.index === -1 ? null : key && key[i++];
                values[indice] = value === void 0 ? Tools.Data.generateRndValue(column) : value;
            });
            super(content, parameters, values);
            this._created = true;
        }

        public commit(callback?: (valid: boolean, messages?: ReadonlyArray<ICheckMessage>)=> any): void {
            let h = (valid: boolean, messages: ReadonlyArray<ICheckMessage>)=> {
                valid && (delete this._created);
                callback && callback(valid, messages);
            }
            Store.commit(this, this.key, this._parameters, h);
        }

        public close(): void {
            this._created ? this._closed = true : super.close();
        }
    }
    
    function _updateContent(content: Mutable<IStoreTableResourceContent>): void {
        let columnIndex: {[key: string]: number;} = {};

        content.definition.columns.forEach((item, indice)=> {
            columnIndex[item.name] = indice;
            columnIndex[item.alias] = indice;
            if (Tools.Data.checkGeometryType(item, DataKind.point) && (content.geometryIndice === void 0)) {
                content.geometryIndice = indice;
            }
        });
        content.columnIndex = columnIndex;
    }

    function _updateColumns(dataTable: IDataTable, content: IStoreTableResourceContent): void {
        dataTable.columns.forEach((column: IDBColumn)=> {
            let i: number = content.columnIndex[column.name];

            if ((i === void 0) || content.definition.columns[i].readOnly) {
                column.readOnly = true;
            }
        });
    }

    async function _createBranch(content: ITableResourceContent<HistoricizedTableDescriptor>, options?: Parameters<HistoricizedTableDescriptor['insertBranch']>[0]): Promise<IDBHistoryBranchBase> {
        return content.descriptor.isHistoricized ?
            content.descriptor.insertBranch(options): {
                id: AFC.Tools.Data.generateRndString(10),
                author: content.descriptor.database.schema.restModel.identity.name,
                creationDate: new Date(),
                properties: (options || (options = {})).properties,
                rating: options.rating,
                description: options.description,
                status: options.status
            };
    }

    type IDataItemStore = IDataItemContainer<IDataItemStoreData<IStore>>;

    const _getDMASites = Symbol();

    interface IDMAContext extends TradeArea.IDMAContext {
        readonly storeSource: StoreSource;
    }

    export interface IStoreSourceProject {
        readonly id: string,
        readonly events?: IModificationEvents;
        readonly info?: IDBHistoryBranchInfo;
    }
        
    export abstract class StoreSource extends ResourceLoader<IStoreTableResourceContent> implements IDataModel, IStoreSource, ISourceParametersData {
        protected _historizedModel: HistorizedModel;
        protected _cache: TradeArea.IDMAContext;
        protected _scenario: Scenario;
        protected _dataModel: IDataModelView;
        protected _parameters: ISourceParameters;
        protected _ready: boolean;
        public check: (storeSource: IStoreSource, store: Store, column: IDBColumnDefinition, dirty: boolean, value: string, callback: (valid: boolean, message?: Readonly<ICheckMessage>) => void) => void;

        public static DMAContext: {new (storeSource: StoreSource): IDMAContext} = class implements IDMAContext {
            public readonly storeSource: StoreSource;
            protected _source: TradeArea.IDMASites;
            protected _target: TradeArea.IDMASites;

            constructor(storeSource: StoreSource) {
                this.storeSource = storeSource;
            }

            public get source(): TradeArea.IDMASites {
                return this._source || (this._source = this.storeSource[_getDMASites]());
            }

            public get target(): TradeArea.IDMASites {
                return this.storeSource._dataModel ? this._target || (this._target = this.storeSource[_getDMASites](this.storeSource._dataModel.branch)) : this.source;
            }
        };

        constructor(resource: ITableResource, remote?: IHistorizedModelRemote) {
            super(resource);
            this._parameters = {
                data: this,
                check: this._check.bind(this)
            };
            this._historizedModel = new HistorizedModel(remote);
        }

        /** @internal */
        private [_getDMASites](branch?: string): TradeArea.IDMASites {
            if (this._content) {
                let events: IModificationEvents;
                let dmaSites: Mutable<TradeArea.IDMASites> = {
                    reference: this._content.resource
                };
                (events = this._historizedModel.generateEvents(branch)) && (dmaSites.events = events);
                return dmaSites;
            }
        }

        protected _check(store: Store, column: IDBColumnDefinition, dirty: boolean, value: string, callback: (valid: boolean, message?: Readonly<ICheckMessage>)=> any): void {
            return this.check ? this.check(this, store, column, dirty, value, callback) : callback(true);
        }

        protected _onDirty(event: IDataEvent): void {
            delete this._cache;
            this.fireEvent(Tools.EventType.Dirty, event.data);
        }

        protected abstract _load(content: ITableResourceContent): Promise<IDataTable>;

        protected _release(): void {
            if (this._dataModel) {
                this._dataModel.off(Tools.EventType.Dirty, this._onDirty, this);
                this._historizedModel.releaseBranch(this._dataModel.branch);
                delete this._dataModel;
                delete this._cache;
            }
        }
            
        public override async getMetadata(): Promise<IStoreTableResourceContent> {
            let history = this._content?.history,
                content = await super.getMetadata();
                
            history && history !== content.history && this._release();
            _updateContent(content);
            return content;
        }
                    
        public get parameters(): ISourceParameters {
            return this._parameters;
        }
        
        public get fullName(): string {
            return this._content?.descriptor.fullName;
        }
        
        public get isHistoricized(): boolean {
            return this._content?.descriptor.isHistoricized;
        }
        
        public get branchInfo(): IDBHistoryBranchInfo {
            return this._dataModel?.branchInfo;
        }
        
        public get geometry(): IDBColumnDefinition {
            return this._content?.definition.columns[this._content.geometryIndice];
        }

        public release(): void {
            this._release();
        }

        public get session(): string {
            return this._historizedModel.session;
        }

        public get columns(): ReadonlyArray<IDBColumn> {
            return this._historizedModel.columns;
        }

        public get primaryKey(): ReadonlyArray<string> {
            return this._historizedModel.primaryKey;
        }

        public get values(): ReadonlyArray<ReadonlyArray<any>> {
            return this._dataModel?.values;
        }

        public get columnIndex():{ [key:string]:number; } {
            return this._historizedModel.columnIndex;
        }

        public getKeyFromRow(row: ReadonlyArray<any>): ReadonlyArray<any> {
            return this._historizedModel.getKeyFromRow(row);
        }

        public compareKey(row: ReadonlyArray<any>, key: ReadonlyArray<any>): number {
            return this._historizedModel.compareKey(row, key);
        }

        public compareRow(row0: ReadonlyArray<any>, row1: ReadonlyArray<any>): number {
            return this._historizedModel.compareRow(row0, row1);
        }

        public create(key: ReadonlyArray<any>, values: {[key: string]: any}): void {
            this._dataModel.create(key, values);
        }

        public modify(key: ReadonlyArray<any>, values: {[key: string]: any}): void {
            this._dataModel.modify(key, values);
        }

        public delete_(key: ReadonlyArray<any>): void {
            this._dataModel.delete_(key);
        }

        public indexOf(row: ReadonlyArray<any>): number {
            return this._dataModel.indexOf(row);
        }

        public find(key: ReadonlyArray<any>): number {
            return this._dataModel.find(key);
        }

        public getRow(index: number): ReadonlyArray<any> {
            return this._dataModel.values[index];
        }

        public dropEvents(key: ReadonlyArray<any>): void {
            let reference: boolean = (this._dataModel === this._historizedModel);
            this._dataModel.dropEvents(key, reference ? {session: this.session} : void 0);
        }            

        public generateContext(): TradeArea.IDMAContext {
            return this._cache || (this._cache = new StoreSource.DMAContext(this));
        }

        public get scenario(): Scenario {
            return this._scenario || (this._scenario = new Scenario(this, this._dataModel));
        }

        protected async _setBranch(project: IStoreSourceProject, commit?: boolean): Promise<ITableResourceContent> {
            let dataModel: IDataModelView = this._historizedModel,
                session = this.session;
            
            if (project) {
                project.events && this._historizedModel.appendEvents(project.events, !!commit, project.id, session);
                dataModel = await this._historizedModel.getBranch(project.id);
                dataModel.session = session;
                dataModel.branchInfo = project.info;
                if (commit && project.events) {
                    await new Promise(resolve => dataModel.once(Tools.EventType.Dirty, resolve, this._onDirty, this));  // wait for update
                }				
            } else {
                await this._historizedModel.ready();
            }
            
            this._release();   
            (this._dataModel = dataModel).on(Tools.EventType.Dirty, this._onDirty, this);
            return this._content;
        }

        protected _onDataTable(content: IStoreTableResourceContent, dataTable: IDataTable, project?: IStoreSourceProject): Promise<ITableResourceContent> {
            if (!this._content)
                this._content = content;
            _updateColumns(dataTable, content);
            this._historizedModel.initFrom(dataTable.columns, dataTable.primaryKey, <any[][]> dataTable.values, content);
            this._historizedModel.session = this.tableResource.session;
            return this._setBranch(project);
        }

        public get branch(): string {
            return this._dataModel && this._dataModel.branch;
        }

        public async init(project?: IStoreSourceProject): Promise<boolean> {
            this._ready = false;
            this._release();
            let content = await this.getMetadata(),
                dataTable = await this._load(content);
            await this._onDataTable(content, dataTable, project);
            this.fireEvent(Tools.EventType.UserEvent + 1);
            this.fireEvent(Tools.EventType.Dirty, new DataEventData(void 0, true));
            this._ready = true;
            return !!content;
        }
        
        public ready(): Promise<boolean> {
            return this._ready ? Promise.resolve(!!this._content) : new Promise((resolve: (valid: boolean) => void) => this.notify(Tools.EventType.UserEvent + 1, (/*event: Tools.IEvent*/) => resolve(!!this._content)));
        }
        
        public createStore(code?: any): Store {
            let stores: IStoreTableResourceContent = this._content;
            return stores && new NewStore(stores, this._parameters, (code === void 0) || (code instanceof Array) ? code : [code]);
        }

        public getStore(code: any): Store {
            let index: number = this._dataModel.find(code instanceof Array ? code : [code]);
            return (index !== -1) && this.getStoreFromRow(this.values[index]);
        }

        public getStoreFromRow(row?: ReadonlyArray<any>): Store | undefined {
            const content: IStoreTableResourceContent = row && this._content;
            return content && new ExistingStore(content, this._parameters, row);
        }

        public hasQualifier(qualifier: Qualifier): boolean {
            return this._content && (findQualifier(this._content, qualifier, true) !== -1);
        }

        public getQualifiedColumn(qualifier: Qualifier): IDBColumnDefinition {
            return this._content && this._content.definition.columns[findQualifier(this._content, qualifier, true)];
        }

        public get length(): number {
            return this.values ? this.values.length : 0;
        }

        public item(index: number): IDataItemStore {
            return {
                dataItem: {
                    get key(): ReadonlyArray<any> {
                        return this.store.key;
                    },
                    store: this.getStoreFromRow(this.values[index])
                },
                dataItemIndex: index
            };
        }
        
        public generateEvents(): IModificationEvents {
            return this._dataModel && this._historizedModel.generateEvents(this._dataModel.branch);
        }
        
        public async createBranch(options?: Parameters<HistoricizedTableDescriptor['insertBranch']>[0], events?: IModificationEvents): Promise<IDBHistoryBranchBase> {
            let content = await this.getMetadata(),
                branch: IDBHistoryBranchBase;
                            
            if (!this._historizedModel.values) {
                let table: AFC.Data.IDataTable = {
                    columns: content.definition.columns,
                    primaryKey: content.definition.primaryKey,
                    values: []
                };
                await this._onDataTable(content, table);
            }

            branch = await _createBranch(content, options);
            await this._setBranch({
                id: branch.id,
                info: {
                    description: branch.description,
                    properties: branch.properties,
                    rating: branch.rating
                },
                events: events
            }, true);
            return branch;
        }
        
        public override clone(): StoreSource {
            let clone = <StoreSource>super.clone();
            
            clone._historizedModel = this._historizedModel;
            clone._parameters = {
                data: clone,
                check: clone._check.bind(clone)
            };
            clone.check = this.check;
            return clone;
        }
        
        public copy(project?: IStoreSourceProject): StoreSource {
            let clone = this.clone();
            
            this.ready().then(success => {
                if (clone._ready = success) {
                    clone._setBranch(project);
                }
            });
            return clone;
        }
    }

    type GetProps<TBase> = TBase extends new (props: infer P) => any ? P : never;
    type GetInstance<TBase> = TBase extends new (...args: any[]) => infer I ? I : never;
    type MergeCtor<A, B> = new (props: GetProps<A> & GetProps<B>) => GetInstance<A> & GetInstance<B>;
    
    export function readOnlyStoreSourceMixin<A extends {}, TBase extends new (args: A) => IRowCollection>(Base: TBase) {
        const Derived = class extends (Base as any) {
            constructor(args: { content: IStoreTableResourceContent } & GetProps<TBase>) {
                super(args);
                this.content = args.content;
            }

            public get geometry(): IDBColumnDefinition {
                return this.content.definition.columns[this.content.geometryIndice];
            }
            
            public get fullName(): string {
                return this.content.descriptor.fullName;
            }
            
            public hasQualifier(qualifier: Qualifier): boolean {
                return findQualifier(this.content, qualifier, true) !== -1;
            }
            
            public getQualifiedColumn(qualifier: Qualifier): IDBColumnDefinition {
                return this.content.definition.columns[findQualifier(this.content, qualifier, true)];
            }

            public getStoreFromRow(row?: ReadonlyArray<any>): ReadonlyStore | undefined {
                return row && new ReadonlyStore(this.content, row);
            }

            public item(index: number): IDataItemContainer<IDataItemStoreData> {
                const store = this.getStoreFromRow(this.getRow(index));
                return store && {
                    dataItem: {
                        get key(): ReadonlyArray<any> {
                            return this.store.key;
                        },
                        store
                    },
                    dataItemIndex: index
                };
            }
    
            public readonly content: IStoreTableResourceContent;
        }
        return Derived as MergeCtor<typeof Derived, TBase>;
    }

    function _check(this: IStoreSource, store: Store, column: IDBColumnDefinition, dirty: boolean, value: string, callback: (valid: boolean, message?: Readonly<ICheckMessage>)=> void): void {
        return this.check ? this.check(this, store, column, dirty, value, callback) : callback(true);
    }    

    export function storeSourceMixin<A extends {}, TBase extends new (args: A) => IDataEditor & IRowCollection & Data.IColumnIndexProvider & Data.IKeyProvider & Tools.IObservable>(Base: TBase) {
        const Derived = class extends (Base as any) {
            constructor(args: { content: IStoreTableResourceContent; } & GetProps<TBase>) {
                super(args);
                this.content = args.content;
                this.parameters = {
                    data: <IDataEditor & IRowCollection & Data.IColumnIndexProvider & Data.IKeyProvider & Tools.IObservable><any>this,
                    check: _check.bind(this)
                };    
            }

            public get geometry(): IDBColumnDefinition {
                return this.content.definition.columns[this.content.geometryIndice];
            }
            
            public get fullName(): string {
                return this.content.descriptor.fullName;
            }
            
            public hasQualifier(qualifier: Qualifier): boolean {
                return findQualifier(this.content, qualifier, true) !== -1;
            }
            
            public getQualifiedColumn(qualifier: Qualifier): IDBColumnDefinition {
                return this.content.definition.columns[findQualifier(this.content, qualifier, true)];
            }

            public createStore(code?: any): Store {
                const content: IStoreTableResourceContent = this.content;
                return content && new NewStore(content, this.parameters, (code === void 0) || (code instanceof Array) ? code : [code]);
            }
    
            public getStoreFromRow(row?: ReadonlyArray<any>): Store | undefined {
                return row && new ExistingStore(this.content, this.parameters, row);
            }

            public item(index: number): IDataItemStore {
                const store = this.getStoreFromRow(this.getRow(index));
                return store && {
                    dataItem: {
                        get key(): ReadonlyArray<any> {
                            return this.store.key;
                        },
                        store
                    },
                    dataItemIndex: index
                };
            }
    
            public readonly parameters: ISourceParameters;
            public readonly content: IStoreTableResourceContent;
            public check: (storeSource: IStoreSource, store: Store, column: IDBColumnDefinition, dirty: boolean, value: string, callback: (valid: boolean, message?: Readonly<ICheckMessage>) => void) => void;
        }
        return Derived as MergeCtor<typeof Derived, TBase>;
    }
}