/**
 * Created by jean.rennes on 14/03/2016.
 */
///<reference path="../models/globals/MapView.ts" />
///<reference path="../adapters/globals/MapAdapter.ts" />
///<reference types="leaflet" />

namespace AFC.Tools.ParcEdition {
    export interface IMapLayerEditorInfo {
        gui: gui.AfcGuiLayer;
        layer: L.Layer;
        store: AFC.Data.IStore;
        source: Globals.IEventLayerInfo;
    }
    
    export interface IMapLayerEditorOptions {
        createCode?: (handlers: LayerEditionHandlers)=> any;
        onMoveEnd?: (handlers: LayerEditionHandlers, destination: GeoJSON.Point, info: IMapLayerEditorInfo)=> boolean;
        click(handlers: LayerEditionHandlers, latlng: L.LatLng, info: IMapLayerEditorInfo, event: L.LeafletMouseEvent): any;
    }

    class MoveControl extends L.Control {
        protected _text: d3.Selection<SVGTextElement, undefined, SVGElement, undefined>;
        protected _start: L.LatLngTuple;
        protected _cancel: ()=> void;
        public readonly info: IMapLayerEditorInfo;

        constructor(info: IMapLayerEditorInfo, cancel: ()=> void) {
            let coordinates: number[] = info.store.geometry.coordinates;
            
            super();
            this._start = [coordinates[1], coordinates[0]];
            this._cancel = cancel;
            this.info = info;
            this.options  = {
                position: 'topleft'
            };
            $((<any>info.layer)._icon).addClass('selectedMarker');
        }

        protected _onMove(e: L.LeafletMouseEvent) {
            let latlng: L.LatLng = e.latlng;
            let distance: number = Math.round(latlng.distanceTo(this._start));

            this._text.text(distance + ' m');
        }

        public onAdd(map: L.Map): HTMLElement {
            let svg: SVGElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            let selection: d3.Selection<SVGElement, undefined, null, undefined> = d3.select<SVGElement, undefined>(svg)
                .attr("id", "moveCtrl")
                .attr('height', 180)
                .attr('width', 180);
            
            selection.append<SVGPolygonElement>('polygon')
                .attr('points', '0,0 180,0 0,180');
            this._text = selection.append<SVGTextElement>('text')
                .attr('x', 10)
                .attr('y', 25)
                .attr('font-size', 20)
                .text('0');
            map.on('mousemove', this._onMove, this);
            selection.append<SVGImageElement>('image')
                .attr('xlink:href', 'img/Picto_Move_Large.png')
                .attr('x', 10)
                .attr('y', 35)
                .attr('height', 64)
                .attr('width', 64)
                .on('click', (event: MouseEvent/*, d*/)=>{
                    this._cancel();
                    event.stopPropagation();
                });
            return <any>svg;
        }

        public onRemove(map: L.Map): void {
            $((<any>this.info.layer)._icon).removeClass('selectedMarker');
            map.off('mousemove', this._onMove, this);
        }
    }
    
    export type ILayerEditionSource = AFC.Data.IDataEditor & AFC.Data.IStoreSource & { getStoreFromRow(row?: ReadonlyArray<any>): AFC.Data.Store | undefined };
    
    export class LayerEditionHandlers implements gui.IMapEventHandlers {
        protected _move: MoveControl;
        public readonly options: IMapLayerEditorOptions;
        public readonly parc: ILayerEditionSource;
        public readonly holder: gui.AfcGuiMapHolder;
        public readonly guiLayers: ReadonlyArray<gui.AfcGuiLayer>;
        public readonly symbolFactory: Globals.SymbolFactory;
        public disabled: boolean;

        constructor(storeSource: ILayerEditionSource, holder: gui.AfcGuiMapHolder, guiLayers: ReadonlyArray<gui.AfcGuiLayer>, symbolFactory: Globals.SymbolFactory, options: IMapLayerEditorOptions) {
            this.options = options;
            this.parc = storeSource;
            this.holder = holder;
            this.guiLayers = guiLayers;
            this.symbolFactory = symbolFactory;
        }

        public create(latlng: L.LatLng): AFC.Data.IStore {
            if (latlng) {
                let code: any = this.options.createCode && this.options.createCode(this);
                let store: AFC.Data.IStore = this.parc.createStore(code);
                store.geometry = {type: 'Point', coordinates: [latlng.lng, latlng.lat]};
                return store;
            }
        }

        public startMove(info: IMapLayerEditorInfo): void {
            this.endMove();
            this.holder.control.closePopup();
            this.holder.control.addControl(this._move = new MoveControl(info, this.endMove.bind(this)));
        }

        public endMove(): void {
            if (this._move) {
                this.holder.control.removeControl(this._move);
                delete this._move;
            }
        }
        
        public click(latlng: L.LatLng, source: gui.IEventLayerInfo<Globals.LayerType.symbol>, event: L.LeafletMouseEvent): boolean {
            let info: IMapLayerEditorInfo,
                gui: AFC.gui.AfcGuiLayer;
            
            if (this.disabled) {
                return true;
            }
            
            if (this._move) {
                let destination: GeoJSON.Point = {type: 'Point', coordinates: [latlng.lng, latlng.lat]};
                let close: boolean = true;
                
                info = this._move.info;
                if (this.options.onMoveEnd) {
                    close = this.options.onMoveEnd(this, destination, info);
                } else {
                    info.store.geometry = destination;
                    info.store.commit();
                }
                close && this.endMove();
            }
            else {
                gui = source && this.guiLayers.find(guiLayer => guiLayer === source.provider);
                if (gui) {
                    const layer = source.feature,
                        store = layer && this.parc.getStoreFromRow(layer.feature.properties.data);

                    info = store && { gui, layer, source, store };
                }
                if (!source === !info) {
                    this.options.click(this, latlng, info, event);
                } else {
                    return true;
                }
            }
            event && L.DomEvent.stopPropagation(event);
        }
    }
}