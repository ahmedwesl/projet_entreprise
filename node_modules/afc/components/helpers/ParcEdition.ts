/**
 * Created by jean.rennes on 02/08/2016.
 */
///<reference path="../models/dashboards/Dashboard.ts" />
///<reference path="../models/data/StoreSource.ts" />
///<reference path="../models/globals/TileVectorModel.ts" />
///<reference path="data.ts" />

namespace AFC.Tools.ParcEdition {
    interface IDBHistoryBranchBase extends AFC.Data.IDBHistoryBranchBase {
        properties: {
            code: string | number | Array<string | number>;
        };
    };

    interface IDBHistoryBranchRow extends IDBHistoryBranchBase {
        values: {[key: string]: any}[];
    };

    interface IDBHistoryBranch extends IDBHistoryBranchBase {
        events: AFC.Data.IModificationEvents;
    }

    interface IProjectBase extends AFC.Data.IDataItemStoreData {
        readonly id: string;
        readonly author: string;
        readonly creationDate: Date;
        readonly name: string;
        readonly description: string | null;
        readonly rating: number | null;
        readonly status: AFC.Data.HistoryBranchStatus | null;
        readonly store: AFC.Data.IReadonlyStore;
    }

    export interface IProjectInfo extends IProjectBase {
        load(): Promise<IProject>;
    }

    export interface IProject extends IProjectBase, AFC.Data.IStoreSourceProject, AFC.Tools.IObservable {
        readonly info: AFC.Data.IDBHistoryBranchInfo;
        description: string | null;
        rating: number | null;
        status: AFC.Data.HistoryBranchStatus | null;
        events: AFC.Data.IModificationEvents;
    }

    function _getRequiredColumns(definition: AFC.Data.IDBTableDefinition, additionalColumns: ReadonlyArray<string>): ReadonlyArray<AFC.Data.IDBColumnDefinition> {
        let all: boolean = definition.columns.every(column => !column.qualifiers);
        let geometry: boolean = false;

        return definition.columns.filter((column) => {
            return all || (!column.readOnly && column.qualifiers) || (!geometry && (geometry = Data.checkGeometryType(column, AFC.Data.DataKind.geometry))) || definition.primaryKey.some(name => name === column.name) || (additionalColumns && additionalColumns.some(name => name === column.name));
        });
    }

    function _getListOptions(columns: ReadonlyArray<AFC.Data.IDBColumnDefinition>, history: AFC.Data.IHistory, filters?: AFC.Data.IDBHistoryBranchesFilters): {
            dataSelector: AFC.Data.IDBHistoryDataSelector;
            filter?: AFC.Data.IDBHistoryBranchesFilters;
        } {
        let parameters: {
                dataSelector: AFC.Data.IDBHistoryDataSelector;
                filter?: AFC.Data.IDBHistoryBranchesFilters;
            } = {
                dataSelector: {
                    "columns": columns.map(column => column.name),
                    "fromProperties": "code"
                }
            };                
        history && (parameters.dataSelector.history = history);
        filters && (parameters.filter = filters);
        return parameters;
    }

    function _check(value: any): any {
        return value === void 0 ? null : value;
    }

    function _cast(column: AFC.Data.IDBColumnDefinition, value: any): any {
        if (value) {
            return column.type === AFC.Data.DataKind.date || column.type === AFC.Data.DataKind.time || column.type === AFC.Data.DataKind.timestamp ? new Date(value) : value;
        }
        return _check(value);
    }

    function _castAll(columns: ReadonlyArray<AFC.Data.IDBColumnDefinition>, data: AFC.Data.IModificationEventInfo): AFC.Data.IModificationEventInfo {
        let values = data.values;
        columns.forEach(column => values.hasOwnProperty(column.name) && (values[column.name] = _cast(column, values[column.name])));
        return data;
    }

    function _loadBranch(descriptor: AFC.Data.HistoricizedTableDescriptor, history: AFC.Data.IHistory, definition: AFC.Data.IDBTableDefinition, id: string): Promise<IDBHistoryBranch> {
        return descriptor.getBranchInfo(id, history).then(base => {
            let events: AFC.Data.IModificationEvents = {},
                branch = <IDBHistoryBranch><any>{...base};

            branch.events = events;
            base.events.forEach((e: AFC.Data.IDBHistoryEvent)=> { 
               switch(e.type) {
                   case AFC.Data.HistoryEventType.creation:
                       (events.creations || (events.creations = [])).push(_castAll(definition.columns, e.data));
                       break;
                   case AFC.Data.HistoryEventType.modification:
                       (events.modifications || (events.modifications = [])).push(_castAll(definition.columns, e.data));
                       break;
                   case AFC.Data.HistoryEventType.deletion:
                       (events.deletions || (events.deletions = [])).push(e.data.code);
                       break;
               }
            });
            return branch;
        });
    }

    interface IProjectChange {
        description?: string;
        rating?: number;
        status?: AFC.Data.HistoryBranchStatus;
    }

    class Project extends Tools.EventSink implements IProject {
        protected _status: AFC.Data.HistoryBranchStatus;
        public readonly descriptor: AFC.Data.HistoricizedTableDescriptor;
        public readonly id: string;
        public readonly author: string;
        public readonly creationDate: Date;
        public readonly name: string;
        public readonly key: any[];            
        public readonly store: AFC.Data.IReadonlyStore;
        public readonly info: AFC.Data.IDBHistoryBranchInfo;
        public readonly events: AFC.Data.IModificationEvents; /*** hidden, to be deleted when smart load implemented ***/

        constructor(branchBase: IDBHistoryBranchBase, descriptor: AFC.Data.HistoricizedTableDescriptor, store: AFC.Data.IReadonlyStore, events: AFC.Data.IModificationEvents, info?: AFC.Data.IDBHistoryBranchInfo) {
            let code: any = branchBase.properties.code;

            super();
            this.info = info || {properties: branchBase.properties};
            this.descriptor = descriptor;
            this.id = branchBase.id;
            this.author = branchBase.author;
            this.creationDate = branchBase.creationDate;
            this.name = branchBase.name || '';
            this.info.description = branchBase.description;
            this.info.rating = branchBase.rating;
            this._status = branchBase.status;
            this.key = code instanceof Array ? code : [code];
            this.store = store;
            this.events = events;
            this.on(Tools.EventType.UserEvent, this._onChange, this);
        }

        protected _onChange(event: IEvent): void {
            let data: IProjectChange[] = <any>event.data,
                i: number = data?.length,
                description = this.description,
                rating = this.rating,
                status = this.status,
                change: IProjectChange = {
                    description: description,
                    rating: rating,
                    status: status
                },
                values: {description?: string, rating?: number, status?: AFC.Data.HistoryBranchStatus} = {};

            if (i) {
                for (; i > 0; --i) {
                    $.extend(change, data[i - 1]);
                }
                if (description !== change.description) {
                    (values || (values = {})).description = description;
                }
                if (rating !== change.rating) {
                    (values || (values = {})).rating = rating;
                }
                if (status !== change.status) {
                    (values || (values = {})).status = status;
                }
                values && (this.descriptor.updateBranch(this.id, values), this.fireEvent(Tools.EventType.Dirty));
            }
        }

        public get description(): string | null {
            return this.info.description ?? null;
        }

        public set description(value: string | null) {
            this.fireEvent(Tools.EventType.UserEvent, [{
                description: this.description
            }]);
            this.info.description = value;
        }

        public get rating(): number | null {
            return this.info.rating ?? null;
        }

        public set rating(value: number | null) {
            this.fireEvent(Tools.EventType.UserEvent, [{
                rating: this.rating
            }]);
            this.info.rating = value;
        }                        

        public get status(): AFC.Data.HistoryBranchStatus | null {
            return this._status ?? null;
        }

        public set status(value: AFC.Data.HistoryBranchStatus | null) {
            this.fireEvent(Tools.EventType.UserEvent, [{
                status: this.status
            }]);
            this._status = value;
        }      
    }

    const _bookmark: string = "{6E79B3B3-123C-47B4-B82B-6FD4FB872362}",
        _name: string = "{E306FF9A-BD19-4614-8E4B-3DD3EF14DD68}",
        _author: string = "{0B253F86-2C75-4072-B690-A1791640D254}",
        _creationDate: string = "{FDE7E448-D4E7-4A92-8A1F-C582D8011903}",
        _rating: string = "{C411CF83-8FDE-46D5-BB38-C8D73904048E}",
        _description: string = "{EC9D92ED-41FE-49F3-81EC-1AFA24A0999B}",
        _status: string = "{154C0554-937C-4f8f-AC5B-0A1A289B644C}";

    import DBColumnDefinition = AFC.Data.DBColumnDefinition;

    function _getProjetTableParameters(storeColumns: ReadonlyArray<AFC.Data.IDBColumnDefinition>) {
        let columns: AFC.Data.IDBColumnDefinition[] = [
            <AFC.Data.IDBColumn>(new DBColumnDefinition(_bookmark, AFC.Data.DataKind.character, 0, 38, "id", true)),
            <AFC.Data.IDBColumn>(new DBColumnDefinition(_name, AFC.Data.DataKind.character, -1, 255, "name", true)),
            <AFC.Data.IDBColumn>(new DBColumnDefinition(_author, AFC.Data.DataKind.character, -1, 255, "author", true)),
            <AFC.Data.IDBColumn>(new DBColumnDefinition(_creationDate, AFC.Data.DataKind.time, -1, 38, "creation date", true)),
            <AFC.Data.IDBColumn>(new DBColumnDefinition(_rating, AFC.Data.DataKind.real, -1, 4, "rating")),
            <AFC.Data.IDBColumn>(new DBColumnDefinition(_description, AFC.Data.DataKind.character, -1, 255, "description")),
            <AFC.Data.IDBColumn>(new DBColumnDefinition(_status, AFC.Data.DataKind.integer, -1, 4, "status"))
        ];
        let key: number[] = [],
            offset = columns.length,
            geometry: number = -1;

        storeColumns.forEach(column => {
            if (column.index !== -1) {
                column = new AFC.Data.DBColumnDefinition(column.name, column.type, -1, column.size, column.alias, true, column.qualifiers, column.geographicalLevel, column.isSearchable);
                key.push(columns.length);
            } else if ((geometry === -1) && Data.checkGeometryType(column, AFC.Data.DataKind.point)) {
                geometry = columns.length;
            }
            columns.push(column);
        });
        return {
            key: key,
            offset: offset,
            columns: columns,
            primaryKey: <ReadonlyArray<string>>[_bookmark],
            geometry: geometry
        }
    }
    
    function _mapBranches(columns: ReadonlyArray<AFC.Data.IDBColumnDefinition>, offset: number, geometry: number, branches: ReadonlyArray<IDBHistoryBranchRow>): ReadonlyArray<any>[] {
        let values: ReadonlyArray<any>[] = [],
            geometryName  = columns[geometry].name;

        branches.forEach(branch => {
            if (branch.properties && branch.properties.code && branch.values.length) {
                let data: {[key: string]: any} = branch.values[0], column;

                if (data && Data.isValid(AFC.Data.DataKind.point, data[geometryName])) {
                    let row: any[] = [branch.id, _check(branch.name), _check(branch.author), _check(branch.creationDate), _check(branch.rating), _check(branch.description), _check(branch.status)];
                    for (let i = offset; i < columns.length; ++i)
                        row.push(_cast(column = columns[i], data[column.name]));
                    values.push(row);
                }
            }
        });
        return values;
    }
       
    interface IProjectInfoProvider {
        readonly descriptor: AFC.Data.HistoricizedTableDescriptor;
        readonly history: AFC.Data.IHistory;
        readonly content: AFC.Data.IStoreTableResourceContent;
        readonly key: ReadonlyArray<number>;
    }
    
    const _key = Symbol();
    
    class Store extends AFC.Data.ReadonlyStore {
        protected [_key]: ReadonlyArray<number>;

        constructor(provider: IProjectInfoProvider, values: ReadonlyArray<any>) {
            super(provider.content, values);
            this[_key] = provider.key;
        }
        
        public get key(): ReadonlyArray<any> {
            return this[_key].map((index: number) => this._values[index]);
        }
    };

    class ReadonlyProjectInfo implements IProjectInfo {
        protected readonly _provider: IProjectInfoProvider;
        protected readonly _values: ReadonlyArray<any>;
        protected _store: AFC.Data.IReadonlyStore;

        protected _getValue(column: string): any {
            return this._values[this._provider.content.columnIndex[column]];
        }

        constructor(provider: IProjectInfoProvider, values: ReadonlyArray<any>) {
            this._provider = provider;
            this._values = values;
        }

        public get id(): string {
            return this._getValue(_bookmark);
        }

        public get name(): string {
            return this._getValue(_name);
        }

        public get author(): string {
            return this._getValue(_author);
        }

        public get creationDate(): Date {
            return this._getValue(_creationDate);
        }

        public get rating(): number | null {
            return this._getValue(_rating);
        }

        public get description(): string | null {
            return this._getValue(_description);
        }

        public get status(): AFC.Data.HistoryBranchStatus | null {
            return this._getValue(_status);
        }

        public get key(): ReadonlyArray<any> {
            return [this.id];
        }

        public get store(): AFC.Data.IReadonlyStore {
            return this._store || (this._store = new Store(this._provider, this._values));
        }

        public async load(): Promise<IProject> {
            let descriptor = this._provider.descriptor,
                history = this._provider.history,
                definition = this._provider.content.definition,
                branch = await _loadBranch(descriptor, history, definition, this.id);
            return new Project(branch, descriptor, this.store, branch.events);
        }
    }
        
    class ProjectInfo extends ReadonlyProjectInfo {
        declare protected readonly _provider: ProjectsList;

        protected _setValue(column: string, value: any): any {
            let key: ReadonlyArray<any> = this._provider.getKeyFromRow(this._values),
                values: {[key: string]: any} = {
                    [column]: value
                };
            return this._provider.modify(key, values);
        }

        public get status(): AFC.Data.HistoryBranchStatus | null {
            return super.status;
        }

        public set status(value: AFC.Data.HistoryBranchStatus | null) {
            this._setValue(_status, value);
            this._provider.descriptor.updateBranch(this.id, {status: value});
        }
    }
  
    type IDataItemProject = AFC.Data.IDataItemContainer<IProjectInfo>;
    
    export interface IProjectSource extends AFC.Data.IReadonlyStoreSource {
        item(index: number): IDataItemProject;
    }

    export class ProjectsList extends AFC.Data.DataModel implements AFC.Data.IDataModel, IProjectInfoProvider, IProjectSource  {
        protected readonly _offset: number;
        public readonly descriptor: AFC.Data.HistoricizedTableDescriptor;
        public readonly history: AFC.Data.IHistory;
        public readonly content: AFC.Data.IStoreTableResourceContent;
        public readonly parameters: AFC.Data.IDataContainerChecker<AFC.Data.IReadonlyStore>;
        public readonly key: ReadonlyArray<number>;

        public check: (storeSource: AFC.Data.IReadonlyStoreSource, store: AFC.Data.IReadonlyStore, column: AFC.Data.IDBColumnDefinition, dirty: boolean, value: string, callback: (valid: boolean, message: Readonly<AFC.Data.ICheckMessage>)=> any)=> void;

        protected _check(store: AFC.Data.IReadonlyStore, column: AFC.Data.IDBColumnDefinition, dirty: boolean, value: string, callback: (valid: boolean, message?: Readonly<AFC.Data.ICheckMessage>)=> any): void {
            return this.check ? this.check(this, store, column, dirty, value, callback) : callback(true);
        }

        constructor(refContent: AFC.Data.IStoreTableResourceContent, storeColumns: ReadonlyArray<AFC.Data.IDBColumnDefinition>, branches: IDBHistoryBranchRow[]) {
            let parameters = _getProjetTableParameters(storeColumns),
                values: ReadonlyArray<any>[],
                firstGeometry: number;

            if (parameters.geometry !== -1) {
                firstGeometry = parameters.geometry;
                values = _mapBranches(parameters.columns, parameters.offset, firstGeometry, branches);
            }
            super(parameters.columns, parameters.primaryKey, values || []);
            this._offset =  parameters.offset;
            this.descriptor = <AFC.Data.HistoricizedTableDescriptor> refContent.descriptor;
            this.history = refContent.history;
            this.content = {
                definition: this,
                columnIndex: this.columnIndex,
                geometryIndice: firstGeometry,
                resource: refContent.resource,
                descriptor: refContent.descriptor,
                history: refContent.history
            };
            this.parameters = {
                check: this._check.bind(this)
            }
            this.key = parameters.key;
        }

        public get length(): number {
            return this.values.length;
        }
        
        public getRow(indice: number): ReadonlyArray<any> {
            return this.values[indice];
        }

        public get geometry(): AFC.Data.IDBColumnDefinition {
            return this.content && this.content.definition.columns[this.content.geometryIndice];
        }
        
        public hasQualifier(qualifier: AFC.Data.Qualifier): boolean {
            return this.content && (AFC.Data.findQualifier(this.content, qualifier, true) !== -1);
        }

        public getQualifiedColumn(qualifier: AFC.Data.Qualifier): AFC.Data.IDBColumnDefinition {
            return this.content && this.content.definition.columns[AFC.Data.findQualifier(this.content, qualifier, true)];
        }
        
        public get fullName(): string {
            return this.content && this.content.descriptor.fullName;
        }
        
        public item(index: number): IDataItemProject {
            return {
                dataItem: this.getProjectFromRow(this.values[index]),
                dataItemIndex: index
            };
        }

        public getProjectFromRow(row?: ReadonlyArray<any>): IProjectInfo & {readonly key: ReadonlyArray<any>;} | undefined {
            return row && new ProjectInfo(this, row);
        }
    };

    ProjectsList.prototype.create = null;                   // Not implemented
    ProjectsList.prototype.delete_ = null;                  // Not implemented

    function _getMetadata(dataSource: AFC.Data.ResourceLoader<AFC.Data.IStoreTableResourceContent>): Promise<AFC.Data.IStoreTableResourceContent> {
        return dataSource.getMetadata().then(content => content.descriptor.isHistoricized ? content : Promise.reject());
    }

    export function listProjects(dataSource: AFC.Data.StoreSource, filters?: AFC.Data.IDBHistoryBranchesFilters, additionalColumns?: ReadonlyArray<string>): Promise<ProjectsList> {
        return _getMetadata(dataSource).then(content => {
            let columns = _getRequiredColumns(content.definition, additionalColumns);
            return content.descriptor.selectBranches(_getListOptions(columns, content.history, filters)).then(branches => new ProjectsList(content, columns, <IDBHistoryBranchRow[]>branches));
        });
    }

    export async function createProject(dataSource: AFC.Application.DashboardParc, store: AFC.Data.Store): Promise<IProject> {
        const check: Promise<IDBHistoryBranchBase> = new Promise((resolve, reject) => store.check(valid => {
                let key: ReadonlyArray<any> = store.key,
                    info = {
                        properties: {
                            code: key.length === 1 ? key[0] : key
                        }
                    };
                    
                if (valid) {
                    dataSource.createBranch(info)
                        .then(branch => AFC.Data.Store.commit(store, key, dataSource.parameters, () => resolve(<IDBHistoryBranchBase>branch)))
                        .catch(reject);
                } else {
                    reject();
                }
            })),
            [base, content] = await Promise.all([check, _getMetadata(dataSource)]),
            project = new Project(base, content.descriptor, store, dataSource.generateEvents(), dataSource.branchInfo);
        return project;
    }

    export async function loadProject(dataSource: AFC.Data.ResourceLoader<AFC.Data.IStoreTableResourceContent>, id: string, store: AFC.Data.Store): Promise<IProject> {
        const content = await _getMetadata(dataSource),
            branch = await _loadBranch(content.descriptor, content.history, content.definition, id);
        return branch && new Project(branch, content.descriptor, store, branch.events);
    }

    export async function cloneProject(dataSource: AFC.Data.StoreSource, project: IProject): Promise<IProject> {
       const [base, content] = await Promise.all([dataSource.createBranch(project.info, project.events), _getMetadata(dataSource)]);
       return new Project(<IDBHistoryBranchBase>base, content.descriptor, dataSource.getStore(project.store.key), dataSource.generateEvents(), dataSource.branchInfo);
    }
    
    export class QueryParc extends AFC.Data.StoreSource {
        protected _command: AFC.Data.IQueryCommand;

        public static readonly tableToken: string = '{{table}}';
        public static readonly brandToken: string = '{{brand}}';

        protected _load(content: AFC.Data.ITableResourceContent): Promise<AFC.Data.IDataTable> {
            if (this._command) {
                let restModel: Rest.RestModel = content.descriptor.database.schema.restModel;
                let brand: string;
                let command: AFC.Data.IQueryCommand = {
                    commandText: this._command.commandText.replace(new RegExp(`\\B${QueryParc.tableToken}\\B`, 'g'), content.resource).replace(new RegExp(`\\B${QueryParc.brandToken}\\B`, 'g'), (substring: string, ...args: any[])=> {
                        if (brand === void 0) {
                            brand = this.getQualifiedColumn(AFC.Data.Qualifier.brand).name;
                        }
                        return brand;
                    })
                };
                this._command.maximumRows && (command.maximumRows = this._command.maximumRows);
                this._command.parameters && (command.parameters = this._command.parameters);
                return new AFC.Data.Queries(restModel).getDataTable([command]).then((queries: AFC.Data.IDataTable[])=> queries[0]);
            }
        }

        public loadData(command: AFC.Data.IQueryCommand, project?: AFC.Data.IStoreSourceProject): Promise<boolean> {
            this._command = command;
            return this.init(project);
        }
    }
    
    class ProjectTileProvider implements Globals.ITileLayerProvider {
        private readonly _offset: number;
        private readonly _filter: AFC.Data.IDBHistoryBranchesFilter;
        private readonly _options: {filter?: AFC.Data.IDBHistoryBranchesFilters, dataSelector: AFC.Data.IDBHistoryDataSelector};
        public readonly content: AFC.Data.IStoreTableResourceContent;
        public readonly key: ReadonlyArray<number>;
        
        constructor(content: AFC.Data.ITableResourceContent, parameters: ReturnType<typeof _getProjetTableParameters>, columns: ReadonlyArray<AFC.Data.IDBColumnDefinition>) {
            let descriptor = <AFC.Data.HistoricizedTableDescriptor>content.descriptor;
            
            if (descriptor.isHistoricized) {
                let definition: Readonly<AFC.Data.IDBTableDefinition> = {
                    columns: parameters.columns,
                    primaryKey: parameters.primaryKey
                };
                
                this._offset = parameters.offset;
                this._options = _getListOptions(columns, content.history, this._filter = {});
                this.content = {
                    resource: null,
                    descriptor: descriptor,
                    definition: definition,
                    geometryIndice: parameters.geometry,
                    columnIndex: AFC.Data.getColumnIndex(definition.columns)
                };
                this.key = parameters.key;
            }
        }
/*        
        public set filters(value: AFC.Data.IDBHistoryBranchesFilter & {proximity: never}) {
            not implemented yet
        }
*/        
        public requestTiles(layer: Globals.ITileLayer, tiles: ReadonlyArray<string>, callback: (tiles: ReadonlyArray<string>, rows: ReadonlyArray<any>[])=> any): void {
            let bounds = layer.getBoundsFromKeys(tiles),
                center = bounds.getCenter(),
                refPoint = center.lat > 0 ? bounds.getSouthWest() : bounds.getNorthEast();   // roughly !
            
            this._filter.proximity = {
                location: [center.lng, center.lat],
                distance: Math.ceil(center.distanceTo(refPoint))
            }
            this.content.descriptor.selectBranches(this._options).then((branches: IDBHistoryBranchRow[]) => callback(tiles, _mapBranches(this.content.definition.columns, this._offset, this.content.geometryIndice, branches)));
        }
    }

    export class ProjectTileVectorModel extends AFC.Data.readOnlyStoreSourceMixin(Globals.TileVectorModel<Globals.LayerType.symbol, ProjectTileProvider>) implements IProjectInfoProvider, IProjectSource {
        public readonly descriptor: AFC.Data.HistoricizedTableDescriptor;
        public readonly history: AFC.Data.IHistory;
        public readonly key: ReadonlyArray<number>;
        
        constructor(content: AFC.Data.IStoreTableResourceContent, additionalColumns?: ReadonlyArray<string>) {
            const columns = _getRequiredColumns(content.definition, additionalColumns),
                parameters = _getProjetTableParameters(columns),
                provider = new ProjectTileProvider(content, parameters, columns),
                name = `{${AFC.Tools.Data.generateRndString(20)}}`;
             
            super({
                provider,
                name,
                geometryIndice: parameters.geometry,
                columns: parameters.columns,
                primaryKey: parameters.primaryKey,
                content: provider.content
            });
            this.descriptor = content.descriptor;
            this.history = content.history;
            this.key = provider.key;
        }

        public item(index: number): IDataItemProject {
            const row = this.getRow(index);
            return row && {
                dataItem: this.getProjectFromRow(row),
                dataItemIndex: index
            };
        }

        public getProjectFromRow(row?: ReadonlyArray<any>): IProjectInfo & {readonly key: ReadonlyArray<any>;} | undefined {
            return row && new ReadonlyProjectInfo(this, row);
        }
    }
}