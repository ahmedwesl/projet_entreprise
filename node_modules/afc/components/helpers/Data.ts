/**
 * Created by jean.rennes on 03/02/2016.
 */
///<reference path="../AFC.ts" />
///<reference path="../models/data/Global.ts" />

namespace AFC.Tools.Data {
    import IDBColumn = AFC.Data.IDBColumn;

    export function checkGeometryType(column: AFC.Data.IDBColumn, geometryType: AFC.Data.DataKind): boolean {
        return (column.type & geometryType) === column.type;
    }

    export function findFirstGeometry(data: AFC.Data.IDBTableDefinition | ReadonlyArray<AFC.Data.IDBColumn>, geometryType: AFC.Data.DataKind = AFC.Data.DataKind.geometry): number {
        let columns: ReadonlyArray<AFC.Data.IDBColumn> = data && (data instanceof Array ? data : (<AFC.Data.IDBTableDefinition>data).columns);

        if (columns) {
            for (let i = 0, iCount = columns.length; i < iCount; ++i) {
                if (checkGeometryType(columns[i], geometryType)) {
                    return i;
                }
            }
        }
    }

    declare function rng_get_byte(): number;
    declare function rng_get_bytes(bytes: any): void;

    var rndGenerator: { [key: number]: (l: number) => any } = {};

    let g_zbase32: string = 'ybndrfg8ejkmcpqxot1uwisza345h769';

    rndGenerator[AFC.Data.DataKind.character] = (l: number) => {
        let size: number = Math.ceil((l * 5) / 8);
        let b: ArrayBuffer = new ArrayBuffer(size);
        let a: { [key: number]: number } = new Uint8Array(b);
        let rules: any[] = [{ o: 0, d: 11 }, { o: 0, d: 6 }, { o: 0, d: 1 }, { o: 1, d: 4 }, { o: 2, d: 7 }, { o: 2, d: 2 }, { o: 3, d: 5 }, { o: 3, d: 0 }];
        let rule: any, c: number, pos: number;
        let s: string = '';

        rng_get_bytes(a);
        for (let i: number = 0; i < l; ++i) {
            rule = rules[i % 8];
            pos = Math.floor(i / 8) * 5 + rule.o;
            c = (((a[pos] << 8) + a[pos + 1]) >> rule.d) & 0x1F;
            s += g_zbase32.charAt(c & 0x1F);
        }
        return s;
    };

    rndGenerator[AFC.Data.DataKind.real] = (l: number) => {
        let b: ArrayBuffer;
        let a: { [key: number]: number };

        if (l === 4) {
            b = new ArrayBuffer(4);
            a = new Float32Array(b);
        } else {
            b = new ArrayBuffer(8);
            a = new Float64Array(b);
        }
        rng_get_bytes(new Uint8Array(b));
        return a[0];
    };

    rndGenerator[AFC.Data.DataKind.integer] = (l: number) => {
        let a: Uint8Array = new Uint8Array(l || 4);
        let ret: number = 0;

        rng_get_bytes(a);
        a.forEach((i: number) => ret = (ret * 0xFF) + i);
        return ret;
    };

    rndGenerator[AFC.Data.DataKind.bool] = (l: number) => {
        return !(rng_get_byte() & 1);
    };

    export var generateRndString: (l: number) => string = rndGenerator[AFC.Data.DataKind.character];

    export function generateRndValue(column: IDBColumn): any {
        let f: (l: number) => any = rndGenerator[column.type];
        return f(Math.min(column.size, 32));
    }

    export function getKeyColumns(data: AFC.Data.IDataTable): IDBColumn[] {
        let pK: ReadonlyArray<string> = data.primaryKey;
        let pKL: number = pK.length;
        let kC: IDBColumn[] = [];

        if (pKL > 0) {
            let cs: ReadonlyArray<IDBColumn> = data.columns;
            let i: { [key: string]: IDBColumn };
            let s: string = pK[0];

            for (let c of cs) {
                if (c.name === s) {
                    kC.push(c);
                    if (pK.length === 1)
                        return kC;
                }
                i[c.name] = c;
            }

            for (let j: number = 1; j < pKL; ++j) {
                kC.push(i[s]);
            }
        }
        return kC;
    }

    export function isString(value: any): boolean {
        return typeof value === 'string' || value instanceof String;
    }

    export function isNumber(value: any) {
        return typeof value === 'number' && isFinite(value);
    }

    function isData(value: any) {
        return value instanceof Date;
    }

    function isValidCoordinates(coordinates: GeoJSON.Position): boolean {
        return valid[AFC.Data.DataKind.real](coordinates[0]) && valid[AFC.Data.DataKind.real](coordinates[1]);
    }

    const valid: { readonly [key: number]: (value: any) => boolean } = {
        [AFC.Data.DataKind.character]: isString,
        [AFC.Data.DataKind.real]: isNumber,
        [AFC.Data.DataKind.integer]: (value: any) => isNumber(value) && (Math.round(value) === value),
        [AFC.Data.DataKind.bool]: (value: any) => typeof value === 'boolean',
        [AFC.Data.DataKind.date]: isData,
        [AFC.Data.DataKind.timestamp]: isData,
        [AFC.Data.DataKind.time]: isData,
        [AFC.Data.DataKind.point]: (value: GeoJSON.Point) => {
            let coordinates: GeoJSON.Position;
            return (value &&
                (coordinates = value.coordinates) &&
                (value.type === 'Point')) && isValidCoordinates(coordinates);
        },
        [AFC.Data.DataKind.polygon]: (value: GeoJSON.Polygon | GeoJSON.MultiPolygon) => value && value.coordinates && ((value.type === 'Polygon') || (value.type === 'MultiPolygon'))
    }

    export function isValid(kind: AFC.Data.DataKind, value: any): boolean {
        let f: (value: any) => any;
        return (value === null) || !(f = valid[kind]) || f(value);
    }

    export function isValidKey(keyProvider: AFC.Data.IKeyProvider & AFC.Data.IColumnIndexProvider, value: any): boolean {
        return value && keyProvider.primaryKey.every((name, indice) => {
            let f, column = keyProvider.columns[keyProvider.columnIndex[name]];
            return value[indice] === null ? column.nullable : (f = valid[column.type]) && f(value[indice]);
        });
    }

    export function equalValue(kind: AFC.Data.DataKind, v0: any, v1: any): boolean {
        switch(kind) {
            case AFC.Data.DataKind.rectangle:
            case AFC.Data.DataKind.line:
            case AFC.Data.DataKind.polygon:
                return true;
            case AFC.Data.DataKind.point:
                return Geometry.equalPoint(v0, v1);
        }
        return v0 === v1;
    }

    export function splitSQLName(n: string): { dbName: string; name: string; } {
        if (n) {
            let a: string[] = n.match(/[^\[\]]+/gi);
            if (a) {
                if (a.length === 3 && a[1] === '.')
                    return { name: a[2] || '', dbName: a[0] };
                n = a[0];
            }
            return n && { name: n || '', dbName: '' };
        }
    }

    export function makeSQLName(dbName: string, name: string): string {
        return dbName ? `[${dbName}].[${name}]` : `[${name}]`;
    }


    export async function getSQLNameParts(schema: AFC.Data.SchemaDescriptor, tableName: string): Promise<{ dbName: string; name: string; }> {
        let parts = Tools.Data.splitSQLName(tableName);

        if (parts?.name) {
            if (!parts.dbName) {
                let collator = new Intl.Collator('en', { sensitivity: 'base' }),
                    min: number = Number.MAX_SAFE_INTEGER;

                await schema.getDatabases().then(async (databases: ReadonlyArray<AFC.Data.DatabaseDescriptor>) => {
                    await Promise.all(databases.map((database, indice) => database.getTables().then(tables => {
                        let table;

                        if (!parts.dbName && indice < min && (table = tables.find(table => table.name === parts.name || table.alias === parts.name))) {
                            parts.dbName = database.id;
                        }

                    })));
                });
            }
            return parts;
        }
    }

    export async function normalizeSQLName(schema: AFC.Data.SchemaDescriptor, tableName: string): Promise<string> {
        let { dbName, name } = await getSQLNameParts(schema, tableName) || {};
        return dbName && makeSQLName(dbName, name);
    }

    export function sort(dataModel: AFC.Data.IDataModel, columns: string[]): ReadonlyArray<any>[] {
        let index: AFC.Data.Index = new AFC.Data.Index(columns.map(name => Tools.indexOf(dataModel.columns, (column: IDBColumn) => column.name === name)), dataModel.values);
        return index.values;
    }

    export function mapRow(columns: ReadonlyArray<AFC.Data.IDBColumn>, row: ReadonlyArray<any>): { [key: string]: any } {
        let value: { [key: string]: any } = {};
        columns.forEach((column: AFC.Data.IDBColumn, indice: number) => { value[column.name] = value[column.alias] = row[indice]; });
        return value;
    }

    export function toInteger(s: string, defaultValue?: number): number {
        let i = parseInt(s);

        //true => 1 / false => 0
        if (isNaN(i))
            i = Number(s);
        return isNaN(i) ? defaultValue : i;
    }

    export function toFloat(s: string, defaultValue?: number): number {
        let i = parseFloat(s);
        return isNaN(i) ? defaultValue : i;
    }

    export function toBoolean(s: string): boolean {
        return !!s;
    }

    const _casts: { [key: number]: (value: any) => any } = {
        [AFC.Data.DataKind.real]: AFC.Tools.Data.toFloat,
        [AFC.Data.DataKind.integer]: AFC.Tools.Data.toInteger,
        [AFC.Data.DataKind.bool]: AFC.Tools.Data.toBoolean,
        [AFC.Data.DataKind.date]: (value: string) => new Date(value + "T00:00")
    };

    export function castInputValue(column: AFC.Data.IDBColumn, value: string | boolean): any {
        let cast, ret;
        return value === '' ?
            null :
            (
                cast = _casts[column.type],
                ret = cast && cast(value),
                ret === void 0 ? value : ret
            );
    }

    const _numeric = 'numeric',
        _geometry = 'geometry';

    export const QueryTemplateParameters = {
        [AFC.Data.DataKind.character]: 'text',
        [AFC.Data.DataKind.real]: _numeric,
        [AFC.Data.DataKind.integer]: _numeric,
        [AFC.Data.DataKind.bool]: 'boolean',
        [AFC.Data.DataKind.date]: 'date',
        /*time,
        timestamp,
        currency,
        blob,
        dynamic,
        formula,*/
        [AFC.Data.DataKind.point]: _geometry,
        [AFC.Data.DataKind.line]: _geometry,
        [AFC.Data.DataKind.polygon]: _geometry,
        [AFC.Data.DataKind.geometry]: _geometry
    };

    interface ITableComponent {
        key: ReadonlyArray<any>,
        row: ReadonlyArray<any>
    }

    class TableIterator implements Iterator<ITableComponent> {
        public readonly reader: TableReader;
        private _i: number;
        private _key: ReadonlyArray<any>;
        private _iEx: number;
        private _keyEx: ReadonlyArray<any>;

        private _next(): ITableComponent {
            let reader = this.reader,
                component: ITableComponent = this._key && {
                    key: this._key,
                    row: reader.getRow(this._i)
                };
            this._key = reader.getKey(++this._i);
            return component;
        }

        private _nextEx(): ITableComponent {
            let reader = this.reader,
                component: ITableComponent = this._keyEx && {
                    key: this._keyEx,
                    row: reader.getRowEx(this._iEx)
                };
            this._keyEx = reader.getKeyEx(++this._iEx);
            return component;
        }

        private _merge(component0: ITableComponent, component1: ITableComponent): void {
            component0.row.forEach((value, indice) => this.reader.index[indice] === void 0 && ((<Mutable<any[]>>component0.row)[indice] = component1.row[indice]));
        }

        constructor(reader: TableReader) {
            this.reader = reader;
            this._i = this._iEx = -1;
            this._next();
            this._nextEx();
        }

        public next() {
            let next = this._key || this._keyEx,
                component: ITableComponent,
                diff = 1;

            if (next) {
                !this._keyEx || (this._key && ((diff = AFC.Data.compareKey(this._key, this._keyEx)) <= 0)) ?
                    (component = this._next(), diff || this._merge(component, this._nextEx())) :
                    component = this._nextEx();
            }
            return {
                done: !next,
                value: component
            };
        }
    }

    interface IDataTemplate {
        readonly columns: ReadonlyArray<IDBColumn>;
        readonly primaryKey: ReadonlyArray<string>;
        readonly columnIndex: { [key: string]: number; };
    }

    class PartReader {
        public readonly values: ReadonlyArray<ReadonlyArray<any>>;
        public readonly key: ReadonlyArray<number>;
        public readonly index: ReadonlyArray<number>;

        constructor(dataModel: IDataTemplate, key: ReadonlyArray<number>, part: AFC.Data.IDataModelBase) {
            let indexEx = this.index = dataModel.columns.map(column => part.columnIndex[column.name]);
            this.values = (new AFC.Data.UniqueIndex(this.key = key.map(indice => indexEx[indice]), part.values)).values;
        }

        public getKey(i: number): ReadonlyArray<any> {
            let row: ReadonlyArray<any> = this.values && this.values[i];
            return row && this.key.map(indice => row[indice]);
        }

        public getRow(i: number): ReadonlyArray<any> {
            let row: ReadonlyArray<any> = this.values && this.values[i];
            return row && this.index.map(indice => indice === void 0 ? null : row[indice]);
        }
    }

    export class TableReader extends PartReader implements Iterable<ITableComponent> {
        public readonly readerEx: PartReader;

        constructor(dataModel: IDataTemplate, dataModel0: AFC.Data.IDataModelBase, dataModel1: AFC.Data.IDataModelBase) {
            let key: number[] = dataModel.primaryKey.map(name => dataModel.columnIndex[name]);

            super(dataModel, key, dataModel0);
            dataModel1 && (this.readerEx = new PartReader(dataModel, key, dataModel1));
        }

        public getKeyEx(i: number): ReadonlyArray<any> {
            return this.readerEx && this.readerEx.getKey(i);
        }

        public getRowEx(i: number): ReadonlyArray<any> {
            return this.readerEx && this.readerEx.getRow(i);
        }

        public [Symbol.iterator]() {
            return new TableIterator(this);
        }
    }

    export function mergeTables(dataModel0: AFC.Data.IDataModelBase, dataModel1?: AFC.Data.IDataModelBase, dataModel?: IDataTemplate): AFC.Data.DataModel {
        dataModel = dataModel || (dataModel0.primaryKey && <IDataTemplate>dataModel0);
        if (dataModel) {
            let reader = new TableReader(dataModel, dataModel0, dataModel1),
                values: ReadonlyArray<any>[] = [],
                component;

            for (component of reader) {
                values.push(component.row);
            }
            return new AFC.Data.DataModel(dataModel.columns, dataModel.primaryKey, values);
        }
    }
}