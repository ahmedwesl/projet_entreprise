/**
 * Created by jean.rennes on 08/04/2016.
 */
///<reference path="../models/data/Global.ts" />
///<reference path="../models/globals/Global.ts" />


namespace AFC.Tools.Cartographer {
    const _byPass = <Gin, Gout = Gin>(geometry: Gin): Gout => <any>geometry;

    const _concat = <T>(a: T[], b: T[]): void => {
        b.forEach((item: T) => {a.push(item);});
    };
        
    const _polygonConcats: {[key: string]: (coordinates: GeoJSON.Position[][][], geometry: GeoJSON.Geometry) => void } = {
        Polygon: (coordinates: GeoJSON.Position[][][], geometry: GeoJSON.Polygon)=> {
            coordinates.push(geometry.coordinates);
        },
        MultiPolygon: (coordinates: GeoJSON.Position[][][], geometry: GeoJSON.MultiPolygon)=> {
            _concat(coordinates, geometry.coordinates);
        },
        GeometryCollection: (coordinates: GeoJSON.Position[][][], geometry: GeoJSON.GeometryCollection) => {
            geometry.geometries.forEach(geometry => {
                let concat = geometry && _polygonConcats[geometry.type];
                concat && concat(coordinates, geometry);
            });
        }
    }
    
    const _polygonConverters: {[key: string]: (geometry: GeoJSON.Geometry) => GeoJSON.Polygon | GeoJSON.MultiPolygon } = {
        Polygon: _byPass,
        MultiPolygon: _byPass,
        GeometryCollection: (geometry: GeoJSON.GeometryCollection) => {
            let coordinates: GeoJSON.Position[][][] = [];
            _polygonConcats.GeometryCollection(coordinates, geometry);
            if (coordinates.length) {
               return coordinates.length > 1 ? {
                   type: 'MultiPolygon',
                   coordinates: coordinates
               } : {
                   type: 'Polygon',
                   coordinates: coordinates[0]
               };
            }
        }
    }
    
    function _buildLineString(coordinates: GeoJSON.Position[][]): GeoJSON.LineString | GeoJSON.MultiLineString {
        if (coordinates.length) {
            return coordinates.length > 1 ? {
                type: 'MultiLineString',
                coordinates: coordinates
            } : {
                type: 'LineString',
                coordinates: coordinates[0]
            };
        }
    }
    
    const _lineConcats: {[key: string]: (coordinates: GeoJSON.Position[][], geometry: GeoJSON.Geometry) => void } = {
        LineString: (coordinates: GeoJSON.Position[][], geometry: GeoJSON.LineString)=> {
            coordinates.push(geometry.coordinates);
        },
        MultiLineString: (coordinates: GeoJSON.Position[][], geometry: GeoJSON.MultiLineString)=> {
            _concat(coordinates, geometry.coordinates);
        },
        Polygon: (coordinates: GeoJSON.Position[][], geometry: GeoJSON.Polygon)=> {
            _concat(coordinates, geometry.coordinates);
        },
        MultiPolygon: (coordinates: GeoJSON.Position[][], geometry: GeoJSON.MultiPolygon)=> {
            geometry.coordinates.forEach(item => _concat(coordinates, item));
        },
        GeometryCollection: (coordinates: GeoJSON.Position[][], geometry: GeoJSON.GeometryCollection) => {
            geometry.geometries.forEach(geometry => {
                let concat = geometry && _lineConcats[geometry.type];
                concat && concat(coordinates, geometry);
            });
        }
    }
    
    const _lineConverters: {[key: string]: (geometry: GeoJSON.Geometry) => GeoJSON.LineString | GeoJSON.MultiLineString } = {
        LineString: _byPass,
        MultiLineString: _byPass,
        Polygon: (geometry: GeoJSON.Polygon) => _buildLineString(geometry.coordinates),
        MultiPolygon: (geometry: GeoJSON.MultiPolygon) => {
            let coordinates: GeoJSON.Position[][] = [];    
            _lineConcats.MultiPolygon(coordinates, geometry);       
            return _buildLineString(coordinates);
        },
        GeometryCollection: (geometry: GeoJSON.GeometryCollection) => {
            let coordinates: GeoJSON.Position[][] = [];
            _lineConcats.GeometryCollection(coordinates, geometry);
            return _buildLineString(coordinates);
        }
    }
    
    const _converters: {[key: number]: (geometry: GeoJSON.Geometry) => GeoJSON.Geometry|void } = {
        [Globals.LayerType.polygon]: (geometry: GeoJSON.Geometry) => geometry && _polygonConverters[geometry.type] && _polygonConverters[geometry.type](geometry),
        [Globals.LayerType.line]: (geometry: GeoJSON.Geometry)=> geometry && _lineConverters[geometry.type] && _lineConverters[geometry.type](geometry),
        [Globals.LayerType.symbol]: Geometry.getCentroid
     }
     
    export function getRowConverter<K extends keyof Globals.GeometryForLayerType, G extends GeoJSON.Geometry = Globals.GeometryForLayerType[K]>(layerType: K, iGeometry: number): (row: ReadonlyArray<any>)=> G  {
        let f: (geometry: GeoJSON.Geometry) => G = <any>_converters[layerType];
        return f ? (row: ReadonlyArray<any>)=> f(row[iGeometry]) : <any>(()=>{});
    }
            
    export function feature<G extends GeoJSON.Geometry = GeoJSON.Geometry, P extends Globals.IGeoJsonProperties = Globals.IGeoJsonProperties>(geometry: G, properties: P): GeoJSON.Feature<G, P> {
        return {
            type: 'Feature',
            geometry: geometry,
            properties: properties
        };
    }
    
    export function getGeoJSONFromCollection(collection: AFC.Data.IRowCollection, iGeometry: number, layerType: Globals.LayerType, options?: Globals.IConverterOptions): GeoJSON.GeoJsonObject {
        let geometries: Globals.GeoJSONFeature[] = [];
        let bbox: Tools.Geometry.Rectangle;
        let converter = getRowConverter(layerType, iGeometry);
        
        for (let i = 0, iCount = collection.length; i < iCount; ++i) {
            let row = collection.getRow(i);
            
            if (!options || !options.allow || options.allow(row)) {
                let geometry = converter(row);

                if (geometry) {
                    if (!options || !options.toBBox || options.toBBox(row)) {
                        let rect: Tools.Geometry.Rectangle = Tools.Geometry.getBoundRect(geometry);
                        Tools.Geometry.inflateRectWithRect(bbox || (bbox = [180, 90, -180, -90]), rect);
                    }
                    geometries.push(feature(geometry, {data: row}));
                }
            }
        }
        let json: GeoJSON.FeatureCollection<GeoJSON.GeometryObject, Globals.IGeoJsonProperties> = {
            bbox: bbox,
            type: 'FeatureCollection',
            features: geometries
        };
        return json;
    }
}