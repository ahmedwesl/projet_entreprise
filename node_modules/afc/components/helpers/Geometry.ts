/**
 * Created by jean.rennes on 03/02/2016.
 */
///<reference path="../AFC.ts" />

namespace AFC.Tools.Geometry {
    export type Rectangle = [number, number, number, number];

    function _inflate(geoJsonObject: GeoJSON.GeoJsonObject, bbox: Rectangle): boolean {
        let inflater: (geometry: GeoJSON.GeoJsonObject, bbox: Rectangle)=> void;
        return geoJsonObject && (inflater = _inflaters[geoJsonObject.type]) && (inflater(geoJsonObject, bbox), true);
    }
            
    const _inflaters: { [key: string]: (geometry: GeoJSON.GeoJsonObject, bbox: Rectangle)=> void} = {
        Point: (geometry: GeoJSON.Point, bbox: Rectangle) => inflateRect(bbox, geometry.coordinates),
        LineString: (geometry: GeoJSON.LineString, bbox: Rectangle) => geometry.coordinates.forEach(item=> inflateRect(bbox, item)),
        Polygon: (geometry: GeoJSON.Polygon, bbox: Rectangle) => geometry.coordinates[0].forEach(item=> inflateRect(bbox, item)),
        MultiPoint: (geometry: GeoJSON.MultiPoint, bbox: Rectangle) => geometry.coordinates.forEach(item=> inflateRect(bbox, item)),
        MultiLineString: (geometry: GeoJSON.MultiLineString, bbox: Rectangle) => geometry.coordinates.forEach(item=> item.forEach(item => inflateRect(bbox, item))),
        MultiPolygon: (geometry: GeoJSON.MultiPolygon, bbox: Rectangle) => geometry.coordinates.forEach(item=> item[0].forEach(item => inflateRect(bbox, item))),
        GeometryCollection: (geometry: GeoJSON.GeometryCollection, bbox: Rectangle) => geometry.geometries.forEach((item: GeoJSON.GeometryObject)=> _inflate(item, bbox)),
        Feature: (feature: GeoJSON.Feature, bbox: Rectangle)=> _inflate(feature.geometry, bbox),
        FeatureCollection: (featureCollection: GeoJSON.FeatureCollection, bbox: Rectangle)=> featureCollection.features.forEach((item: GeoJSON.Feature)=> _inflate(item, bbox))
    };
               
    export function inflateRect(bbox: Rectangle, position: GeoJSON.Position): void {
        bbox[0] = Math.min(bbox[0], position[0]); 
        bbox[1] = Math.min(bbox[1], position[1]); 
        bbox[2] = Math.max(bbox[2], position[0]); 
        bbox[3] = Math.max(bbox[3], position[1]); 
    }

    export function inflateRectWithRect(bbox0: Rectangle, bbox1: Rectangle): void {
        bbox0[0] = Math.min(bbox0[0], bbox1[0]); 
        bbox0[1] = Math.min(bbox0[1], bbox1[1]); 
        bbox0[2] = Math.max(bbox0[2], bbox1[2]); 
        bbox0[3] = Math.max(bbox0[3], bbox1[3]); 
    }

    export function getBoundRect(geometry: GeoJSON.GeoJsonObject): Rectangle {
        let rect: Rectangle = [180, 90, -180, -90];

        if (_inflate(geometry, rect) && rect[0] !== 180) {
            return rect;
        }
    }
    
    export function equalPoint(g0: GeoJSON.Point, g1: GeoJSON.Point): boolean {
        return (g0 === g1) || (g0 && g1 && _pointEqual(g0.coordinates, g1.coordinates));
    }
    
    export function makePoint(x: number, y: number): GeoJSON.Point {
        return {
            type: "Point",
            coordinates: [x, y]
        };
    } 
    
    function _getLength(positions: GeoJSON.Position[], lengths: number[]): number {
        let length: number = 0;
        for (let i = 1; i < positions.length; ++i) {
            lengths.push(length += Math.sqrt(Math.pow(positions[i][0] - positions[i - 1][0], 2) + Math.pow(positions[i][1] - positions[i - 1][1], 2)));
        }
        return length;
    }
            
    function _getLineCentroid(positions: GeoJSON.Position[], lengths: number[], length: number): GeoJSON.Point {
        if (length === 0) {
            return makePoint(positions[0][0], positions[0][1]);            
        }
        let i = Tools.lower_bound(lengths, length),
            ratio = (lengths[i] - length) / (lengths[i] - (lengths[i - 1] || 0)),
            end: GeoJSON.Position = positions[i];
        return makePoint(
            end[0] - ratio * (end[0] - positions[i - 1][0]),
            end[1] - ratio * (end[1] - positions[i - 1][1])
        );
    }
    
    function _getCentroid(ring: ReadonlyArray<GeoJSON.Position>, point: {x: number; y: number; w: number;}): void {
	let x: number, y: number, w: number;
        
        for (let i = 1; i < ring.length; ++i) {
            x = (ring[i][0] + ring[i-1][0])/2;
            y = (ring[i][1] + ring[i-1][1])/2;
            w = Math.abs((ring[i][1] + ring[i-1][1])*(ring[i][0] - ring[i-1][0])/2);
            point.x += x * w;
            point.y += y * w;
            point.w += w;
        }
    }

    function _nearest(pt: GeoJSON.Position, ring: ReadonlyArray<GeoJSON.Position>): GeoJSON.Position {
        let distance: number = Number.MAX_SAFE_INTEGER, position: number = -1, local: number;
        
        ring.forEach((point, indice)=> {
            local = Math.pow(point[0] - pt[0], 2) + Math.pow(point[1] - pt[1], 2);
            if (local < distance) {
                distance = local;
                position = indice;
            }
        });
        return position === -1 ? pt : ring[position];
    }

    function _checkCentroid(rings: ReadonlyArray<ReadonlyArray<GeoJSON.Position>>, point: {readonly x: number; readonly y: number; readonly w: number;}): GeoJSON.Point {
        let pt: GeoJSON.Position = [point.x / point.w, point.y / point.w];
        if (_pointInRing(pt, rings[0])) {
            for (let i = 1; i < rings.length; ++i) {
                if (_pointInRing(pt, rings[i])) {
                    pt = _nearest(pt, rings[i]);
                    break;
                }
            }
        } else {
            pt = _nearest(pt, rings[0]);
        }
        return makePoint(pt[0], pt[1]);
    }
    
    const centroids: {    [key: string]: (geometry: GeoJSON.Geometry)=> GeoJSON.Point;   } = {
        Point: function(geometry: GeoJSON.Point): GeoJSON.Point {
            return geometry;
        },
        MultiPoint: function(geometry: GeoJSON.MultiPoint): GeoJSON.Point {
            let position: GeoJSON.Position = geometry.coordinates[0];
            return position && makePoint(position[0], position[1]);
        },
        LineString: function(geometry: GeoJSON.LineString): GeoJSON.Point {
            let positions: GeoJSON.Position[] = geometry.coordinates;

            if (positions.length > 0) {
                let lengths: number[] = [], length: number = _getLength(positions, lengths);
                return _getLineCentroid(positions, lengths, length);
            }
        },
        MultiLineString: function(geometry: GeoJSON.MultiLineString): GeoJSON.Point {
            let positions: GeoJSON.Position[][] = geometry.coordinates,
                current: number = -1,
                currents: number[],
                pos: number;

            if (positions.length > 0) {
                for (let i = 0; i < positions.length; ++i) {
                    let locs: number[] = [];
                    let loc = _getLength(positions[i], locs);
                    if (loc > current) {
                        current = loc;
                        currents = locs;
                        pos = i;
                    }
                }
                return _getLineCentroid(positions[pos], currents, current);
            }                        
        },
        Polygon: function(geometry: GeoJSON.Polygon): GeoJSON.Point {
            let point = {x: 0, y: 0, w: 0};
            _getCentroid(geometry.coordinates[0], point);
            return _checkCentroid(geometry.coordinates, point);
        },
        MultiPolygon: function(geometry: GeoJSON.MultiPolygon): GeoJSON.Point {
            let positions: GeoJSON.Position[][][] = geometry.coordinates,
                maxArea: number = -1,
                pos: number;
            
            for (let i = 0; i < positions.length; ++i) {
               let rect: Rectangle = [180, 90, -180, -90];
               positions[i][0].forEach(item => inflateRect(rect, item));
               
               let x = rect[2] - rect[0],
                   y = rect[2] - rect[0],
                   area;
                   
               if ((x > 0) && (y > 0)) {
                    area = x * y;
                    if (maxArea < area) {
                        maxArea = area;
                        pos = i;
                    }
               }
            }
            if (maxArea > 0) {
                let point = {x: 0, y: 0, w: 0};
                _getCentroid(geometry.coordinates[pos][0], point);
                return _checkCentroid(geometry.coordinates[pos], point);
            }
        },
        GeometryCollection: function(geometry: GeoJSON.GeometryCollection): GeoJSON.Point {
            throw new Error('Not implemented');
        }
    }
    
    export function getCentroid(geometry: GeoJSON.Geometry): GeoJSON.Point {
        let f: (geometry: GeoJSON.Geometry)=> GeoJSON.Point;
        return geometry && (f = centroids[geometry.type]) && f(geometry);
    }
    
    function _isLeft(p0: GeoJSON.Position, p1: GeoJSON.Position, p2: GeoJSON.Position): number {
        return ((p1[0] - p0[0]) * (p2[1] - p0[1]) - (p2[0] -  p0[0]) * (p1[1] - p0[1]));
    }    
      
    function _pointInRing(pt: GeoJSON.Position, ring: ReadonlyArray<GeoJSON.Position>): boolean {
        let x: number = pt[0],
            y: number = pt[1],
            wn: number = 0;

        for (let i: number = 0, j: number = ring.length - 1; i < ring.length; j = i++) {
            let xi = ring[i][0], yi = ring[i][1],
                xj = ring[j][0], yj = ring[j][1];

            if (yj <= y) {
                if (yi > y) {
                    if (_isLeft([xj, yj], [xi, yi], [x, y]) > 0) {
                        wn++;
                    }
                }
            } else {
                if (yi <= y) {
                    if (_isLeft([xj, yj], [xi, yi], [x, y]) < 0) {
                        wn--;
                    }
                }
            }
        }
        return wn !== 0;
    }
    
    function _pointInPolygon(pt: GeoJSON.Position, coordinates: ReadonlyArray<ReadonlyArray<GeoJSON.Position>>): boolean {
        return coordinates.length && coordinates.every((ring, indice) => indice ? !_pointInRing(pt, ring) : _pointInRing(pt, ring));
    }
    
    function _pointEqual(pt0: GeoJSON.Position, pt1: GeoJSON.Position): boolean {
        return (Math.abs(pt0[0] - pt1[0]) < 10E-8) && (Math.abs(pt0[1] - pt1[1]) < 10E-8);
    }
    
    function _pointOnSegment(pt: GeoJSON.Position, pt1: GeoJSON.Position, pt2: GeoJSON.Position): boolean {
        let c = pt2[0] - pt1[0],
            d = pt2[1] - pt1[1],
            len_sq = c * c + d * d,
            ptCalc: GeoJSON.Position;

        if (!len_sq) {
            ptCalc = pt1;
        } else {
            let a = pt[0] - pt1[0],
                b = pt[1] - pt1[1],
                fact = (a * c + b * d) / len_sq;;
                
            if ((fact < 0) || (fact > 1)) {
                return;
            }
            ptCalc = [pt1[0] + fact * c, pt1[1] + fact * d];
        }
        return _pointEqual(ptCalc, pt);
    }
    
    function _pointOnLineString(pt: GeoJSON.Position, coordinates: ReadonlyArray<GeoJSON.Position>): boolean {
        let l = coordinates.length;
        if (l) {
            return l === 1 ?
                _pointEqual(pt, coordinates[0]):
                coordinates.some((position, indice) => indice && _pointOnSegment(pt, coordinates[indice - 1], position));
        }
    }
    const _pointInGeometry: {[key: string]: (point: GeoJSON.Position, geometry: GeoJSON.Geometry) => boolean;} = {
        Point: (point: GeoJSON.Position, geometry: GeoJSON.Point) => _pointEqual(point, geometry.coordinates),
        MultiPoint: (point: GeoJSON.Position, geometry: GeoJSON.MultiPoint) => geometry.coordinates.some(point2 => _pointEqual(point, point2)),
        LineString: (point: GeoJSON.Position, geometry: GeoJSON.LineString) => _pointOnLineString(point, geometry.coordinates),
        MultiLineString: (point: GeoJSON.Position, geometry: GeoJSON.MultiLineString) => geometry.coordinates.some(lineString => _pointOnLineString(point, lineString)),
        Polygon: (point: GeoJSON.Position, geometry: GeoJSON.Polygon) => _pointInPolygon(point, geometry.coordinates),
        MultiPolygon: (point: GeoJSON.Position, geometry: GeoJSON.MultiPolygon) => geometry.coordinates.some(polygon => _pointInPolygon(point, polygon)),
    };
    
    export function pointInGeometry(point: GeoJSON.Position, geometry: GeoJSON.Point | GeoJSON.MultiPoint | GeoJSON.LineString | GeoJSON.MultiLineString | GeoJSON.Polygon | GeoJSON.MultiPolygon): boolean {
        let f: (point: GeoJSON.Position, geometry: GeoJSON.Geometry)=> boolean;
        return geometry && (f = _pointInGeometry[geometry.type]) && f(point, geometry);
    }
}