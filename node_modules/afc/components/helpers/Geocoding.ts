/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

///<reference path="../AFC.ts" />

namespace AFC.Tools.Geocoding {
    export const enum Provider {
        auto,
        nominatim,
        dataGouv
    }
    
    export interface ISearchOptions {
        countryCode?: string;
        bbox?: number[];
        maxResults?: number;
        provider?: Provider;
    }

    export interface IReverseOptions {
        countryCode?: string;
        provider?: Provider;
    }

    export interface IGeocodeResult {
	address?: string;
        zipCode?: string;
    	city?: string;
	country?: string;
	countryCode?: string;
        score?: number;
        location?: GeoJSON.Point;
        native_?: any;
    }
    
    const _nominatimUrl:string = 'https://nominatim.openstreetmap.org/';
    const _dataGouvUrl:string = 'https://api-adresse.data.gouv.fr/';
    
    interface ISearchConfiguration {
        handle: (data: any)=>IGeocodeResult[];
        settings: JQueryAjaxSettings;
    };

    interface IReverseConfiguration {
        handle: (data: any)=>IGeocodeResult;
        settings: JQueryAjaxSettings;
    };
    
        
    function _processNominatim(item: any): IGeocodeResult {
        let x: any = item.lon, y: any = item.lat;
        let geocodeResult: IGeocodeResult;

        if ((x !== void 0)&&(y !== void 0)) {
            geocodeResult = {
                score: item.importance,
                location: {
                    type: 'Point',
                    coordinates: [parseFloat(x), parseFloat(y)]
                },
                native_: item
            };
            let address: any = item.address;

            if (address) {
                if (address.pedestrian||address.road) {
                    let streetNumber: string = address.house_number ? `${address.house_number}, ` : '';
                    geocodeResult.address = `${streetNumber}${address.pedestrian||address.road}`;
                }
                geocodeResult.zipCode = address.postcode ? address.postcode.split(';')[0] : void 0;
                geocodeResult.city = address.city||address.town||address.village||void 0;
                geocodeResult.country = address.country||void 0;
                geocodeResult.countryCode = address.country_code||void 0;
            }
        }
        return geocodeResult;
    }

    interface IDataGouvFeature extends GeoJSON.Feature<GeoJSON.Point> {
        properties: {
            id?: string;
            type?: string;
            housenumber?: string;
            street?: string;
            place?: string;
            village?: string;
            town?: string;
            city?: string;
            score?: number;
            name?: string;
            postcode?: string;
            citycode?: string;
            context?: string;
            label?: string;
        };
    }
    
    
    function _processDataGouv(item: IDataGouvFeature): IGeocodeResult {
        let geocodeResult: IGeocodeResult;

        if (item.geometry) {
            geocodeResult = {
                score: item.properties.score,
                location: item.geometry,
                native_: item
            };
            geocodeResult.address = item.properties.name;
            geocodeResult.zipCode = item.properties.postcode;
            geocodeResult.city = item.properties.city||item.properties.town||item.properties.village||void 0;
            geocodeResult.country = 'France';
            geocodeResult.countryCode = 'fr';
        }
        return geocodeResult;
    }

    function _map<T>(ts: T[], f:(t: T)=>IGeocodeResult): IGeocodeResult[] {
        let results: IGeocodeResult[] = [];
        ts.forEach((t: T)=>{
            let result: IGeocodeResult = f(t);
            results&&results.push(result);
        });
        return results;
    }
    
    const _searchConfigurations: {(query: string, options: ISearchOptions): ISearchConfiguration}[] = [
        //auto
        (query: string, options: ISearchOptions): ISearchConfiguration=>{
            return (options && options.countryCode && (options.countryCode.toLowerCase() === 'fr') ? _searchConfigurations[Provider.dataGouv] : _searchConfigurations[Provider.nominatim])(query, options);
        },
        //nominatim
        (query: string, options: ISearchOptions): ISearchConfiguration=>{
            let data: string = `format=json&addressdetails=1&q=${query}`;
            if (options) {
                (options.countryCode)&&(data += `&countrycodes=${options.countryCode}`);
                (options.bbox&&(options.bbox.length===4))&&(data += `&bounded=1&viewboxlbrt=${options.bbox.join(',')}`);
                (options.maxResults)&&(data += `&limit=${options.maxResults}`);
            }
            let settings: JQueryAjaxSettings = {
                url: `${_nominatimUrl}search`,
                data: data
            };
            return {settings: settings, handle: (data: any[]) => _map(data, _processNominatim)};
        },
        //dataGouv
        (query: string, options: ISearchOptions): ISearchConfiguration=>{
            let data: string = `q=${query}`;
            if (options) {
                (options.maxResults)&&(data += `&limit=${options.maxResults}`);
            }
            let settings: JQueryAjaxSettings = {
                url: `${_dataGouvUrl}search/`,
                data: data
            };
            return { settings: settings, handle: (data: { features: IDataGouvFeature[] }) => _map(data.features, _processDataGouv)};
        }
    ];

    const _reverseConfigurations: { (lat: number, lon: number, options: IReverseOptions): IReverseConfiguration}[] = [
         //auto
        (lat: number, lon: number, options: IReverseOptions): IReverseConfiguration=>{
            return (options && options.countryCode && (options.countryCode.toLowerCase() === 'fr') ? _reverseConfigurations[Provider.dataGouv] : _reverseConfigurations[Provider.nominatim])(lat, lon, options);
        },
        //nominatim
        (lat: number, lon: number, options: IReverseOptions): IReverseConfiguration=>{
            let data: string = `format=json&zoom=18&addressdetails=1&lat=${lat}&lon=${lon}`;
            let settings: JQueryAjaxSettings = {
                url: `${_nominatimUrl}reverse`,
                data: data
            };
            return {settings: settings, handle: _processNominatim};
        },
        //dataGouv
        (lat: number, lon: number, options: IReverseOptions): IReverseConfiguration=>{
            let data: string = `lon=${lon}&lat=${lat}`;
            let settings: JQueryAjaxSettings = {
                url: `${_dataGouvUrl}reverse/`,
                data: data
            };
            return { settings: settings, handle: (data: { features: IDataGouvFeature[] }) => data.features && data.features.length && _processDataGouv(data.features[0])};
        }
    ];
              
    export class Geocoder {
        protected _onReverseComplete(handle: (data: any)=>IGeocodeResult, callback: (geocodeResult: IGeocodeResult, success: boolean)=> any, jqXHR: JQueryXHR, textStatus: string): void {
            let geocodeResult: IGeocodeResult;
            let success: boolean = jqXHR.status === 200;

            if (success) {
                let data: any = jqXHR.responseText && JSON.parse(jqXHR.responseText);

                data && (geocodeResult = handle(data));
           }
           callback(geocodeResult, success);
        }
               
        protected _onSearchComplete(handle: (data: any)=>IGeocodeResult[], callback: (geocodeResults: IGeocodeResult[], success: boolean)=> any, jqXHR: JQueryXHR, textStatus: string): void {
            let geocodeResults: IGeocodeResult[];
            let success: boolean = jqXHR.status === 200;

            if (success) {
                let data: any[] = jqXHR.responseText && JSON.parse(jqXHR.responseText);

                data && (geocodeResults = handle(data));
           }
           callback(geocodeResults || [], success);
        }
        
        public search(query: string, callback: (geocodeResults: IGeocodeResult[], success: boolean)=>any, options?: ISearchOptions): void {
            let provider: Provider = (options && options.provider) || Provider.auto;
            let handler: { (query: string, options: ISearchOptions): ISearchConfiguration } = _searchConfigurations[provider];
            let configuration: ISearchConfiguration;
                
            if (handler && (configuration = handler(query, options))) {
                let settings: JQueryAjaxSettings = jQuery.extend({
                    method: 'GET',
                    processData: false,
                    async: true,
                    complete: (jqXHR: JQueryXHR, textStatus: string) => this._onSearchComplete(configuration.handle, callback, jqXHR, textStatus)
                }, configuration.settings);
                jQuery.ajax(settings);
            }
        }

        public reverse(lat: number, lon: number, callback: (geocodeResult: IGeocodeResult, success: boolean)=> any, options?: IReverseOptions): void {
            let provider: Provider = (options && options.provider) || Provider.auto;
            let handler: { (lat: number, lon: number, options: IReverseOptions): IReverseConfiguration } = _reverseConfigurations[provider];
            let configuration: IReverseConfiguration;
                
            if (handler && (configuration = handler(lat, lon, options))) {
                let settings: JQueryAjaxSettings = jQuery.extend({
                    method: 'GET',
                    processData: false,
                    async: true,
                    complete: (jqXHR: JQueryXHR, textStatus: string) => this._onReverseComplete(configuration.handle, callback, jqXHR, textStatus)
                }, configuration.settings);
                jQuery.ajax(settings);
            }
        }
    }
}