/**
 * Created by jean.rennes on 29/09/2015.
 */
///<reference path="../AFC.ts" />

namespace AFC.Tools {
    export const enum EventType {
        NetworkError = 1,
        NetworkBegin,
        NetworkComplete,
        IdentityError,
        Internal,
        Dirty,
        UserEvent = (1 << 16),
        Attach = (1 << 30),
        Ready,
        Refresh
    }

    export interface IEventData {
        concat?: (d: any) => IEventData;
        onDispatch?: () => IEventData;
    }

    export interface IEvent<TObservable extends INotifier = INotifier, TData extends IEventData = IEventData> {
        type: EventType;
        target: TObservable;
        data?: TData;
    }

    export interface INotifier<TObservable extends INotifier = any, TData extends IEventData = IEventData> {
        on(type: EventType, callback: (event: IEvent<TObservable, TData>) => any, context?: any): any;
        off(type: EventType, callback: (event: IEvent<TObservable, TData>) => any, context?: any): any;
    }

    export interface IObservable<TObservable extends IObservable = any, TData extends IEventData = IEventData> extends INotifier<TObservable, TData> {
        once(type: EventType, callback: (event: IEvent<TObservable, TData>) => any, callbackref: any, context?: any): any;
        notify(type: EventType, callback: (event: IEvent<TObservable, TData>) => any): this;
        fireEvent(type: EventType, data?: TData): any;
        dispatchEvent(type: EventType, data?: TData): void;
    }

    interface IEventReference {
        id: string;
        fn: (event: IEvent) => any;
        once?: boolean;
        ctx?: Object;
    }

    interface IEventEntry {
        a: IEventReference[];
        i: { [key: string]: number };
    }

    export interface IPendingEvent {
        sink: IObservable & { dispatchEvent: (type: EventType, data?: IEventData) => any; };
        type: EventType;
        data?: IEventData;
    }

    const _idProperty = Symbol('afcId');

    namespace Kernel {
        var _stampCnt: number = 1;
        var _pendingIndex: { [key: string]: IPendingEvent };
        var _pendings: IPendingEvent[];

        export function stamp(o: any): number {
            return o[_idProperty] || (o[_idProperty] = (_stampCnt++));
        }

        export function dispatch(): void {
            if (_pendings.length) {
                //let pendings: IPendingEvent[] = _pendings;
                let offset: number, event: IPendingEvent;

                if (_pendings.length > 1) {
                    _pendings.reduce((_type: EventType, event: IPendingEvent, indice: number) => {
                        if (event.type < _type) {
                            offset = indice;
                            _type = event.type;
                        }
                        return _type;
                    }, Number.MAX_SAFE_INTEGER);
                    event = _pendings[offset];
                    delete _pendingIndex[event.type + '_' + stamp(event.sink)];
                    _pendings.splice(offset, 1);
                    setTimeout(dispatch, 0);
                } else {
                    event = _pendings[0];
                    _pendingIndex = _pendings = void 0;
                }
                event.sink.dispatchEvent(event.type, event.data);
            }
        }

        export function fire(e: IPendingEvent): IPendingEvent {
            if (!_pendings) {
                _pendingIndex = {};
                _pendings = [];
                setTimeout(dispatch, 0);
            }

            let indexId: string = e.type + '_' + stamp(e.sink);
            let o: IPendingEvent;

            if (o = _pendingIndex[indexId]) {
                e.data ? (o.data = o.data?.concat ? o.data.concat(e.data) : e.data) : delete o.data;
            }
            else
                _pendings.push(_pendingIndex[indexId] = o = e);
            return o;
        }

        export function packEvent(this: any, callback: (event: IEvent) => any, callbackRef: any, context: any, once?: boolean): IEventReference {
            var ctx: number = (context || 0) && (context !== this) && stamp(context);
            var indexId: string = ctx + '_' + stamp(callbackRef);
            return { id: indexId, once: once, fn: callback, ctx: context };
        }
    }

    export type Callable = (...args: any[]) => any;

    export var AfcReferenceMixin = function (callback: Callable, ref: any): Callable {
        let h = function (this: any) { callback.apply(this, arguments); }
        Object.defineProperty(h, _idProperty, {
            get: function (): number {
                return ref[_idProperty];
            },
            set: function (value: number) {
                ref[_idProperty] = value;
            },
            enumerable: true,
            configurable: true
        });
        return h;
    };

    export type Constructor<T = {}> = new (...args: any[]) => T;

    const _target = Symbol();

    function EventSinkMixinBase<T extends abstract new (...args: any[]) => any, TObservable extends IObservable = any, TData extends IEventData = IEventData>(Base: T) {
        const _events = Symbol(),
            _count = Symbol();

        function _on(events: { [key: number]: IEventEntry }, type: EventType, eventReference: IEventReference): void {
            let event: IEventEntry = (events[type] || (events[type] = { i: {}, a: [] }));
            let index: { [key: string]: number } = event.i;
            let queue: IEventReference[] = event.a;
            let id: string = eventReference.id;

            if (index[id] === void 0) {
                index[id] = queue.length;
                queue.push(eventReference);
            }
        }

        abstract class Derived extends Base implements IObservable<TObservable, TData> {
            private [_events]: { [key: number]: IEventEntry };
            private [_count]: number = 0;
            protected [_target]: IObservable = this;

            public countObservers(type: EventType): number {
                let events: { [key: number]: IEventEntry } = this[_events];
                return (events && events[type] && events[type].a.length) || 0;
            }

            public notify(type: EventType, callback: (event: IEvent<TObservable, TData>) => void): this {
                let o = { [_idProperty]: ++this[_count] };
                this.once(type, callback, _on, o);
                return this;
            }

            public once(type: EventType, callback: (event: IEvent<TObservable, TData>) => any, callbackref: any, context?: any): void {
                _on(this[_events] || (this[_events] = {}), type, Kernel.packEvent(callback, callbackref, context, true));
            }

            public on(type: EventType, callback: (event: IEvent<TObservable, TData>) => any, context?: any): void {
                _on(this[_events] || (this[_events] = {}), type, Kernel.packEvent(callback, <any>callback, context));
            }

            public off(type: EventType, callback: (event: IEvent<TObservable, TData>) => any, context?: any): void {
                let events: { [key: number]: IEventEntry };
                let event: IEventEntry;

                if (type && callback && (events = this[_events]) && (event = events[type])) {
                    let ctx: number = (context || 0) && (context !== this) && context[_idProperty];
                    let id: string = ctx + '_' + (<any>callback)[_idProperty];
                    let index: { [key: string]: number } = event.i;
                    let i: number = index[id];

                    if (i !== void 0) {
                        event.a.splice(i, 1);
                        event.i = index = {};
                        event.a.forEach((item, i) => index[item.id] = i);
                    }
                }
            }

            public fireEvent(type: EventType, data?: IEventData): IPendingEvent {
                let e: IPendingEvent = { sink: this, type: type, data: data };
                return Kernel.fire(e);
            }

            public dispatchEvent(type: EventType, data?: IEventData): void {
                let events: { [key: number]: IEventEntry };
                let event: IEventEntry;
                let newEvent: IEventEntry;

                if (type && (events = this[_events]) && (event = events[type])) {
                    let e: IEvent = {
                        type: type,
                        target: this[_target]
                    };
                    data && (e.data = (data.onDispatch ? data.onDispatch() : data));
                    delete events[type];
                    for (let ref of event.a) {
                        if (!ref.once) {
                            if (!newEvent) {
                                events[type] = newEvent = { i: {}, a: [] };
                            }
                            newEvent.i[ref.id] = newEvent.a.length;
                            newEvent.a.push(ref);
                        }
                        try {
                            ref.ctx ? ref.fn.call(ref.ctx, e) : ref.fn(e);
                        }
                        catch (e) {
                            console.log(e.message);
                            e.stack && console.log(e.stack);
                        }
                    }
                }
            }
        }
        return Derived;
    }

    export interface IEventSink extends IObservable {
        countObservers(type: EventType): number;
    }

    export const EventSinkMixin: <T extends abstract new (...args: any[]) => any, TObservable extends IObservable = any, TData extends IEventData = IEventData>(Base: T) => abstract new (...args: any[]) => (InstanceType<T> & IEventSink)
        = EventSinkMixinBase;

    export class EventSink<TObservable extends IObservable = any, TData extends IEventData = IEventData> extends EventSinkMixin(class { }) {
        /** @internal */
        private [_target]: IObservable = this;

        constructor(target?: any) {
            super();
            target && (this[_target] = target);
        }
    }

    export function observableObject<T extends Object>(t?: T): T & IObservable {
        let sink = new EventSink();
        return sink[_target] = <any>new Proxy(Object.assign(sink, t || {}), {
            set: (target: AFC.Tools.EventSink, prop: string | symbol, value: any, receiver: any) => {
                let old = Reflect.get(target, prop);

                if (old !== value) {
                    Reflect.set(target, prop, value)
                    target.fireEvent(AFC.Tools.EventType.Dirty);
                }
                return true;
            }
        });
    }

    export interface IForward {
        type: EventType;
        targetType?: EventType;
        observable: IObservable;
        callback: (event: IEvent) => any;
    }

    const _forwards = Symbol();

    export class AutoSubscribeForwarder<TObservable extends IObservable = any, TData extends IEventData = IEventData> extends EventSink<TObservable, TData> {
        /** @internal */
        private [_forwards]: { [key: string]: IForward } | undefined;

        private static _update(type: EventType, forwarder: AutoSubscribeForwarder, on?: boolean): void {
            const forward: IForward = forwarder[_forwards]?.[type];

            if (forward && !forwarder.countObservers(type)) {
                (on ? forward.observable.on : forward.observable.off).call(forward.observable, forward.targetType ?? type, forward.callback, forwarder);
            }
        }

        protected _setForwards(forwards: IForward[]) {
            let map = this[_forwards];

            if (map) {
                for (let key in map) {
                    const forward: IForward = map[key];
                    forward.observable.off(forward.targetType ?? forward.type, forward.callback, this);
                }
            }
            this[_forwards] = map = {};
            forwards && forwards.forEach((forward: IForward) => map[forward.type] = forward);
        }

        public once(type: EventType, callback: (event: IEvent<TObservable, TData>) => any, callbackref: any, context: any): void {
            AutoSubscribeForwarder._update(type, this, true);
            super.once(type, callback, callbackref, context);
        }

        public on(type: EventType, callback: (event: IEvent<TObservable, TData>) => any, context?: any): void {
            AutoSubscribeForwarder._update(type, this, true);
            super.on(type, callback, context);
        }

        public off(type: EventType, callback: (event: IEvent<TObservable, TData>) => any, context?: any): void {
            super.off(type, callback, context);
            AutoSubscribeForwarder._update(type, this);
        }

        public dispatchEvent(type: EventType, data?: TData): void {
            super.dispatchEvent(type, data);
            AutoSubscribeForwarder._update(type, this);
        }
    }
}