/**
 * Created by jean.rennes on 27/01/2016.
 */

namespace AFC {
    export type PartialMutable<T> = { -readonly [P in keyof T]+?: T[P] };

    export type Mutable<T> = { -readonly [P in keyof T]: T[P] };
    
    export namespace Tools {
        export function lower_bound<Item, Value>(a: ReadonlyArray<Item>, v: Value, pred: (item: Item, value: Value)=> number = (a: Item, b: Value)=> (a < <any>b) ? -1 : 0): number {
            let n:number = a.length;

            if(n>0) {
                let f: number = 0;
                let n2: number, m: number;

                while(0 < n) {
                    n2 = n >> 1;
                    m = f+n2;
                    if (pred(a[m], v) < 0)
                        f = m+1, n -= n2+1;
                    else
                        n = n2;
                }
                return f;
            }
            return 0;
        }

        export function findById<Interface extends {id: string;}>(id: string, interfaces: ReadonlyArray<Interface>): Interface {
            if (id !== void 0) {
                let ref: string = id.toLowerCase();

                for (let o of interfaces) {
                    if (o.id.toLowerCase() === ref) {
                        return o;
                    }
                }
            }
        }

        export function indexOf(a: {readonly length: number; [index: number]: any;}, pred: (item: any)=>boolean): number {
            for (let i: number = 0; i < a.length; ++i) {
                if (pred(a[i])) {
                    return i;
                }
            }
            return -1;
        }

        export function findByIdOrName<Interface extends {id: string; name?: string;}>(id: string, interfaces: ReadonlyArray<Interface>, filter?: (i: Interface)=> boolean): Interface {
            if (id !== void 0) {
                let ref: string = id.toLowerCase();

                for (let o of interfaces) {
                    if ((!filter || filter(o)) && ((o.id.toLowerCase() === ref) || ((o.name !== void 0) && (o.name.toLowerCase() === ref)))) {
                        return o;
                    }
                }
            }
        }

        export function arrayCompare(v0: ReadonlyArray<any>, v1: ReadonlyArray<any>): number {
            let iLength: number = v0.length,
                ret: number = iLength - v1.length;

            for (let i: number = 0; !ret&&(i < iLength); ++i) {
                ret = v0[i] instanceof Array ? arrayCompare(v0[i], v1[i]) : AFC.Data.compareValue(v0[i], v1[i]);
            }
            return ret;
        }
        
        function _open(activity: Application.Activity, message: string, yesNoChoice: boolean, title: string): Promise<boolean> {
            return new Promise(resolve => {
                const AlertDialog = AFC.Controls.AlertDialog;
                let dialog = new AlertDialog(activity),
                    end = (confirm?: boolean) => (dialog.dismiss(), resolve(confirm));

                title && dialog.setTitle(title);
                dialog.setMessage(message);
                if (yesNoChoice) {
                    dialog.setButton(AlertDialog.BUTTON_POSITIVE, '', (/*dialog, which*/)=> end(true));
                    dialog.setButton(AlertDialog.BUTTON_NEUTRAL, '', (/*dialog, which*/)=> end());
                } else {
                    dialog.setButton(AlertDialog.BUTTON_POSITIVE, '', (/*dialog, which*/)=> end());
                }
                dialog.show();
            });
        }

        export const alert = async (activity: Application.Activity, message: string, title?: string) => await _open(activity, message, false, title);

        export const confirm = async (activity: Application.Activity, message: string, title?: string) => await _open(activity, message, true, title);

        export namespace Lang {
            export const enum Locale {
                fr = 1,
                us,
                en
            }
        }

        export namespace Style {
            export function convertColor(v: number): string {
                if (v < 0) return 'transparent';
                let r: number = (v & 0xFF),
                    g: number = ((v>>8) & 0xFF),
                    b: number = ((v>>16) & 0xFF);

                return '#' + (function(h:string){
                    return new Array(7-h.length).join("0")+h
                })(((r<<16)+(g<<8)+b).toString(16));
            }
            
            export function convertRGBAColor(v: number): string {
                if (v < 0) return 'transparent';
                let r: number = (v & 0xFF),
                    g: number = ((v>>8) & 0xFF),
                    b: number = ((v>>16) & 0xFF),
                    a: number = Math.round((0xFF - ((v>>24) & 0xFF)) / 2.56) * 100;
                return `rgba(${r},${g},${b},${a})`;
            }
            
            export const transparent1Pixel = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
        }

        export namespace StringTools {
            export function normalizeString(s: string) {
                if (s && (s !== null)) {
                    let str: string = s.toLowerCase();
                    str = str.replace(/[' ,;-]/g, '_');
                    str = str.replace(/[éèêë]/g, 'e');
                    str = str.replace(/[àâä]/g, 'a');
                    str = str.replace(/ö/g, 'o');
                    str = str.replace(/ï/g, 'i');
                    str = str.replace(/ç/g, 'c');
                    str = str.replace(/ü/g, 'u');
                    return str.toUpperCase();
                }
                return '';
            }
            
            export function buildUrl(host: string, path: string, secure?: boolean, port?: number): string {
                let url = (secure ? 'https://' : 'http://') + host;
                if (port !== void 0) {
                    url += `:${port}`;
                }
                return url + ((path[0] === '/') ? '' : '/') + path;
            }
            
            function _2digit(i: number): string {
                return (i < 10 ? '0' : '') + i.toString();
            }
            
            const _dateMap: {[key: number]: {[key: number]: (d: Date)=> string|number;};} = {
                100: {  // "d"
                    1: (d: Date) => d.getDate(),
                    2: (d: Date) => _2digit(d.getDate()),
                    3: (d: Date) => d.toLocaleDateString(void 0, { weekday: 'short' }),
                    4: (d: Date) => d.toLocaleDateString(void 0, { weekday: 'long' })
                },
                77: {   // "M"
                    1: (d: Date) => d.getMonth() + 1,
                    2: (d: Date) => _2digit(d.getMonth() + 1),
                    3: (d: Date) => d.toLocaleDateString(void 0, { month: 'short' }),
                    4: (d: Date) => d.toLocaleDateString(void 0, { month: 'long' })
                },
                121: {  // "y"
                    2: (d: Date) => _2digit(d.getFullYear()%100),
                    4: (d: Date) => _2digit(d.getFullYear())
                },
                104: {   // "h"
                    1: (d: Date) => (d.getHours()%12) || 12,
                    2: (d: Date) => _2digit((d.getHours()%12) || 12)
                },
                72: {   // "H"
                    1: (d: Date) => d.getHours(),
                    2: (d: Date) => _2digit(d.getHours())
                },
                109: {   // "m"
                    1: (d: Date) => d.getMinutes() + 1,
                    2: (d: Date) => _2digit(d.getMinutes() + 1)
                },
                115: {   // "s"
                    1: (d: Date) => d.getSeconds() + 1,
                    2: (d: Date) => _2digit(d.getSeconds() + 1)
                },
                116: {   // "t"
                    1: (d: Date) => d.getHours()<12 ? 'A':'P',
                    2: (d: Date) => d.getHours()<12 ? 'AM':'PM'
                }
            };
                       
            function _parseDateFormat(format: string) {
                let i = 0,
                    formatters: Array<(d: Date)=> string|number> = [],
                    c: number,
                    byPass = (str: string) => ((d: Date) => str);
                
                while (c = format.charCodeAt(i)) {
                    let j = 0;
                    do {
                        ++j;
                    } while (c === format.charCodeAt(i + j));
                    
                    let formatter = _dateMap[c] && _dateMap[c][j];
                    formatters.push(formatter || byPass(format.substr(i, j)));
                    i += j;
                }
                return formatters;
            }
            
            export class FormatString {
                protected _format:          string;
                protected _datakind:        AFC.Data.DataKind;
                private _decodedFormat :    {
                    kind: string,
                    numeric_options: Intl.NumberFormatOptions,
                    prefix: string,
                    suffix: string,
                    nullvalue?: string,
                    custom_property?: string,
                    formatters?: ((d: any) => string|number)[]
                };

                constructor(format: string, datakind: AFC.Data.DataKind) {
                    this._datakind      = datakind;
                    this._format        = (format === void 0 ? '' : format);
                    this._decodedFormat = void 0;
                }

                public getFormated(value: any): string {
                    let formatedValue = '';

                    this._decodeFormat();

                    if ((value == null) || (value === void 0)) {
                        if (this._decodedFormat.nullvalue !== void 0)
                            formatedValue = this._decodedFormat.nullvalue;
                        else
                            formatedValue = '';
                    }
                    else if (this._decodedFormat.formatters) {
                        formatedValue = this._decodedFormat.formatters.reduce((acc, formatter) => acc + formatter(value), '');
                    } else {
                        switch (this._decodedFormat.kind) {
                            case 'numeric':
                                formatedValue = (Math.round(<number> value * 100) / 100).toLocaleString(undefined, this._decodedFormat.numeric_options);
                                break;
                            case 'date':
                                formatedValue = value.toLocaleString();
                                break;
                            case 'time':
                                formatedValue = value.toLocaleString();
                                break;
                            default:
                                formatedValue = value;
                                break;
                        }
                        formatedValue = this._decodedFormat.prefix + formatedValue + this._decodedFormat.suffix;
                    }

                    return formatedValue;
                }

                public isNumeric(): boolean {
                    this._decodeFormat();

                    if (this._decodedFormat.kind == 'numeric')    
                        return true;
                    return false;
                }

                private _decodeFormat() {
                    if (this._decodedFormat === void 0)
                    {
                        this._decodedFormat = {kind:'string', numeric_options:{}, prefix:'', suffix:''};

                        if (this._datakind == AFC.Data.DataKind.real || this._datakind == AFC.Data.DataKind.integer)
                            this._decodedFormat.kind = 'numeric';

                        if (this._format != '') {
                            let regex    = /{!(.*?)!}/g;
                            this._format.match(regex).forEach(token=> {
                                    let values = token.slice(2, token.length - 2).split(":");
                                    if (values.length == 2) {
                                    switch (values[0].toLowerCase()) {
                                        case 'kind':
                                            switch (values[1].toLowerCase()) {
                                                case 'date':
                                                    this._decodedFormat.kind = 'date';
                                                    break;
                                                case 'time':
                                                    this._decodedFormat.kind = 'time';
                                                    break;
                                                case 'percent':
                                                    this._decodedFormat.kind = 'numeric';
                                                    //this._decodedFormat.numeric_options.style = 'percent';
                                                    this._decodedFormat.suffix = ' %';
                                                    break;
                                                case 'number':
                                                    this._decodedFormat.kind = 'numeric';
                                                    this._decodedFormat.numeric_options.style = 'decimal';
                                                    break;
                                                case 'currency':
                                                case 'euro':
                                                     //Default currency is EUR
                                                    this._decodedFormat.kind = 'numeric';
                                                    this._decodedFormat.numeric_options.style = 'currency';
                                                    this._decodedFormat.numeric_options.currency = 'EUR';
                                                    break;
                                                case 'yen':
                                                    this._decodedFormat.kind = 'numeric';
                                                    this._decodedFormat.numeric_options.style = 'currency';
                                                    this._decodedFormat.numeric_options.currency = 'JPY';
                                                    break;
                                                case 'dollard':
                                                    this._decodedFormat.kind = 'numeric';
                                                    this._decodedFormat.numeric_options.style = 'currency';
                                                    this._decodedFormat.numeric_options.currency = 'USD';
                                                    break;
                                            }     
                                            break;
                                        case 'round':
                                            this._decodedFormat.numeric_options.minimumFractionDigits = Number(values[1]);
                                            this._decodedFormat.numeric_options.maximumFractionDigits = this._decodedFormat.numeric_options.minimumFractionDigits;
                                            break;
                                        case 'prefix':
                                            this._decodedFormat.prefix = values[1];
                                            break;
                                        case 'suffix':
                                            this._decodedFormat.suffix = values[1];
                                            break;
                                        case 'nullvalue':
                                            this._decodedFormat.nullvalue = values[1];
                                            break;
                                        case 'thousand_separator':
                                            this._decodedFormat.numeric_options.useGrouping = values[1] == '1' ? true : false;
                                            break;
                                        case 'custom_property':
                                        case 'custom_properyy':
                                            if (this._decodedFormat.kind === 'time' || this._decodedFormat.kind === 'date') {
                                                this._decodedFormat.formatters = _parseDateFormat(values[1]);
                                            } else {
                                                this._decodedFormat.custom_property = values[1];
                                            }
                                            break;
                                    }
                                }
                            });
                        }
                    }
                }
            }  
        }
    }
}