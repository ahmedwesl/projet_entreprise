/**
 * Created by jean.rennes on 26/04/2016.
 */
///<reference path="../models/dashboards/Dashboard.ts" />
///<reference path="../models/dashboards/GridApp.ts" />
///<reference path="../models/tradearea/DMAConfig.ts" />
///<reference path="../models/rest/RequestBuilder.ts" />
///<reference path="../models/traffic/Traffic.ts" />
///<reference path="../models/data/Global.ts" />
///<reference path="../models/data/Data.ts" />
///<reference path="Data.ts" />

namespace AFC.Tools.Dashboards {
    import Dashboards = AFC.Dashboards;

    export interface IDMAReplacementOptions {
        readonly confirm?: () => Promise<boolean>;
        readonly zone?: Dashboards.IZone<Dashboards.ZoneType.predefined>;      // pdz zone
        readonly income?: Dashboards.IZone<Dashboards.ZoneType.predefined>;    // pdz zone
        readonly impact?: string;    // table id
        readonly neighbors?: string;    // table id
        readonly descriptor?: TradeArea.DMAConfigDescriptor;
    }
    
    export interface ITrafficReplacementOptions {
        readonly confirm?: (callback: (update: boolean)=> void)=> any;
        readonly workingZone?: Dashboards.IZone<Dashboards.ZoneType.predefined>;    // pdz zone
        readonly livingZone?: Dashboards.IZone<Dashboards.ZoneType.predefined>;     // pdz zone
        readonly geographicSource?: string;
        readonly customServer?: string;
        readonly x: number;
        readonly y: number;
        readonly currentCodeValue: string | number;
    }

    type ResourceSubstitute = Rest.ResourceSubstitute;
    const ResourceSubstitute = Rest.ResourceSubstitute;

    const _init = Symbol();

    interface IStoreSourceListenerEventData extends IEventData {
        readonly data: ReadonlyArray<AFC.Data.IDataEvent>;
        readonly dashboard: ReadonlyArray<AFC.Data.IDataEvent>;
    }

    export type IStoreSourceListenerEvent = IEvent<AFC.Data.StoreSource, IStoreSourceListenerEventData>;

    abstract class StoreSourceListener implements Rest.IContextModifier {
        public readonly dashboard: Dashboards.IDashboard;
        public readonly storeSource: AFC.Data.StoreSource;
        /** @internal */
        protected [_init]: boolean;
        
        constructor(dashboard: Dashboards.IDashboard, storeSource: AFC.Data.StoreSource) {
            this.dashboard = dashboard;
            this.storeSource = storeSource;
            this[_init] = true;
            dashboard.requestBuilder.pushModifier(this);
        }
        
        protected _create(): void {}
                
        protected abstract _update(event: AFC.Data.IDataEvent): void;
        
        public abstract updateBody(body: AFC.Dashboards.IDashboardContextData/*, options?: Dashboards.IDashboardContextModifierOptions*/): void;
        
        public async load(/* options?: Dashboards.IDashboardContextModifierOptions*/): Promise<any> {
            if (this[_init]) {
                this[_init] = false;
                let success = await this.storeSource.ready();
                if (success) {
                    this._create();
                    this.storeSource.on(EventType.Dirty, this._update, this);
                }
                return success;
            }
            return this.storeSource.ready();
        }
               
        public release(): void {
            this.dashboard.requestBuilder.popModifier(this);
            this.storeSource.off(EventType.Dirty, this._update, this);
        }
    }

    type IZone = Dashboards.IZone<Dashboards.ZoneType.radius> | 
        Dashboards.IZone<Dashboards.ZoneType.isodistance> |
        Dashboards.IZone<Dashboards.ZoneType.isochrone> |
        Dashboards.IZone<Dashboards.ZoneType.predefined> |
        Dashboards.IZone<Dashboards.ZoneType.surrounding> |
        Dashboards.IZone<Dashboards.ZoneType.bulkMail>;

    export class StoreSourceLoader extends StoreSourceListener implements Rest.IContextModifier {
        public readonly creator: ResourceSubstitute;
        
        constructor(dashboard: Dashboards.IDashboard, storeSource: AFC.Data.StoreSource) {
            super(dashboard, storeSource);
            this.creator = new ResourceSubstitute(dashboard.requestBuilder, storeSource.fullName);
        }
        
        protected override _create(): void {
            let storeSource = this.storeSource,
                context = storeSource.generateContext(),
                sites = context.target,
                branchInfo;
                
            if (storeSource.isHistoricized) {
                branchInfo = storeSource.branchInfo;
            }
            branchInfo || sites.events ?
                this.creator.create(new AFC.Data.ModificationCreation(sites.reference, sites.events, branchInfo)):
                this.creator.replacement = sites.reference;
        }
                
        protected override _update(event: AFC.Data.IDataEvent): void {
            let data = event.data;
            
            if (data && (data.reset || data.items.every(item => item.committed))) {
                let tableName = this.creator.reference.toUpperCase();
                
                this[_init] = true;
                this.storeSource.off(EventType.Dirty, this._update, this);
                this.dashboard.invalidateViews();
                this.dashboard.clusters.forEach(cluster => {
                    cluster.zones.forEach((zone: IZone) => {
                        switch (zone.type) {
                            case Dashboards.ZoneType.radius:
                            case Dashboards.ZoneType.isodistance:
                            case Dashboards.ZoneType.isochrone:
                                let sitesTable = zone.reference.sitesTable;

                                if (sitesTable && sitesTable.table.toUpperCase() === tableName && (event.data.reset || event.data.items.some(item => {
                                    let column = this.storeSource.columnIndex[sitesTable.codecolumn];

                                    if (item.row[column] === cluster.current) {
                                        return true;            //item.values.hasOwnProperties(zone.perSiteConfiguration) || geometry;
                                    }
                                }))) {
                                    zone.invalidate(true);      // should be false when geometry
                                }
                                break;
                        }
                    });
                });
            }
        }
        
        public override updateBody(body: AFC.Dashboards.IDashboardContextData/*, options?: Dashboards.IDashboardContextModifierOptions*/): void {
            this.creator.updateBody(body);
        }
        
        public release(): void {
            this.creator.release();
            super.release();
        }
    }

    const enum SimulationStatus {
        none = 0,
        pending,
        ready,
        dirty
    }
    
    interface IDMALoaderZone extends ResourceSubstitute {
        readonly zone: Dashboards.IZone<Dashboards.ZoneType.predefined>;
        load(reset?: boolean): Promise<void>;
    }
    
    function _checkValues(item: AFC.Data.IDataEventItem & {values: {[key: string]: any}}, columns: ReadonlyArray<string>): boolean {
        return item.type !== AFC.Data.DataEventType.none &&
            (item.type !== AFC.Data.DataEventType.modify || !columns || !item.values || columns.some(column => item.values.hasOwnProperty(column)));
    }
    
    export class DMALoader extends EventSinkMixin(StoreSourceListener) implements Rest.IContextModifier {
// <editor-fold defaultstate="collapsed" desc="DMALoader._Zone">
        private static _Zone = class extends ResourceSubstitute implements IDMALoaderZone {
            public readonly zone: Dashboards.IZone<Dashboards.ZoneType.predefined>;
            public readonly loader: DMALoader;

            constructor(loader: DMALoader, dataCreator: Rest.DataCreator, zone: Dashboards.IZone<Dashboards.ZoneType.predefined>) {
                super(dataCreator, zone.reference.areaTable);
                this.loader = loader;
                this.zone = zone;
            }

            public async load(reset?: boolean): Promise<void> {
                const zone = this.zone,
                    [simulation] = await Promise.all([this.loader._simulate(), reset && await zone.district.reset()]);
                this.create(simulation.area);
                zone.invalidate(true);
            }
        };
// </editor-fold>
        
        public readonly dmaModel: TradeArea.DMAConfigModel;
        public readonly confirm: () => Promise<boolean>;
        public readonly zone: IDMALoaderZone;
        public readonly income: ResourceSubstitute;
        public readonly impact: ResourceSubstitute;
        public readonly neighbors: ResourceSubstitute;
        private _status: SimulationStatus;
        private _pending: boolean;
        private _columns: ReadonlyArray<string>;
        private _reaffectStorage: Dashboards.IReaffectStorage;

        constructor(dashboard: Dashboards.IDashboard, storeSource: AFC.Data.StoreSource, dmaModel: TradeArea.DMAConfigModel, options: IDMAReplacementOptions) {
            let requestBuilder = dashboard.requestBuilder;
            
            super(dashboard, storeSource);
            this.dmaModel = dmaModel;
            if (options) {
                options.confirm && (this.confirm = options.confirm);
                options.zone && (this.zone = new DMALoader._Zone(this, requestBuilder, options.zone));
                options.income && (this.income = new ResourceSubstitute(requestBuilder, options.income.reference.sitesTable.table));
                options.impact && (this.impact = new ResourceSubstitute(requestBuilder, options.impact));
                options.neighbors && (this.neighbors = new ResourceSubstitute(requestBuilder, options.neighbors));
                options.descriptor?.dataInput?.some(dataInput => {
                    if (!storeSource.fullName.localeCompare(dataInput.table, undefined, { sensitivity: 'accent' })) {
                        this._columns = dataInput.columns;
                        return true;
                    }
                });
            }
        }

        private _off(): void {
            this._reaffectStorage?.off(Tools.EventType.Dirty, this._onReset, this);        
        }
        
        private _onReset(event: Tools.IEvent<Dashboards.IReaffectStorage, ReadonlyArray<Dashboards.IDistrictOperation>>): void {
            event.data.some(operation => operation.type === Dashboards.OperationType.reset) && (this._status = SimulationStatus.none);
        }
        
        protected override async _update(event: AFC.Data.IDataEvent): Promise<void> {
            // check for columns match ...
            let data = event.data;
            
            if (data) {
                if (data.reset || (data.items.reduce((acc, item) => {
                        this._pending = this._pending || _checkValues(<any> item, this._columns);
                        return acc && item.committed;
                    }, true) && this._pending)) {
                    delete this._pending;
                    this._status = SimulationStatus.dirty;
                }
            }
        }
        
        public override updateBody(body: Dashboards.IDashboardContextData, options?: Dashboards.IDashboardContextModifierOptions): any {
            this.zone && this.zone.updateBody(body);
            this.income && this.income.updateBody(body);
            this.impact && this.impact.updateBody(body);
            this.neighbors && this.neighbors.updateBody(body);
        }
        
        public async load(options?: Dashboards.IDashboardContextModifierOptions): Promise<void> {
            if (this._status !== SimulationStatus.ready) {
                await super.load();
                if (!options || options.districtType !== Dashboards.DistrictType.base) {
                    return new Promise(async resolve => {
                        const reset = this._status === SimulationStatus.dirty,
                            zone = this.zone;
                        
                        this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/) => resolve());
                        if (reset) {
                            this._status = SimulationStatus.none;
                        }
                        if (!this._status) {
                            this._status = SimulationStatus.pending;
                            if (!reset || !this.confirm || await this.confirm()) {
                                if (zone) {
                                    this._off();
                                    await zone.load(reset);
                                    
                                    // bug work around: as ReaffectEditableStorage is not fully implemented, reload zone when reset occur
                                    zone.zone.getReaffectStorage().then(reaffectStorage => reaffectStorage && (this._reaffectStorage = reaffectStorage).on(Tools.EventType.Dirty, this._onReset, this));
                                } else {
                                    await this._simulate();
                                }
                            }
                            this._status = SimulationStatus.ready;
                            this.fireEvent(Tools.EventType.UserEvent);
                        }
                    });
                }
            }
        }

        protected async _simulate(): Promise<TradeArea.IDMASimulation> {
            let dmaModel: TradeArea.DMAConfigModel = this.dmaModel,
                context: TradeArea.IDMAContext = this.storeSource.generateContext(),
                simulation: TradeArea.IDMASimulation;

            dmaModel.source.sites = context.source;
            dmaModel.target.sites = context.target;
            await dmaModel.simulate();
            simulation = dmaModel.target;
            this.income && this.income.create(simulation.income);
            this.impact && dmaModel.impactTable.columns && this.impact.create(dmaModel.impactTable);
            this.neighbors && this.neighbors.create(simulation.neighbors);
            return simulation;
        }
                
        public release(): void {
            this._off();
            this.impact && this.impact.release();
            this.neighbors && this.neighbors.release();
            this.income && this.income.release();
            this.zone && this.zone.release();
            super.release();
        }        
    }
    
    export class TrafficLoader extends EventSinkMixin(StoreSourceLoader) implements Rest.IContextModifier {
        protected _confirm: (callback: (update: boolean)=> void)=> any;
        protected _workingArea: ResourceSubstitute;
        protected _livingArea: ResourceSubstitute;
        protected _trafficStatistics: ResourceSubstitute;
        protected _status: Traffic.TrafficStatus;
        protected _trafficModel : Traffic.TrafficModel;
        protected _dashboard: Dashboards.IDashboard;
        protected _cluster: string;
                
        constructor(dashboard: Dashboards.IDashboard, storeSource: AFC.Data.StoreSource, restModel: Rest.RestModel, options?: ITrafficReplacementOptions) {
            super(dashboard, storeSource);
            this._trafficModel = new Traffic.TrafficModel(restModel);
            this._status = Traffic.TrafficStatus.none;
            
            let clusterId = ""    ;
            if (options) {
                options.confirm && (this._confirm = options.confirm);
                if (options.workingZone) {
                    this._workingArea       = new ResourceSubstitute(dashboard.requestBuilder, options.workingZone.reference.areaTable);
                    this._trafficStatistics = new ResourceSubstitute(dashboard.requestBuilder, options.workingZone.reference.sitesTable.table);
                    clusterId = options.workingZone.cluster.id;
                    
                    this._trafficModel.infoTableTemplate = options.workingZone.reference.sitesTable.table;
                }
                if (options.livingZone) {
                    this._livingArea        = new ResourceSubstitute(dashboard.requestBuilder, options.livingZone.reference.areaTable);
                    this._trafficStatistics = new ResourceSubstitute(dashboard.requestBuilder, options.livingZone.reference.sitesTable.table);
                    clusterId = options.livingZone.cluster.id;
                    
                    this._trafficModel.infoTableTemplate = options.workingZone.reference.sitesTable.table;
                }
                //this._setDashboardCluster(dashboard, clusterId, options.currentCodeValue);
                this._dashboard = dashboard;
                this._cluster   = clusterId;
                                       
                this._trafficModel.serverKind       = options.customServer;
                this._trafficModel.x                = options.x;
                this._trafficModel.y                = options.y;
                this._trafficModel.currentCodeValue = options.currentCodeValue;
                this._trafficModel.geographicSource = options.geographicSource;
                this._trafficModel.setUseCredit(false, "");
            }
        }
        
        protected _setDashboardCluster(dashboard: Dashboards.IDashboard, clusterId: string, value: string) {
            for (var i = 0; i < dashboard.clusters.length; i++) {
                if (dashboard.clusters[i].id === clusterId) {
                    if (dashboard.clusters[i].current != value)
                        dashboard.clusters[i].current = value;
                    break;
                }
            }
        }
        protected _getDashboardCluster(dashboard: Dashboards.IDashboard, clusterId: string) : string {
            for (var i = 0; i < dashboard.clusters.length; i++) {
                if (dashboard.clusters[i].id === clusterId) {
                    return dashboard.clusters[i].current as string;
                }
            }
            return "";
        }
        
        public updateBody(body: Dashboards.IDashboardContextData): any {
            super.updateBody(body);
            if (!this._trafficModel.isOnError && (this._status == Traffic.TrafficStatus.ready)) {
                this._workingArea && this._workingArea.updateBody(body);
                this._livingArea && this._livingArea.updateBody(body);
                this._trafficStatistics && this._trafficStatistics.updateBody(body);
            }
        }
                
        public forceBuy(pack: string) {
            this._trafficModel.setUseCredit(true, pack);
        }
        public load(): Promise<void> {
            return (this._status === Traffic.TrafficStatus.ready) ? Promise.resolve() : new Promise(async resolve => {
                await super.load();
                this.notify(Tools.EventType.UserEvent, (/*event: Tools.IEvent*/)=> resolve());
                this._trafficModel.request().then((statistics: Traffic.ITrafficStatistics) => {
                    if (!this._trafficModel.isOnError) {
                        this._workingArea && this._workingArea.create(statistics.workingArea);
                        this._livingArea && this._livingArea.create(statistics.livingArea);
                        this._trafficStatistics && this._trafficStatistics.create(statistics.infoTable);
                        
                        this._setDashboardCluster(this._dashboard, this._cluster, statistics.id);
                    } else {
                        /*
                        delete this._workingArea;
                        delete this._livingArea;
                        delete this._trafficStatistics;
                        */
                    }
                    this._trafficModel.setUseCredit(false, "");
                    this._status                    = Traffic.TrafficStatus.ready;
                    
                    this.fireEvent(Tools.EventType.UserEvent);
                });
            });
        }
        
        protected _update(event: AFC.Data.IDataEvent): void {
            let h = (update: boolean) => update && super._update(event);
            this._confirm ? this._confirm(h) : h(true);
        }
        
        public release(): void {
            this._status = Traffic.TrafficStatus.none;
            /*
            this._workingArea && this._workingArea.release();
            this._livingArea && this._livingArea.release();
            this._trafficStatistics && this._trafficStatistics.release();
            */
            super.release();
        }        
    }

    export function setClusterSite(cluster: Dashboards.IZoneCluster, store: AFC.Data.IReadonlyStore): number|string {
        let code: number|string;

        cluster.zones.some((zone: Dashboards.IZone & {reference: {sitesTable: Dashboards.ISitesTable}}) => {
            let sitesTable: Dashboards.ISitesTable = zone.reference.sitesTable;
            return sitesTable && (code = store.getData(sitesTable.codecolumn));
        });
        return cluster.current = code;
    }
    
    interface IPosition {
        readonly columns: number;
        readonly offset: number;
        readonly lines: readonly number[];
    }
    
    function _getMaxValue(i0: number, i1: number): number {
        return i0 === void 0 && i1 === void 0 ? void 0 : Math.max(i0 || 0, i1 || 0);
    }
    
    class RowIndex {
        protected _index: {[key: string]: number};
        protected _length: number;
        
        constructor() {
            this._index = {};
            this._length = 0;
        }
        
        public get(key: string): number {
            return this._index[key];
        }
        
        public add(key: string): number {
            return this._index[key] = this._length++;
        }
    }
       
    class SheetColumns {
        public readonly lines: number[];
        public readonly columnHeaders: readonly Globals.ITemplateSheetColumnHeader[];
        public readonly classes: {[key: string]: string};
        public readonly classCount: number;
        public readonly cells: Globals.ITemplateSheetCell[][];
        
        constructor(metadataIn: Readonly<Globals.ITemplateSheet>, rowIndex: RowIndex, cellTemplates: Globals.ITemplateSheetCell[], metadataOut: Globals.ITemplateSheet, classCount: number) {
            let columnHeadersIn = metadataIn.columnHeaders,
                rowHeadersIn = metadataIn.rowHeaders,
                imagesIn = metadataIn.images,
                classesIn = metadataIn.classes,
                columnHeadersOut = metadataOut.columnHeaders,
                rowHeadersOut = metadataOut.rowHeaders,
                imagesOut,
                classesOut: {[key: string]: Globals.ITemplateSheetClass;},
                lines: number[];
            
            this.classCount = 0;
            if (rowHeadersIn.items.length && columnHeadersIn.items.length) {
                this.cells = metadataIn.items;
                this.lines = lines = [];
                if (imagesIn) {
                    imagesOut = metadataOut.images || (metadataOut.images = {});
                    for (let image in imagesIn) {
                        imagesOut[image] = imagesIn[image];
                    }
                }
                if (classesIn) {
                    classesOut = metadataOut.classes || (metadataOut.classes = {});
                    this.classes = {};
                    for (let item in classesIn) {
                        let name = `c${classCount + this.classCount++}`;
                        classesOut[this.classes[item] = name] = classesIn[item];
                    }
                }                
                
                columnHeadersOut.visibility = columnHeadersOut.visibility || columnHeadersIn.visibility;
                columnHeadersOut.height = _getMaxValue(columnHeadersOut.height, columnHeadersIn.height);                
                this.columnHeaders = columnHeadersIn.items.map(cell => this.getCell(cell));
                
                rowHeadersOut.visibility = rowHeadersOut.visibility || rowHeadersIn.visibility;
                rowHeadersOut.width = _getMaxValue(rowHeadersOut.width, rowHeadersIn.width);
                rowHeadersIn.items.forEach((rowHeader: Globals.ITemplateSheetRowHeader, y: number) => {
                    let pos: number = rowIndex.get(rowHeader.value),
                        cellTemplate: Mutable<Globals.ITemplateSheetCell>;

                    if (pos === void 0) {
                        pos = rowIndex.add(rowHeader.value);
                        rowHeadersOut.items.push(this.getCell(rowHeader));
                        cellTemplate = this.getCell(metadataIn.items[y][0]);
                        cellTemplate.format = void 0;
                        cellTemplate.value = '-';
                        cellTemplates.push(cellTemplate);
                    }
                    lines[pos] = y;
                });
            }
        }

        public get length(): number {
            return (this.lines && this.lines.length) || 0;
        }
        
        // append rowheaders, images and classes, build column headers
        public appendSheet(cellTemplates: Globals.ITemplateSheetCell[], views: AFC.Dashboards.ISheet<AFC.Dashboards.ViewType.spreadSheet | AFC.Dashboards.ViewType.aggregatedSheet>[], sheet: number, positions: IPosition[], properties: Globals.ITemplateSheet): void {
            let columnHeaders = properties.columnHeaders.items,
                nbRow: number = properties.rowHeaders.items.length,
                cells = properties.items;
            
            for (let row = 0; row < nbRow; ++row) {
                let y = this.lines[row];
                this.columnHeaders.forEach((header: Globals.ITemplateSheetColumnHeader, x: number) => {
                    let cell: Globals.ITemplateSheetCell;
                   
                    row || (positions.push({columns: sheet, offset: x, lines: (this.lines.length = nbRow, this.lines)}), columnHeaders.push(header));
                    if (y !== void 0) {
                        cell = this.getCell(this.cells[y][x]);
                    }
                    (cells[row] || (cells[row] = [])).push(cell || cellTemplates[row]);
                });
            }
        }
        
        public getCell<T extends Globals.ITemplateSheetCell | Globals.ITemplateSheetColumnHeader | Globals.ITemplateSheetRowHeader>(cell: Mutable<T>): Mutable<T> {
            if (cell.className) {
                let clone: Mutable<T> = Object.create(cell);
                clone.className = this.classes[cell.className];
                return clone;
            }
            return cell; 
        }        
    }
            
    function _analyze(results: Readonly<{id: string; sheetProperties: Globals.ITemplateSheet}>[], celltemplates: Globals.ITemplateSheetCell[], properties: Globals.ITemplateSheet): ReadonlyArray<{sheet: number, columns: SheetColumns}> {
        let index: {[key: string]: SheetColumns;} = {},
            rowIndex = new RowIndex(),
            content: {sheet: number, columns: SheetColumns}[],
            classCount: number = 0;
                
        results.map((result, indice) => {
            let columns = index[result.id];
            if (!columns) {
                index[result.id] = columns = new SheetColumns(result.sheetProperties, rowIndex, celltemplates, properties, classCount);
                classCount += columns.classCount;
            }
            columns.length && (content || (content = [])).push({sheet: indice, columns: columns});
        });
        return content;
    }
   
    function _buildProperties(results: Readonly<Dashboards.ISheetMetadata>[], views: AFC.Dashboards.ISheet<AFC.Dashboards.ViewType.spreadSheet | AFC.Dashboards.ViewType.aggregatedSheet>[], positions: IPosition[]): Globals.ITemplateSheet {
        let celltemplates: Globals.ITemplateSheetCell[] = [],
            properties: Globals.ITemplateSheet = {
                columnHeaders: {
                    visibility: false,
                    items: []
                },
                items: [],
                rowHeaders: {
                    visibility: false,
                    items: []
                }
            },
            analysis = _analyze(results, celltemplates, properties);
        
        analysis.forEach(item => {
            item.columns.appendSheet(celltemplates, views, item.sheet, positions, properties);
        });
        return properties;
    }    

    class GridAppAggregate extends Dashboards.MetaGridApp {
        public readonly positions: IPosition[];
        public readonly allowOrdering: boolean = false;
        public readonly data: Readonly<Globals.IDataSheet>[];

        constructor(template: Globals.ITemplateSheet, positions: IPosition[], data: Readonly<Globals.IDataSheet>[]) {
            super(template, false);
            this.positions = positions;
            this.data = data;
        }
        
        public getRowCount(): number {
            return this.template.items.length;
        }
        
        public getRowHeader(line: number): Globals.IGridAppCell {
            let item = this.template.rowHeaders.items[line];
            return this._getCellEx(item, item.value, item.text);
        }
        
        public getRowHeaderWidth(): number {
            return this.template.rowHeaders.width;
        }
        
        public getRowHeight(line: number): number {
            return this.template.rowHeaders.items[line].height;
        }
        
        public getColumnInfo(column: number): Globals.IGridAppColumnInfo {
            return;
        }
        
        public getColumnHeader(column: number): Globals.IGridAppCell {
            let item = this.template.columnHeaders.items[column],
                value,
                position, data;
                
            if (item.dynamic) {
                position = this.positions[column];
                value = (data = this.data[position.columns]) && data.columnHeaders.items[position.offset]?.value;
            } else {
                value = item.value;
            }
            return this._getCellEx(item, value, item.text);
        }
        
        public getColumnHeaderHeight(): number {
            return this.template.columnHeaders.height;
        }
        
        public getColumnWidth(column: number): number {
            return this.template.columnHeaders.items[column].width;
        }
        
        public getCell(column: number, line: number): Globals.IGridAppCell {
            let item = this.template.items[line][column],
                value,
                position, indice, data;
                
            if (item.dynamic) {
                position = this.positions[column];
                if ((data = this.data[position.columns]) && ((indice = position.lines[line]) !== void 0)) {
                    value = data.items[indice][position.offset]?.value;
                }
            } else {
                value = item.value;
            }
            return this._getCellEx(item, value, item.text);
        }
        
        public getValue(column: string, line: number): number|string {
            return;
        }
    }
    
    export class DashboardsAggregate extends EventSink implements AFC.Dashboards.IGridModel {
        protected _dashboards: ReadonlyArray<Dashboards.IDashboard>;
        protected _id: string;
        protected _gridApp: GridAppAggregate;
        protected _sheets: ReadonlyArray<AFC.Dashboards.ISheet<AFC.Dashboards.ViewType.spreadSheet | AFC.Dashboards.ViewType.aggregatedSheet>>;
        protected _data: Readonly<Globals.IDataSheet>[];
        
        /* Obsolete : for compatibility only */
        public getType(): Promise<AFC.Dashboards.ViewType> {
            return Promise.resolve(AFC.Dashboards.ViewType.aggregatedSheet);
        }
        public readonly properties: ReadonlyArray<AFC.Dashboards.IDashboardProperty>;
        public readonly dashboard: AFC.Dashboards.IDashboard;
        public dashboardModel: AFC.Dashboards.DashboardModel;
      
        public getForeignDataModel(): AFC.Data.IDataModel {
            return;
        }
        
        public getLegendImage(width: number, height: number, horizontal: boolean, quality?: number): Promise<string|void> {
            throw new Error('not implemented');
        }
        /* End Obsolete */

        protected _onAttach(): void {
            this.fireEvent(EventType.Dirty);
        }
                
        constructor() {
            super();
            this.on(EventType.Attach, this._onAttach, this);
        }
        
        protected _releaseView(view: Dashboards.IView): void {
            view.dashboard.off(Tools.EventType.Dirty, this._onDirty, this);
        }
        
        protected _loadViewData(sheet: AFC.Dashboards.ISheet<AFC.Dashboards.ViewType.spreadSheet | AFC.Dashboards.ViewType.aggregatedSheet>, indice: number): void {
            let data = this._data;
            
            delete data[indice];
            sheet.getData().then((d: Readonly<Globals.IDataSheet>) => {
                if (data === this._data) {
                    let columns: number[] = [],
                        gridApp = this._gridApp;

                    data[indice] = d;
                    if (gridApp) {
                        gridApp.positions.forEach((position, column) => position.columns === indice && columns.push(column));
                        this.fireEvent(Tools.EventType.Dirty, columns);
                    }
                }
            });
        }
        
        protected _onDirty(e: Tools.IEvent): void {
            let dashboard = <Dashboards.IDashboard>e.target;
            
            this._sheets && this._sheets.forEach((sheet, indice) => {
                if (sheet.dashboard === dashboard) {
                    this._loadViewData(sheet, indice);
                }
            });
        }
               
        public _clear(): void {
            if (this._gridApp) {
                this._sheets.forEach(this._releaseView.bind(this));
                delete this._gridApp;
            }
            delete this._sheets;
            delete this._data;
            this.fireEvent(EventType.Attach);
        }
        
        public setId(value: string): void {
            if (value !== this._id) {
                this._id = value;
                this._clear();
            }
        }
        
        public get id(): string {
            return this._id;
        }
        
        public get label(): string {
            return this._id;
        }
        
        public set dashboards(value: ReadonlyArray<AFC.Dashboards.IDashboard>) {
            if (value !== this._dashboards) {
                this._dashboards = value;
                this._clear();
            }
        }
        
        public get dashboards(): ReadonlyArray<AFC.Dashboards.IDashboard> {
            return this._dashboards;
        }
        
        public async getGridApp(): Promise<Globals.IGridApp> {
            let dashboards: ReadonlyArray<Dashboards.IDashboard>, id: string;
            return this._gridApp || ((dashboards = this._dashboards) && dashboards.length && (id = this._id) && new Promise(resolve => {
                this.notify(Tools.EventType.UserEvent, () => resolve(this._gridApp));
                if (!this._sheets) {
                    let positions: IPosition[] = [],
                        data: Readonly<Globals.IDataSheet>[] = [],
                        sheets: AFC.Dashboards.ISheet<AFC.Dashboards.ViewType.spreadSheet | AFC.Dashboards.ViewType.aggregatedSheet>[] = [],
                        promises: Promise<Readonly<Dashboards.ISheetMetadata>>[] = [];
                        
                    this._sheets = sheets;
                    this._data = data;
                    dashboards.forEach((dashboard, indice) => {
                        let view = <AFC.Dashboards.ISheet>Tools.findByIdOrName(id, dashboard.views, view => (view.type === AFC.Dashboards.ViewType.aggregatedSheet) || (view.type === AFC.Dashboards.ViewType.spreadSheet));
                        if (view) {
                            promises.push(view.getMetadata());
                            view.dashboard.on(Tools.EventType.Dirty, this._onDirty, this);
                            sheets.push(view);
                            this._loadViewData(view, indice);
                        }
                    });
                    
                    Promise.all(promises).then(results => {
                        if (this._sheets === sheets) {
                            this._gridApp = new GridAppAggregate(_buildProperties(results, sheets, positions), positions, data);
                            this.fireEvent(Tools.EventType.UserEvent);
                        }
                    });
                }
            }));
        }
    }
}