/**
 * Created by jean.rennes on 03/02/2016.
 */
///<reference path="../AFC.ts" />
///<reference path="EventSink.ts" />

namespace AFC.Tools {
    const _disabled = Symbol(),
        _muted = Symbol(),
        _dirty = Symbol(),
        _refresh = Symbol(),
        _update = Symbol();

    function _doUpdate<Model extends Partial<INotifier>>(adapter: AdapterBase<Model>, event?: Tools.IEvent): void {
        adapter[_dirty] = true;
        adapter[_update](event);
    }

    export abstract class AdapterBase<Model extends Partial<INotifier>> extends Tools.EventSink {
        /** @internal */        
        protected [_disabled]: boolean;
        /** @internal */        
        protected [_muted]: boolean;
        /** @internal */        
        public [_dirty]: boolean;
        protected _model: Model;

        public static disable<Model extends Partial<INotifier>>(adapter: AdapterBase<Model>, value: boolean): void {
            value = !!value;
            if (!adapter[_disabled] === value) {
                adapter[_disabled] = value;
                adapter[_update]();
            }
        }
        
        constructor() {
            super();
        }
        
        /** @internal */        
        public [_update](event?: Tools.IEvent): void {
            if (this.ready && this[_dirty]) {
                this._update(this.model, event);
                delete this[_dirty];
            }
        }
        
        /** @internal */        
        private [_refresh](): void {
            this.once(Tools.EventType.Attach, (e: IEvent<this, Model[]>) => {
                let model = e?.data.find(model => model === this.model);
                
                if (model) {
                    _doUpdate(this);
                    model?.on && model.on(Tools.EventType.Dirty, this._onDirty, this);
                }
            }, _doUpdate, this);
            this.fireEvent(Tools.EventType.Attach, [this.model]);
        }

        public set mute(value: boolean) {
            value = !!value;
            if (this.mute !== value) {
                this[_muted] = value;
                this[_update]();
            }
        }

        public get model(): Model {
            return this._model;
        }

        public get mute(): boolean {
            return !!this[_muted];
        }

        public get ready(): boolean {
            return !this[_muted] && !this[_disabled];
        }

        protected abstract _update(model: Model, event?: Tools.IEvent): void;

        protected _onDirty(event?: Tools.IEvent<Required<Model>>): void {
            event?.target === this._model && _doUpdate(this, event);
        }

        public bindTo(model: Model):void {
            if (model !== this.model) {
                this.unbind();
                model && (this._model = model);
                this[_refresh]();
            }
        }

        public unbind():void {
            let model: Model = this.model;
            if (model) {
                delete this._model;
                model.off && model.off(Tools.EventType.Dirty, this._onDirty, this);
            }
        }
        
        public refresh(): void {
            this.model && this[_refresh]();
        }
    }
};
