namespace AFC.Tools {
    const _pendings = Symbol();
    
    export const enum MutexState {
        acquired,
        e_cancelled
    }
    
    export class Mutex {
        /* lock */
        public acquire(): Promise<MutexState> {
            return new Promise(resolve => {
                let pendings = this[_pendings];
                if (pendings) {
                    pendings.push(resolve);
                } else {
                    this[_pendings] = [];
                    resolve(MutexState.acquired);
                }
            });
        }
        
        /* Unlock */
        public release(): void {
            let pendings = this[_pendings];
            
            if (pendings && pendings.length) {
                pendings.shift()(MutexState.acquired);
            } else {
                delete this[_pendings];
            }
        }

        /* Cancel pending locks */
        public cancel(): void {
            let pendings = this[_pendings];
            if (pendings) {
                pendings.forEach(pending => pending(MutexState.e_cancelled));
                this[_pendings] = [];
            }
        }

        /* Check if lock is acquired */
	public isLocked(): boolean {
            return !!this[_pendings];
	}
                        
        /** @internal */
        private [_pendings]?: ((state: MutexState)=> void)[];
    }
}