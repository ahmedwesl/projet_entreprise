///<reference path="../AFC.ts" />

namespace AFC.Tools {
    interface ICommandFunc { (params: any): void; }
    interface IItemCommandHistory { cmdRollback: ICommandFunc, cmdCommit: ICommandFunc }
    interface IExecCommandFunc { (command: ICommandFunc): void; }

    /**
     * Helper for command history, stack list of actions, enable to undo or redo stacked commands.
     */
    export class CommandHistoryHelper {
        private _currentCommitDone = false;
        private _currentRollbackDone = false;
        private _cursor: number = 0;
        private _stackCommands: IItemCommandHistory[] = [];
        private _execCommand: IExecCommandFunc;

        constructor(execCommand: IExecCommandFunc) {
            this._execCommand = execCommand;
        }

        public undo = this.undoCommand; // aliases
        public redo = this.redoCommand;

        /**
         * Get command at given index
         * @param index The command index, if null, index = cursor
         * @returns 
         */
        public getCommand(index?: number): IItemCommandHistory {
            return this._stackCommands[index ?? this._cursor];
        }

        /**
         * Allow update of last command, in case of action wasnt finished yet, and one command is a succession of multiple actions (eg. mousedown while painting)
         * @param command The updated command
         * @param index The command index, if null, index = cursor
         */
        public updateLastCommand(command: IItemCommandHistory, index?: number): void {
            this._stackCommands[index ?? this._cursor] = command;
        }

        /**
         * Add a command item to history stack at cursor index, then reset all next actions (clean redos after undo > new action).
         * @param commandItem The command to be added to the stack, must contain rollback and commit callbacks. 
         */
        public addCommand(commandItem: IItemCommandHistory): void {
            let atCursor;
            
            if (this._currentRollbackDone) {
                atCursor = this._cursor === 0 ? 0 : this._cursor;
            } else {
                atCursor = this._cursor + 1;
            }

            this._stackCommands.splice(atCursor, this._stackCommands.length, commandItem); // Resets all redos !
            this._cursor = this._stackCommands.length - 1;
            this._currentRollbackDone = false;
            this._currentCommitDone = true;
        }

        /**
         * Can redo if stack is not empty and current box' commit callback not already done
         * @returns true if can redo action (not already comitted), false otherwise
         */
        public canRedo(): boolean {
            return !(this._cursor === this._stackCommands.length - 1 && this._currentCommitDone);
        }

        /**
         * Can redo if stack is not empty and current box' commit callback not already done
         * @returns true if can undo action (not already rollbacked), false otherwise
         */
        public canUndo(): boolean {
            return !(this._cursor === 0 && this._currentRollbackDone);
        }

        /**
         * Undo command if exists, call previous item's cmdRollback function. If only one item, call self rollback.
         */
        public undoCommand(): void {
            if (this.canUndo()) {
                if (this._currentRollbackDone && this._cursor - 1 >= 0) {
                    this._cursor--;
                }

                this.execCommand(this._stackCommands[ this._cursor ].cmdRollback);

                this._currentRollbackDone = true;
                this._currentCommitDone = false;
            }
        }

        /**
         * Redo command if exists, call next item's cmdCommit function. If only one item, call self commit.
         */
        public redoCommand(): void {
            if (this.canRedo()) {
                if (this._currentCommitDone && this._cursor + 1 < this._stackCommands.length) {
                    this._cursor++;
                }

                this.execCommand(this._stackCommands[ this._cursor ].cmdCommit);

                this._currentCommitDone = true;
                this._currentRollbackDone = false;
            }
        }

        /**
         * Execute callback function.
         * @param command The callback function that will apply state according to triggered action (redo or undo).
         */
        public execCommand(command: ICommandFunc): void {
            this._execCommand(command);
        }
    }
};
