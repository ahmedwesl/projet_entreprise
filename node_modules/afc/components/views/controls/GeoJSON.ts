///<reference types="leaflet" />

namespace AFC.Controls {
    const _highlightKeys = Symbol(),
        _highlighted = Symbol(),
        _index = Symbol(),
        _keyProvider = Symbol();
    
    export interface IGeoJSON<K extends Globals.LayerType, P extends Globals.IGeoJsonProperties> extends L.LayerGroup<P> {
        addData(data: GeoJSON.GeoJsonObject | ReadonlyArray<GeoJSON.GeoJsonObject>): this;
        getLayers(): Globals.LayerForLayerType<K, P>[];
        removeLayer(layer: number | Globals.LayerForLayerType<K, P>): this;
        clearLayers(): this;
        highlight(keys?: ReadonlyArray<any>[]): void;
        findItem(key: ReadonlyArray<any>): Globals.LayerForLayerType<K, P>;
        //addLayer(layer: Globals.LayerForLayerType<K, P>): this;
        //getLayer(id: number): Globals.LayerForLayerType<K, P>;
        //setStyle(style: L.PathOptions | L.StyleFunction<P>): this;
        options: L.GeoJSONOptions<P, Globals.GeometryForLayerType[K]>;
    }
    
    export interface GeoJSONOptions<P extends Globals.IGeoJsonProperties = Globals.IGeoJsonProperties> extends L.GeoJSONOptions<P> {
        minZoom?: number;
        maxZoom?: number;
    }

    export interface GeoJSON<K extends Globals.LayerType, P extends Globals.IGeoJsonProperties> extends IGeoJSON<K, P>, L.GeoJSON<P, Globals.GeometryForLayerType[K]> {
        readonly getGeometryFromResult: never;
        addData(data: GeoJSON.GeoJsonObject | ReadonlyArray<GeoJSON.GeoJsonObject>): this;
        addLayer(layer: Globals.LayerForLayerType<K, P>): this;
        getLayer(id: number): Globals.LayerForLayerType<K, P>;
        getLayers(): Globals.LayerForLayerType<K, P>[];
        removeLayer(layer: number | Globals.LayerForLayerType<K, P>): this;
    }

    declare class GeoJSONImpl<K extends Globals.LayerType, P extends Globals.IGeoJsonProperties> extends L.GeoJSON<P> implements GeoJSON<K, P> {
        /** @internal */
        private [_index]: Globals.LayerForLayerType<K, P>[];
        /** @internal */
        private [_keyProvider]: Data.IKeyProvider & Data.IColumnIndexProvider;
        /** @internal */
        private [_highlightKeys]: ReadonlyArray<any>[];
        /** @internal */
        private [_highlighted]: Globals.LayerForLayerType<K, P>[];
        
        protected _resetView(): void;
        protected _layers: {[key: string]: L.Layer};
        protected _onEachFeature(feature: GeoJSON.Feature<Globals.GeometryForLayerType[K], P>, layer: L.Layer): void;
        
        readonly getGeometryFromResult: never;        
        public options: GeoJSONOptions<P>;
        public isVisible(): boolean;
        public addData(data: GeoJSON.GeoJsonObject | ReadonlyArray<GeoJSON.GeoJsonObject>): this;
        public addLayer(layer: Globals.LayerForLayerType<K, P>): this;
        public getLayer(id: number): Globals.LayerForLayerType<K, P>;
        public getLayers(): Globals.LayerForLayerType<K, P>[];
        public getEvents(): {[name: string]: L.LeafletEventHandlerFn};
        public removeLayer(layer: number | Globals.LayerForLayerType<K, P>): this;
        public clearLayers(): this;
        public setStyle(style: L.PathOptions | L.StyleFunction<P>): this;
        public highlight(keys?: ReadonlyArray<any>[]): void;
        public findItem(key: ReadonlyArray<any>): Globals.LayerForLayerType<K, P>;
    }
    
    function _highlight<K extends Globals.LayerType, L extends Globals.LayerForLayerType<K> & {bringToFront?: ()=>any;setStyle?: (style: L.PathOptions)=> any}>(layer: L): L {
        if (layer) {
            if (layer.bringToFront) {
                let element = <HTMLElement>layer.getElement();
                layer.bringToFront();
                element ? L.DomUtil.addClass(element, 'Selected') : layer.setStyle({className: 'Selected'});
            }
            return layer;
        }
    }    
    
    const _getOptions = <O extends { minZoom?: number} >(options: O) => $.extend({minZoom: 0}, options);
    
    export const GeoJSON: {
        new <K extends Globals.LayerType = Globals.LayerType, P extends Globals.IGeoJsonProperties = Globals.IGeoJsonProperties> (keyProvider: Data.IKeyProvider & Data.IColumnIndexProvider, geojson?: GeoJSON.GeoJsonObject, options?: L.GeoJSONOptions<P>): GeoJSONImpl<K, P>;
    } = L.GeoJSON.extend({
        initialize: function<K extends Globals.LayerType, P extends Globals.IGeoJsonProperties>(
                this: GeoJSONImpl<K, P>,
                keyProvider: Data.IKeyProvider & Data.IColumnIndexProvider,
                geojson?: GeoJSON.GeoJsonObject,
                options?: GeoJSONOptions<P>): void {
            this[_keyProvider] = keyProvider;
            (<any>L.GeoJSON.prototype).initialize.call(this, geojson, _getOptions(options));
        },
        
        highlight: function<K extends Globals.LayerType, P extends Globals.IGeoJsonProperties>(this: GeoJSONImpl<K, P>, keys?: ReadonlyArray<any>[]): void {
            let highlighted  = this[_highlighted];
            
            if (highlighted) {
                delete this[_highlightKeys];
                delete this[_highlighted];
                highlighted.forEach(layer => {
                    if (layer) {
                        let element = <HTMLElement>layer.getElement();
                        L.DomUtil.removeClass(element, 'Selected');
                    }
                });
            }
            
            if (keys) {
                this[_highlighted] = (this[_highlightKeys] = keys.slice(0).sort(Data.compareKey)).map(key => _highlight(this.findItem(key)));
            }
        },
        
        addLayer: function<K extends Globals.LayerType, P extends Globals.IGeoJsonProperties>(this: GeoJSONImpl<K, P>, layer: Globals.LayerForLayerType<K, P>): GeoJSONImpl<K, P> {
            let indice: number,
                map = this._map;
            
            delete this[_index];
            if (this[_highlightKeys] && ((indice = this[_highlightKeys].findIndex(key => !this[_keyProvider].compareKey(layer.feature.properties.data, key))) !== -1)) {
                this[_highlighted][indice] = layer = _highlight(layer);
            }
            
            this.isVisible() || (this._map = null);
            L.GeoJSON.prototype.addLayer.call(this, layer);
            this._map = map;
            return this;
        },
        
	onAdd: function<K extends Globals.LayerType, P extends Globals.IGeoJsonProperties>(this: GeoJSONImpl<K, P>, map: L.Map): GeoJSONImpl<K, P> {
            this.isVisible() && L.GeoJSON.prototype.onAdd.call(this, map);
            return this;
	},        
        
        removeLayer: function<K extends Globals.LayerType, P extends Globals.IGeoJsonProperties>(this: GeoJSONImpl<K, P>, layer: number | Globals.LayerForLayerType<K, P>): GeoJSONImpl<K, P> {
            delete this[_index];
            return L.GeoJSON.prototype.removeLayer.call(this, layer);
        },

        findItem: function<K extends Globals.LayerType, P extends Globals.IGeoJsonProperties>(this: GeoJSONImpl<K, P>, key: ReadonlyArray<any>): Globals.LayerForLayerType<K, P> {
            let keyProvider: Data.IKeyProvider & Data.IColumnIndexProvider = this[_keyProvider];
            
            if (AFC.Tools.Data.isValidKey(keyProvider, key)) {
                let layers = this[_index] || (this[_index] = this.getLayers()).sort((layer0: Globals.LayerForLayerType<K, P>, layer1: Globals.LayerForLayerType<K, P>)=> keyProvider.compareRow(layer0.feature.properties.data, layer1.feature.properties.data)),
                    compare = (layer: Globals.LayerForLayerType<K, P>, key: any)=> keyProvider.compareKey(layer.feature.properties.data, key),
                    i: number = Tools.lower_bound(layers, key, compare),
                    layer = layers[i];

                if (layer && !compare(layer, key)) {
                    return layer;
                }
            }
        },
        
        isVisible: function<K extends Globals.LayerType, P extends Globals.IGeoJsonProperties>(this: GeoJSONImpl<K, P>): boolean {
            const map = this._map,
                zoom = map ? map.getZoom() : -1,
                options = this.options,
                minZoom = options.minZoom,
                maxZoom = options.maxZoom ?? Number.MAX_SAFE_INTEGER;

            return (zoom >= minZoom) && (zoom <= maxZoom);
        },
        
        _resetView: function<K extends Globals.LayerType, P extends Globals.IGeoJsonProperties>(this: GeoJSONImpl<K, P>): void {
            const layers = this._layers,
                map = this._map;
            
            if (map) {
                for (let i in layers) {
                    const hasLayer = map.hasLayer(layers[i]);
                    if (this.isVisible()) {
                        hasLayer || this.eachLayer(map.addLayer, map);
                    } else {
                        hasLayer && this.eachLayer(map.removeLayer, map);
                    }
                    break;
                }
            }
        },
        
        getEvents: function<K extends Globals.LayerType, P extends Globals.IGeoJsonProperties>(this: GeoJSONImpl<K, P>): {[name: string]: L.LeafletEventHandlerFn} {
            const options = this.options;
            return options.minZoom || (options.maxZoom !== void 0) ? {
                viewreset: this._resetView,
                zoom: this._resetView,
            } : {};
        }
    });
    
    export interface MarkerClusterGroup<P extends Globals.IGeoJsonProperties = Globals.IGeoJsonProperties> extends L.FeatureGroup<P>, IGeoJSON<Globals.LayerType.symbol, P> {
        readonly getGeometryFromResult: never;
        readonly geoJSONOptions: L.GeoJSONOptions<P>;        
        
        addData(data: GeoJSON.GeoJsonObject | ReadonlyArray<GeoJSON.GeoJsonObject>): this;
        addLayer(layer: Globals.Point<P>): this;
        addLayers(layers: Globals.Point<P>[], skipLayerAddEvent?: boolean): this;
        getLayer(id: number): Globals.Point<P>;
        getLayers(): Globals.Point<P>[];
        removeLayer(layer: number | Globals.Point<P>): this;
        zoomToShowLayer(layer: Globals.Point<P>, callback?: () => void): void;
        getVisibleParent(marker: L.Marker | L.CircleMarker): L.Marker;
        setStyle(style: L.PathOptions | L.StyleFunction<P>): this;
        options: L.GeoJSONOptions<P, GeoJSON.Point>;
    }
    
    interface IGeoJSONLayerProviderImpl<P extends Globals.IGeoJsonProperties = Globals.IGeoJsonProperties> extends L.GeoJSON<P> {
        layers: Globals.Point<P>[];
    }
    
    const GeoJSONLayerProvider: {
        new <P extends Globals.IGeoJsonProperties = Globals.IGeoJsonProperties>(options: L.GeoJSONOptions<P>, geojson?: GeoJSON.GeoJsonObject): IGeoJSONLayerProviderImpl;
    } = L.GeoJSON.extend({
	initialize: function<P extends Globals.IGeoJsonProperties>(this: IGeoJSONLayerProviderImpl<P>, options: L.GeoJSONOptions<P>, geojson: GeoJSON.GeoJsonObject): void {
            L.Util.setOptions(this, options);
            this.layers = [];
            if (geojson) {
                this.addData(geojson);
            }
	},
        addLayer: function<P extends Globals.IGeoJsonProperties>(this: IGeoJSONLayerProviderImpl<P>, layer: Globals.Point<P>): IGeoJSONLayerProviderImpl<P> {
            this.layers.push(layer);
            return this;
        }
    });
    
    const _provider = Symbol();
    
    export interface MarkerClusterGroupOptions extends L.MarkerClusterGroupOptions {
        minZoom?: number;
        maxZoom?: number;
    }
    
    declare class MarkerClusterGroupImpl<P extends Globals.IGeoJsonProperties> extends L.MarkerClusterGroup implements MarkerClusterGroup<P> {
        public readonly getGeometryFromResult: never;
        public readonly geoJSONOptions: L.GeoJSONOptions<P>;        
        /** @internal */
        private [_index]: Globals.LayerForLayerType<Globals.LayerType.symbol, P>[];
        /** @internal */
        private [_keyProvider]: Data.IKeyProvider & Data.IColumnIndexProvider;
        /** @internal */
        private [_provider]: IGeoJSONLayerProviderImpl;

        protected _resetView(): void;
        protected _featureGroup: L.FeatureGroup & {
            _map: L.Map;
        }
        protected _nonPointGroup: L.FeatureGroup & {
            _map: L.Map;
        }        
        
        public isVisible(): boolean;        
        public initialize(clusterOptions?: MarkerClusterGroupOptions, options?: L.GeoJSONOptions<P>): void;
        public addData(data: GeoJSON.GeoJsonObject | ReadonlyArray<GeoJSON.GeoJsonObject>): this;
        public getLayer(id: number): Globals.Point<P>;
        public getLayers(): Globals.Point<P>[];
        public setStyle(style: L.PathOptions | L.StyleFunction<P>): this;
        public findItem(key: ReadonlyArray<any>): Globals.Point<P>;
        public highlight(keys?: ReadonlyArray<any>[]): void;
    }
        
    export const MarkerClusterGroup: {
        new <P extends Globals.IGeoJsonProperties = Globals.IGeoJsonProperties> (keyProvider: Data.IKeyProvider & Data.IColumnIndexProvider, clusterOptions?: MarkerClusterGroupOptions, options?: L.GeoJSONOptions<P>): MarkerClusterGroupImpl<P>;
    } = L.MarkerClusterGroup.extend({
        initialize: function<P extends Globals.IGeoJsonProperties>(this: MarkerClusterGroupImpl<P>, keyProvider: Data.IKeyProvider & Data.IColumnIndexProvider, clusterOptions?: MarkerClusterGroupOptions, options?: L.GeoJSONOptions<P>): void {
            (<any>L.MarkerClusterGroup.prototype).initialize.call(this, _getOptions(clusterOptions));
            this[_keyProvider] = keyProvider;
            this[_provider] = new GeoJSONLayerProvider(options);
            const _this = this,
                _addTo = this._featureGroup.addTo;
            
            this._featureGroup.addTo = this._nonPointGroup.addTo = function(map: L.Map) {
                if (_this.isVisible()) {
                    _addTo.call(this, map);
                }
                return this;
            };
        },
        
        highlight: function<P extends Globals.IGeoJsonProperties>(this: MarkerClusterGroupImpl<P>, keys?: ReadonlyArray<any>[]): void {
        },
        
        addData: function<P extends Globals.IGeoJsonProperties>(this: MarkerClusterGroupImpl<P>, data: GeoJSON.GeoJsonObject): MarkerClusterGroupImpl<P> {
            delete this[_index];
            this[_provider].addData(data);
            L.MarkerClusterGroup.prototype.addLayers.call(this, this[_provider].layers);
            this[_provider].layers.length = 0;
            return this;
        },
        
        addLayer: function<P extends Globals.IGeoJsonProperties>(this: MarkerClusterGroupImpl<P>, layer: Globals.Point<P>): MarkerClusterGroupImpl<P> {
            delete this[_index];
            return L.MarkerClusterGroup.prototype.addLayer.call(this, layer);
        },

        removeLayer: function<P extends Globals.IGeoJsonProperties>(this: MarkerClusterGroupImpl<P>, layer: number | Globals.Point<P>): MarkerClusterGroupImpl<P> {
            delete this[_index];
            return L.MarkerClusterGroup.prototype.removeLayer.call(this, layer);
        },

        findItem: GeoJSON.prototype.findItem,
        
        isVisible: GeoJSON.prototype.isVisible,
        
        _resetView: function<P extends Globals.IGeoJsonProperties>(this: MarkerClusterGroupImpl<P>): void {
            const map = this._map;
            
            if (map) {
                const hasLayer = map.hasLayer(this._featureGroup);
                
                if (this.isVisible()) {
                    hasLayer || (map.addLayer(this._featureGroup), map.addLayer(this._nonPointGroup));                
                } else {
                    hasLayer && (map.removeLayer(this._featureGroup), map.removeLayer(this._nonPointGroup));                
                }
            }
        },
        
        getEvents: GeoJSON.prototype.getEvents        
    });

    Object.defineProperty(MarkerClusterGroup.prototype, "geoJSONOptions", {
        get: function (this: MarkerClusterGroupImpl<any>) {
            return this[_provider].options;
        },
        enumerable: true,
        configurable: true
    });
    
    export function markerClusterGroup<P extends Globals.IGeoJsonProperties = Globals.IGeoJsonProperties>(keyProvider: Data.IKeyProvider & Data.IColumnIndexProvider, options: L.GeoJSONOptions<P>, clusterOptions?: MarkerClusterGroupOptions) {
        return new MarkerClusterGroup(keyProvider, $.extend({
                showCoverageOnHover: false,
                disableClusteringAtZoom: 19
            }, clusterOptions),
            options);
    }
}