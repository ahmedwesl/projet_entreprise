/**
 * Created by jean.rennes on 08/10/2015.
 */
///<reference path="../Global.ts" />

namespace AFC.Controls {
    const _px2pt: number = 0.75;

    function _size(size: number, autoSize: boolean): string {
        return autoSize ? `${Math.round(size * 100)/100}px` : `${Math.round(size * _px2pt * 10)/100}em`;        // reference is 10 pt
    }
    
    function _setWidth(element: HTMLElement, widths: number[]): void {
        widths && widths.length && (element.style.width = element.style.minWidth = `${widths.shift()}%`);
    }
    
    function _getAlignment(cell: Globals.IGridAppCell): string {
        return cell && cell.textAlign ? cell.textAlign : 'left';
    }
    
    function _getVAlignment(cell: Globals.IGridAppCell): string {
        return cell && cell.verticalAlign ? cell.verticalAlign : 'center';
    }
    
    function _getFontSize(cell: Globals.IGridAppCell, autoSize: boolean): string {
        let fontSize = cell && cell.fontSize;
        return fontSize && (autoSize ? `calc(${fontSize} + 0.1em)` : _pt2em(fontSize));
    }
    
    export interface IGridCell {
        positionX: number;
        positionY: number;
        templateCell: Globals.IGridAppCell;
    }
          
    let cssImageClasses: {[key: string]: true;};
    
    function _setCellData(grid: GridView, gridApp: Globals.IGridApp, element: HTMLElement, container: HTMLElement, cell: Globals.IGridAppCell, fontSize: string, x: number, y: number): void {
        let renderer = cell.renderer,
            value: IGridCell,
            templateName: string,
            template: ITemplate;
        
        cell.className && (element.className = cell.className);
        if (!renderer || (renderer == Globals.GridRenderer.text) || (renderer == Globals.GridRenderer.trendAndText) || grid.template) {
            templateName = grid.template && grid.templates && grid.template(value = {
                positionX: x,
                positionY: y,
                templateCell: cell
            });
            template = (templateName !== void 0) && grid.templates[templateName];
            if (template) {
                Repeater.generateContent(container, templateName, template, value, grid.dataBinder);
            } else {
                container.innerHTML = cell.text ?? '';
            }
        }
        
        if (cell.image || cell.symbol) {
            let align: string,
                valign: string,
                image: string,
                style = element.style;
            
            if (cell.image) {
                style.background = `url('${cell.image}') no-repeat padding-box border-box`;
            } else if (image = gridApp.getSymbol(cell.symbol)) {
                let key: string = `CTA-RULE-${cell.symbol}`;
                    
                element.className = key;
                if (!(cssImageClasses || (cssImageClasses = {}))[key]) {
                    let rule = document.createElement('style');
                    
                    rule.type = 'text/css';
                    rule.innerHTML = `.${key} { background: url('data:image/svg+xml;utf8,${image.replace(/#/g, '%23')}') no-repeat padding-box border-box;}`;
                    document.getElementsByTagName('head')[0].appendChild(rule);
                    cssImageClasses[key] = true;
                }
                element.className = key;
            }
              
            align = _getAlignment(cell);
            if (renderer !== Globals.GridRenderer.trend) {
                align = (align === 'left') ? 'right' : 'left';
            }
            valign = _getVAlignment(cell);
            if (valign === 'middle') {
                valign = '';
            } else {
                align = align === 'center' ? valign : `${align} ${valign}`;
            }
            align && (style.backgroundPosition = align);
            fontSize && (style.backgroundSize = `${fontSize} ${fontSize}`);
            cell.backgroundColor && (style.backgroundColor = cell.backgroundColor);
        }
    }
    
    function _pt2em(str: string) {
        return `${parseInt(str) / 10}em`;   // 10 pt is the reference
    }

    function _makeCell(grid: GridView, gridApp: Globals.IGridApp, element: HTMLElement, cell: Globals.IGridAppCell, widths: number[], height: number, autoSize: boolean, x: number, y: number): void {
        let container: HTMLElement = element,
            fontSize: string = _getFontSize(cell, autoSize);

        _setWidth(element, widths);
        height && (element.style.height = _size(height, autoSize));

        if (cell) {
            let style: CSSStyleDeclaration = element.style,
                paddingSize: string = cell.padding;

            style.boxSizing = 'border-box';
            if (paddingSize) {
                container = document.createElement('SPAN');
                style.padding = autoSize ? paddingSize : paddingSize.split(' ').map(_pt2em).join(' ');
                element.appendChild(container);
            }
            fontSize && (element.style.lineHeight = container.style.fontSize = fontSize);
            style.color = cell.color;  
            style.backgroundColor = cell.backgroundColor;
            style.textAlign             = _getAlignment(cell);
            style.verticalAlign         = _getVAlignment(cell);
            style.fontWeight            = cell.fontWeight;
            style.fontFamily            = cell.fontFamily;
            style.borderStyle           = cell.borderStyle;
            style.borderWidth           = cell.borderWidth;
            style.borderColor           = cell.borderColor;
            style.textDecoration        = cell.textDecoration;
            style.fontStyle             = cell.fontStyle;
            cell.whiteSpace && (style.whiteSpace = cell.whiteSpace);
            _setCellData(grid, gridApp, element, container, cell, fontSize, x, y);
        }
    }
    
    function _setSize(container: HTMLElement, width: number, initialWidth: number): [number, number] {
        let ratio: number = width  / initialWidth,
            style: CSSStyleDeclaration = container.style;
        
        style.fontSize = `${Math.round(ratio*1333)/100}px`;
        return [width, initialWidth];
    }

    export class GridView extends Control {
        private _widths: [number, number];
        private _gridApp: Globals.IGridApp;
        private _allowSelection: boolean;
        private _highlighted: number;
        public autoSize: boolean;
        public template: (cell: IGridCell)=> string;
        public dataBinder: (name: string, key: string, value: {[key: string]: any})=> string;
        public templates: {[key: string]: ITemplate};
        public onCellClick: (column: number, line: number)=> any;
        
        constructor(element: string | HTMLElement, noAutoSize?: boolean) {
            super(element);
            this.autoSize = !noAutoSize;
            this.node.addEventListener('click', this._onClick.bind(this));
        }
        
        protected _onClick(e: MouseEvent): void {
            if (this.onCellClick) {
                let cell = <Node>e.target;

                while (cell && cell !== this.node) {
                    if (cell instanceof HTMLTableCellElement) {
                        let line = <HTMLTableRowElement>cell.parentNode,
                            offsetX = this._gridApp.hasRowHeader ? -1 : 0,
                            offsetY = this._gridApp.hasColumnHeader ? -1 : 0;
                        this.onCellClick(cell.cellIndex + offsetX, line.rowIndex + offsetY);
                        return;
                    }
                    cell = cell.parentNode;
                }
            }
        }

        protected _highlight(tbody: HTMLTableSectionElement, indice: number, oldIndice?: number): void {
            if (indice !== void 0 || oldIndice !== void 0) {
                let rows = tbody?.rows,
                    row;
                    
                if (rows) {
                    oldIndice !== void 0 && rows[oldIndice]?.removeAttribute('selected');
                    if (indice !== void 0 && (row = rows[indice])) {
                        row.setAttribute('selected', '');
                        row.scrollIntoView({behavior: "auto", block: "nearest", inline: "nearest"});
                    }
                }
            }
        }
                
        protected _buildFromGridApp(gridApp: Globals.IGridApp): void {
            let table = document.createElement('table'),
                tbody,
                line,
                xCount = gridApp.getColumnCount(),
                yCount = gridApp.getRowCount(),
                widths: number[] = [],
                width: number = 0,
                height: number, x: number, y: number;
                
            table.style.tableLayout = 'fixed';
            if (gridApp.hasRowHeader) {
                width = gridApp.getRowHeaderWidth();
                widths.push(width);
            }
            for (x = 0; x < xCount; ++x) {
                let value = gridApp.getColumnWidth(x);
                widths.push(value);
                width += value;
            }
            
            
            widths[0] = widths.reduce((accumulator: number, value: number, indice: number)=> {
                return accumulator - (widths[indice] = Math.round(100 * value / width));
            }, 100) + widths[0];

            if (this.autoSize) {
                this._widths = _setSize(table, this.width, width);
                table.style.width = '100%';
            } else {
                table.style.width = _size(width, false);
            }

            if (gridApp.hasColumnHeader) {
                let element: HTMLTableCellElement,
                    cell: Globals.IGridAppCell;

                height = gridApp.getColumnHeaderHeight();
                line = table.createTHead().insertRow();
                if (gridApp.hasRowHeader) {
                    element = document.createElement('th');
                    _setWidth(element, widths);
                    line.appendChild(element);
                }
                for (x = 0; x < xCount; ++x) {
                    cell = gridApp.getColumnHeader(x);
                    element = document.createElement('th');
                    _makeCell(this, gridApp, element, cell, widths, height, this.autoSize, x, -1);
                    line.appendChild(element);
                }
            }
            
            tbody = table.createTBody();
            for (y = 0; y < yCount; ++y) {
                height = gridApp.getRowHeight(y);
                line = tbody.insertRow();
                this._allowSelection && (line.className = 'gridViewSelectableLine');
                gridApp.hasRowHeader && _makeCell(this, gridApp, line.insertCell(), gridApp.getRowHeader(y), widths, height, this.autoSize, -1, y);
                for (x = 0; x < xCount; ++x) {
                    _makeCell(this, gridApp, line.insertCell(), gridApp.getCell(x, y), widths, height, this.autoSize, x, y);
                }
            }
            this._highlight(tbody, this._highlighted);
            this.node.appendChild(table);
        }
            
        public refreshCell(positionX: number, positionY: number): void {
            let gridApp = this._gridApp,
                table: HTMLTableElement,
                x: number,
                y: number,
                rows: HTMLCollectionOf<HTMLTableRowElement>,
                cells: HTMLCollectionOf<HTMLTableCellElement>,
                container: HTMLElement,
                gridAppCell: Globals.IGridAppCell;
            
            if (gridApp && this.node && (table = this.node.getElementsByTagName('table')[0])) {
                y = positionY + (gridApp.hasColumnHeader ? 1 : 0);
                if ((y >= 0) && (y < (rows = table.rows).length)) {
                    x = positionX + (gridApp.hasRowHeader ? 1 : 0);
                    if ((x >= 0) && (x < (cells = rows[y].cells).length)) {
                        if (positionX === -1) {
                            if (positionY !== -1) gridAppCell = gridApp.getRowHeader(positionY);
                        } else if (positionY === -1) {
                            gridAppCell = gridApp.getColumnHeader(positionX);
                        } else {
                            gridAppCell = gridApp.getCell(positionX, positionY);
                        }
                        $(container = gridAppCell && gridAppCell.padding ? <HTMLElement>cells[x].firstChild : cells[x]).empty();
                        _setCellData(this, gridApp, cells[x], container, gridAppCell, _getFontSize(gridAppCell, this.autoSize), positionX, positionY);
                    }
                }
            }
        }
        
        protected _build(): void {
            $(this.node).empty();           
            if (this._gridApp) {
                this.loadingEnd();
                this._buildFromGridApp(this._gridApp);
            } else {
                this.loadingStart();
            }
        }
        
        public get selection() {
            return this._highlighted;
        }

        public get gridApp() {
            return this._gridApp;
        }
                
        public setTemplate(value: string, name?: string) {
            if (value) {
                (this.templates || (this.templates = {}))[name] = {content: value};
            } else if (this.templates) {
                delete this.templates[name];
            }
        }
        
        public setGrid(gridApp?: Globals.IGridApp, allowSelection?: boolean): void {
            delete this._highlighted;
            this._allowSelection = allowSelection;
            gridApp ? this._gridApp = gridApp : delete this._gridApp;
            this._build();
        }

        public highlight(indice?: number): void {
            if (this._highlighted !== indice) {
                let tbody = this.node.querySelector('tbody');
                tbody && this._highlight(tbody, indice, this._highlighted);
                this._highlighted = indice;
            }
        }
        
        public invalidateSize(): void {
            if (this.autoSize) {
                let width,
                    table: HTMLTableElement;
                
                if (this._widths && this._widths[0] !== (width = this.width) && (table = this.node.getElementsByTagName('table')[0])) {
                    this._widths = _setSize(table, width, this._widths[1]);
                }
            }
        }        
    }
}