/**
 * Created by jean.rennes on 26/03/2018.
 */
///<reference path="../Global.ts" />

namespace AFC.Controls {
    export const enum ReportViewBlockType {
        none,
        image,
        charts,
        gridView,
        legends
    }    
    
    export interface IReportViewBlock {
        type: ReportViewBlockType;
    }

    export interface IReportViewBlockImage extends IReportViewBlock {
        type: ReportViewBlockType.image;
        data: string;
    }
    
    export interface IReportViewBlockCharts extends IReportViewBlock {
        type: ReportViewBlockType.charts;
        data: Globals.IChartModel;
    }
    
    export interface IReportViewBlockGridView extends IReportViewBlock {
        type: ReportViewBlockType.gridView;
        data: Globals.IGridApp;
    }
    
    export interface IReportViewBlockLegends extends IReportViewBlock {
        type: ReportViewBlockType.legends;
        data: Globals.ILegendInfo[];
    }
        
    function _setSize(container: HTMLElement, width: number, height: number, initialWidth: number, initialHeight: number): [number, number, number, number] {
        let ratio: number = Math.min(width / initialWidth, height / initialHeight),
            correctedWidth: number,
            correctedHeight: number,
            style: CSSStyleDeclaration = container.style;
        
        style.width = `${correctedWidth = Math.floor(initialWidth*ratio)}px`;
        style.height = `${correctedHeight = Math.floor(initialHeight*ratio)}px`;
        ratio = Math.min(correctedWidth / initialWidth, correctedHeight / initialHeight);
        ratio *= 0.352777778;    /* initial values are in mm  -> convert in pt at 72 dpi */
        style.fontSize = `${Math.ceil(1000000 * ratio)/100000}pt`;      // reference is 10pt
        style.left = correctedWidth < width ? `${(width - correctedWidth) / 2}px` : '';
        return [width, height, initialWidth, initialHeight];
    }
    
    function _percent(num: number, denum: number): string {
        return `${Math.round((num * 10000) / denum) / 100}%`;
    }
    
    function _renderBase(container: HTMLDivElement, width: number, height: number, reportObject: Globals.IReportObject): HTMLDivElement {
       /* readonly shadow: {
            readonly color: number;
            readonly XMove: number;
            readonly YMove: number;
            readonly XPosition: number;
            readonly YPosition: number;
            readonly visible: boolean;
        };
        */
        let element: HTMLDivElement = <HTMLDivElement>document.createElement('DIV');
        let style: CSSStyleDeclaration = element.style;
        
        style.position = 'absolute';
        style.boxSizing = 'border-box';
        style.left = _percent(reportObject.left, width);
        style.top = _percent(reportObject.top, height);
        style.width = _percent(reportObject.width, width);
        style.height = _percent(reportObject.height, height);
        style.overflow = 'hidden';
        if (reportObject.backgroundColor !== void 0) {
            style.backgroundColor = Tools.Style.convertColor(reportObject.backgroundColor);
        }
        if ((reportObject.borderColor !== void 0) && (reportObject.borderWidth > 0)) {
            style.border = `${Math.round(reportObject.borderWidth)/10}em solid ${Tools.Style.convertColor(reportObject.borderColor)}`;
        }
        return element;
    }
    
    function _rendererPoint(element: HTMLDivElement, pointReportObject: Globals.IPointReportObject): void {
        
    }
    
    const _flexDirection: {[key: string]: string} = {
        middle: 'center',
        bottom: 'flex-end'
    };
        
    const _renderers: {[key: number]: (element: HTMLDivElement, report: Globals.IReportModel, reportObject: Globals.IReportObject, indice: number)=> void;} = {
        [Globals.ReportObjectType.text]: function(element: HTMLDivElement, report: Globals.IReportModel, textReportObject: Globals.ITextReportObject/*, indice: number*/): void {
            if (textReportObject.text != void 0) {
                let innerElement: HTMLDivElement = element;
                let innerStyle: CSSStyleDeclaration = element.style;
                let font: Globals.IStyleFont = textReportObject.font;
                let flexDirection: string = _flexDirection[textReportObject.verticalAlign];
                let htmlText;
                
                if (flexDirection) {
                    let style: CSSStyleDeclaration = innerStyle; 
                    
                    innerElement = document.createElement('div');
                    innerStyle = innerElement.style;
                    style.display = 'flex';
                    style.flexDirection = 'column';
                    style.justifyContent = flexDirection;
                    innerStyle.width = '100%';
                    innerStyle.overflow = 'hidden';
                    element.appendChild(innerElement);
                }
                innerStyle.color = Tools.Style.convertColor(textReportObject.color);
                textReportObject.textAlign && (innerStyle.textAlign = textReportObject.textAlign);
                if (font) {
                    innerStyle.fontFamily        = font.fontFamily;
                    innerStyle.fontSize          = `${font.fontSize/10}em`;
                    innerStyle.fontWeight        = font.fontWeight;
                    innerStyle.fontStyle         = font.fontStyle;
                    innerStyle.textDecoration    = font.textDecoration;
                }
                
                htmlText = textReportObject.text.replace(/{\$(.*?)\$}/g, (match: string, p1: string)=> {
                    return report.data.tokens[p1]||'';
                });
                innerElement.innerHTML = htmlText;
            }
        },
        [Globals.ReportObjectType.dashboardView]: function(element: HTMLDivElement, report: Globals.IReportModel, dashboardViewReportObject: Dashboards.IDashboardViewReportObject, indice: number): void {
            let promise = report.data.views[indice];

            promise && promise.then(blockView => {
                switch (blockView.type) {
                    case ReportViewBlockType.image:
                        (new Image(element)).setUrl((<IReportViewBlockImage> blockView).data);
                        break;
                    case ReportViewBlockType.charts:
                        (new Charts(element)).setData((<IReportViewBlockCharts> blockView).data);
                        break;
                    case ReportViewBlockType.gridView:
                        (new GridView(element, true)).setGrid((<IReportViewBlockGridView> blockView).data);
                        break;
                    case ReportViewBlockType.legends:
                        (new Legends(element)).update((<IReportViewBlockLegends> blockView).data);
                        break;
                }
            });
        },
        [Globals.ReportObjectType.grid]: function(element: HTMLDivElement, report: Globals.IReportModel, gridReportObject: Globals.IGridReportObject/*, indice: number*/): void {
            (new GridView(element, true)).setGrid(new Dashboards.GridApp(gridReportObject.content));
        },
        [Globals.ReportObjectType.bitmap]: function(element: HTMLDivElement, report: Globals.IReportModel, bitmapReportObject: Globals.IBitmapReportObject/*, indice: number*/): void {
            let image = report.metadata.images && report.metadata.images[bitmapReportObject.id];
            if (image) {
                if (image.charAt(0) === '<') {
                    element.innerHTML += image;
                    if (bitmapReportObject.representationMode && (bitmapReportObject.representationMode !== 'none')) {
                        let svg: SVGElement = element.querySelector('svg');
                        if (svg) {
                            let style: CSSStyleDeclaration = svg.style;
                            style.width = style.height = '100%';
                            svg.setAttribute('preserveAspectRatio', bitmapReportObject.representationMode === 'contain' ? 'xMinYMin meet' : 'none');
                        }
                    }
                } else {
                    let style: CSSStyleDeclaration = element.style;
                    style.backgroundRepeat = 'no-repeat';
                    bitmapReportObject.representationMode && (bitmapReportObject.representationMode !== 'none') && (style.backgroundSize = bitmapReportObject.representationMode);
                    style.backgroundImage = `url("${image}")`;
                }            
            }
        },
        [Globals.ReportObjectType.line]: function(element: HTMLDivElement, report: Globals.IReportModel, lineReportObject: Globals.ILineReportObject): void {
        },
        [Globals.ReportObjectType.shape]: function(element: HTMLDivElement, report: Globals.IReportModel, shapeReportObject: Globals.IShapeReportObject): void {
        }
    };
                
    export class ReportPage extends Charts {
        protected _lengths: [number, number, number, number];
        protected _report: Globals.IReportModel;
        protected _index: number;
                
        public clear() {
            let container: JQuery = $(this.node);
            
            super.clear();
            this._report = null;
            container.empty();
            this.loadingStart();
            this.node.style.backgroundColor = null;
        }
        
        public setPage(report: Globals.IReportModel, index: number): void {            
            this._report = report;
            this._index = index || 0;
            $(this.node).empty();
            if (report) {
                this.loadingEnd();
                
                let metadata: Globals.IReportMetadata = report.metadata;
                
                if (metadata) {
                    let width: number = metadata.width,
                       height: number = metadata.height,
                       container = document.createElement('div'),
                       page;
                    
                    container.style.position = 'absolute';
                    if (metadata.pages && (page = metadata.pages[this._index])) {
                        (page.backgroundColor !== void 0) && (this.node.style.backgroundColor = Tools.Style.convertColor(page.backgroundColor));
                        page.width && (width = page.width);
                        page.height && (height = page.height);
                        page.objects.forEach((reportObject: Globals.IReportObject, indice: number)=> {
                            let renderer = _renderers[reportObject.type],
                                element = _renderBase(container, width, height, reportObject);
                            renderer && renderer(element, report, reportObject, indice);
                            container.appendChild(element);
                        });
                    }
                    this._lengths = _setSize(container, this.width, this.height, width, height);
                    this.node.appendChild(container);
                }
            }
            else
                this.loadingStart();
        }
        
        public invalidateSize(): void {
            if (this._report) {
                let container = this._lengths && this.node.querySelector('div');
                
                if (container) {
                    let width = this.width,
                        height = this.height;
                    if (this._lengths[0] !== width || this._lengths[1] !== height)
                            this._lengths = _setSize(container, width, height, this._lengths[2], this._lengths[3]);
                }
            } else {
                super.invalidateSize();
                /*
                let children: JQuery = this._element && $(this._element).children('DIV');
                if (children && children.length)
                    _setSize(children[0], this.width, this.height, this._width, this._height);
                */
            }
        }
    }    
}