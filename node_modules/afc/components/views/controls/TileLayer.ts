///<reference types="leaflet" />

namespace AFC.Controls {
    export interface TileLayerOptions<K extends Globals.DrawableLayerType = Globals.DrawableLayerType> {
        // @option tileSize: Number|Point = 256
        // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
        tileSize?: number|L.Point;

        // @option updateWhenIdle: Boolean = (depends)
        // Load new tiles only when panning ends.
        // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
        // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
        // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
        updateWhenIdle?: boolean;

        // @option updateWhenZooming: Boolean = true
        // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
        updateWhenZooming?: boolean;

        // @option updateInterval: Number = 200
        // Tiles will not update more than once every `updateInterval` milliseconds when panning.
        updateInterval?: number;

        // @option zIndex: Number = 1
        // The explicit zIndex of the tile layer.
        zIndex?: number;

        // @option bounds: LatLngBounds = undefined
        // If set, tiles will only be loaded inside the set `LatLngBounds`.
        bounds?: L.LatLngBounds,

        // @option minZoom: Number = 0
        // The minimum zoom level down to which this layer will be displayed (inclusive).
        minZoom?: number;

        // @option maxZoom: Number = undefined
        // The maximum zoom level up to which this layer will be displayed (inclusive).
        maxZoom?: number;

        // @option maxNativeZoom: Number = undefined
        // Maximum zoom number the tile source has available. If it is specified,
        // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
        // from `maxNativeZoom` level and auto-scaled.
        maxNativeZoom?: number;

        // @option minNativeZoom: Number = undefined
        // Minimum zoom number the tile source has available. If it is specified,
        // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
        // from `minNativeZoom` level and auto-scaled.
        minNativeZoom?: number;

        // @option noWrap: Boolean = false
        // Whether the layer is wrapped around the antimeridian. If `true`, the
        // GridLayer will only be displayed once at low zoom levels. Has no
        // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
        // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
        // tiles outside the CRS limits.
        noWrap?: boolean;

        // @option pane: String = 'tilePane'
        // `Map pane` where the grid layer will be added.
        pane?: string;

        // @option keepBuffer: Number = 2
        // When panning the map, keep this many rows and columns of tiles before unloading them.
        keepBuffer?: number;
        
        layerProvider?: (options: L.GeoJSONOptions<Globals.ITileFeatureProperties<K>>)=> IGeoJSON<K, Globals.ITileFeatureProperties<K>>;
    }
    
    declare interface GridLayer extends L.GridLayer {
        _clampZoom(zoom: number): number;
        _getTiledPixelBounds(center: L.LatLng): L.Bounds;
        _resetView(): void;
        _animateZoom(): void;
        _resetGrid(): void;   
        _loading: boolean;
        _zoomAnimated: boolean;
        _onMoveEnd(event: L.LeafletEvent): void;
        _pxBoundsToTileRange(bounds: L.Bounds): L.Bounds;
        _isValidTile(coords: L.Coords): boolean;
        _tileCoordsToNwSe(coords: L.Coords): L.Point;
        _tileCoordsToBounds(coords: L.Coords): L.LatLngBounds;
        _setZoomTransforms(center: L.LatLng, zoom: number): void;
        _updateLevels(): void;
        _retainParent(x: number, y: number, z: number, minZoom: number): boolean;
        _retainChildren(x: number, y: number, z: number, maxZoom: number): void;
        _pruneTiles(): void;
        _noTilesToLoad(): boolean;
        _setView(center: L.LatLng, zoom: number, noPrune?: boolean, noUpdate?: boolean): void;
        _keyToBounds(key: string): L.Bounds;        
    }

    let GridLayerPrototype = <GridLayer>L.GridLayer.prototype;

    function _mapFeature<K extends Globals.DrawableLayerType>(tile: TileLayerImpl<K>['_tiles'][0]): Globals.LayerForLayerType<K>[] {
        return tile.features.map(feature => feature.properties.layer);
    }

    export interface ITileLayer<K extends Globals.DrawableLayerType> extends L.FeatureGroup<Globals.ITileFeatureProperties<K>> {
        readonly options: TileLayerOptions<K>;

        getContainer(): HTMLElement | null;
        setOpacity(opacity: number): this;
        setZIndex(zIndex: number): this;
        isLoading(): boolean;
        redraw(): this;
        getTileSize(): L.Point;
        getGeometryFromResult: (row: ReadonlyArray<any>)=> Globals.GeometryForLayerType[K];
        setStyle(style: L.PathOptions | L.StyleFunction): this;
        setFilter(filter: (feature: GeoJSON.Feature<Globals.GeometryForLayerType[K]>) => boolean): this;
        addData(data: GeoJSON.GeoJsonObject | ReadonlyArray<GeoJSON.GeoJsonObject>): this;
        removeLayer(layer: Globals.LayerForLayerType<K>): this;
        findItem(key: ReadonlyArray<any>): Globals.LayerForLayerType<K>;
        requestTiles(keys: ReadonlyArray<string>, callback: (keys: ReadonlyArray<string>, rows: ReadonlyArray<ReadonlyArray<any>>)=> any): void;
        getTileFeaturesForLatLng(latLng: L.LatLng, zoom?: number): Promise<Globals.LayerForLayerType<K>[]>;
        zoomToShowLayer(layer: L.Layer, callback?: () => void): void;
        isVisible(): boolean;
        setZIndex(zIndex: number): this;
        getLayers(): Globals.LayerForLayerType<K>[];
        highlight(keys?: ReadonlyArray<any>[]): void;
    }


    declare class TileLayerImpl<K extends Globals.DrawableLayerType> extends L.FeatureGroup<Globals.ITileFeatureProperties<K>> implements ITileLayer<K> {
        // inheritance
        protected _tiles: L.InternalTiles & {
            [key: string]: {
                features: GeoJSON.Feature<Globals.GeometryForLayerType[K], Globals.ITileFeatureProperties<K>>[];
            }
        };
        protected _map: L.Map & {
            _animateToZoom: number;
            _animatingZoom: boolean;
        }
        protected _loading: boolean;
        protected _zoomAnimated: boolean;        
        protected _tileZoom: number;
        protected _layers: {[key: number]: L.Layer};
        protected _geoJSON: IGeoJSON<K, Globals.ITileFeatureProperties<K>>;
        protected _tileSize: number;
        protected _globalTileRange: L.Bounds;
        protected _wrapX: [number, number];
        protected _wrapY: [number, number];

        protected _removeAllTiles(): void;
        protected _update(center?: L.LatLng): void;
        protected _invalidateAll(): void;
        protected _addTile(coords: L.Coords): void;
        protected _removeTile(key: string): void;
        protected _tileCoordsToKey(coords: L.Coords): string;
        protected _keyToTileCoords(key: string): L.Coords;
        
        protected _abortLoading?: ()=> void;

        protected _clampZoom(zoom: number): number;
        protected _getTiledPixelBounds(center: L.LatLng): L.Bounds;
        protected _resetView(): void;
        protected _animateZoom(): void;
        protected _resetGrid(): void;   
        protected _onMoveEnd(event: L.LeafletEvent): void;
        protected _pxBoundsToTileRange(bounds: L.Bounds): L.Bounds;
        protected _isValidTile(coords: L.Coords): boolean;
        protected _tileCoordsToNwSe(coords: L.Coords): L.Point;
        protected _tileCoordsToBounds(coords: L.Coords): L.LatLngBounds;
        protected _setZoomTransforms(center: L.LatLng, zoom: number): void;
        protected _updateLevels(): void;
        protected _retainParent(x: number, y: number, z: number, minZoom: number): boolean;
        protected _retainChildren(x: number, y: number, z: number, maxZoom: number): void;
        protected _pruneTiles(): void;
        protected _noTilesToLoad(): boolean;
        protected _setView(center: L.LatLng, zoom: number, noPrune?: boolean, noUpdate?: boolean): void;
        protected _keyToBounds(key: string): L.Bounds;        

        public bringToFront(): this;
        public bringToBack(): this;
        public getContainer(): HTMLElement | null;
        public setOpacity(opacity: number): this;
        public setZIndex(zIndex: number): this;
        public isLoading(): boolean;
        public redraw(): this;
        public getTileSize(): L.Point;
                        
        // custom
        protected _callback: (keys: ReadonlyArray<string>, rows: ReadonlyArray<ReadonlyArray<any>>)=> void;
        protected _geojsonOptions: L.GeoJSONOptions;
        protected _features: Globals.ITileVectorModel<K>;
        protected _pending: boolean;
        protected _getGeoJSONOptions(geojsonOptions?: L.GeoJSONOptions): L.GeoJSONOptions;
        protected _onEachFeature(feature: GeoJSON.Feature<Globals.GeometryForLayerType[K], Globals.ITileFeatureProperties<K>>, layer: Globals.LayerForLayerType<K, Globals.ITileFeatureProperties<K>>): void;
        protected _onEachFeatureOption: (feature: GeoJSON.Feature<Globals.GeometryForLayerType[K], Globals.ITileFeatureProperties<K>>, layer: L.Layer)=> void;
        protected _loadTiles(): boolean;
        protected _getPixelBoundsFromRect(rectangle: Tools.Geometry.Rectangle, zoom: number): L.Bounds;
        protected _tilesReady(keys: ReadonlyArray<string>, rows: ReadonlyArray<ReadonlyArray<any>>): void;
        protected _removeFeature(entity: GeoJSON.Feature<Globals.GeometryForLayerType[K], Globals.ITileFeatureProperties<K>>): void;
        protected _eachIntersectingTile(rectangle: Tools.Geometry.Rectangle, method: (tile: TileLayerImpl<K>['_tiles'][0])=> void): void;
        
        public readonly options: TileLayerOptions<K>;
        public getGeometryFromResult: (row: ReadonlyArray<any>)=> Globals.GeometryForLayerType[K];
        public setStyle(style: L.PathOptions | L.StyleFunction): this;
        public setFilter(filter: (feature: GeoJSON.Feature<Globals.GeometryForLayerType[K]>) => boolean): this;
        public addData(data: GeoJSON.GeoJsonObject | ReadonlyArray<GeoJSON.GeoJsonObject>): this;
        public removeLayer(layer: Globals.LayerForLayerType<K>): this;
        public findItem(key: ReadonlyArray<any>): Globals.LayerForLayerType<K>;
        public requestTiles(keys: ReadonlyArray<string>, callback: (keys: ReadonlyArray<string>, rows: ReadonlyArray<ReadonlyArray<any>>)=> any): void;
        public getTileFeaturesForLatLng(latLng: L.LatLng, zoom?: number): Promise<Globals.LayerForLayerType<K>[]>;
        public zoomToShowLayer(layer: L.Layer, callback?: () => void): void;
        public isVisible(): boolean;
        public setZIndex(zIndex: number): this;
        public getLayers(): Globals.LayerForLayerType<K>[];
        public highlight(keys?: ReadonlyArray<any>[]): void;
    }
    
    interface GeometryReference<G extends GeoJSON.Geometry | null = GeoJSON.Geometry> {
        bounds: L.Bounds;
        geometry: G;
        row: ReadonlyArray<any>;
    };
    
    function _comparePoint(pt0: L.Point, pt1: L.Point): number {
        return (pt0.x - pt1.x) || (pt1.y - pt1.y);
    }

    function _compareReference(geometry0: GeometryReference, geometry1: GeometryReference): number {
        return _comparePoint(geometry0.bounds.min, geometry1.bounds.min);
    }

    export const TileLayer: {
        new <K extends Globals.DrawableLayerType = Globals.DrawableLayerType> (model: Globals.ITileVectorModel<K>, options?: TileLayerOptions<K>, geojsonOptions?: L.GeoJSONOptions<Globals.IGeoJsonProperties>): TileLayerImpl<K>;
    } = L.FeatureGroup.extend({
        options: {
            tileSize: 256,
            updateWhenIdle: L.Browser.mobile,
            updateWhenZooming: false,
            updateInterval: 200,
            zIndex: 1,
            bounds: null,
            minZoom: 0,
            maxZoom: undefined,
            maxNativeZoom: undefined,
            minNativeZoom: undefined,
            noWrap: false,
            pane: 'tilePane',
            className: '',
            keepBuffer: 2
        },
        initialize: function <K extends Globals.DrawableLayerType> (
                this: TileLayerImpl<K>, 
                tileVectorModel: Globals.ITileVectorModel<K>, 
                options?: TileLayerOptions<K>, 
                geojsonOptions?: L.GeoJSONOptions): void {
            this._layers = {};
            this._features = tileVectorModel;
            L.Util.setOptions(this, options);
            this._geoJSON = (this.options.layerProvider || ((options: L.GeoJSONOptions) => new GeoJSON(tileVectorModel, null, options)))(this._getGeoJSONOptions(geojsonOptions));
            this._callback = this._tilesReady.bind(this);
        },
        onAdd: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, map: L.Map): void {
            this._geoJSON.addTo(this);
            
            this._tiles = {};
            this._resetView();
            this._update();
        },
        beforeAdd: GridLayerPrototype.beforeAdd,
        onRemove: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, map: L.Map): void {
            this._removeAllTiles();
            this._geoJSON.remove();
            /*DomUtil.remove(this._container);*/
           // map._removeZoomLimit(this);
            /*this._container = null;
            this._tileZoom = undefined;*/
        },
        
        // @method isLoading: Boolean
        // Returns `true` if any tile in the grid layer has not finished loading.
        isLoading: GridLayerPrototype.isLoading,

        // @method redraw: this
        // Causes the layer to clear all the tiles and request them again.
        redraw: GridLayerPrototype.redraw,

        getEvents: GridLayerPrototype.getEvents,

        // @section
        // @method getTileSize: Point
        // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
        getTileSize: GridLayerPrototype.getTileSize,

        _resetView: function (e: any) {
            this._map && GridLayerPrototype._resetView.call(this, e);   // prevent js error when adding this while smart zooming
        },
            
        _animateZoom: GridLayerPrototype._animateZoom,

        _clampZoom: GridLayerPrototype._clampZoom,
        
        _resetGrid: GridLayerPrototype._resetGrid,

        _getTiledPixelBounds: GridLayerPrototype._getTiledPixelBounds,

        _onMoveEnd: GridLayerPrototype._onMoveEnd,

        _pxBoundsToTileRange: GridLayerPrototype._pxBoundsToTileRange,
        
        _isValidTile: GridLayerPrototype._isValidTile,

        _tileCoordsToNwSe: GridLayerPrototype._tileCoordsToNwSe,
        
        _tileCoordsToBounds: GridLayerPrototype._tileCoordsToBounds,
        
        _setZoomTransforms: L.Util.falseFn,

        _updateLevels: L.Util.falseFn,
                
        _retainParent: GridLayerPrototype._retainParent,
        
        _retainChildren: GridLayerPrototype._retainChildren,
        
        _pruneTiles: GridLayerPrototype._pruneTiles,

        _noTilesToLoad: GridLayerPrototype._noTilesToLoad,

        _setView: GridLayerPrototype._setView,

        _getGeoJSONOptions: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, options?: L.GeoJSONOptions): L.GeoJSONOptions {
            let local: any = Object.create(options || null),
                onEachFeatureOption = options?.onEachFeature;
            onEachFeatureOption && (this._onEachFeatureOption = onEachFeatureOption);
            local.onEachFeature = this._onEachFeature.bind(this);
            return local;
        },
        
        _tileCoordsToKey: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, coords: L.Coords): string {
            let key: string = '';
            const map: string = '0123';
            let value: number;
            
            for (let precision: number = coords.z; precision > 0;) {
                --precision;
                value = 2 * (coords.y >> precision & 1) + (coords.x >> precision & 1);
                key += map.charAt(value);
            }
            return key;
        },
        
        _keyToTileCoords: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, key: string): L.Coords {
            let coords = <L.Coords>L.point(0, 0);
            coords.z = 0;
            for (const c of key) {
                ++coords.z;
                coords.y <<= 1;
                coords.x <<= 1;
                switch(c)  {
                    case '3':
                       ++coords.y;
                    case '1':
                       ++coords.x; 
                       break;      
                    case '2':
                       ++coords.y;
                       break;      
                }
            }
            return coords;
        },
        
        _invalidateAll: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>): void {
            this._removeAllTiles();
            this._tileZoom = undefined;
        },

        _update: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, center?: L.LatLng): void {
            let map = this._map;
            if (!map) { return; }
            if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom
            
            let zoom = this._clampZoom(map.getZoom());

            if (center === undefined) { center = map.getCenter(); }

            let pixelBounds = this._getTiledPixelBounds(center),
                tileRange = this._pxBoundsToTileRange(pixelBounds),
                margin = this.options.keepBuffer,
                noPruneRange = new L.Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
                                          tileRange.getTopRight().add([margin, -margin]));

            // Sanity check: panic if the tile range contains Infinity somewhere.
            if (!(isFinite(tileRange.min.x) &&
                  isFinite(tileRange.min.y) &&
                  isFinite(tileRange.max.x) &&
                  isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }

            for (let key in this._tiles) {
                let c = this._tiles[key].coords;
                if (c.z !== this._tileZoom || !noPruneRange.contains(L.point(c.x, c.y))) {
                    this._tiles[key].current = false;
                }
            }

            // _update just loads more tiles. If the tile zoom level differs too much
            // from the map's, let _setView reset levels and prune old tiles.
            if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

            // create a queue of coordinates to load tiles from
            for (let j = tileRange.min.y; j <= tileRange.max.y; ++j) {
                for (let i = tileRange.min.x; i <= tileRange.max.x; ++i) {
                    let coords: L.Coords = <L.Coords>L.point(i, j);

                    coords.z = this._tileZoom;
                    if (!this._isValidTile(coords)) { continue; }

                    let tile = this._tiles[this._tileCoordsToKey(coords)];
                    if (tile) {
                        tile.current = true;
                    } else {
                        if (!this._loading) {
                            this._loading = true;
                            // @event loading: Event
                            // Fired when the grid layer starts loading tiles.
                            this.fire('loading');
                        }
                        this._addTile(coords);
                    }
                }
            }
            this._loadTiles();
        },
        
        _removeAllTiles: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>): void {
            this._geoJSON.clearLayers();
            this._features.empty();
            this._tiles = {};
        },
        
        _addTile: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, coords: L.Coords): void {
            let key = this._tileCoordsToKey(coords);
            this._tiles[key] = <any>{
                coords: coords,
                current: true
            };
        },
        
        _onEachFeature: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, feature: GeoJSON.Feature<Globals.GeometryForLayerType[K], Globals.ITileFeatureProperties<K>>, layer: Globals.LayerForLayerType<K, Globals.ITileFeatureProperties<K>>): void {
            feature.properties.layer = layer;
            if (this._onEachFeatureOption) {
                this._onEachFeatureOption(feature, layer);
            }
        },
        
        _getPixelBoundsFromRect: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, rectangle: Tools.Geometry.Rectangle, zoom: number): L.Bounds {
            let map = this._map,
                pt0 = map.project([rectangle[1], rectangle[0]], zoom),
                pt1 = map.project([rectangle[3], rectangle[2]], zoom);
            return L.bounds(pt0, pt1);
        },
        
        _tilesReady: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, keys: ReadonlyArray<string>, rows: ReadonlyArray<ReadonlyArray<any>>): void {
            let date = +new Date(),
                allFeatures: GeoJSON.Feature<Globals.GeometryForLayerType[K], Globals.ITileFeatureProperties<K>>[];

            this._pending = false;
            keys.forEach((key: string, indice: number)=> {
                let tile = this._tiles[key],
                    references: GeometryReference<Globals.GeometryForLayerType[K]>[],
                    event: string,
                    features: GeoJSON.Feature<Globals.GeometryForLayerType[K], Globals.ITileFeatureProperties<K>>[];

                if (tile) {
                    tile.loaded = <any>date;
                    if (rows) {
                        features = [];
                        tile.active = true;
                        if (!references) {
                            references = [];
                            for (let i: number = 0; i < rows.length; ++i) {
                                let geometry = this.getGeometryFromResult(rows[i]);

                                if (geometry) {
                                    let rectangle = Tools.Geometry.getBoundRect(geometry),
                                        bounds = this._getPixelBoundsFromRect(rectangle, tile.coords.z);

                                    references.push({
                                        bounds: this._pxBoundsToTileRange(bounds),
                                        geometry: geometry,
                                        row: rows[i]
                                    });
                                }
                            }
                            references.sort(_compareReference);
                        }
                        for (let j: number = 0; (j < references.length) && (_comparePoint(references[j].bounds.min, tile.coords) <= 0); ++j) {
                            if (references[j].bounds.contains(tile.coords)) {
                                let reference = references[j],
                                    bookmark = this._features.lowerBound(reference.geometry, reference.row);
                                bookmark.insert() && (allFeatures || (allFeatures = [])).push(bookmark.feature);
                                features.push(bookmark.feature);
                            }
                        }
                        tile.features = features;
                        event = 'tileload';
                    }
                    else {
                        event = 'tileerror';
                    }
                    this.fire(event, {
                        tile: tile,
                        key: key
                    });
                }
            });
            
            allFeatures && this._geoJSON.addData(<any>allFeatures);
            if (!this._loadTiles()) {
                this._loading = false;
                // @event load: Event
                // Fired when the grid layer loaded all visible tiles.
                this.fire('load');

               /* if (Browser.ielt9 || !this._map._fadeAnimated) {
                    Util.requestAnimFrame(this._pruneTiles, this);
                } else*/ {
                    // Wait a bit more than 0.2 secs (the duration of the tile fade-in)
                    // to trigger a pruning.
                    setTimeout(() => {
                        this._pruneTiles();
                        this._features.dispatchChange && this._features.dispatchChange();
                    }, 250);
                }
            }
        },
        
        _loadTiles: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>): boolean {
            if (this._pending) { return; }
            
            let queue = [], tile;
            for (let key in this._tiles) {
                tile = this._tiles[key];
                if (!tile.loaded && (this._tileZoom === tile.coords.z)) {
                    queue.push(key);
                }
            }
            
            if (queue.length > 0) {
                this._pending = true;
                this.requestTiles(queue, this._callback);
            }
            return this._pending;
        },

        _removeFeature: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, feature: GeoJSON.Feature<Globals.GeometryForLayerType[K], Globals.ITileFeatureProperties<K>>): void {
            let layer = feature.properties.layer;
            layer && this._features.remove(feature) && this._geoJSON.removeLayer(layer);
        },
                
        _removeTile: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, key: string): void {
            let tile = this._tiles[key];
            
            if (tile) {
                tile.features && tile.features.forEach(this._removeFeature.bind(this));
                delete this._tiles[key];
            }
        },
        
        _eachIntersectingTile: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, rectangle: Tools.Geometry.Rectangle, method: (tile: TileLayerImpl<K>['_tiles'][0])=> void): void {
            let zoom,
                bounds,
                str,
                tile;

            for (str in this._tiles) {
                tile = this._tiles[str];
                if (tile.loaded) {
                    if (zoom !== tile.coords.z) {
                        bounds = this._pxBoundsToTileRange(this._getPixelBoundsFromRect(rectangle, zoom = tile.coords.z));
                    }
                    bounds.contains(tile.coords) && method.call(null, tile);
                }
            }
        },
        
        getFeatureFromResult: L.Util.falseFn,
        
        requestTiles: L.Util.falseFn,
        
        dispatchChange: L.Util.falseFn,
        
        getLayers: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>): Globals.LayerForLayerType<K>[] {
            return this._geoJSON.getLayers();
        },
        
        setFilter: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, filter: (feature: GeoJSON.Feature<Globals.GeometryForLayerType[K]>) => boolean): TileLayerImpl<K> {
            this._geoJSON.clearLayers();
            this._features.entities.forEach(feature => {
                this._geoJSON.addData(feature);
            });
            return this;
        },
        
        addData: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, data: GeoJSON.GeoJsonObject | ReadonlyArray<GeoJSON.GeoJsonObject>): TileLayerImpl<K> {
            let features: ReadonlyArray<GeoJSON.GeoJsonObject> = data instanceof Array ? data : (<GeoJSON.FeatureCollection>data).features;
            
            if (features) {
                features.forEach(feature => this.addData(feature));
            } else {
                let feature = <GeoJSON.Feature<Globals.GeometryForLayerType[K], Globals.ITileFeatureProperties<K>>>L.GeoJSON.asFeature(<any>data),
                    bookmark = this._features.lowerBound(feature.geometry, feature.properties.data);
                
                if (!bookmark.feature) {
                    let rectangle = Tools.Geometry.getBoundRect(<GeoJSON.GeoJsonObject>data);
                    this._eachIntersectingTile(rectangle, tile => {
                        if (bookmark.insert()) {
                            this._geoJSON.addData(bookmark.feature);
                        }
                        tile.features.push(bookmark.feature);
                    });
                }
            }
            return this;
        },
        
        removeLayer: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, layer: Globals.LayerForLayerType<K>): TileLayerImpl<K> {
            let rectangle = Tools.Geometry.getBoundRect(layer.feature);
            
            this._eachIntersectingTile(rectangle, tile => {
                tile.features = tile.features.filter(feature => {
                    if (feature !== layer.feature)
                        return true;
                    this._removeFeature(feature);
                });
            });
            return this;
        },
        
        findItem: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, key: ReadonlyArray<any>): Globals.LayerForLayerType<K> {
            //let layers = this.getLayers();
            //return layers.find(layer => !this._features.compareKey(layer.feature.properties.data, key));
            return this._geoJSON.findItem(key);
        },
        
        getTileFeaturesForLatLng: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, latLng: L.LatLng, zoom: number = this._map.getZoom()): Promise<Globals.LayerForLayerType<K>[]>  {
            let promise: Promise<Globals.LayerForLayerType<K>[]> = new Promise((resolve, reject) => {
                if (this._map && this._tiles) {
                    zoom = this._clampZoom(zoom);
                    
                    let tileSize: L.Point = this.getTileSize(),
                        pixelPoint: L.Point = this._map.project(latLng, zoom).floor(),
                        coords = <L.Coords>pixelPoint.unscaleBy(tileSize).floor();
                        
                    coords.z = zoom;
                    let key = this._tileCoordsToKey(coords),
                        tile = this._tiles[key];
                    if (tile && tile.active) {
                        resolve(_mapFeature(tile));
                    } else {
                        let f: L.LeafletEventHandlerFn = (/*event: L.LeafletEvent*/)=>{
                            let tile = this._tiles[key];
                            resolve(tile && _mapFeature(tile));
                        };
                        this.once('load', f, this);
                    }
                }
                
            });
            return promise;
        },
        
        zoomToShowLayer: function <K extends Globals.DrawableLayerType>(this: TileLayerImpl<K>, layer: {getLatLng?: (L.Marker | L.CircleMarker)['getLatLng'], getBounds?: (L.Polyline | L.Polygon)['getBounds']}, callback?: () => void): void {
            let markerClusterGroup: {zoomToShowLayer(layer: L.Layer, callback?: () => void): void;} = <any>this._geoJSON;
            
            /*if (markerClusterGroup && markerClusterGroup.zoomToShowLayer)
                return markerClusterGroup.zoomToShowLayer(layer, callback);*/
                
            this._map.once('zoomend moveend', callback);
            layer.getLatLng ?
                this._map.panTo(layer.getLatLng()):
                this._map.fitBounds(layer.getBounds());
        },
        
        isVisible: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>): boolean {
            let visible = false, tileZoom: number;
            
            if (this._map) {
		        tileZoom = this._clampZoom(this._map.getZoom());
		        visible = (this.options.maxZoom === undefined || tileZoom <= this.options.maxZoom) &&
                            (this.options.minZoom === undefined || tileZoom >= this.options.minZoom);
            }
            return visible;
        },
        
        highlight: function <K extends Globals.DrawableLayerType> (this: TileLayerImpl<K>, keys?: ReadonlyArray<any>[]): void {
            this._geoJSON.highlight(keys);
        }
    });

    // @factory L.tileLayer(options?: tileLayer options, geojsonOptions?: geojson options)
    // Creates a new instance of tileLayer with the supplied options.
    export function tileLayer<K extends Globals.DrawableLayerType>(model: Globals.ITileVectorModel<K>, options?: TileLayerOptions<K>, geojsonOptions?: L.GeoJSONOptions<Globals.IGeoJsonProperties>) {
        return new TileLayer<K>(model, options, geojsonOptions);
    }
}