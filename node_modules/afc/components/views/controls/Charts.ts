/**
 * Created by jean.rennes on 13/07/2017.
 */
///<reference path="../Global.ts" />
 
namespace AFC.Controls {
    type D3Selection = d3.Selection<d3.BaseType, {}, null, undefined>;
    type Datum = Globals.IChartDatum;
    interface IPieDatum {
        index: number;
        part: Globals.IChartStylePartSerie;
        value: number;
        percent: number;
    }
    
    function _getChartTTDiv() {
        if ($("#MainChartTT").length == 0) {
            let div = document.createElement('div');
            
            div.id                  = 'MainChartTT';
            div.style.position      = 'absolute';
            div.style.display       = 'block';
            div.style.visibility    = 'hidden';
            div.style.zIndex        = '99999';
            
            document.body.insertBefore(div, document.body.firstChild);
        }        
        
        return d3.select("#MainChartTT");
    }
    
    function _closeCurrentTT(context: any) {
            if (context._currentTTItem) {
                context._divTT.style("visibility", "hidden")
                    .style("left", "0px")		
                    .style("top", "0px")
                    .style("width", "0px");
                if (!(context instanceof RadarRenderer))
                    d3.select(context._currentTTItem).style("stroke", "none");
                d3.select(context._currentTTItem).style("stroke-dasharray", "none");
                context._currentTTItem = null;
            }   
        }
        
    function _showTT(context: any, text: string, elem: d3.BaseType) {
        let stamp       = Date.now();
        let divTT:  d3.Selection<d3.BaseType, {}, d3.BaseType, {}>;;
        let svg:    D3Selection;
        
        _closeCurrentTT(context);
        context._lastOpenTT = stamp;
        divTT   = context._divTT;     
        svg     = context._svg;
        if (divTT) {
            divTT.html(text)
                    .style("left", $(svg.node()).offset().left + "px")		
                    .style("top", $(svg.node()).offset().top - 20 + "px")
                    .style("width", $(svg.node()).width() + "px")
                    .style("visibility", "visible");
        }
        if (!(context instanceof RadarRenderer))
        {
            d3.select(elem).style("stroke", "black");
            d3.select(elem).style("stroke-width", "1");
            d3.select(elem).style("stroke-dasharray", "1,1");
        }
        else
            d3.select(elem).style("stroke-dasharray", "2,2");
        
        context._currentTTItem = elem;
    }
    
    function _getChartDefaultLabelFontSize() {
        return 6;
    }
    function _getChartDefaultTickFontSize() {
        return 4;
    }
    
    function _breakText(label: string) {
        let result = _breakTextEx(label, ' ', false);
        if (result.length == 1)
            result = _breakTextEx(label, '-', true);
        return result;
    }
    function _breakTextEx(label_source: string, breakChar: string, keepBreak: boolean) {
        let label = label_source.trim();
        let result = Array(label);
        
        let middle = Math.floor(label.length / 2);
        let before = label.lastIndexOf(breakChar, middle);
        let after = label.indexOf(breakChar, middle);
        
        if (before == -1)
            middle = after;
        else if (after == -1)
            middle = before;
        else {
            let maxAfter    = after;
            let maxBefore   = label.length - before;
            if (maxAfter <= maxBefore)
                middle = before;
            else
                middle = after;
            /*
            if (middle - before < after - middle)
                middle = before;
            else
                middle = after;
            */
        }
        if (middle != -1) {
            result = Array(label.substr(0, middle + (keepBreak ? 1 : 0)));
            result.push(label.substr(middle + 1));
        }
        else {
            result = label.split(breakChar);
            if (keepBreak) {
                for (var i = 0; i < result.length; i++) {
                    if (i != result.length - 1)
                        result[i] = breakChar + result[i];
                }
            }
        }

        return result;
    }
                    
    function _getOpacity(color: number): number {
        return 1 - (color / 0xff000000);
    }

    function _getPieData(data: Datum[][], j: number, properties: Globals.IChartPieProperties): IPieDatum[] {
        let parts: Globals.IChartStylePartSerie[] = properties.parts;
        let sum: number = 0;
        let computed: IPieDatum[] = [];
        let remainders: number[] = [];
        let aggregationPercentage: number = properties.pie.aggregation.active ? properties.pie.aggregation.aggregationPercentage : 0;
        let aggregated: Partial<IPieDatum>;
        let push = (datum: Partial<IPieDatum>) => {
            remainders.push(datum.index = computed.length);
            computed.push(<IPieDatum>datum);
        };
        let round = (indice: number, ceil?: boolean) => {
            let item = computed[remainders[indice]],
                percent = item.percent,
                rounding = ceil ? Math.ceil(percent) : Math.floor(percent);
            return (item.percent = rounding) - percent;
        };

        data.forEach((d: Datum[], i: number) => sum += data[i][j].value);
        data.forEach((d: Datum[], i: number)=> {
            let value: number = data[i][j].value,
                percent: number = 100 * value / sum;

            if (percent < aggregationPercentage) {
                if (!aggregated) {
                    let label: Globals.IChartStyleLabelPercentItem = parts[i].label;
                    
                    aggregated = {
                        part: {
                            name: properties.pie.aggregation.name,
                            fillColor: parts[i].fillColor,
                            borderColor: parts[i].borderColor,
                            label: {
                                showPercent: label.showPercent,
                                font: label.font,
                                color: 0,
                                backgroundColor: label.backgroundColor,
                                borderColor: label.borderColor,
                                visible: true,
                                align: label.align
                            }
                        },
                        value: 0
                    };
                }
                aggregated.value += value;
            } else {
                push({
                    part: parts[i],
                    value: value,
                    percent: percent
                });
            }
        });
        if (aggregated) {
            aggregated.percent = 100 * aggregated.value / sum;
            push(aggregated);
        }
        
        // Round values
        remainders.sort((i0: number, i1: number) => {
            let percent0 = computed[i0].percent,
                remainder0 = percent0 - Math.floor(percent0),
                percent1 = computed[i1].percent,
                remainder1 = percent1 - Math.floor(percent1);
            return remainder0 - remainder1;
        });
        for (let min = 0, max = remainders.length -1, delta = 0; min <= max;) {
            delta += round(min++);
            while ((min <= max) && (delta !== 0)) {
                delta += delta < 0 ? round(max--, true) : round(min++);
            }
        }
        return computed;
    }

    function _appendSVGGradientColor(svg: D3Selection, svgColorId: string, color: Globals.ITwoColorsGradientStyle, reverse: boolean, isHorizontal: boolean) {
        let svgGradient;
        
        if (color.type === 'twoColorsGradient') {
            let x1 = 0,
                x2 = 0,
                y1 = 0,
                y2 = 0;
                
            svgGradient = svg.append('linearGradient')
                            .attr('id', svgColorId);
                        
            if (color.style == 'vertical') {
                if (color.subStyle == 'start')
                    x2 = 100;
                else
                    x1 = 100;
            }
            else if (color.style == 'horizontal') {
                if (color.subStyle == 'start')
                    y1 = 100;
                else
                    y2 = 100;
            }
            else if (color.style == 'upperDiag') {
                x1 = 100;
                y1 = 100;
            }
            else if (color.style == 'lowerDiag') {
                x2 = 100;
                y2 = 100;
            }
            else if (color.style == 'upperCorner') {
                x2 = 100;
                y1 = 100;
            }
            else if (color.style == 'lowerCorner') {
                x1 = 100;
                y2 = 100;
            }
            else if (color.style == 'center') {
                x1 = 100;
                y2 = 100;
            }
                                   
            svgGradient.attr('x1', x1 + '%')
                       .attr('y1', y1 + '%')
                       .attr('x2', x2 + '%')
                       .attr('y2', y2 + '%');
                       
            svgGradient.append('stop')
                        .attr('offset', '0%')
                        .attr('stop-color', reverse ? Tools.Style.convertColor(color.color2) : Tools.Style.convertColor(color.color))
                        .attr('stop-opacity', 1);
             svgGradient.append('stop')
                        .attr('offset', '100%')
                        .attr('stop-color', reverse ? Tools.Style.convertColor(color.color) : Tools.Style.convertColor(color.color2))
                        .attr('stop-opacity', 1);
        }
        
    }
           
    class BarRenderer {
        private _viewPortHeight:     number;
        private _viewPortWidth:      number;
        private _nrSeries:           number;
        private _divTT:              d3.Selection<d3.BaseType, {}, d3.BaseType, {}>;
        private _lastOpenTT:         number;
        private _currentTTItem:      d3.BaseType;
        private _svg:                D3Selection;
        private _seriesDataGroups:   d3.Selection<Element, Datum[], d3.BaseType, {}>;
        private _margin:             {top:number, left:number, bottom:number, right:number};
        private _subtitles:          Globals.IChartModelSubtitles;
        private _properties:         Globals.IChartBarProperties; 
        private _isHorizontal:       boolean;
        private _dataTransposed:     boolean;
        private _data:               Datum[][];
        private _originPos:          number;
        private _seriesColor:        Array<{default:string, negative:string}>;
        private _xScale:             d3.ScaleLinear<number, number>;
        private _yScale:             d3.ScaleBand<string>;
        private _stacked:            boolean;
        
        constructor(subtitles: Globals.IChartModelSubtitles, properties: Globals.IChartBarProperties, isHorizontal: boolean, stacked: boolean) {
            this._subtitles         = subtitles;
            this._properties        = properties;
            this._isHorizontal      = isHorizontal;
            this._nrSeries          = 0;
            this._currentTTItem     = null;
            this._margin            = {top:0, left:0, bottom:0, right:0};
            this._stacked           = stacked;
        }
        
        public setData(rawData: Datum[][], dataTransposed: boolean) {
            this._data              = [];
            this._nrSeries          = 0;
            this._dataTransposed    = dataTransposed;
            
            if (!this._dataTransposed)
                this._data = rawData;
            else {
                let rows = rawData.length;
                let cols = rawData[0].length;
                
                this._data = [];
                for (let j = 0; j < cols; j++) {
                    this._data[j] = Array(rows);
                }
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        this._data[j][i] = rawData[i][j];
                    }
                }
            }
            if (this._data.length > 0)
                this._nrSeries = this._data[0].length;
        }
        
        public makeSVG(element: HTMLElement, initWidth:number, initHeight:number) {
            let _this = this;
            
            _this._viewPortHeight    = 100;
            _this._viewPortWidth     = (initHeight > 0) ? _this._viewPortHeight * (initWidth / initHeight) : _this._viewPortHeight;
            _this._svg               = d3.select(element)
                                            .append("svg")
                                            .attr("style", "overflow:visible")
                                            .attr("viewBox", "0 0 " + _this._viewPortWidth + " " + _this._viewPortHeight);
            _this._divTT             = _getChartTTDiv();
                                
            _this._addColors();
            _this._computeScales();
            
            this._seriesDataGroups = _this._svg.selectAll(".oneSeriesDataGroup")
                                        .data(_this._data)
                                        .enter()
                                        .append("g")
                                        .attr("class", "oneSeriesDataGroup")
                                        .attr("transform", function(d, index) {
                                            if (_this._isHorizontal)
                                                return "translate(0," + _this._yScale(_this._getValueAxisLabel(index).id) + ")";
                                            return "translate(" + _this._yScale(_this._getValueAxisLabel(index).id) + ", " + _this._originPos + ")"; 
                                        });
            
            _this._appendBars();        
            _this._appendLinesAndSymbols();
            _this._appendAxis();        
        }
        
        public getSVG() {
            return this._svg;
        }
        
        private _labelsPostProcess(text: D3Selection, width: number, isHeight: boolean) {
            let noDrawCount = 0;
            let minPos      = 0;
            let maxPos      = width * (text.nodes().length + 1);
                        
            text.each(function(t, idx) {
                    let text        = d3.select(this);
                    let textWidth   = isHeight ? _getChartDefaultLabelFontSize() : (<SVGTextContentElement>text.node()).getComputedTextLength() + 4;
                    let pos0        = (idx + 1) * width - textWidth / 2.0;
                    let pos1        = (idx + 1) * width + textWidth / 2.0;
                    
                    if ((pos0 >= minPos) && (pos1 <= maxPos)) {
                        minPos = pos1;
                    }
                    else {
                        text.remove();
                    }
                });
                /*
                 let text = d3.select(this),
                    words = text.text().split(/\s+/).reverse(),
                    word,
                    line: Array<string>,
                    lineNumber = 0,
                    lineHeight = 1.1, // ems
                    y = text.attr("y"),
                    dy = parseFloat(text.attr("dy")),
                    tspan : D3Selection;

                tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");              
                line = new Array();
                while (word = words.pop()) {
                    line.push(word);
                    tspan.text(line.join(" "));
                    if ((<SVGTextContentElement>tspan.node()).getComputedTextLength() > width) {
                        line.pop();
                        tspan.text(line.join(" "));
                        line = [word];
                        tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                        lineNumber++;
                    }
                }
                */
        }
        
        private _getValueAxisLabel(index: number) {
            let axisLabel = {id:'', name:''};
        
            axisLabel.id = 'AxisLabel' + index;
            if (this._dataTransposed) {
                if (index < this._subtitles.columnHeaders.length)
                    axisLabel.name = this._subtitles.columnHeaders[index]  || '';
            }
            else {
                if (index < this._subtitles.rowHeaders.length)
                    axisLabel.name = this._subtitles.rowHeaders[index] || '';
            }
            return axisLabel;
        }
        
        private _getSerieLabel(index: number) {
            let name = '';
        
            if (this._dataTransposed) {
                if (index < this._subtitles.rowHeaders.length)
                    name = this._subtitles.rowHeaders[index];
            }
            else if (this._subtitles.columnHeaders) {
                if (index < this._subtitles.columnHeaders.length)
                    name = this._subtitles.columnHeaders[index];
            }
            return name || '';
        }
                
        private _addColors() {
            let svgDefs = this._svg.append('defs');
            let _this   = this;
            
            _this._seriesColor = new Array();            
            _this._properties.series.forEach(function (serie, index) {
                let serieColor = {default:'', negative:''};
                
                if (serie.bar.color.type === 'solid')
                    serieColor.default = Tools.Style.convertColor(serie.bar.color.color);
                else if (serie.bar.color.type === 'transparent')
                    serieColor.default = 'none';
                else {
                    let colorId = 'gradientBar' + index;
                    
                    _appendSVGGradientColor(svgDefs, colorId, <Globals.ITwoColorsGradientStyle>serie.bar.color, false, _this._isHorizontal);
                    serieColor.default = 'url(#' + colorId + ')';
                }
                
                if (serie.bar.negative) {
                    if (serie.bar.negative.color.type === 'solid')
                        serieColor.negative = Tools.Style.convertColor(serie.bar.negative.color.color);
                    else if (serie.bar.color.type === 'transparent')
                        serieColor.negative = 'none';
                    else {
                        let colorId = 'gradientBarNegatice' + index;
                    
                        _appendSVGGradientColor(svgDefs, colorId, <Globals.ITwoColorsGradientStyle>serie.bar.negative.color, true, _this._isHorizontal);
                        serieColor.negative = 'url(#' + colorId + ')';
                    }
                }
                _this._seriesColor.push(serieColor);
            });
        }
        
        private _computeScales() {
            let dataExtent:         Array<number>;  
            let longestLabel:       string;    
            let minMarginForLabels: number = 0;  
            let bottomAxisProps:    Globals.IChartStyleAxis;
            let leftAxisProps:      Globals.IChartStyleAxis;
            let rawOrigin:          number;
            let _this = this;
            
            _this._margin.right += _getChartDefaultLabelFontSize();
            _this._margin.top   += _getChartDefaultLabelFontSize();
            if (_this._isHorizontal) {
                bottomAxisProps = _this._properties.xAxis;
                leftAxisProps   = _this._properties.yAxis[0];
            }
            else {
                bottomAxisProps = _this._properties.yAxis[0];
                leftAxisProps   = _this._properties.xAxis;
            }
            if (bottomAxisProps.showTickers || bottomAxisProps.showLine)
                _this._margin.bottom += _getChartDefaultLabelFontSize();
            if (bottomAxisProps.showValues && !_this._isHorizontal)
                _this._margin.bottom += 2 * _getChartDefaultLabelFontSize();
            if (_this._properties.title.visible && _this._properties.title.text && _this._properties.title.text != '')    
                _this._margin.bottom += _getChartDefaultLabelFontSize();

            if (leftAxisProps.showTickers || leftAxisProps.showLine) {
                _this._margin.left += _getChartDefaultLabelFontSize();
                 if (_this._isHorizontal)
                    _this._margin.bottom += _getChartDefaultLabelFontSize();
            }
            if (leftAxisProps.showValues || (_this._isHorizontal && bottomAxisProps.showValues))
                minMarginForLabels = -1;
             
            longestLabel    = '';
            if (_this._properties.yAxis[0].min.automatic || _this._properties.yAxis[0].max.automatic) {
                _this._data.forEach(function (d, index) {
                    let e = d3.extent(d, function(dd) { return dd.value || 0; }); 
                    if (_this._stacked) {
                        let sum = d.reduce((sum, v) => sum + (v.value || 0), 0);
                        e[0] = 0;
                        e[1] = sum;
                    }
                    if (!index)
                        dataExtent = e;
                    else {
                        dataExtent[0] = d3.min([dataExtent[0], e[0]]);
                        dataExtent[1] = d3.max([dataExtent[1], e[1]]);
                    }
                });
            }
        
            {
                let order       = Math.floor(Math.log(dataExtent[1] - dataExtent[0]) / Math.log(10));
                if (dataExtent[1] == dataExtent[0])
                    order = 1;
                let zeta       = (dataExtent[1] - dataExtent[0])/Math.pow(10.0, order);
                let epsilon    = 5;
                if (zeta >= 1 && zeta < 2)
                    epsilon = 5;
                else if (zeta >= 2 && zeta < 5)
                    epsilon = 2;
                else if (zeta >= 5 && zeta < 10)
                    epsilon = 1;
	
                let max         = Math.ceil(epsilon * dataExtent[1]/Math.pow(10.0, order));
                let min         = Math.floor(epsilon * dataExtent[0]/Math.pow(10.0, order));
            
                let tick        = Math.pow(10.0, order) / epsilon;
                dataExtent[0]   = min * tick;
                dataExtent[1]   = max * tick;
                //dataExtent[0] = Math.floor(dataExtent[0] / 10) * 10;
                //dataExtent[1] = Math.ceil(dataExtent[1] / 10) * 10;
            }
                
            if (!_this._properties.yAxis[0].min.automatic)
                dataExtent[0] = _this._properties.yAxis[0].min.value;
            
            if (!_this._properties.yAxis[0].max.automatic)
                dataExtent[1] = _this._properties.yAxis[0].max.value;
            
            rawOrigin = dataExtent[0];
            if (!_this._properties.yAxis[0].axisIntersectPoint.automatic) {
                rawOrigin = _this._properties.yAxis[0].axisIntersectPoint.value;
                if (rawOrigin < dataExtent[0])
                    dataExtent[0] = rawOrigin;
                if (rawOrigin > dataExtent[1])
                    dataExtent[1] = rawOrigin;
            }
                                  
            if (!(_this._properties.title.visible && _this._properties.title.text && _this._properties.title.text != '')) {
                if (!_this._properties.yAxis[0].showValues && !_this._properties.yAxis[0].showTickers && !_this._properties.yAxis[0].showLine) {
                    if (!_this._properties.xAxis.showValues && !_this._properties.xAxis.showTickers && !_this._properties.xAxis.showLine) {
                        _this._margin.left = _this._margin.top = _this._margin.right = _this._margin.bottom = 0;
                    }
                }
            }
                
            let expandMargin        = false;
            let defaultLeftMargin   = _this._margin.left;
            do {
                _this._xScale  = d3.scaleLinear()
                                    .rangeRound([_this._isHorizontal ? _this._margin.left : _this._viewPortHeight  - _this._margin.bottom, _this._isHorizontal ? _this._viewPortWidth - _this._margin.right : _this._margin.top])
                                    .domain(d3.extent(dataExtent));
                _this._yScale  = d3.scaleBand<string>()
                                    .range([_this._isHorizontal ? _this._margin.top : _this._margin.left, _this._isHorizontal ? _this._viewPortHeight - _this._margin.bottom : _this._viewPortWidth - _this._margin.right])
                                    .domain(_this._data.map(function (d, index) {
                                            let label = _this._getValueAxisLabel(index).name;

                                            if (label) {
                                                if (longestLabel.length < label.length)
                                                    longestLabel = label;
                                            }
                                            return _this._getValueAxisLabel(index).id;
                                        }))
                                    .padding(_this._properties.spaceX / 100.0);        

                _this._originPos = _this._xScale(rawOrigin);
                if (!expandMargin && (minMarginForLabels < 0)) {
                    let maxWidth:       number = 0;
                    let extraMargin:    number = _this._isHorizontal ? _this._originPos : 0;

                    _this._svg.append("text").text(_this._isHorizontal ? longestLabel : dataExtent[1].toString())
                                        .attr("font-size", _getChartDefaultLabelFontSize())
                                        .attr("font-family", leftAxisProps.font.fontFamily)
                                        .each(function() { maxWidth = (<SVGTextContentElement>this).getBBox().width + 15; })
                                        .remove();
                    if (Math.max(0, extraMargin) < (maxWidth + _getChartDefaultLabelFontSize())) {
                        _this._margin.left  = (defaultLeftMargin + maxWidth + _getChartDefaultLabelFontSize() - extraMargin);
                        expandMargin = true;
                    }
                }
                else
                    expandMargin = false;
            } while (expandMargin)
        }
        
        private _getDataCoords(d: Datum[], valueIndex:number, serieIndex: number) {
            let x:          number;
            let y:          number;
            let dataPos:    number;
            let valuePos:   number;
            let oneSerieWidth = this._yScale.bandwidth() / this._nrSeries;
                        
            valuePos    = this._xScale(d[serieIndex].value || 0);
            if (this._stacked) {
                oneSerieWidth   = this._yScale.bandwidth();
                dataPos         = this._yScale(this._getValueAxisLabel(valueIndex).id) + oneSerieWidth / 2;            
            } else
                dataPos         = this._yScale(this._getValueAxisLabel(valueIndex).id) + oneSerieWidth * serieIndex + oneSerieWidth / 2;            
            x  = this._isHorizontal ? valuePos : dataPos; 
            y  = this._isHorizontal ? dataPos : valuePos;
            
            return {x:x, y:y};
        }
        
        private _appendLinesAndSymbols() {
            let _this               = this;
            let seriesWithLines     = new Array<{_serieIndex:number, _path: string, _tweenStartPath: string}>();
            let seriesWithSymbols   = new Array<{_serieIndex:number}>();
            
            _this._properties.series.forEach(function (serie, serieIndex) {
                if (serie.line.visible) {
                    seriesWithLines.push({_serieIndex: serieIndex, _path: '', _tweenStartPath: ''});
                }
                if (serie.symbol.visible) {
                    seriesWithSymbols.push({_serieIndex: serieIndex});
                }
            });
            
            if (seriesWithLines.length > 0) {
                _this._data.forEach(function (d, valueIndex) {
                    seriesWithLines.forEach(function (seriePath) {
                        let coords  = _this._getDataCoords(d, valueIndex, seriePath._serieIndex);
                        let command = '';
                        
                        if (seriePath._path == '')
                            command = 'M';
                        else
                            command = 'L';
                            
                        seriePath._path             += ' ' + command + ' ' + coords.x + ' ' + coords.y;
                        seriePath._tweenStartPath   += ' ' + command + ' ' + (_this._isHorizontal ? _this._originPos : coords.x).toString() + ' ' + (_this._isHorizontal ? coords.y : _this._originPos).toString();
                    });
                    
                    seriesWithSymbols.forEach(function (seriePath) {
                        let coords      = _this._getDataCoords(d, valueIndex, seriePath._serieIndex);
                        let isNegative  = (_this._xScale(d[seriePath._serieIndex].value) - _this._originPos) < 0 ? true : false;
                        let font:       Globals.IStyleFont;
                        let color: number;
                        let charCode: string;
                        
                        if (isNegative && _this._properties.series[seriePath._serieIndex].symbol.negative) {
                            color       = _this._properties.series[seriePath._serieIndex].symbol.negative.color;
                            font        = _this._properties.series[seriePath._serieIndex].symbol.negative.font
                            charCode    = _this._properties.series[seriePath._serieIndex].symbol.negative.charCode;
                        }
                        else {
                            color       = _this._properties.series[seriePath._serieIndex].symbol.color;
                            font        = _this._properties.series[seriePath._serieIndex].symbol.font
                            charCode    = _this._properties.series[seriePath._serieIndex].symbol.charCode;
                        }
                                                
                        _this._svg.append("text")
                            .attr(_this._isHorizontal ? "y" : "x", _this._isHorizontal ? coords.y : coords.x)
                            .attr('text-anchor', "middle")
                            .attr('alignment-baseline', "middle")
                            .attr('dominant-baseline', 'middle')
                            .attr("font-family", font.fontFamily)
                            .attr('text-weight', font.fontWeight)
                            .attr('fill', Tools.Style.convertColor(color))
                            .text(String.fromCharCode(charCode.charCodeAt(0)))
                            .attr('pointer-events', 'none')
                            .attr("font-size", Math.max(7, (_this._yScale.bandwidth() / _this._nrSeries)) / 2)
                            .transition().duration(750)
                            .attrTween(_this._isHorizontal ? "x" : "y", tweenPos);
                            function tweenPos(this: SVGTextElement) {
                                var pos = _this._isHorizontal ? coords.x : coords.y,
                                    i   = d3.interpolateString(_this._originPos, pos);
                                return function (t:number) { return i(t); };
                            };
                    });
                });
                
                seriesWithLines.forEach(function (seriePath) {
                    _this._svg.append("path")
                            .attr("fill", "none")
                            .attr('pointer-events', 'none')
                            .attr("stroke", Tools.Style.convertColor(_this._properties.series[seriePath._serieIndex].line.color))
                            .attr("stroke-width", 0.5)
                            .transition().duration(750)
                            .attrTween("d", tweenPath);
                            function tweenPath(this: SVGPathElement) {
                                var l = this.getTotalLength(),
                                    i = d3.interpolateString(seriePath._tweenStartPath, seriePath._path);
                                return function (t:number) { return i(t); };
                            };
                });
            }
        }
        
        private _formatTTValue(value: number) {
            let roundedValue = value;
            
            if (Math.abs(roundedValue) < 10)
                roundedValue = Math.round(value * 100) / 100;
            else if (Math.abs(roundedValue) < 100)
                roundedValue = Math.round(value * 10) / 10;
            else
                roundedValue = Math.round(value)
            return roundedValue.toLocaleString();
        }
        private _openTT(context: BarRenderer, elem: d3.BaseType, datumArray: Datum[], serieIndex: number, axisIndex: number) {
            let datum       = datumArray[serieIndex];
            let text        = '';
            let s           = '';
                                    
            _closeCurrentTT(context);
                            
            text    = context._getSerieLabel(serieIndex);
            s       = context._getValueAxisLabel(axisIndex).name.trim();
            if (text != '') {
                text = '<span class="title">' + text + '&nbsp;:&nbsp;</span>';
            }
            text += '<span>';
            text += (s == '' ? 'Valeur' : s);
            text += " : ";
            text += this._formatTTValue(datum.value || 0);
            text += '</span>';
            
            _showTT(context, text, elem);
        }
                                                  
        private _appendBars() {
            let _this                           = this;
            let previousHeights: Array<number>  = [];          
            let interSpacePct                   = _this._properties.spaceX ? (_this._properties.spaceX / 100.0) : 0.0;
            
            _this._properties.series.forEach(function (serie, serieIndex) {
                if (!serie.bar.visible)
                    return;
                
                _this._seriesDataGroups.append("rect")
                        .attr("class", function(d) { return "serieBar serieBars" + serieIndex; })
                        .attr("fill", function (d) {
                                let datumArray : Datum[]    = <Datum[]>(d);
                                let datum                   = datumArray[serieIndex];
                                let isNegative              = (_this._xScale(datum.value || 0) - _this._originPos) < 0 ? true : false;
                                let serieColor              = _this._seriesColor[serieIndex];
                            
                                if (!_this._isHorizontal)
                                    isNegative = !isNegative;
                                
                                if (isNegative && serieColor.negative !== '')
                                    return serieColor.negative;
                                return serieColor.default;
                            })
                        .attr('pointer-events', 'all')
                        .attr(_this._isHorizontal ? "height" : "width", function(d) {
                            let ret;
                            if (_this._stacked)
                                ret = (1.0 - interSpacePct) * _this._yScale.bandwidth();
                            else
                                ret = (1.0 - interSpacePct) * _this._yScale.bandwidth() / _this._nrSeries;
                            return ret;
                        })
                        .on("click", function(event, datum) {	
                             if (_this._currentTTItem == this)	
                                _closeCurrentTT(_this);
                            else {
                                let e = _this._seriesDataGroups.nodes(),
                                    idx = e.indexOf(this.parentElement);
                                _this._openTT(_this, this, datum, serieIndex, idx);
                            }
                        })
                        .on("mouseover", function(event, datum) {	
                            let e = _this._seriesDataGroups.nodes(),
                                    idx = e.indexOf(this.parentElement);
                            _this._openTT(_this, this, datum, serieIndex, idx);
                        })					
                        .on("mouseout", function(d) {		
                            _closeCurrentTT(_this);
                        })
                        .attr("transform", function(d, idx) {
                                let datumArray : Datum[]    = <Datum[]>(d);
                                let datum                   = datumArray[serieIndex];
                                let previousHeight          = 0;
                                
                                if (!_this._isHorizontal) {
                                    let height      = _this._xScale(datum.value || 0) - _this._originPos;
                                    let xTransform  = ((_this._yScale.bandwidth() / _this._nrSeries) * serieIndex);
                                    let yTransform  = height;
                                    
                                    if (_this._stacked) {
                                        xTransform = 0;
                                        if (idx < previousHeights.length) {
                                            previousHeight          = previousHeights[idx];
                                            previousHeights[idx]    = previousHeight + height;
                                        } else {
                                            previousHeight = 0;
                                            previousHeights.push(height);
                                        }
                                        previousHeight = Math.abs(previousHeight);
                                    }
                                    
                                    yTransform = 0;
                                    if (height > 0) {
                                        xTransform += 0.5 * interSpacePct * _this._yScale.bandwidth();
                                        return "translate(" + xTransform + "," + yTransform + ") translate(0," + previousHeight + ")";
                                    }
                                    if (!_this._stacked) {
                                        xTransform -= 0.5 * interSpacePct * _this._yScale.bandwidth();
                                        xTransform += _this._yScale.bandwidth() / _this._nrSeries;
                                    }
                                    else {
                                        xTransform += _this._yScale.bandwidth();
                                        xTransform -= 0.5 * interSpacePct * _this._yScale.bandwidth();
                                    }
                                    return "translate(" + xTransform + ",0) rotate(180)" + " translate(0," + previousHeight + ")";
                                }
                                else {
                                    let width           = _this._xScale(datum.value || 0) - _this._originPos;
                                    let yTransform      = ((_this._yScale.bandwidth() / _this._nrSeries) * serieIndex);
                                    let xTransform      = _this._originPos;
                                    let previousWidth   = 0;

                                    if (_this._stacked) {
                                        yTransform = 0;
                                        if (idx < previousHeights.length) {
                                            previousWidth          = previousHeights[idx];
                                            previousHeights[idx]   = previousWidth + width;
                                        } else {
                                            previousWidth = 0;
                                            previousHeights.push(width);
                                        }
                                        previousWidth = Math.abs(previousWidth);
                                    }
                                    
                                    yTransform += 0.5 * interSpacePct * _this._yScale.bandwidth();
                                
                                    if (width < 0) {
                                        yTransform += (_this._yScale.bandwidth() / _this._nrSeries) - interSpacePct * _this._yScale.bandwidth();
                                        return "rotate(180) translate(-" + xTransform + ",-" + yTransform + ")";
                                    }
                                    return "translate(" + xTransform + "," + yTransform + ")"  + " translate(" + previousWidth + ", 0)";
                                }
                            })
                        .transition().duration(750)
                        .attr(_this._isHorizontal ? "width" : "height", function(d) { 
                                let datumArray : Datum[]    = <Datum[]>(d);
                                let datum                   = datumArray[serieIndex];
                                
                                let width = _this._xScale(datum.value || 0) - _this._originPos;
                                return Math.abs(width || 0);
                        });
                });
        }
            
        private _insertSVGAxis(classAttr:string, axis: any, propAxis: Globals.IChartStyleAxis) {
            let axisGroup = this._svg.append('g')
                                    .attr("class", classAttr)
                                    .call(axis);
        
            if (!propAxis.showValues)
                axisGroup.selectAll("text").remove();
            else {
                axisGroup.selectAll("text").attr("font-size", _getChartDefaultLabelFontSize());
                axisGroup.selectAll("text").attr("font-weight", propAxis.font.fontWeight);
                axisGroup.selectAll("text").attr("font-family", propAxis.font.fontFamily);
            }
            if (!propAxis.showLine)    
                axisGroup.selectAll(".domain").remove();
            else
                axisGroup.selectAll(".domain").attr("stroke-width", 0.4);
            if (!propAxis.showTickers)    
                axisGroup.selectAll(".tick line").remove();
            else
                axisGroup.selectAll(".tick line").attr("stroke-width", 0.4);
            return axisGroup
        }
        
        private _appendAxis() {
            let _this = this;
            
            let xAxis : d3.Axis<any>;
            let yAxis : d3.Axis<any>;
            
            if (_this._isHorizontal) {
                xAxis = d3.axisBottom(_this._xScale).tickSize(4).tickSizeOuter(0);
                yAxis = d3.axisLeft(_this._yScale).tickSize(4).tickSizeOuter(0);
            }
            else {
                xAxis = d3.axisLeft(_this._xScale).tickSize(4).tickSizeOuter(0);
                yAxis = d3.axisBottom(_this._yScale).tickSize(4).tickSizeOuter(0);
            }
            
            xAxis.tickFormat(function(tickValue) { return tickValue.toLocaleString(); })
            yAxis.tickFormat(function(tickId, index) { return _this._getValueAxisLabel(index).name; })
            if (_this._isHorizontal) {
                let xAxisGroup = _this._insertSVGAxis("x axis", xAxis, _this._properties.yAxis[0]);                                 
                let yAxisGroup = _this._insertSVGAxis("y axis", yAxis, _this._properties.xAxis);
            
                yAxisGroup.attr("transform", "translate(" + _this._originPos + ", 0)");
                xAxisGroup.attr("transform", "translate(0, " + (_this._viewPortHeight - _this._margin.bottom) + ")");
                
                yAxisGroup.selectAll(".tick text").attr('pointer-events', 'none')
                xAxisGroup.selectAll(".tick text").attr('pointer-events', 'none')
                
                 if (_this._properties.xAxis.showValues) {
                    let v0 = _this._xScale.ticks()[0],
                        v1 = _this._xScale.ticks()[1];
                    let xTickIntervalHeight =  Math.abs(_this._xScale(v1) - _this._xScale(v0));
                    xAxisGroup.selectAll(".tick text").call(_this._labelsPostProcess, xTickIntervalHeight - 1, true);
                }
            }
            else {
                let xAxisGroup = _this._insertSVGAxis("x axis", xAxis, _this._properties.yAxis[0]);                                 
                let yAxisGroup = _this._insertSVGAxis("y axis", yAxis, _this._properties.xAxis);
                
                yAxisGroup.attr("transform", "translate(0, " + _this._originPos + ")");
                xAxisGroup.attr("transform", "translate(" + _this._margin.left + " , 0)");
                if (_this._properties.yAxis[0].showValues) {
                    let v0 = _this._xScale.ticks()[0],
                        v1 = _this._xScale.ticks()[1];
                    let xTickIntervalHeight =  Math.abs(_this._xScale(v1) - _this._xScale(v0));
                    xAxisGroup.selectAll(".tick text").call(_this._labelsPostProcess, xTickIntervalHeight, true);
                }
                if (_this._properties.xAxis.showValues) {
                    yAxisGroup.selectAll(".tick text").call(_this._labelsPostProcess, _this._yScale.bandwidth(), false);
                }
                                    
                yAxisGroup.selectAll(".tick text").attr('pointer-events', 'none')
                xAxisGroup.selectAll(".tick text").attr('pointer-events', 'none')
            }
            
            if (_this._properties.title.visible && _this._properties.title.text && _this._properties.title.text != '') {
                _this._svg.append("text")
                       .attr("font-size", _getChartDefaultLabelFontSize())
                       .attr("font-weight", _this._properties.title.font.fontWeight)
                       .attr("font-family", _this._properties.title.font.fontFamily)
                       .attr('x', _this._viewPortWidth / 2)
                       .attr('y', _this._viewPortHeight - _getChartDefaultLabelFontSize())
                       .attr('text-anchor', "middle")
                       .attr('alignment-baseline', "hanging")
                       .attr('dominant-baseline', 'hanging')
                       .attr('fill', Tools.Style.convertColor(_this._properties.title.color))
                       .text(_this._properties.title.text);
            }
        }
    }
            
    function _renderBar(element: HTMLElement, subtitles: Globals.IChartModelSubtitles, rawData: Datum[][], properties: Globals.IChartBarProperties, isHorizontal: boolean, dataTransposed: boolean, initWidth:number, initHeight:number, stacked: boolean): D3Selection {
        let barRendererData = new BarRenderer(subtitles, properties, isHorizontal, stacked);
        
        if (element.style) {
            element.style.overflow 	= "visible";
			//element.style.zIndex 	= "9999";
		}
            
        barRendererData.setData(rawData, dataTransposed);
        barRendererData.makeSVG(element, initWidth, initHeight);
        
        return barRendererData.getSVG();
    }
    
    function _transpose(data: Datum[][]): Datum[][] {
        return data && data[0] && data[0].map((value, x) => data.map((row, y) => data[y][x]));
    }
    
    function _round(value: number, precision: number = 1) {
        const dec = Math.pow(10, precision);
        return Math.round(value * dec) / dec;
    }
    
    function _applyFont(d3: D3Selection, height: number, font: Globals.IChartStyleFont, defaultFont?: Globals.IChartStyleFont): D3Selection {
        let fontSize;
        
        if (font) {
            const f: Partial<Globals.IChartStyleFont> = defaultFont || {};
            
            font.fontFamily && f.fontFamily !== font.fontFamily && d3.attr("font-family", font.fontFamily);
            font.fontSize && (fontSize = font.fontSize);
            font.fontWeight && f.fontWeight !== font.fontWeight && d3.attr("font-weight", font.fontWeight);
            font.fontStyle && f.fontStyle !== font.fontStyle && d3.attr("font-style", font.fontStyle);
            font.textDecoration && f.textDecoration !== font.textDecoration && d3.attr("text-decoration", font.textDecoration);
        }
        if (font.fontSize || !defaultFont) {
            d3.attr("style", `font-size: ${font.fontSize || /*_getChartDefaultLabelFontSize()*/12}pt`);
        }
        return d3;
    }
    
    function _drawPie(selection: d3.Selection<d3.BaseType, unknown, null, undefined>, style: Globals.IChartStylePie, values: d3.PieArcDatum<IPieDatum>[], radius: number, innerRadius?: number):
            [d3.Arc<any, d3.PieArcDatum<IPieDatum>>, d3.Selection<SVGGElement, d3.PieArcDatum<IPieDatum>, d3.BaseType, unknown>] {
        let arc = d3.arc<any, d3.PieArcDatum<IPieDatum>>()
            .innerRadius(innerRadius || 0)                
            .outerRadius(radius);
        let arcs = selection
            .selectAll("g")
            .data(values)
            .enter().append("g");

        let enterClockwise: d3.PieArcDatum<IPieDatum> = <any>{
            startAngle: 0,
            endAngle: 0
        };

        let path = arcs.append("path")
            .each(function(this: SVGPathElement&{_current: any;}, d: d3.PieArcDatum<IPieDatum>) {
                let part = d.data.part;
                this.setAttribute("fill", Tools.Style.convertColor(part.fillColor));
                if (_getOpacity(part.borderColor)) {
                    this.setAttribute("stroke-width", <any>(radius / 50));
                    this.setAttribute("stroke",  Tools.Style.convertColor(part.borderColor));
                }
                this.setAttribute("d", arc(enterClockwise));
                if (style.explode && style.explode === d.index) {
                    var centroid = arc.centroid(d);
                    centroid[0] *= 2.0 * style.radial / 100.0;
                    centroid[1] *= 2.0 * style.radial / 100.0;
                    this.setAttribute("transform", "translate(" + centroid[0] + ", " + centroid[1] + ")");
                }

              this._current = {
                data: d.data,
                value: d.value,
                startAngle: enterClockwise.startAngle,
                endAngle: enterClockwise.endAngle
              }
            }); // store the initial values                    
        path.transition()  // update
            .duration(750)
            .attrTween("d", arcTween);
        function arcTween(this: SVGPathElement&{_current: any;}, a: d3.PieArcDatum<IPieDatum>) {
            var i = d3.interpolate(this._current, a);
            this._current = i(0);
            return function(t: number) {
                return arc(i(t));
            };
        }
        return [arc, arcs];
    }
    
    function _drawSubtitle(selection: d3.Selection<d3.BaseType, unknown, null, undefined>, style: Globals.IChartStyleTitle, title: string, height: number, translateY: number, defaultFont?: Globals.IChartStyleFont): [number, d3.Selection<d3.BaseType, unknown, null, undefined>] {
        let ret: [number, d3.Selection<d3.BaseType, unknown, null, undefined>] = [height, selection],
            text,
            titleHeight;
        
        if (style.visible) {
            text = <d3.Selection<SVGTextContentElement, unknown, null, undefined>>_applyFont(selection.append("text"), height, style.font, defaultFont)
                .attr('text-anchor', "middle")
                .attr('dominant-baseline', 'text-before-edge')
                .attr('fill', Tools.Style.convertColor(style.color))
                .text(title || '');
            titleHeight = text.node().getBBox().height;
            text.attr('y', _round(height - translateY - titleHeight));
            ret = [height - titleHeight, selection
                    .append('g')
                    .attr("transform", `translate(0, ${-titleHeight / 2})`)];
        }
        return ret;
    }
    
    
    function _renderPie(element: HTMLElement, subtitles: Globals.IChartModelSubtitles, data: Datum[][], properties: Globals.IChartPieProperties, hole: number, width: number, height: number, dataTransposed: boolean): D3Selection {
        const svg: D3Selection   = _applyFont(d3.select(element).append("svg")
                                    .attr("style", "overflow:visible")
                                    .attr("viewBox", `0 0 ${width} ${height}`), height, properties.font);

        const borderLeft = 5,
            borderRight = width - 5;    // TODO : implement correct label positioning
                                    
        if (element.style)
            element.style.overflow = "visible";
        
        const formattedData = dataTransposed ? _transpose(data) : data;
        const part0: Datum[] = formattedData?.[0];
        
        if (part0) {
            const titleProperties = properties.title,
                labelProperties = properties.label;
            const showLabels: boolean = labelProperties.visible;
            const showPercent: boolean = labelProperties.showPercent;
            const stackMode = part0.length > 1;     // stack mode = chart are drawn over its predecessor
            let availableHeight: number = height;
            let translateY = height / 2;

            if (titleProperties.visible) {
                let titleHeight,
                    textAnchor = 'start',
                    x = null,
                    y = 0;
                
                if (titleProperties?.align !== 'left') {
                    if (titleProperties.align === 'center') {
                        textAnchor = 'middle';
                        x = width / 2;
                    }
                    if (titleProperties.align === 'right') {
                        textAnchor = 'end';
                        x = width;
                    }
                }
                const text = <d3.Selection<SVGTextContentElement, unknown, null, undefined>>_applyFont(svg.append("text"), height, titleProperties.font, properties.font)
                        .attr('x', x)
                        .attr('y', y)
                        .attr('text-anchor', textAnchor)
                        .attr('dominant-baseline', 'text-before-edge')
                        .attr('fill', Tools.Style.convertColor(titleProperties.color))
                        .text(titleProperties.text);
                        
                titleHeight = text.node().getBBox().height;
                availableHeight -= titleHeight;
                if (titleProperties.placement === 'bottom') {
                    y = availableHeight;
                    text.attr('y', y);
                }
                translateY += _round(titleHeight / (y ? -2 : 2), 1);
            }
            
            const translateX = width / 2;
            const g: D3Selection = svg
                    .append("g")
                    .attr("transform", `translate(${width / 2}, ${translateY})`);
            const pie = d3.pie<IPieDatum>()
                    .value((d: IPieDatum) => d.value)
                    .startAngle(((properties.pie.angle || 0) - 90) * Math.PI / 180)
                    .sort(null);
            const radius: number = Math.min(width, availableHeight) / 2;
            const ring: number = ((100 - hole) / 100) * radius;
           
            let draw = function(this: d3.BaseType, d: Datum, j: number) {
                const values: d3.PieArcDatum<IPieDatum>[] = pie(_getPieData(formattedData, j, properties));
                values.forEach((d: d3.PieArcDatum<IPieDatum>)=> {
                    d.startAngle = - d.startAngle;
                    d.endAngle = - d.endAngle;
                });
                
                let selection = d3.select(this);
                
                if (stackMode) {
                    let outerRadius = radius - (j * ring),
                        innerRadius = (outerRadius - ring) * (j === (part0.length - 1) ? 1 : 0.99);                   
                    _drawPie(selection, properties.pie, values, outerRadius, innerRadius);
                } else if (!j) {
                    [availableHeight, selection] = _drawSubtitle(selection, properties.subtitle, subtitles?.columnHeaders[j], availableHeight, translateY, properties.font);
                    let radius = Math.min(width, availableHeight) * ((showLabels || showPercent) ? 0.5 : 0.9) / 2;
                    let [arc, arcs] = _drawPie(selection, properties.pie, values, radius, radius * hole / 100);
                    let labelRadius = radius + 10;
                
                    if (showLabels || showPercent) {
                        function _getTextPos(d: d3.PieArcDatum<IPieDatum>) {
                            let c = arc.centroid(d),
                                    x = c[0],
                                    y = c[1],
                                    // pythagorean theorem for hypotenuse
                                    h = Math.sqrt(x*x + y*y),
                                    bias = labelProperties.showPartColor ? 5 : 0;
                            return { x: ((x/h * labelRadius) - bias), y: ((y/h * labelRadius) - bias)}; 
                        }
                        arcs.append("g")
                            .attr("transform", function(d: d3.PieArcDatum<IPieDatum>) {
                                let pos = _getTextPos(d);
                                return "translate(" + pos.x +  ',' + pos.y +  ")"; 
                            })
                            .each(function(this: SVGGElement, d: d3.PieArcDatum<IPieDatum>) {
                                let part: Globals.IChartStylePartSerie = d.data.part;
                                let val: number = (d.endAngle + d.startAngle) / 2;
                                let left: boolean = ((val) < 0) && (val > -Math.PI);
                                let top: boolean = Math.abs(val) < Math.PI / 2;
                                let selection = d3.select(this);

                                if ((d.value != 0) && ((part.label.visible && part.name) || part.label.showPercent)) {
                                    let percent: string = (part.label.showPercent && showPercent) && `${d.data.percent} %`;
                                    let pos             = _getTextPos(d);
                                    let textWidth       = 0;
                                    let textHeight      = 0;
                                    let text            = (part.label.visible && showLabels) ? part.name + (percent ? ` (${percent})` : '') : percent;
                                    let toDraw: Array<string>;
                                    let font = $.extend({}, labelProperties.font, d.data.part.label.font);

                                    _applyFont(selection, height, font, properties.font)
                                            .append("text")
                                            .text(text)
                                            .each(function() { 
                                                textWidth  = (<SVGTextContentElement>this).getBBox().width; 
                                                textHeight = (<SVGTextContentElement>this).getBBox().height; 
                                                })
                                            .remove();

                                    toDraw = Array(text);
                                    if (left) {
                                        if ((pos.x + translateX - textWidth) <= borderLeft)
                                            toDraw = _breakText(text);
                                    }
                                    else {
                                        if ((pos.x + translateX + textWidth) >= borderRight)
                                            toDraw = _breakText(text);
                                    }
                                    
                                    const xOffset = top && toDraw.length > 1 && text ? - textWidth * 2 / text.length : 0; // roughly 2 characters

                                    toDraw.forEach(function(line, index) {
                                        selection.append('text')
                                            .text(line)
                                            .each(function(this: SVGTextElement) {
                                                this.setAttribute('fill', Tools.Style.convertColor(d.data.part.label.color));
                                                this.setAttribute('text-anchor', left ? 'end' : 'start');
                                                this.setAttribute('dominant-baseline', 'middle');
                                                if (labelProperties.showPartColor) {
                                                    this.setAttribute('x', (left ? -2 : 9) + <any>xOffset);
                                                    this.setAttribute('y', <any>(6 + textHeight * index));
                                                }
                                                else
                                                    xOffset && this.setAttribute('x', <any>xOffset);
                                                    this.setAttribute('y', <any>(textHeight * index));
                                            });
                                    });
                                }
                                if (labelProperties.showPartColor) {
                                    selection.insert('rect', function(this: SVGGElement) {
                                            return left ? <SVGTextElement>this.firstChild : null;
                                        })
                                        .each(function(this: SVGRectElement) {
                                            if (d.value != 0) {
                                                this.setAttribute('width', <any>7);
                                                this.setAttribute('height', <any>7);
                                                this.setAttribute('fill', Tools.Style.convertColor(d.data.part.fillColor));
                                                this.setAttribute('stroke', 'black');
                                                this.setAttribute('stroke-width', <any>(radius / 50));
                                            }
                                        });
                                }
                            });
                        }                    
                    }
                };

            g.selectAll("g")
                .data(part0)
                .enter()
                .append("g")
                .each(draw);
        }
        return svg;            
    }
        
    class RadarRenderer {
        private _viewPortHeight:     number;
        private _viewPortWidth:      number;
        private _divTT:              d3.Selection<d3.BaseType, {}, d3.BaseType, {}>;
        private _lastOpenTT:         number;
        private _currentTTItem:      d3.BaseType;
        private _svg:                D3Selection;
        private _margin:             {top:number, left:number, bottom:number, right:number};
        private _subtitles:          Globals.IChartModelSubtitles;
        private _properties:         Globals.IChartRadarProperties; 
        private _dataTransposed:     boolean;
        private _data:               Datum[][];
        private _nrSeries:           number;
        private _labelFontSize:      number;
        private _axisInfo:          {
                                        width:          number;
                                        originX:        number;
                                        originY:        number;
                                        tick:           number;
                                        maxValue:       number;
                                        minValue:       number;
                                    };
        
        constructor(subtitles: Globals.IChartModelSubtitles, properties: Globals.IChartRadarProperties) {
            this._subtitles         = subtitles;
            this._properties        = properties;
            this._currentTTItem     = null;
            this._margin            = {top:0, left:0, bottom:0, right:0};
            this._axisInfo          = { width:0,
                                        originX:0,
                                        originY:0,
                                        tick:0,
                                        maxValue:0,
                                        minValue:0
                                    };
        }
        
         private _openTT(context: RadarRenderer, elem: d3.BaseType, iSerie: number) {
            let text        = '<div class="title">' + context._properties.series[iSerie].name + '</div>';
            _showTT(context, text, elem);
        }
                       
        public setData(rawData: Datum[][], dataTransposed: boolean) {
            this._data              = [];
            this._nrSeries          = 0;
            this._dataTransposed    = dataTransposed;
            
            if (!this._dataTransposed)
                this._data = rawData;
            else {
                let rows = rawData.length;
                let cols = rawData[0].length;
                
                this._data = [];
                for (let j = 0; j < cols; j++) {
                    this._data[j] = Array(rows);
                }
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        this._data[j][i] = rawData[i][j];
                    }
                }
            }
            if (this._data.length > 0)
                this._nrSeries = this._data[0].length;
        }
        
        private _computeScales() {
            let dataExtent: Array<number>;  
            let _this = this;
            
            _this._margin.left      += _getChartDefaultLabelFontSize();
            _this._margin.right     += _getChartDefaultLabelFontSize();
            _this._margin.top       += _getChartDefaultLabelFontSize();
            _this._margin.bottom    += _getChartDefaultLabelFontSize();
            
            if (_this._properties.axes.min.automatic || _this._properties.axes.max.automatic) {
                _this._data.forEach(function (d, index) {
                    let e = d3.extent(d, function(dd) { return dd.value; }); 
                        if (!index)
                            dataExtent = e;
                        else {
                            dataExtent[0] = d3.min([dataExtent[0], e[0]]);
                            dataExtent[1] = d3.max([dataExtent[1], e[1]]);
                        }
                });
            }
        
            {
                let order = Math.floor(Math.log(dataExtent[1] - dataExtent[0]) / Math.log(10));
                let zeta       = (dataExtent[1] - dataExtent[0])/Math.pow(10.0, order);
                let epsilon    = 5;
                if (zeta >= 1 && zeta < 2)
                    epsilon = 5;
                else if (zeta >= 2 && zeta < 5)
                    epsilon = 2;
                else if (zeta >= 5 && zeta < 10)
                    epsilon = 1;
	
                let max         = Math.ceil(epsilon * dataExtent[1]/Math.pow(10.0, order));
                let min         = Math.floor(epsilon * dataExtent[0]/Math.pow(10.0, order));
            
                let tick        = Math.pow(10.0, order) / epsilon;
                dataExtent[0]   = min * tick;
                dataExtent[1]   = max * tick;
                //dataExtent[0] = Math.floor(dataExtent[0] / 10) * 10;
                //dataExtent[1] = Math.ceil(dataExtent[1] / 10) * 10;
                
                _this._axisInfo.tick = tick;
            }
                
            if (!_this._properties.axes.min.automatic)
                dataExtent[0] = _this._properties.axes.min.value;
            if (!_this._properties.axes.max.automatic)
                dataExtent[1] = _this._properties.axes.max.value;
            
            //_this._axisInfo.width       = Math.min(_this._viewPortWidth / 2 - (_this._margin.right + _this._margin.left), _this._viewPortHeight / 2 - (_this._margin.bottom + _this._margin.top));
            _this._axisInfo.width       = Math.min(_this._viewPortWidth / 2 - Math.max(_this._margin.right, _this._margin.left), _this._viewPortHeight / 2 - Math.max(_this._margin.bottom, _this._margin.top));
            _this._axisInfo.originX     = _this._viewPortWidth / 2;
            _this._axisInfo.originY     = _this._viewPortHeight / 2;
            _this._axisInfo.minValue    = dataExtent[0];
            _this._axisInfo.maxValue    = dataExtent[1];
            
            let minWidth = 3.0 * (_this._axisInfo.width / 4.0);
             _this._properties.axes.labels.forEach(function(label, index) {
                let localLabels     = _breakText(label);
                let labelWidth      = 0;
                let textAnchor      = _this._getAxisTextAnchor(index);
                let newWidth        = _this._axisInfo.width;
                let newWidthToTest  = newWidth;
                
                localLabels.forEach(function(localLabel, index2) {    
                    let fontTooBig = true;
                    while (fontTooBig)  {
                        fontTooBig = false;
                        _this._svg.append("text").text(localLabel)
                                            .attr("font-size", _this._labelFontSize)
                                            .attr("font-family", _this._properties.axes.font.fontFamily)
                                            .attr('text-weight', _this._properties.axes.font.fontWeight)
                                            .each(function() { labelWidth = (<SVGTextContentElement>this).getBBox().width; })
                                            .remove();
                        let maxValueCoords  = _this._getCoords(index, _this._axisInfo.maxValue);
                        if (textAnchor == 'start') {
                            if ((maxValueCoords.x + labelWidth) >= (_this._viewPortWidth - 1)) {
                                fontTooBig = true;
                                newWidthToTest -= maxValueCoords.x + labelWidth - _this._viewPortWidth + 1 + 1;
                            }
                        }
                        else if (textAnchor == 'end') {
                            if ((maxValueCoords.x - labelWidth) <= 0) {
                                fontTooBig = true;
                                newWidthToTest -= labelWidth - maxValueCoords.x + 1;
                            }
                        }
                        if (fontTooBig) {
                            if (newWidth <= minWidth)
                                _this._labelFontSize -= 0.1;
                            else
                                newWidth = newWidthToTest;
                        }
                        if (_this._labelFontSize < 1)
                            fontTooBig = false;
                        _this._axisInfo.width = Math.max(minWidth, newWidth);
                    }                    
                });
             });
        }
        private _getAxisTextAnchor(index: number) {
             let angle   = this._getAxisAngle(index);
             let result = 'start';
             
             if (angle == Math.PI / 2.0)
                result = 'middle';
             else if (angle < 3 * (Math.PI / 2.0) && (angle > (Math.PI / 2.0)))
                result = 'end';
             else if (angle == 3 * (Math.PI / 2.0))
                result = 'middle';
             return result;
        }
        private _getAxisTextBaseLine(index: number) {
             let angle   = this._getAxisAngle(index);
             let result = 'start';
             
             if ((angle >= 0) && (angle <= Math.PI))
                result = 'baseline';
             else
                result = 'hanging';
             return result;
        }
        private _getAxisAngle(iAxe:number) {
            let angle  = 0;
            
            if (this._properties.axes.labels.length == 2) {
                if (!iAxe)
                    angle = Math.PI / 2.0;
                else
                    angle = 0.0;
            }
            else
                angle = (Math.PI / 2.0) + 2 * iAxe * Math.PI / this._properties.axes.labels.length;	
            
            return (angle % (2 * Math.PI));
        }
        
        private _getCoords(iAxe:number, iValue:number) {
            let result  = {x:0, y:0};
            let angle   = this._getAxisAngle(iAxe);
            let proj    = ((iValue || 0) - this._axisInfo.minValue) * this._axisInfo.width / (this._axisInfo.maxValue - this._axisInfo.minValue);
            
            result.x = this._axisInfo.originX + proj * Math.cos(angle);
            result.y = this._axisInfo.originY - proj * Math.sin(angle);
            return result;
        }
        private _appendAxis() {
            let _this = this;
            
            _this._properties.axes.labels.forEach(function(label, index) {
                let axis            = _this._svg.append('svg:line').attr("class", "axes");
                let minValueCoords  = _this._getCoords(index, _this._axisInfo.minValue);
                let maxValueCoords  = _this._getCoords(index, _this._axisInfo.maxValue);
                let localLabels     = Array(label);
                let labelWidth      = 0;
                let baseLine        = _this._getAxisTextBaseLine(index);
                let textAnchor      = _this._getAxisTextAnchor(index);
                let multiLine       = false;
                                
                axis.attr("x1", minValueCoords.x)
                    .attr("y1", minValueCoords.y)
                    .attr("x2", maxValueCoords.x)
                    .attr("y2", maxValueCoords.y)
                    .attr('pointer-events', 'none');
                if (_this._properties.axes.showLine) {
                    axis.attr("stroke", Tools.Style.convertColor(_this._properties.axes.color))
                        .attr("stroke-width", 0.5);
                }
                
                _this._svg.append("text").text(label)
                                        .attr("font-size", _this._labelFontSize)
                                        .attr("font-family", _this._properties.axes.font.fontFamily)
                                        .attr('text-weight', _this._properties.axes.font.fontWeight)
                                        .each(function() { labelWidth = (<SVGTextContentElement>this).getBBox().width; })
                                        .remove();
                if (textAnchor == 'start') {
                    if ((maxValueCoords.x + labelWidth) > (_this._viewPortWidth - 5))
                        multiLine = true;
                }
                else if (textAnchor == 'end') {
                    if ((maxValueCoords.x - labelWidth) < 5)
                        multiLine = true;
                }
                if (multiLine)
                    localLabels = _breakText(label);
                else
                    localLabels = Array(label);
                                        
                localLabels.forEach(function(localLabel, index) {
                    _this._svg.append("text").text(localLabel).attr("font-size", _this._labelFontSize)
                        .attr("x", maxValueCoords.x + (textAnchor == 'start' ? 1 : 0))
                        .attr("y", maxValueCoords.y - (baseLine == 'baseline' ? 1 : 0) + (index * _this._labelFontSize))
                        .attr('pointer-events', 'none')
                        .attr('text-anchor', textAnchor)
                        .attr('alignment-baseline', baseLine)
                        .attr('dominant-baseline', baseLine)
                        .attr("font-family", _this._properties.axes.font.fontFamily)
                        .attr('text-weight', _this._properties.axes.font.fontWeight)
                        .attr('fill', Tools.Style.convertColor(_this._properties.axes.textColor));
                });
                        
                if (!index && _this._properties.axes.showValues) {
                    let iTickValue = _this._axisInfo.minValue;
                    for (; iTickValue <= _this._axisInfo.maxValue; iTickValue += _this._axisInfo.tick) {
                         let coords  = _this._getCoords(index, iTickValue);
                         
                        _this._svg.append("text").text(iTickValue.toString()).attr("font-size", _getChartDefaultTickFontSize())
                            .attr("x", coords.x)
                            .attr("y", coords.y)
                            .attr('pointer-events', 'none')
                            .attr('alignment-baseline', 'hanging')
                            .attr('dominant-baseline', 'hanging')
                            .attr("font-family", _this._properties.axes.font.fontFamily)
                            .attr('text-weight', _this._properties.axes.font.fontWeight)
                            .attr('fill', Tools.Style.convertColor(_this._properties.axes.textColor));
                    }
                }
            });
        }
        
        private _appendGrid() {
            let _this           = this;
            let iTickValue      = _this._axisInfo.minValue + _this._axisInfo.tick;
            
            for (; iTickValue <= _this._axisInfo.maxValue; iTickValue += _this._axisInfo.tick) {
                let i       = 0;
                let path    = '';
                for (i = 0; i < _this._properties.axes.labels.length; i++) {
                    let command = '';
                    let coords  = _this._getCoords(i, iTickValue);
                    if (path == '')
                        command = 'M';
                    else
                        command = 'L';
                    path            += ' ' + command + ' ' + coords.x + ' ' + coords.y;
                }
                let coords  = _this._getCoords(0, iTickValue);
                
                path            += ' L ' + coords.x + ' ' + coords.y;
                _this._svg.append("path")
                        .attr('pointer-events', 'none')
                        .attr("fill", "transparent")
                        .attr("stroke", Tools.Style.convertColor(_this._properties.axes.color))
                        .attr("stroke-width", 0.5)
                        .attr("d", path);
            }
        }
        
        private _appendSeries() {
            let _this   = this;
            let svgDefs = _this._svg.append('defs');
            let iSerie  = 0;
            
            for (; iSerie < _this._data.length; iSerie++) {
                let i               = 0;
                let _iSerie         = iSerie;
                let path            = '';
                let tweenStartPath  = '';
                let strokeStyle     = _this._properties.series[iSerie].line.visible ? Tools.Style.convertColor(_this._properties.series[iSerie].line.color) : 'none';
                
                for (i = 0; i < _this._properties.axes.labels.length; i++) {
                    let command = '';
                    let coords  = _this._getCoords(i, _this._data[iSerie][i].value);
                    if (path == '')
                        command = 'M';
                    else
                        command = 'L';
                    path            += ' ' + command + ' ' + coords.x + ' ' + coords.y;
                    tweenStartPath  += ' ' + command + ' ' + _this._axisInfo.originX + ' ' + _this._axisInfo.originY;
                }
                let coords  = _this._getCoords(0, _this._data[iSerie][0].value);
                path            += ' L ' + coords.x + ' ' + coords.y;
                tweenStartPath  += ' L ' + _this._axisInfo.originX + ' ' + _this._axisInfo.originY;
                let svgPath = _this._svg.append("path").attr("d", path);
                
                if (_this._properties.series[iSerie].filling.visible) {
                    let color = 'none';
                    
                    if (_this._properties.series[iSerie].filling.color.type === 'solid')
                        color = Tools.Style.convertColor(_this._properties.series[iSerie].filling.color.color);
                    else {
                        let colorId = 'gradientBar' + iSerie;
                    
                        _appendSVGGradientColor(svgDefs, colorId, <Globals.ITwoColorsGradientStyle>_this._properties.series[iSerie].filling.color, false, false);
                        color = 'url(#' + colorId + ')';
                    }
                    svgPath.attr("fill", color);
                    
                    if (_this._properties.series[iSerie].filling.transparency)
                        svgPath.attr("fill-opacity", _this._properties.series[iSerie].filling.transparency / 100.0);
                }
                else
                    svgPath.attr("fill", "transparent");
                 
                svgPath.attr('pointer-events', 'all');    
                if (_this._properties.series[iSerie].line.visible) {   
                    svgPath.attr("stroke", strokeStyle)
                    svgPath.attr("stroke-width", _this._properties.series[iSerie].line.width / 2);
                    svgPath.attr('pointer-events', 'stroke');
                }
                else
                    svgPath.attr("stroke-width", 0.0);
                    
                svgPath.on("click", function(d) {	
                            if (_this._currentTTItem == this)	
                                _closeCurrentTT(_this);
                            else
                                _this._openTT(_this, this, _iSerie);
                        })
                        .on("mouseover", function(d) {	
                            _this._openTT(_this, this, _iSerie);
                        })					
                        .on("mouseout", function(d) {		
                            _closeCurrentTT(_this);
                        });
                                    
                svgPath.transition().duration(750)
                       .attrTween("d", function (this: SVGPathElement) {
                                            var l = this.getTotalLength(),
                                            i = d3.interpolateString(tweenStartPath, path);
                                            return function (t:number) { return i(t); };
                                        });
              
            }
        }
        
        public makeSVG(element: HTMLElement, initWidth:number, initHeight:number) {
            let _this           = this;
            let titleVisible    = false;
            
            if (_this._properties.title.visible && _this._properties.title.text && _this._properties.title.text != '')
                titleVisible = true;
                
            _this._viewPortHeight   = 100;
            if (titleVisible)
                _this._margin.bottom += _getChartDefaultLabelFontSize();
            _this._viewPortWidth     = (initHeight > 0) ? _this._viewPortHeight * (initWidth / initHeight) : _this._viewPortHeight;
            _this._svg               = d3.select(element).append("svg").attr("viewBox", "0 0 " + _this._viewPortWidth + " " + _this._viewPortHeight).attr("style", "overflow:visible");
            _this._divTT             = _getChartTTDiv();
            _this._labelFontSize    = _getChartDefaultLabelFontSize();
            
            _this._computeScales();
            _this._appendGrid();
            _this._appendSeries();
            _this._appendAxis();
            
            if (titleVisible) {
                 _this._svg.append("text")
                        .attr("font-size", _getChartDefaultLabelFontSize())
                        .attr("font-weight", _this._properties.title.font.fontWeight)
                        .attr("font-family", _this._properties.title.font.fontFamily)
                        .attr('x', _this._viewPortWidth / 2)
                        .attr('y', _this._viewPortHeight - _getChartDefaultLabelFontSize())
                        .attr('text-anchor', "middle")
                        .attr('alignment-baseline', "hanging")
                        .attr('dominant-baseline', 'hanging')
                        .attr('fill', Tools.Style.convertColor(_this._properties.title.color))
                        .text(_this._properties.title.text);
             }
        }
        
        public getSVG() {
            return this._svg;
        }
    }
    
    function _renderRadar(element: HTMLElement, subtitles: Globals.IChartModelSubtitles, rawData: Datum[][], properties: Globals.IChartRadarProperties, dataTransposed: boolean, initWidth:number, initHeight:number): D3Selection {
        let radarRendererData = new RadarRenderer(subtitles, properties);
        
        if (element.style)
            element.style.overflow = "visible";
            
        radarRendererData.setData(rawData, dataTransposed);
        radarRendererData.makeSVG(element, initWidth, initHeight);
        
        return radarRendererData.getSVG();
    }
    
    const _renderers: {[key: number]: ((element: HTMLElement, chart: Globals.IChartModel, width:number, height:number)=> D3Selection)} = {
        [Globals.ChartType.pie]: (element: HTMLElement, chart: Globals.IChartModel, width:number, height:number) => _renderPie(element, chart.subtitles, chart.data, <Globals.IChartPieProperties>chart.chartProperties, 0, width, height, chart.chartDataTransposed),
        [Globals.ChartType.doughnut]: (element: HTMLElement, chart: Globals.IChartModel, width:number, height:number) => _renderPie(element, chart.subtitles, chart.data, <Globals.IChartDoughnutProperties> chart.chartProperties, (<Globals.IChartDoughnutProperties> chart.chartProperties).pie.hole, width, height, chart.chartDataTransposed),
        [Globals.ChartType.barHorizontal]: (element: HTMLElement, chart: Globals.IChartModel, width:number, height:number) => _renderBar(element, chart.subtitles, chart.data, <Globals.IChartBarProperties> chart.chartProperties, true, chart.chartDataTransposed ? true : false, width, height, false),
        [Globals.ChartType.bar]: (element: HTMLElement, chart: Globals.IChartModel, width:number, height:number) => _renderBar(element, chart.subtitles, chart.data, <Globals.IChartBarProperties> chart.chartProperties, false, chart.chartDataTransposed ? true : false, width, height, false),
        [Globals.ChartType.radar]: (element: HTMLElement, chart: Globals.IChartModel, width:number, height:number) => _renderRadar(element, chart.subtitles, chart.data, <Globals.IChartRadarProperties> chart.chartProperties, chart.chartDataTransposed ? true : false, width, height),
        [Globals.ChartType.stackedBarHorizontal]: (element: HTMLElement, chart: Globals.IChartModel, width:number, height:number) => _renderBar(element, chart.subtitles, chart.data, <Globals.IChartBarProperties> chart.chartProperties, true, chart.chartDataTransposed ? true : false, width, height, true),
        [Globals.ChartType.stackedBar]: (element: HTMLElement, chart: Globals.IChartModel, width:number, height:number) => _renderBar(element, chart.subtitles, chart.data, <Globals.IChartBarProperties> chart.chartProperties, false, chart.chartDataTransposed ? true : false, width, height, true),
    };
    
    export class Charts extends Image {
        protected _chart: Globals.IChartModel;
         
        protected _size(svg: D3Selection):void {
            let width: number = Math.floor(this.width),
                height: number = Math.floor(this.height);

            svg
                .attr("width", width)
                .attr("height", height);
        }        
        
        public clear() {
            let container: JQuery = $(this.node);
            
            this._chart = null;
            container.empty();
            this.loadingStart();
        }
        
        public setData(chart: Globals.IChartModel): void {
            let container: JQuery = $(this.node);
            let element: HTMLElement;
            let renderer: (element: HTMLElement, chart: Globals.IChartModel, width:number, height:number)=> D3Selection;
            let width = this.width,
                height = this.height;
            
            this._chart = chart;
            container.empty();
            if (width && height) {
                if (chart && (element = container[0]) && (renderer = _renderers[chart.chartProperties.type])) {
                    this._size(renderer(element, chart, width, height));
                    this.loadingEnd();
                }
                else
                    this.loadingStart();
            }
        }
        
        public invalidateSize(): void {
            if (this._chart) {
                this.setData(this._chart);
            }
            else {
                let element: HTMLElement;
                (element = this.node) && this._size(d3.select(element).select("svg"));
            }
        }        
    }
}