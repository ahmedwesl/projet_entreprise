/**
 * Created by jean.rennes on 06/12/2019.
 */
///<reference path="../Global.ts" />
///<reference path="../../application/Fragment.ts" />

namespace AFC.Controls {
    export namespace ViewPager {
        export interface IPageTransformer {
            transformPage(view: gui.AfcGuiDiv, position: number): void;
        }
    }

    interface _IContext {
        frameGroup: HTMLElement,
        frameGroupStyle: CSSStyleDeclaration,
        width: number;
        height: number;
    }

    interface _ITarget {
        position: -1 | 1,
        right?: number,
        left?: number
    }

    function _create(width: number, height: number, styleEx?: Partial<CSSStyleDeclaration>): gui.AfcGuiDiv {
        let element = new gui.AfcGuiDiv(),
            style = element.style;
        element.init({ width: width, height: height });
        styleEx && $.extend(style, styleEx);
        return element;
    }

    const _fragmentManager = Symbol();

    export abstract class FragmentStateAdapter {
        constructor(fragmentManager: Application.FragmentManager) {
            this[_fragmentManager] = fragmentManager;
        }
        abstract getFragment(item: number): Application.Fragment;
        abstract getItemCount(): number;

        /** @internal */
        public readonly [_fragmentManager]: Application.FragmentManager;
    };

    export class ViewPager extends Control {
        protected _frameGroup: HTMLElement;
        protected _animation: InstanceType<typeof ViewPager._Animation>;
        protected _adapter: FragmentStateAdapter;
        protected _transformer: ViewPager.IPageTransformer;
        protected _frame: InstanceType<typeof ViewPager._Frame>;
        public duration: DOMHighResTimeStamp;
        public ease: (n: number) => number;
        public onPageScrollStateChanged: (state: number) => any;

        protected static _ease(n: number): number {
            return n * n * n * n * n;
        }

        public static SCROLL_STATE_IDLE = 0;
        public static SCROLL_STATE_DRAGGING = 1;
        public static SCROLL_STATE_SETTLING = 2;

        protected static _Frame = class {
            public readonly container: HTMLElement;
            public readonly inner: gui.AfcGuiDiv;
            public readonly item: number;
            public offset: number;
            public fragment: Application.Fragment;

            constructor(frameGroup: HTMLElement, container: gui.IView, inner: gui.AfcGuiDiv, item: number, offset: number, referenceNode: HTMLElement) {
                this.container = container;
                this.inner = inner;
                this.item = item;
                this.offset = offset;
                frameGroup.insertBefore(container, referenceNode);
            }

            public drawNoCheck(pager: ViewPager): void {
                if (!this.fragment) {
                    let adapter = pager._adapter,
                        fragment = this.fragment = adapter.getFragment(this.item),
                        view;
                    this.container.appendChild(this.inner);
                    view = adapter[_fragmentManager].attachView(this.inner, fragment, `p${pager.getCurrentItem()}`);
                }
            }

            public draw(pager: ViewPager, context: _IContext, position: number): void {
                if (!this.fragment) {
                    let truePosition = this.offset - position + (this.inner.left / context.width);

                    if (Math.abs(truePosition) < 1) {
                        this.drawNoCheck(pager);
                    }
                }
            }

            public detach(pager: ViewPager): void {
                if (this.fragment) {
                    Application.FragmentManager.detachView(this.fragment);
                }
                this.container.parentNode.removeChild(this.container);
            }
        }

        protected static _Animation = class {
            public stop: () => void;

            constructor(pager: ViewPager, context: _IContext, frames: [InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>], position: -1 | 1, resolve: (fragment: Application.Fragment) => void) {
                let duration = pager.duration,
                    ease = pager.ease || ViewPager._ease,
                    start: number = null,
                    step = (timestamp: number) => {
                        let progress;
                        if (start === null)
                            start = timestamp;
                        progress = (timestamp - start);
                        if (progress < duration) {
                            id = requestAnimationFrame(step);
                            pager._transform(context, frames, position * ease(progress / duration));
                        } else {
                            pager._transformer?.transformPage(frames[1 + position].inner, 0);
                            resolve(pager._shrinkFrameGroup(context, frames));
                        }
                    },
                    id = requestAnimationFrame(step);

                this.stop = () => {
                    cancelAnimationFrame(id);
                    resolve(pager._shrinkFrameGroup(context, frames));
                };
                pager._onPageScrollStateChanged(ViewPager.SCROLL_STATE_SETTLING);
            }
        }

        constructor(element: string | HTMLElement) {
            super(element);
            this.duration = 400;	// in ms
        }

        protected _onPageScrollStateChanged(state: number): void {
            this.onPageScrollStateChanged && this.onPageScrollStateChanged(state);
        }

        protected _getContext(): _IContext {
            let frameGroup = this._frameGroup;
            return frameGroup && {
                frameGroup: frameGroup,
                frameGroupStyle: frameGroup.style,
                width: this.node.offsetWidth,
                height: this.node.offsetHeight
            };
        }

        protected _stop(): void {
            // stop all animations
            if (this._animation) {
                this._animation.stop();
            }
        }

        protected _createFrame(frameGroup: HTMLElement, width: number, height: number, item: number, offset: number, referenceNode: HTMLElement = null): InstanceType<typeof ViewPager._Frame> {
            let container = _create(width, height, { cssFloat: "left", position: "relative" }),
                inner = _create(width, height, { position: "absolute" });
            if (item !== void 0) {
                inner.id = `page${item}`;
            }
            return new ViewPager._Frame(frameGroup, container, inner, item, offset, referenceNode);
        }

        protected _reset(item: number = 0): void {
            this._stop();

            let adapter = this._adapter,
                element = this.node;

            if (element) {
                let width = element.offsetWidth,
                    height = element.offsetHeight,
                    frameGroup = this._frameGroup,
                    div = document.createElement('div');

                this._frame && this._frame.detach(this);
                $(element).empty();
                $.extend(div.style, {
                    top: 0,
                    left: 0,
                    width: `${width}px`,
                    height: `${height}px`,
                    overflow: 'hidden',
                    position: 'absolute'
                });
                element
                    .appendChild(div)
                    .appendChild(this._frameGroup = frameGroup = _create(width, height, { position: "absolute" }));

                if (adapter && (item >= 0) && (item < adapter.getItemCount())) {
                    let frame = this._frame = this._createFrame(frameGroup, width, height, item, 0);
                    frame.drawNoCheck(this);
                }
                this._onPageScrollStateChanged(ViewPager.SCROLL_STATE_IDLE);
            }
        }

        protected _expandFrameGroup(context: _IContext, frame: InstanceType<typeof ViewPager._Frame>, left: number, right: number, position: -1 | 1): [InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>] {
            let frameGroup = context.frameGroup,
                frames: [InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>];

            if ((frameGroup.childNodes.length !== 1) || (frame.offset != 0)) {
                return;
            }
            context.frameGroupStyle.width = `${3 * context.width}px`;
            context.frameGroupStyle.left = `-${context.width}px`;
            frames = [
                this._createFrame(frameGroup, context.width, context.height, left, -1, frame.container),
                frame,
                this._createFrame(frameGroup, context.width, context.height, right, 1)
            ];
            this._frame = frames[position + 1];
            return frames;
        }

        protected _transform(context: _IContext, frames: [InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>], position: number): void {
            // position between -1 and 1
            if (Math.abs(position) <= 1) {
                let offset = (-position - 1) * context.width;

                context.frameGroupStyle.left = `${offset}px`;
                frames.forEach((frame, indice) => {
                    if (frame.item !== void 0) {
                        this._transformer?.transformPage(frame.inner, indice - position - 1);
                        frame.draw(this, context, position);
                    }
                });
            }
        }

        protected _shrinkFrameGroup(context: _IContext, frames: [InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>]): Application.Fragment {
            if (this._animation) {
                let frame = this._frame;

                frames.forEach(item => (item !== frame) && item.detach(this));
                context.frameGroupStyle.width = `${context.width}px`;
                context.frameGroupStyle.left = "0";
                frame.offset = 0;
                frame.drawNoCheck(this);
                delete this._animation;
                this._onPageScrollStateChanged(ViewPager.SCROLL_STATE_IDLE);
                return frame.fragment;
            }
        }

        protected _getTarget(start: number, end: number, max: number): _ITarget {
            let target: _ITarget;

            if (start < end) {
                target = {
                    position: 1,
                    right: end
                };
                if (start > 0) {
                    target.left = start - 1;
                }
            } else {
                target = {
                    position: -1,
                    left: end
                };
                if (max > start) {
                    target.right = start + 1;
                }
            }
            return target;
        }

        public setCurrentItem(item: number): Promise<Application.Fragment> {
            return new Promise((resolve: (fragment: Application.Fragment) => void) => {
                let adapter = this._adapter,
                    frame = this._frame,
                    count,
                    context,
                    target,
                    frames;

                this._stop();
                if (adapter && frame && (item >= 0) && (item < (count = adapter.getItemCount())) && (frame.item !== item) && (context = this._getContext(), target = this._getTarget(frame.item, item, count - 1), frames = this._expandFrameGroup(context, frame, target.left, target.right, target.position))) {
                    this._animation = new ViewPager._Animation(this, context, frames, target.position, resolve);
                } else {
                    this._reset(item);
                    resolve(this._frame && this._frame.fragment);
                }
            });
        }

        public getCurrentItem(): number {
            return this._frame && this._frame.item;
        }

        public setAdapter(adapter: FragmentStateAdapter): void {
            this._stop();
            delete this._frame;
            this._adapter = adapter;
        }

        public setPageTransformer(transformer?: ViewPager.IPageTransformer): void {
            this._transformer = transformer;
        }

        public invalidateSize(): void {
            this._reset(this.getCurrentItem());
        }
    }
}