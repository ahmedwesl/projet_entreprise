/**
 * Created by jean.rennes on 20/05/2020.
 */

namespace AFC.Controls {
    const _element = Symbol(),
        _pointerdown = Symbol();

    export class Draggable {
        public moveThreshold: number
        public moveThrottle: number
        public swipeThreshold: number
        public swipeTimeThreshold: number
        public clickTimeThreshold: number

        /** @internal */
        private [_element]: HTMLElement;
        /** @internal */
        private [_pointerdown]: (event: PointerEvent) => void;

        public static moveThreshold = 75;		// px
        public static moveThrottle = 5;                 // px
        public static swipeThreshold = 200;		// px
        public static swipeTimeThreshold = 200;		// ms
        public static clickTimeThreshold = 1000;	// ms


        public static destroy(draggable: Draggable): void {
            if (draggable && draggable[_pointerdown]) {
                draggable[_element].removeEventListener('pointerdown', draggable[_pointerdown], true);
                delete draggable[_pointerdown];
                delete draggable[_element];
            }
        }

        constructor(element: HTMLElement) {
            this.moveThreshold = Draggable.moveThreshold;
            this.swipeTimeThreshold = Draggable.swipeTimeThreshold;
            this.clickTimeThreshold = Draggable.clickTimeThreshold;
            this.moveThrottle = Draggable.moveThrottle;
            this.swipeThreshold = Draggable.swipeThreshold;

            element.style.touchAction = 'none';
            (this[_element] = element).addEventListener('pointerdown', this[_pointerdown] = (event: PointerEvent) => {
                let start = Date.now(),
                    initialClientX = event.clientX,
                    initialClientY = event.clientY,
                    lastClientX = initialClientX,
                    lastClientY = initialClientY,
                    swipeStamps: {timestamp: number, x: number, y: number}[] = [{timestamp: start, x: initialClientX, y: initialClientY}],
                    moveMode = false,
                    refreshFrame: number,
                    currentClientX: number,
                    currentClientY: number,
                    _end = (clientX: number, clientY: number) => {
                        let event;

                        refreshFrame && cancelAnimationFrame(refreshFrame);
                        document.removeEventListener('pointermove', pointermove, true);
                        document.removeEventListener('pointerup', pointerup, true);
                        if (moveMode) {
                            event = new DragEvent('drag:end', {clientX: clientX, clientY: clientY});
                        } else if ((Date.now() - start) <= this.clickTimeThreshold) {
                            event = new MouseEvent('vclick', {clientX: clientX, clientY: clientY});
                        }
                        event && element.dispatchEvent(event);
                    },
                    pointermove = (event: PointerEvent) => {
                        currentClientX = event.clientX;
                        currentClientY = event.clientY;
                        refreshFrame || (refreshFrame = requestAnimationFrame(() => {
                            if ((Math.abs(lastClientX - currentClientX) >= this.moveThrottle) || (Math.abs(lastClientY - currentClientY) >= this.moveThrottle)) {
                                let timestamp = Date.now();

                                for (let i = 0; i < swipeStamps.length; ++i) {
                                    if ((timestamp - swipeStamps[i].timestamp) > this.swipeTimeThreshold) {
                                        swipeStamps.splice(0, i - 1);
                                        break;
                                    }
                                }
                                for (let i = 0; i < swipeStamps.length; ++i) {
                                    let offsetX = currentClientX - swipeStamps[i].x;
                                    if (Math.abs(offsetX) >= this.swipeThreshold) {
                                        _end(currentClientX, currentClientY);
                                        element.dispatchEvent(new DragEvent(offsetX > 0 ? 'swipe:right' : 'swipe:left', {clientX: currentClientX, clientY: currentClientY}));
                                        return;
                                    }
                                }
                                swipeStamps.push({timestamp: timestamp, x: currentClientX, y: currentClientY});

                                if (!moveMode && ((Math.abs(lastClientX - currentClientX) >= this.moveThreshold) || (Math.abs(lastClientY - currentClientY) >= this.moveThreshold))) {
                                    moveMode = true;
                                    element.dispatchEvent(new DragEvent('drag:start', {clientX: lastClientX, clientY: lastClientY}));
                                }
                                if (moveMode) {
                                    element.dispatchEvent(new DragEvent('drag:move', {clientX: lastClientX = currentClientX, clientY: lastClientY = currentClientY}));
                                }
                            }
                            refreshFrame = 0;
                        }));
                    },
                    pointerup = (event: PointerEvent) => _end(event.clientX, event.clientY);

                document.addEventListener('pointermove', pointermove, true);
                document.addEventListener('pointerup', pointerup, true);
            }, true);
        }
    }
}