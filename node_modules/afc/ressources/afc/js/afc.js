"use strict";
/**
 * Created by jean.rennes on 25/09/2015.
 */
var AFC;
(function (AFC) {
    AFC.Version = '5.0.0';
})(AFC || (AFC = {}));
// create exports
// @ts-ignore
if (typeof module != "undefined")
    module.exports = AFC;
/**
 * Created by jean.rennes on 29/09/2015.
 */
///<reference path="../AFC.ts" />
var AFC;
(function (AFC) {
    var Tools;
    (function (Tools) {
        var _a;
        let EventType;
        (function (EventType) {
            EventType[EventType["NetworkError"] = 1] = "NetworkError";
            EventType[EventType["NetworkBegin"] = 2] = "NetworkBegin";
            EventType[EventType["NetworkComplete"] = 3] = "NetworkComplete";
            EventType[EventType["IdentityError"] = 4] = "IdentityError";
            EventType[EventType["Internal"] = 5] = "Internal";
            EventType[EventType["Dirty"] = 6] = "Dirty";
            EventType[EventType["UserEvent"] = 65536] = "UserEvent";
            EventType[EventType["Attach"] = 1073741824] = "Attach";
            EventType[EventType["Ready"] = 1073741825] = "Ready";
            EventType[EventType["Refresh"] = 1073741826] = "Refresh";
        })(EventType = Tools.EventType || (Tools.EventType = {}));
        const _idProperty = Symbol('afcId');
        let Kernel;
        (function (Kernel) {
            var _stampCnt = 1;
            var _pendingIndex;
            var _pendings;
            function stamp(o) {
                return o[_idProperty] || (o[_idProperty] = (_stampCnt++));
            }
            Kernel.stamp = stamp;
            function dispatch() {
                if (_pendings.length) {
                    //let pendings: IPendingEvent[] = _pendings;
                    let offset, event;
                    if (_pendings.length > 1) {
                        _pendings.reduce((_type, event, indice) => {
                            if (event.type < _type) {
                                offset = indice;
                                _type = event.type;
                            }
                            return _type;
                        }, Number.MAX_SAFE_INTEGER);
                        event = _pendings[offset];
                        delete _pendingIndex[event.type + '_' + stamp(event.sink)];
                        _pendings.splice(offset, 1);
                        setTimeout(dispatch, 0);
                    }
                    else {
                        event = _pendings[0];
                        _pendingIndex = _pendings = void 0;
                    }
                    event.sink.dispatchEvent(event.type, event.data);
                }
            }
            Kernel.dispatch = dispatch;
            function fire(e) {
                if (!_pendings) {
                    _pendingIndex = {};
                    _pendings = [];
                    setTimeout(dispatch, 0);
                }
                let indexId = e.type + '_' + stamp(e.sink);
                let o;
                if (o = _pendingIndex[indexId]) {
                    e.data ? (o.data = o.data?.concat ? o.data.concat(e.data) : e.data) : delete o.data;
                }
                else
                    _pendings.push(_pendingIndex[indexId] = o = e);
                return o;
            }
            Kernel.fire = fire;
            function packEvent(callback, callbackRef, context, once) {
                var ctx = (context || 0) && (context !== this) && stamp(context);
                var indexId = ctx + '_' + stamp(callbackRef);
                return { id: indexId, once: once, fn: callback, ctx: context };
            }
            Kernel.packEvent = packEvent;
        })(Kernel || (Kernel = {}));
        Tools.AfcReferenceMixin = function (callback, ref) {
            let h = function () { callback.apply(this, arguments); };
            Object.defineProperty(h, _idProperty, {
                get: function () {
                    return ref[_idProperty];
                },
                set: function (value) {
                    ref[_idProperty] = value;
                },
                enumerable: true,
                configurable: true
            });
            return h;
        };
        const _target = Symbol();
        function EventSinkMixinBase(Base) {
            var _b, _c;
            const _events = Symbol(), _count = Symbol();
            function _on(events, type, eventReference) {
                let event = (events[type] || (events[type] = { i: {}, a: [] }));
                let index = event.i;
                let queue = event.a;
                let id = eventReference.id;
                if (index[id] === void 0) {
                    index[id] = queue.length;
                    queue.push(eventReference);
                }
            }
            class Derived extends Base {
                constructor() {
                    super(...arguments);
                    this[_b] = 0;
                    this[_c] = this;
                }
                countObservers(type) {
                    let events = this[_events];
                    return (events && events[type] && events[type].a.length) || 0;
                }
                notify(type, callback) {
                    let o = { [_idProperty]: ++this[_count] };
                    this.once(type, callback, _on, o);
                    return this;
                }
                once(type, callback, callbackref, context) {
                    _on(this[_events] || (this[_events] = {}), type, Kernel.packEvent(callback, callbackref, context, true));
                }
                on(type, callback, context) {
                    _on(this[_events] || (this[_events] = {}), type, Kernel.packEvent(callback, callback, context));
                }
                off(type, callback, context) {
                    let events;
                    let event;
                    if (type && callback && (events = this[_events]) && (event = events[type])) {
                        let ctx = (context || 0) && (context !== this) && context[_idProperty];
                        let id = ctx + '_' + callback[_idProperty];
                        let index = event.i;
                        let i = index[id];
                        if (i !== void 0) {
                            event.a.splice(i, 1);
                            event.i = index = {};
                            event.a.forEach((item, i) => index[item.id] = i);
                        }
                    }
                }
                fireEvent(type, data) {
                    let e = { sink: this, type: type, data: data };
                    return Kernel.fire(e);
                }
                dispatchEvent(type, data) {
                    let events;
                    let event;
                    let newEvent;
                    if (type && (events = this[_events]) && (event = events[type])) {
                        let e = {
                            type: type,
                            target: this[_target]
                        };
                        data && (e.data = (data.onDispatch ? data.onDispatch() : data));
                        delete events[type];
                        for (let ref of event.a) {
                            if (!ref.once) {
                                if (!newEvent) {
                                    events[type] = newEvent = { i: {}, a: [] };
                                }
                                newEvent.i[ref.id] = newEvent.a.length;
                                newEvent.a.push(ref);
                            }
                            try {
                                ref.ctx ? ref.fn.call(ref.ctx, e) : ref.fn(e);
                            }
                            catch (e) {
                                console.log(e.message);
                                e.stack && console.log(e.stack);
                            }
                        }
                    }
                }
            }
            _b = _count, _c = _target;
            return Derived;
        }
        Tools.EventSinkMixin = EventSinkMixinBase;
        class EventSink extends Tools.EventSinkMixin(class {
        }) {
            constructor(target) {
                super();
                /** @internal */
                this[_a] = this;
                target && (this[_target] = target);
            }
        }
        _a = _target;
        Tools.EventSink = EventSink;
        function observableObject(t) {
            let sink = new EventSink();
            return sink[_target] = new Proxy(Object.assign(sink, t || {}), {
                set: (target, prop, value, receiver) => {
                    let old = Reflect.get(target, prop);
                    if (old !== value) {
                        Reflect.set(target, prop, value);
                        target.fireEvent(6 /* AFC.Tools.EventType.Dirty */);
                    }
                    return true;
                }
            });
        }
        Tools.observableObject = observableObject;
        const _forwards = Symbol();
        class AutoSubscribeForwarder extends EventSink {
            static _update(type, forwarder, on) {
                const forward = forwarder[_forwards]?.[type];
                if (forward && !forwarder.countObservers(type)) {
                    (on ? forward.observable.on : forward.observable.off).call(forward.observable, forward.targetType ?? type, forward.callback, forwarder);
                }
            }
            _setForwards(forwards) {
                let map = this[_forwards];
                if (map) {
                    for (let key in map) {
                        const forward = map[key];
                        forward.observable.off(forward.targetType ?? forward.type, forward.callback, this);
                    }
                }
                this[_forwards] = map = {};
                forwards && forwards.forEach((forward) => map[forward.type] = forward);
            }
            once(type, callback, callbackref, context) {
                AutoSubscribeForwarder._update(type, this, true);
                super.once(type, callback, callbackref, context);
            }
            on(type, callback, context) {
                AutoSubscribeForwarder._update(type, this, true);
                super.on(type, callback, context);
            }
            off(type, callback, context) {
                super.off(type, callback, context);
                AutoSubscribeForwarder._update(type, this);
            }
            dispatchEvent(type, data) {
                super.dispatchEvent(type, data);
                AutoSubscribeForwarder._update(type, this);
            }
        }
        Tools.AutoSubscribeForwarder = AutoSubscribeForwarder;
    })(Tools = AFC.Tools || (AFC.Tools = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 13/10/2015.
 */
var AFC;
(function (AFC) {
    var Data;
    (function (Data) {
        let DataKind;
        (function (DataKind) {
            DataKind[DataKind["unknown"] = 0] = "unknown";
            DataKind[DataKind["character"] = 1] = "character";
            DataKind[DataKind["real"] = 2] = "real";
            DataKind[DataKind["integer"] = 3] = "integer";
            DataKind[DataKind["bool"] = 4] = "bool";
            DataKind[DataKind["date"] = 5] = "date";
            DataKind[DataKind["time"] = 6] = "time";
            DataKind[DataKind["timestamp"] = 7] = "timestamp";
            DataKind[DataKind["currency"] = 8] = "currency";
            DataKind[DataKind["blob"] = 9] = "blob";
            DataKind[DataKind["dynamic"] = 10] = "dynamic";
            DataKind[DataKind["formula"] = 11] = "formula";
            DataKind[DataKind["rectangle"] = 12] = "rectangle";
            DataKind[DataKind["point"] = 1048576] = "point";
            DataKind[DataKind["line"] = 2097152] = "line";
            DataKind[DataKind["polygon"] = 4194304] = "polygon";
            DataKind[DataKind["geometry"] = 7340032] = "geometry";
        })(DataKind = Data.DataKind || (Data.DataKind = {}));
        let TableType;
        (function (TableType) {
            TableType[TableType["undef"] = 0] = "undef";
            TableType[TableType["table"] = 1] = "table";
            TableType[TableType["view"] = 2] = "view";
            TableType[TableType["query"] = 3] = "query";
            TableType[TableType["compound"] = 4] = "compound";
            TableType[TableType["cubeView"] = 5] = "cubeView";
            TableType[TableType["memory"] = 6] = "memory";
            TableType[TableType["filter"] = 7] = "filter";
            TableType[TableType["seamless"] = 8] = "seamless";
            TableType[TableType["history"] = 9] = "history";
            TableType[TableType["synonym"] = 10] = "synonym";
        })(TableType = Data.TableType || (Data.TableType = {}));
        let CreationType;
        (function (CreationType) {
            CreationType[CreationType["query"] = 1] = "query";
            CreationType[CreationType["modification"] = 2] = "modification";
            CreationType[CreationType["embedded"] = 3] = "embedded";
            CreationType[CreationType["historyView"] = 4] = "historyView";
        })(CreationType = Data.CreationType || (Data.CreationType = {}));
        let Qualifier;
        (function (Qualifier) {
            Qualifier[Qualifier["identifier"] = 1] = "identifier";
            Qualifier[Qualifier["mainAddress"] = 2] = "mainAddress";
            Qualifier[Qualifier["address"] = 3] = "address";
            Qualifier[Qualifier["zipCode"] = 4] = "zipCode";
            Qualifier[Qualifier["city"] = 5] = "city";
            Qualifier[Qualifier["country"] = 6] = "country";
            Qualifier[Qualifier["totalSurface"] = 7] = "totalSurface";
            Qualifier[Qualifier["surface"] = 8] = "surface";
            Qualifier[Qualifier["symbol"] = 9] = "symbol";
            Qualifier[Qualifier["brand"] = 10] = "brand";
            Qualifier[Qualifier["businessCode"] = 11] = "businessCode";
            Qualifier[Qualifier["revenue"] = 12] = "revenue";
            Qualifier[Qualifier["changes"] = 13] = "changes"; // encoded modifications applied on a row from an historized table
        })(Qualifier = Data.Qualifier || (Data.Qualifier = {}));
        let DataEventType;
        (function (DataEventType) {
            // order is important
            DataEventType[DataEventType["none"] = 0] = "none";
            DataEventType[DataEventType["create"] = 1] = "create";
            DataEventType[DataEventType["modify"] = 2] = "modify";
            DataEventType[DataEventType["delete_"] = 4] = "delete_";
            DataEventType[DataEventType["drop"] = 8] = "drop";
            DataEventType[DataEventType["reset"] = 16] = "reset";
        })(DataEventType = Data.DataEventType || (Data.DataEventType = {}));
        let CheckMessageType;
        (function (CheckMessageType) {
            CheckMessageType[CheckMessageType["error"] = 0] = "error";
            CheckMessageType[CheckMessageType["info"] = 1] = "info";
            CheckMessageType[CheckMessageType["confirm"] = 2] = "confirm";
            CheckMessageType[CheckMessageType["user"] = 3] = "user";
        })(CheckMessageType = Data.CheckMessageType || (Data.CheckMessageType = {}));
        ;
        ;
    })(Data = AFC.Data || (AFC.Data = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 29/09/2015.
 */
///<reference path="../../AFC.ts" />
///<reference path="../../helpers/EventSink.ts" />
///<reference path="../data/Global.ts" />
var AFC;
(function (AFC) {
    var Rest;
    (function (Rest) {
        var _a;
        function _extract(s) {
            return s.startsWith('dataCreations:') ? s.substr(14) : void 0;
        }
        const _dataCnt = Symbol(), _entries = Symbol();
        class DataCreator extends AFC.Tools.EventSink {
            constructor(base) {
                super();
                /** @internal */
                this[_a] = 0;
                this.base = base;
            }
            load(options) {
                return this.base?.load?.(options);
            }
            updateBody(body, options) {
                let entries = this[_entries];
                this.base?.updateBody(body, options);
                if (entries) {
                    let context = body.context || (body.context = {}), entry;
                    for (let key in entries) {
                        entry = entries[key];
                        if (entry.persist || entry.show) {
                            delete entry.show;
                            (context.dataCreations || (context.dataCreations = {}))[key] = entry.creation;
                        }
                    }
                }
            }
            createData(creation, autoDisable) {
                let entries = this[_entries] || (this[_entries] = {}), key = `t${DataCreator._global++}`;
                ++this[_dataCnt];
                return entries[key] = {
                    key: `dataCreations:${key}`,
                    creation: creation,
                    persist: !autoDisable
                };
            }
            getData(id) {
                let s = _extract(id);
                let creations = this[_entries];
                return s && creations && creations[s].creation;
            }
            updateData(id, creation) {
                let s = _extract(id);
                let creations = this[_entries];
                if (s && creations && creations[s]) {
                    creations[s].creation = creation;
                    return id;
                }
            }
            discardData(id) {
                if (id) {
                    let s = _extract(id);
                    let creations = this[_entries];
                    if (s && creations && creations[s]) {
                        delete creations[s];
                        if (--this[_dataCnt] === 0) {
                            delete this[_entries];
                        }
                    }
                }
                else {
                    delete this[_entries];
                    delete this[_dataCnt];
                }
            }
            clone() {
                let clone = Reflect.construct(DataCreator, [this.base], this.constructor);
                if (this[_dataCnt]) {
                    let destinations = clone[_entries] = {}, sources = this[_entries], source;
                    clone[_dataCnt] = this[_dataCnt];
                    for (let key in sources) {
                        source = sources[key];
                        destinations[key] = {
                            key: key,
                            creation: source.creation,
                            persist: source.persist
                        };
                    }
                }
                return clone;
            }
        }
        _a = _dataCnt;
        DataCreator._global = 0;
        Rest.DataCreator = DataCreator;
        class DataResource {
            get provider() {
                return this._provider;
            }
            get id() {
                return this._provider && this._entry?.key;
            }
            create(provider, creation) {
                if (this._provider === provider) {
                    provider.updateData(this.id, creation);
                    return false;
                }
                this.release();
                this._entry = (this._provider = provider).createData(creation);
                return true;
            }
            release() {
                if (this._provider) {
                    this._provider.discardData(this.id);
                    delete this._provider;
                }
            }
            clone(provider) {
                let clone = Object.create(this.constructor.prototype), id = this.id, creation = id && this._provider.getData(id);
                creation && clone.create(provider, creation);
                return clone;
            }
        }
        Rest.DataResource = DataResource;
    })(Rest = AFC.Rest || (AFC.Rest = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 29/09/2015.
 */
///<reference path="DataCreation.ts" />
var AFC;
(function (AFC) {
    var Rest;
    (function (Rest) {
        const _modifiers = Symbol();
        class DataUpdates {
            constructor() {
                this.index = {};
            }
            push(id, replacement) {
                this.index[id] = replacement;
            }
            toJSON() {
                return Object.entries(this.index).map(([key, entry]) => ({ id: key, replacement: entry }));
            }
        }
        class RequestBuilder extends Rest.DataCreator {
            get modifiers() {
                return this[_modifiers];
            }
            pushModifier(modifier) {
                (this[_modifiers] || (this[_modifiers] = [])).some(item => item === modifier) || this[_modifiers].push(modifier);
                return modifier;
            }
            popModifier(modifier) {
                this[_modifiers] && (this[_modifiers] = this[_modifiers].filter(item => item !== modifier));
            }
            async load(options) {
                await super.load(options);
                return this[_modifiers] && Promise.all(this[_modifiers].map(modifier => modifier.load && modifier.load(options)));
            }
            updateBody(body, options) {
                super.updateBody(body);
                if (!options?.noReplacements) {
                    this[_modifiers]?.forEach((modifier) => modifier.updateBody(body, options));
                }
                return body;
            }
            clone() {
                let clone = super.clone();
                this[_modifiers] && (clone[_modifiers] = this[_modifiers].slice(0));
                return clone;
            }
            release() {
                this[_modifiers]?.forEach((modifier) => modifier.release && modifier.release());
                delete this[_modifiers];
            }
        }
        Rest.RequestBuilder = RequestBuilder;
        function _updateBody(body, reference, replacement) {
            if (replacement) {
                ((body.context || (body.context = {})).dataUpdates || (body.context.dataUpdates = new DataUpdates)).push(reference, replacement);
            }
        }
        class ContextSubstitute {
            constructor(reference, replacement) {
                this.reference = reference;
                this.replacement = replacement;
            }
            updateBody(body) {
                _updateBody(body, this.reference, this.replacement);
            }
        }
        Rest.ContextSubstitute = ContextSubstitute;
        class ResourceSubstitute {
            constructor(dataCreator, reference) {
                this.reference = reference;
                this.dataCreator = dataCreator;
            }
            get replacement() {
                return this._resource?.id || this._replacement;
            }
            set replacement(value) {
                this.release();
                this._replacement = value;
            }
            create(creation) {
                delete this._replacement;
                if (!this._resource) {
                    this._resource = new Rest.DataResource();
                }
                this._resource.create(this.dataCreator, creation);
            }
            updateBody(body) {
                _updateBody(body, this.reference, this.replacement);
            }
            release() {
                this._resource && this._resource.release();
            }
        }
        Rest.ResourceSubstitute = ResourceSubstitute;
    })(Rest = AFC.Rest || (AFC.Rest = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 03/02/2016.
 */
///<reference path="../AFC.ts" />
///<reference path="../models/data/Global.ts" />
var AFC;
(function (AFC) {
    var Tools;
    (function (Tools) {
        var Data;
        (function (Data) {
            function checkGeometryType(column, geometryType) {
                return (column.type & geometryType) === column.type;
            }
            Data.checkGeometryType = checkGeometryType;
            function findFirstGeometry(data, geometryType = 7340032 /* AFC.Data.DataKind.geometry */) {
                let columns = data && (data instanceof Array ? data : data.columns);
                if (columns) {
                    for (let i = 0, iCount = columns.length; i < iCount; ++i) {
                        if (checkGeometryType(columns[i], geometryType)) {
                            return i;
                        }
                    }
                }
            }
            Data.findFirstGeometry = findFirstGeometry;
            var rndGenerator = {};
            let g_zbase32 = 'ybndrfg8ejkmcpqxot1uwisza345h769';
            rndGenerator[1 /* AFC.Data.DataKind.character */] = (l) => {
                let size = Math.ceil((l * 5) / 8);
                let b = new ArrayBuffer(size);
                let a = new Uint8Array(b);
                let rules = [{ o: 0, d: 11 }, { o: 0, d: 6 }, { o: 0, d: 1 }, { o: 1, d: 4 }, { o: 2, d: 7 }, { o: 2, d: 2 }, { o: 3, d: 5 }, { o: 3, d: 0 }];
                let rule, c, pos;
                let s = '';
                rng_get_bytes(a);
                for (let i = 0; i < l; ++i) {
                    rule = rules[i % 8];
                    pos = Math.floor(i / 8) * 5 + rule.o;
                    c = (((a[pos] << 8) + a[pos + 1]) >> rule.d) & 0x1F;
                    s += g_zbase32.charAt(c & 0x1F);
                }
                return s;
            };
            rndGenerator[2 /* AFC.Data.DataKind.real */] = (l) => {
                let b;
                let a;
                if (l === 4) {
                    b = new ArrayBuffer(4);
                    a = new Float32Array(b);
                }
                else {
                    b = new ArrayBuffer(8);
                    a = new Float64Array(b);
                }
                rng_get_bytes(new Uint8Array(b));
                return a[0];
            };
            rndGenerator[3 /* AFC.Data.DataKind.integer */] = (l) => {
                let a = new Uint8Array(l || 4);
                let ret = 0;
                rng_get_bytes(a);
                a.forEach((i) => ret = (ret * 0xFF) + i);
                return ret;
            };
            rndGenerator[4 /* AFC.Data.DataKind.bool */] = (l) => {
                return !(rng_get_byte() & 1);
            };
            Data.generateRndString = rndGenerator[1 /* AFC.Data.DataKind.character */];
            function generateRndValue(column) {
                let f = rndGenerator[column.type];
                return f(Math.min(column.size, 32));
            }
            Data.generateRndValue = generateRndValue;
            function getKeyColumns(data) {
                let pK = data.primaryKey;
                let pKL = pK.length;
                let kC = [];
                if (pKL > 0) {
                    let cs = data.columns;
                    let i;
                    let s = pK[0];
                    for (let c of cs) {
                        if (c.name === s) {
                            kC.push(c);
                            if (pK.length === 1)
                                return kC;
                        }
                        i[c.name] = c;
                    }
                    for (let j = 1; j < pKL; ++j) {
                        kC.push(i[s]);
                    }
                }
                return kC;
            }
            Data.getKeyColumns = getKeyColumns;
            function isString(value) {
                return typeof value === 'string' || value instanceof String;
            }
            Data.isString = isString;
            function isNumber(value) {
                return typeof value === 'number' && isFinite(value);
            }
            Data.isNumber = isNumber;
            function isData(value) {
                return value instanceof Date;
            }
            function isValidCoordinates(coordinates) {
                return valid[2 /* AFC.Data.DataKind.real */](coordinates[0]) && valid[2 /* AFC.Data.DataKind.real */](coordinates[1]);
            }
            const valid = {
                [1 /* AFC.Data.DataKind.character */]: isString,
                [2 /* AFC.Data.DataKind.real */]: isNumber,
                [3 /* AFC.Data.DataKind.integer */]: (value) => isNumber(value) && (Math.round(value) === value),
                [4 /* AFC.Data.DataKind.bool */]: (value) => typeof value === 'boolean',
                [5 /* AFC.Data.DataKind.date */]: isData,
                [7 /* AFC.Data.DataKind.timestamp */]: isData,
                [6 /* AFC.Data.DataKind.time */]: isData,
                [1048576 /* AFC.Data.DataKind.point */]: (value) => {
                    let coordinates;
                    return (value &&
                        (coordinates = value.coordinates) &&
                        (value.type === 'Point')) && isValidCoordinates(coordinates);
                },
                [4194304 /* AFC.Data.DataKind.polygon */]: (value) => value && value.coordinates && ((value.type === 'Polygon') || (value.type === 'MultiPolygon'))
            };
            function isValid(kind, value) {
                let f;
                return (value === null) || !(f = valid[kind]) || f(value);
            }
            Data.isValid = isValid;
            function isValidKey(keyProvider, value) {
                return value && keyProvider.primaryKey.every((name, indice) => {
                    let f, column = keyProvider.columns[keyProvider.columnIndex[name]];
                    return value[indice] === null ? column.nullable : (f = valid[column.type]) && f(value[indice]);
                });
            }
            Data.isValidKey = isValidKey;
            function equalValue(kind, v0, v1) {
                switch (kind) {
                    case 12 /* AFC.Data.DataKind.rectangle */:
                    case 2097152 /* AFC.Data.DataKind.line */:
                    case 4194304 /* AFC.Data.DataKind.polygon */:
                        return true;
                    case 1048576 /* AFC.Data.DataKind.point */:
                        return Tools.Geometry.equalPoint(v0, v1);
                }
                return v0 === v1;
            }
            Data.equalValue = equalValue;
            function splitSQLName(n) {
                if (n) {
                    let a = n.match(/[^\[\]]+/gi);
                    if (a) {
                        if (a.length === 3 && a[1] === '.')
                            return { name: a[2] || '', dbName: a[0] };
                        n = a[0];
                    }
                    return n && { name: n || '', dbName: '' };
                }
            }
            Data.splitSQLName = splitSQLName;
            function makeSQLName(dbName, name) {
                return dbName ? `[${dbName}].[${name}]` : `[${name}]`;
            }
            Data.makeSQLName = makeSQLName;
            async function getSQLNameParts(schema, tableName) {
                let parts = Tools.Data.splitSQLName(tableName);
                if (parts?.name) {
                    if (!parts.dbName) {
                        let collator = new Intl.Collator('en', { sensitivity: 'base' }), min = Number.MAX_SAFE_INTEGER;
                        await schema.getDatabases().then(async (databases) => {
                            await Promise.all(databases.map((database, indice) => database.getTables().then(tables => {
                                let table;
                                if (!parts.dbName && indice < min && (table = tables.find(table => table.name === parts.name || table.alias === parts.name))) {
                                    parts.dbName = database.id;
                                }
                            })));
                        });
                    }
                    return parts;
                }
            }
            Data.getSQLNameParts = getSQLNameParts;
            async function normalizeSQLName(schema, tableName) {
                let { dbName, name } = await getSQLNameParts(schema, tableName) || {};
                return dbName && makeSQLName(dbName, name);
            }
            Data.normalizeSQLName = normalizeSQLName;
            function sort(dataModel, columns) {
                let index = new AFC.Data.Index(columns.map(name => Tools.indexOf(dataModel.columns, (column) => column.name === name)), dataModel.values);
                return index.values;
            }
            Data.sort = sort;
            function mapRow(columns, row) {
                let value = {};
                columns.forEach((column, indice) => { value[column.name] = value[column.alias] = row[indice]; });
                return value;
            }
            Data.mapRow = mapRow;
            function toInteger(s, defaultValue) {
                let i = parseInt(s);
                //true => 1 / false => 0
                if (isNaN(i))
                    i = Number(s);
                return isNaN(i) ? defaultValue : i;
            }
            Data.toInteger = toInteger;
            function toFloat(s, defaultValue) {
                let i = parseFloat(s);
                return isNaN(i) ? defaultValue : i;
            }
            Data.toFloat = toFloat;
            function toBoolean(s) {
                return !!s;
            }
            Data.toBoolean = toBoolean;
            const _casts = {
                [2 /* AFC.Data.DataKind.real */]: AFC.Tools.Data.toFloat,
                [3 /* AFC.Data.DataKind.integer */]: AFC.Tools.Data.toInteger,
                [4 /* AFC.Data.DataKind.bool */]: AFC.Tools.Data.toBoolean,
                [5 /* AFC.Data.DataKind.date */]: (value) => new Date(value + "T00:00")
            };
            function castInputValue(column, value) {
                let cast, ret;
                return value === '' ?
                    null :
                    (cast = _casts[column.type],
                        ret = cast && cast(value),
                        ret === void 0 ? value : ret);
            }
            Data.castInputValue = castInputValue;
            const _numeric = 'numeric', _geometry = 'geometry';
            Data.QueryTemplateParameters = {
                [1 /* AFC.Data.DataKind.character */]: 'text',
                [2 /* AFC.Data.DataKind.real */]: _numeric,
                [3 /* AFC.Data.DataKind.integer */]: _numeric,
                [4 /* AFC.Data.DataKind.bool */]: 'boolean',
                [5 /* AFC.Data.DataKind.date */]: 'date',
                /*time,
                timestamp,
                currency,
                blob,
                dynamic,
                formula,*/
                [1048576 /* AFC.Data.DataKind.point */]: _geometry,
                [2097152 /* AFC.Data.DataKind.line */]: _geometry,
                [4194304 /* AFC.Data.DataKind.polygon */]: _geometry,
                [7340032 /* AFC.Data.DataKind.geometry */]: _geometry
            };
            class TableIterator {
                _next() {
                    let reader = this.reader, component = this._key && {
                        key: this._key,
                        row: reader.getRow(this._i)
                    };
                    this._key = reader.getKey(++this._i);
                    return component;
                }
                _nextEx() {
                    let reader = this.reader, component = this._keyEx && {
                        key: this._keyEx,
                        row: reader.getRowEx(this._iEx)
                    };
                    this._keyEx = reader.getKeyEx(++this._iEx);
                    return component;
                }
                _merge(component0, component1) {
                    component0.row.forEach((value, indice) => this.reader.index[indice] === void 0 && (component0.row[indice] = component1.row[indice]));
                }
                constructor(reader) {
                    this.reader = reader;
                    this._i = this._iEx = -1;
                    this._next();
                    this._nextEx();
                }
                next() {
                    let next = this._key || this._keyEx, component, diff = 1;
                    if (next) {
                        !this._keyEx || (this._key && ((diff = AFC.Data.compareKey(this._key, this._keyEx)) <= 0)) ?
                            (component = this._next(), diff || this._merge(component, this._nextEx())) :
                            component = this._nextEx();
                    }
                    return {
                        done: !next,
                        value: component
                    };
                }
            }
            class PartReader {
                constructor(dataModel, key, part) {
                    let indexEx = this.index = dataModel.columns.map(column => part.columnIndex[column.name]);
                    this.values = (new AFC.Data.UniqueIndex(this.key = key.map(indice => indexEx[indice]), part.values)).values;
                }
                getKey(i) {
                    let row = this.values && this.values[i];
                    return row && this.key.map(indice => row[indice]);
                }
                getRow(i) {
                    let row = this.values && this.values[i];
                    return row && this.index.map(indice => indice === void 0 ? null : row[indice]);
                }
            }
            class TableReader extends PartReader {
                constructor(dataModel, dataModel0, dataModel1) {
                    let key = dataModel.primaryKey.map(name => dataModel.columnIndex[name]);
                    super(dataModel, key, dataModel0);
                    dataModel1 && (this.readerEx = new PartReader(dataModel, key, dataModel1));
                }
                getKeyEx(i) {
                    return this.readerEx && this.readerEx.getKey(i);
                }
                getRowEx(i) {
                    return this.readerEx && this.readerEx.getRow(i);
                }
                [Symbol.iterator]() {
                    return new TableIterator(this);
                }
            }
            Data.TableReader = TableReader;
            function mergeTables(dataModel0, dataModel1, dataModel) {
                dataModel = dataModel || (dataModel0.primaryKey && dataModel0);
                if (dataModel) {
                    let reader = new TableReader(dataModel, dataModel0, dataModel1), values = [], component;
                    for (component of reader) {
                        values.push(component.row);
                    }
                    return new AFC.Data.DataModel(dataModel.columns, dataModel.primaryKey, values);
                }
            }
            Data.mergeTables = mergeTables;
        })(Data = Tools.Data || (Tools.Data = {}));
    })(Tools = AFC.Tools || (AFC.Tools = {}));
})(AFC || (AFC = {}));
var AFC;
(function (AFC) {
    var Application;
    (function (Application) {
        const _ctorMap = [], _clsId = Symbol(), _parcelId = "___parcel_id___";
        class Parcel {
            /** @internal */
            constructor(clsId) {
                this[_parcelId] = clsId;
            }
        }
        Application.Parcel = Parcel;
        //type ExtractGeneric<T> = T extends A<infer X> ? X : never;
        let Parcelable;
        (function (Parcelable) {
            class CreatorImpl {
                constructor(createFromParcel) {
                    this[_clsId] = _ctorMap.length;
                    this.createFromParcel = createFromParcel;
                    _ctorMap.push(this);
                }
            }
            Parcelable.Creator = CreatorImpl;
            function writeToParcel(parcelable) {
                let ctor = parcelable.constructor, parcel;
                if (ctor.CREATOR) {
                    parcel = Reflect.construct(Parcel, [ctor.CREATOR[_clsId]]);
                    parcelable.writeToParcel(parcel);
                    return parcel;
                }
            }
            Parcelable.writeToParcel = writeToParcel;
            function createFromParcel(parcel) {
                let clsId = parcel[_parcelId], creator = _ctorMap[clsId];
                return creator?.createFromParcel(parcel);
            }
            Parcelable.createFromParcel = createFromParcel;
        })(Parcelable = Application.Parcelable || (Application.Parcelable = {}));
    })(Application = AFC.Application || (AFC.Application = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 20/11/2015.
 */
///<reference path="../../AFC.ts" />
///<reference path="../../helpers/EventSink.ts" />
///<reference path="../../helpers/Data.ts" />
///<reference path="../../application/Parcelable.ts" />
var AFC;
(function (AFC) {
    var Rest;
    (function (Rest) {
        "use strict";
        var _a;
        let ConnectionStatus;
        (function (ConnectionStatus) {
            ConnectionStatus[ConnectionStatus["ok"] = 1] = "ok";
            ConnectionStatus[ConnectionStatus["failed"] = 2] = "failed";
            ConnectionStatus[ConnectionStatus["maxConnection"] = 3] = "maxConnection";
            ConnectionStatus[ConnectionStatus["error"] = 4] = "error";
            ConnectionStatus[ConnectionStatus["resetPassword"] = 5] = "resetPassword";
            ConnectionStatus[ConnectionStatus["timeout"] = 6] = "timeout";
        })(ConnectionStatus = Rest.ConnectionStatus || (Rest.ConnectionStatus = {}));
        const ConnectionStatusLookup = {
            ok: 1 /* ConnectionStatus.ok */,
            failed: 2 /* ConnectionStatus.failed */,
            maxConnection: 3 /* ConnectionStatus.maxConnection */,
            error: 4 /* ConnectionStatus.error */,
            resetPassword: 5 /* ConnectionStatus.resetPassword */,
            timeout: 6 /* ConnectionStatus.timeout */
        };
        let State;
        (function (State) {
            State[State["uninitialized"] = 0] = "uninitialized";
            State[State["pending"] = 1] = "pending";
            State[State["ready"] = 2] = "ready";
        })(State || (State = {}));
        ;
        ;
        const _rsa = Symbol(), _identity = Symbol(), _mode = Symbol(), _logoutUri = Symbol(), _tokenUri = Symbol(), _authorizationUri = Symbol(), _state = Symbol(), _refresh = Symbol();
        let gCnt = 0;
        let AuthType;
        (function (AuthType) {
            AuthType[AuthType["uninitialized"] = 0] = "uninitialized";
            AuthType[AuthType["loading"] = 1] = "loading";
            AuthType[AuthType["error"] = 2] = "error";
            AuthType[AuthType["self"] = 3] = "self";
            AuthType[AuthType["direct"] = 16] = "direct";
            AuthType[AuthType["openIdForward"] = 1048576] = "openIdForward";
            AuthType[AuthType["authorizationCode"] = 1048592] = "authorizationCode";
        })(AuthType = Rest.AuthType || (Rest.AuthType = {}));
        function _isCodeBased(authType) {
            return !!(authType & 0x100000);
        }
        function _allowDirectIdentity(authType) {
            return !!(authType & 0x10);
        }
        function _getLocation() {
            return window.location.href;
        }
        const AuthTypeLookup = {
            direct: 16 /* AuthType.direct */,
            openIdForward: 1048576 /* AuthType.openIdForward */,
            authorizationCode: 1048592 /* AuthType.authorizationCode */
        };
        function authType(value) {
            return AuthTypeLookup[value];
        }
        function _key() {
            return AFC.Tools.Data.generateRndString(116);
        }
        let _session = AFC.Tools.Data.generateRndString(20);
        class UrlLoader {
            constructor() {
                this.searchParams = new URLSearchParams(window.location.search);
                window.history.replaceState(null, '', _getLocation().split(/[?#]/)[0]);
            }
        }
        Rest.UrlLoader = UrlLoader;
        class AuthorizationPolicy extends AFC.Tools.EventSinkMixin(UrlLoader) {
            constructor(url) {
                super();
                this.baseUrl = url;
                this[_mode] = 0 /* AuthType.uninitialized */;
                this[_state] = 0 /* State.uninitialized */;
                this[_identity] = new AuthorizationPolicy.Identity(this);
            }
            getLogoutUri() {
                return this[_logoutUri];
            }
            _onTokenAlways(sequence, key, jqXHR, textStatus) {
                if (this._sequence === sequence) {
                    let message, responseInfo, userName, credentials, status, data;
                    if (jqXHR.status === 200 && (message = jqXHR.responseText) && (message = CryptoJS.Rabbit.decrypt(message, key).toString(CryptoJS.enc.Utf8)) && (responseInfo = JSON.parse(message))) {
                        userName = responseInfo.userName;
                        credentials = responseInfo.credentials;
                        status = ConnectionStatusLookup[responseInfo.status];
                        data = responseInfo.data;
                    }
                    userName || (userName = '');
                    status || (status = 2 /* ConnectionStatus.failed */);
                    this[_identity][_refresh](userName, credentials, status, data);
                    this[_state] = 2 /* State.ready */;
                    this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                }
            }
            _getBody(key, message) {
                let crypted = message && encodeURIComponent(CryptoJS.Rabbit.encrypt(JSON.stringify(message), key).toString()) || AFC.Tools.Data.generateRndString(64), rsaKey = new RSAKey();
                rsaKey.setPublic(this[_rsa].n, this[_rsa].e);
                return `content=${rsaKey.encrypt(key) + crypted}`;
            }
            _buildAjaxSettings(key, endPoint, message) {
                this[_state] = 1 /* State.pending */;
                (message || (message = {})).session = _session;
                message.rnd = _key();
                return {
                    url: this.baseUrl + (endPoint ? `/${endPoint}` : ''),
                    complete: this._onTokenAlways.bind(this, this._sequence = ++gCnt, key),
                    method: 'POST',
                    processData: false,
                    async: true,
                    data: this._getBody(key, message)
                };
            }
            _loadCertificate(url) {
                return new Promise(resolve => jQuery.ajax({
                    url: url,
                    complete: (jqXHR, textStatus) => {
                        let o = jqXHR.responseJSON, success = false;
                        if (o && o.keys && o.keys.length) {
                            this[_rsa] = o.keys[0];
                            success = true;
                        }
                        resolve(success);
                    },
                    method: 'GET',
                    async: true
                }));
            }
            _setAuthorizationCode(code) {
                return new Promise(resolve => {
                    this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this[_identity]));
                    if (this[_state] !== 1 /* State.pending */) {
                        let key = _key(), settings = this._buildAjaxSettings(key, '');
                        settings.url = this[_tokenUri];
                        settings.data += `&code=${code}&redirect_uri=${this.getRedirectUri()}`;
                        jQuery.ajax(settings);
                    }
                });
            }
            async _refresh(identity) {
                return new Promise(resolve => {
                    this.notify(65536 /* AFC.Tools.EventType.UserEvent */, ( /*event*/) => resolve(identity));
                    if (this[_state] !== 1 /* State.pending */) {
                        let key = _key(), settings = this._buildAjaxSettings(key, 'authenticate'), tokenUri = this[_tokenUri];
                        if (tokenUri) {
                            settings.url = tokenUri;
                        }
                        settings.data += `&${identity.getAjaxBody()}&redirect_uri=${this.getRedirectUri()}`;
                        jQuery.ajax(settings);
                    }
                });
            }
            restart(loose) {
                if (!loose || (_isCodeBased(this[_mode]) && !this.searchParams.get('code'))) {
                    let authorizationUri = this[_authorizationUri];
                    if (!authorizationUri || (_getLocation() !== authorizationUri.split(/[?#]/)[0])) {
                        window.location.replace(this.getAuthorizationUri());
                    }
                }
            }
            getAuthorizationUri() {
                return this[_authorizationUri] || `${_getLocation()}?rnd=${AFC.Tools.Data.generateRndString(20)}`;
                ;
            }
            getRedirectUri() {
                return _getLocation().split(/[?#]/)[0].replace(/\/index.html$|\/$/i, '');
            }
            async init() {
                return this[_mode] !== 0 /* AuthType.uninitialized */ && this[_mode] !== 1 /* AuthType.loading */ ? this[_mode] :
                    new Promise(resolve => {
                        this.notify(65536 /* AFC.Tools.EventType.UserEvent */ + 1, ( /*event*/) => resolve(this[_mode]));
                        if (this[_mode] === 0 /* AuthType.uninitialized */) {
                            this[_mode] = 1 /* AuthType.loading */;
                            jQuery.ajax({
                                url: `${this.baseUrl}/auth`,
                                complete: async (jqXHR, textStatus) => {
                                    this[_mode] = 16 /* AuthType.direct */;
                                    if (jqXHR.status === 200) {
                                        let discovery = jqXHR.responseJSON;
                                        if (discovery) {
                                            let mode = authType(discovery.type), code, isCodeBased = _isCodeBased(mode);
                                            if (isCodeBased && (this[_tokenUri] = discovery.token_endpoint)) {
                                                code = this.searchParams.get('code');
                                                this[_mode] = mode;
                                            }
                                            this[_authorizationUri] = discovery.authorization_endpoint;
                                            this[_logoutUri] = discovery.end_session_endpoint;
                                            if (await this._loadCertificate(discovery.jwks_uri)) {
                                                isCodeBased && code ?
                                                    this._setAuthorizationCode(code) :
                                                    this[_state] = 2 /* State.ready */;
                                            }
                                            else {
                                                this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                                                this[_mode] = 2 /* AuthType.error */;
                                            }
                                        }
                                    }
                                    this.fireEvent(65536 /* AFC.Tools.EventType.UserEvent */ + 1);
                                },
                                method: 'GET',
                                async: true,
                                data: `redirect_uri=${this.getRedirectUri()}`
                            });
                        }
                    });
            }
            getIdentity() {
                return this.init().then(authType => authType !== 2 /* AuthType.error */
                    && (this[_state] === 2 /* State.ready */ ? this[_identity] : new Promise(resolve => this.notify(65536 /* AFC.Tools.EventType.UserEvent */, ( /*event*/) => resolve(this[_identity])))));
            }
            setDirectIdentity(name, password) {
                return this.init().then(authType => _allowDirectIdentity(authType)
                    && new Promise(resolve => {
                        let key = _key(), message = {
                            name: name,
                            password: CryptoJS.SHA1(password).toString(CryptoJS.enc.Base64)
                        };
                        this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this[_identity]));
                        jQuery.ajax(this._buildAjaxSettings(key, 'authenticate', message));
                    }));
            }
            resetPasswordUntrusted(name, oldPassword, newPassword) {
                return this.init().then(authType => _allowDirectIdentity(authType)
                    && new Promise(resolve => {
                        let key = _key(), message = {
                            name: name,
                            password: CryptoJS.SHA1(oldPassword).toString(CryptoJS.enc.Base64),
                            newPassword: CryptoJS.SHA1(newPassword).toString(CryptoJS.enc.Base64)
                        };
                        this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this[_identity]));
                        jQuery.ajax(this._buildAjaxSettings(key, 'reset', message));
                    }));
            }
            resetPasswordTrusted(credentials, newPassword) {
                return this.init().then(authType => _allowDirectIdentity(authType)
                    && new Promise(resolve => {
                        let key = _key(), message = {
                            trusted: true,
                            newPassword: CryptoJS.SHA1(newPassword).toString(CryptoJS.enc.Base64),
                            credentials: credentials
                        };
                        this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this[_identity]));
                        jQuery.ajax(this._buildAjaxSettings(key, 'reset', message));
                    }));
            }
            sendReminder(name, returnUrl) {
                return this.init().then(authType => _allowDirectIdentity(authType)
                    && new Promise(resolve => {
                        let message = {
                            name: name,
                            url: returnUrl + `${returnUrl.indexOf('?') === -1 ? '?' : '&'}content=%1`
                        };
                        let opts = {
                            url: `${this.baseUrl}/forgotten`,
                            complete: (jqXHR, textStatus) => {
                                resolve((jqXHR.status === 200) && (jqXHR.responseText === (1 /* ConnectionStatus.ok */).toString()));
                            },
                            method: 'POST',
                            processData: false,
                            async: true,
                            data: this._getBody(_key(), message)
                        };
                        jQuery.ajax(opts);
                    }));
            }
            invalidate() {
                delete this._sequence;
                this[_state] = 2 /* State.ready */;
                this[_identity].invalidate();
            }
        }
        AuthorizationPolicy.Identity = (_a = class Identity {
                constructor(policy, userName, credentials, status, data) {
                    this.authorizationPolicy = policy;
                    this[_refresh](userName, credentials, status, data);
                }
                get name() {
                    return this._name;
                }
                get status() {
                    return this._status;
                }
                get data() {
                    return this._data;
                }
                get isAuthenticated() {
                    return this._status === 1 /* ConnectionStatus.ok */ || this._status === 5 /* ConnectionStatus.resetPassword */;
                }
                get logoutUri() {
                    return this.authorizationPolicy.getLogoutUri();
                }
                [_refresh](userName = '', credentials, status = 2 /* ConnectionStatus.failed */, data) {
                    this._name = userName;
                    this._token = encodeURIComponent(credentials);
                    this._status = status;
                    data && (this._data = data);
                }
                getAjaxBody() {
                    return `token=${this._token}`;
                }
                getCredentials() {
                    return {
                        token: this._token
                    };
                }
                refresh() {
                    return this.authorizationPolicy._refresh(this);
                }
                async getAuthorizationCode() {
                    return new Promise((resolve, reject) => {
                        let settings = {
                            url: this.authorizationPolicy.baseUrl + '/auth/code',
                            complete: (jqXHR, textStatus) => {
                                let token = jqXHR.status === 200 && jqXHR.responseText;
                                token ? resolve(token) : reject();
                            },
                            method: 'POST',
                            processData: false,
                            async: true,
                            data: this.authorizationPolicy._getBody(_key(), {
                                session: _session, rnd: _key()
                            })
                        };
                        settings.data += `&${this.getAjaxBody()}`;
                        jQuery.ajax(settings);
                    });
                }
                invalidate() {
                    if (this.isAuthenticated) {
                        jQuery.ajax({
                            url: `${this.authorizationPolicy.baseUrl}/logout`,
                            method: 'POST',
                            processData: false,
                            async: true,
                            data: `content=${this._token}`
                        });
                        this[_refresh]();
                        this.authorizationPolicy.invalidate();
                    }
                }
                writeToParcel(out) {
                    out.baseUrl = this.authorizationPolicy.baseUrl;
                    out.rsa = this.authorizationPolicy[_rsa];
                    out.logoutUri = this.authorizationPolicy[_logoutUri];
                    out.tokenUri = this.authorizationPolicy[_tokenUri];
                    out.authorizationUri = this.authorizationPolicy[_authorizationUri];
                    out.mode = this.authorizationPolicy[_mode];
                    out.state = this.authorizationPolicy[_state];
                    out.sequence = this.authorizationPolicy._sequence;
                    out.session = _session;
                    out.name = this._name;
                    out.token = this._token;
                    out.status = this._status;
                    out.data = this._data;
                }
            },
            _a.CREATOR = new AFC.Application.Parcelable.Creator((parcel) => {
                let authorizationPolicy = new AuthorizationPolicy(parcel.baseUrl), identity = new _a(authorizationPolicy, parcel.name, "", parcel.status, parcel.data);
                identity._token = parcel.token;
                authorizationPolicy[_rsa] = parcel.rsa;
                authorizationPolicy[_logoutUri] = parcel.logoutUri;
                authorizationPolicy[_tokenUri] = parcel.tokenUri;
                authorizationPolicy[_authorizationUri] = parcel.authorizationUri;
                authorizationPolicy[_mode] = parcel.mode;
                authorizationPolicy[_state] = parcel.state;
                authorizationPolicy._sequence = parcel.sequence;
                _session = parcel.session;
                return identity;
            }),
            _a);
        Rest.AuthorizationPolicy = AuthorizationPolicy;
        class Self {
            constructor(authorizationPolicy, key, name, data) {
                this.authorizationPolicy = authorizationPolicy;
                this._key = key;
                this.name = name || '';
                this.isAuthenticated = true;
                this.status = 1 /* ConnectionStatus.ok */;
                data && (this.data = data);
            }
            getAjaxBody() {
                return `key=${this._key}`;
            }
            getCredentials() {
                return {
                    key: this._key
                };
            }
            async refresh() {
                return this;
            }
            invalidate() {
            }
            writeToParcel(out) {
                out.session = _session;
                out.key = this._key;
                out.name = this.name;
                out.data = this.data;
            }
        }
        Self.CREATOR = new AFC.Application.Parcelable.Creator((parcel) => {
            let authorizationPolicy = new SelfAuthorizationPolicy(parcel.key, parcel.name, parcel.data);
            _session = parcel.session;
            return authorizationPolicy[_identity];
        });
        class SelfAuthorizationPolicy extends UrlLoader {
            constructor(key, name, data) {
                super();
                this[_identity] = new Self(this, key, name, data);
            }
            init() {
                return Promise.resolve(3 /* AuthType.self */);
            }
            restart(loose) {
                loose || window.location.replace(this.getAuthorizationUri());
            }
            getIdentity() {
                return Promise.resolve(this[_identity]);
            }
            getAuthorizationUri() {
                return `${AuthorizationPolicy.prototype.getRedirectUri.call(null)}?rnd=${AFC.Tools.Data.generateRndString(20)}`;
            }
            invalidate() {
            }
        }
        Rest.SelfAuthorizationPolicy = SelfAuthorizationPolicy;
    })(Rest = AFC.Rest || (AFC.Rest = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 27/01/2016.
 */
var AFC;
(function (AFC) {
    let Tools;
    (function (Tools) {
        function lower_bound(a, v, pred = (a, b) => (a < b) ? -1 : 0) {
            let n = a.length;
            if (n > 0) {
                let f = 0;
                let n2, m;
                while (0 < n) {
                    n2 = n >> 1;
                    m = f + n2;
                    if (pred(a[m], v) < 0)
                        f = m + 1, n -= n2 + 1;
                    else
                        n = n2;
                }
                return f;
            }
            return 0;
        }
        Tools.lower_bound = lower_bound;
        function findById(id, interfaces) {
            if (id !== void 0) {
                let ref = id.toLowerCase();
                for (let o of interfaces) {
                    if (o.id.toLowerCase() === ref) {
                        return o;
                    }
                }
            }
        }
        Tools.findById = findById;
        function indexOf(a, pred) {
            for (let i = 0; i < a.length; ++i) {
                if (pred(a[i])) {
                    return i;
                }
            }
            return -1;
        }
        Tools.indexOf = indexOf;
        function findByIdOrName(id, interfaces, filter) {
            if (id !== void 0) {
                let ref = id.toLowerCase();
                for (let o of interfaces) {
                    if ((!filter || filter(o)) && ((o.id.toLowerCase() === ref) || ((o.name !== void 0) && (o.name.toLowerCase() === ref)))) {
                        return o;
                    }
                }
            }
        }
        Tools.findByIdOrName = findByIdOrName;
        function arrayCompare(v0, v1) {
            let iLength = v0.length, ret = iLength - v1.length;
            for (let i = 0; !ret && (i < iLength); ++i) {
                ret = v0[i] instanceof Array ? arrayCompare(v0[i], v1[i]) : AFC.Data.compareValue(v0[i], v1[i]);
            }
            return ret;
        }
        Tools.arrayCompare = arrayCompare;
        function _open(activity, message, yesNoChoice, title) {
            return new Promise(resolve => {
                const AlertDialog = AFC.Controls.AlertDialog;
                let dialog = new AlertDialog(activity), end = (confirm) => (dialog.dismiss(), resolve(confirm));
                title && dialog.setTitle(title);
                dialog.setMessage(message);
                if (yesNoChoice) {
                    dialog.setButton(AlertDialog.BUTTON_POSITIVE, '', ( /*dialog, which*/) => end(true));
                    dialog.setButton(AlertDialog.BUTTON_NEUTRAL, '', ( /*dialog, which*/) => end());
                }
                else {
                    dialog.setButton(AlertDialog.BUTTON_POSITIVE, '', ( /*dialog, which*/) => end());
                }
                dialog.show();
            });
        }
        Tools.alert = async (activity, message, title) => await _open(activity, message, false, title);
        Tools.confirm = async (activity, message, title) => await _open(activity, message, true, title);
        let Lang;
        (function (Lang) {
            let Locale;
            (function (Locale) {
                Locale[Locale["fr"] = 1] = "fr";
                Locale[Locale["us"] = 2] = "us";
                Locale[Locale["en"] = 3] = "en";
            })(Locale = Lang.Locale || (Lang.Locale = {}));
        })(Lang = Tools.Lang || (Tools.Lang = {}));
        let Style;
        (function (Style) {
            function convertColor(v) {
                if (v < 0)
                    return 'transparent';
                let r = (v & 0xFF), g = ((v >> 8) & 0xFF), b = ((v >> 16) & 0xFF);
                return '#' + (function (h) {
                    return new Array(7 - h.length).join("0") + h;
                })(((r << 16) + (g << 8) + b).toString(16));
            }
            Style.convertColor = convertColor;
            function convertRGBAColor(v) {
                if (v < 0)
                    return 'transparent';
                let r = (v & 0xFF), g = ((v >> 8) & 0xFF), b = ((v >> 16) & 0xFF), a = Math.round((0xFF - ((v >> 24) & 0xFF)) / 2.56) * 100;
                return `rgba(${r},${g},${b},${a})`;
            }
            Style.convertRGBAColor = convertRGBAColor;
            Style.transparent1Pixel = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
        })(Style = Tools.Style || (Tools.Style = {}));
        let StringTools;
        (function (StringTools) {
            function normalizeString(s) {
                if (s && (s !== null)) {
                    let str = s.toLowerCase();
                    str = str.replace(/[' ,;-]/g, '_');
                    str = str.replace(/[éèêë]/g, 'e');
                    str = str.replace(/[àâä]/g, 'a');
                    str = str.replace(/ö/g, 'o');
                    str = str.replace(/ï/g, 'i');
                    str = str.replace(/ç/g, 'c');
                    str = str.replace(/ü/g, 'u');
                    return str.toUpperCase();
                }
                return '';
            }
            StringTools.normalizeString = normalizeString;
            function buildUrl(host, path, secure, port) {
                let url = (secure ? 'https://' : 'http://') + host;
                if (port !== void 0) {
                    url += `:${port}`;
                }
                return url + ((path[0] === '/') ? '' : '/') + path;
            }
            StringTools.buildUrl = buildUrl;
            function _2digit(i) {
                return (i < 10 ? '0' : '') + i.toString();
            }
            const _dateMap = {
                100: {
                    1: (d) => d.getDate(),
                    2: (d) => _2digit(d.getDate()),
                    3: (d) => d.toLocaleDateString(void 0, { weekday: 'short' }),
                    4: (d) => d.toLocaleDateString(void 0, { weekday: 'long' })
                },
                77: {
                    1: (d) => d.getMonth() + 1,
                    2: (d) => _2digit(d.getMonth() + 1),
                    3: (d) => d.toLocaleDateString(void 0, { month: 'short' }),
                    4: (d) => d.toLocaleDateString(void 0, { month: 'long' })
                },
                121: {
                    2: (d) => _2digit(d.getFullYear() % 100),
                    4: (d) => _2digit(d.getFullYear())
                },
                104: {
                    1: (d) => (d.getHours() % 12) || 12,
                    2: (d) => _2digit((d.getHours() % 12) || 12)
                },
                72: {
                    1: (d) => d.getHours(),
                    2: (d) => _2digit(d.getHours())
                },
                109: {
                    1: (d) => d.getMinutes() + 1,
                    2: (d) => _2digit(d.getMinutes() + 1)
                },
                115: {
                    1: (d) => d.getSeconds() + 1,
                    2: (d) => _2digit(d.getSeconds() + 1)
                },
                116: {
                    1: (d) => d.getHours() < 12 ? 'A' : 'P',
                    2: (d) => d.getHours() < 12 ? 'AM' : 'PM'
                }
            };
            function _parseDateFormat(format) {
                let i = 0, formatters = [], c, byPass = (str) => ((d) => str);
                while (c = format.charCodeAt(i)) {
                    let j = 0;
                    do {
                        ++j;
                    } while (c === format.charCodeAt(i + j));
                    let formatter = _dateMap[c] && _dateMap[c][j];
                    formatters.push(formatter || byPass(format.substr(i, j)));
                    i += j;
                }
                return formatters;
            }
            class FormatString {
                constructor(format, datakind) {
                    this._datakind = datakind;
                    this._format = (format === void 0 ? '' : format);
                    this._decodedFormat = void 0;
                }
                getFormated(value) {
                    let formatedValue = '';
                    this._decodeFormat();
                    if ((value == null) || (value === void 0)) {
                        if (this._decodedFormat.nullvalue !== void 0)
                            formatedValue = this._decodedFormat.nullvalue;
                        else
                            formatedValue = '';
                    }
                    else if (this._decodedFormat.formatters) {
                        formatedValue = this._decodedFormat.formatters.reduce((acc, formatter) => acc + formatter(value), '');
                    }
                    else {
                        switch (this._decodedFormat.kind) {
                            case 'numeric':
                                formatedValue = (Math.round(value * 100) / 100).toLocaleString(undefined, this._decodedFormat.numeric_options);
                                break;
                            case 'date':
                                formatedValue = value.toLocaleString();
                                break;
                            case 'time':
                                formatedValue = value.toLocaleString();
                                break;
                            default:
                                formatedValue = value;
                                break;
                        }
                        formatedValue = this._decodedFormat.prefix + formatedValue + this._decodedFormat.suffix;
                    }
                    return formatedValue;
                }
                isNumeric() {
                    this._decodeFormat();
                    if (this._decodedFormat.kind == 'numeric')
                        return true;
                    return false;
                }
                _decodeFormat() {
                    if (this._decodedFormat === void 0) {
                        this._decodedFormat = { kind: 'string', numeric_options: {}, prefix: '', suffix: '' };
                        if (this._datakind == 2 /* AFC.Data.DataKind.real */ || this._datakind == 3 /* AFC.Data.DataKind.integer */)
                            this._decodedFormat.kind = 'numeric';
                        if (this._format != '') {
                            let regex = /{!(.*?)!}/g;
                            this._format.match(regex).forEach(token => {
                                let values = token.slice(2, token.length - 2).split(":");
                                if (values.length == 2) {
                                    switch (values[0].toLowerCase()) {
                                        case 'kind':
                                            switch (values[1].toLowerCase()) {
                                                case 'date':
                                                    this._decodedFormat.kind = 'date';
                                                    break;
                                                case 'time':
                                                    this._decodedFormat.kind = 'time';
                                                    break;
                                                case 'percent':
                                                    this._decodedFormat.kind = 'numeric';
                                                    //this._decodedFormat.numeric_options.style = 'percent';
                                                    this._decodedFormat.suffix = ' %';
                                                    break;
                                                case 'number':
                                                    this._decodedFormat.kind = 'numeric';
                                                    this._decodedFormat.numeric_options.style = 'decimal';
                                                    break;
                                                case 'currency':
                                                case 'euro':
                                                    //Default currency is EUR
                                                    this._decodedFormat.kind = 'numeric';
                                                    this._decodedFormat.numeric_options.style = 'currency';
                                                    this._decodedFormat.numeric_options.currency = 'EUR';
                                                    break;
                                                case 'yen':
                                                    this._decodedFormat.kind = 'numeric';
                                                    this._decodedFormat.numeric_options.style = 'currency';
                                                    this._decodedFormat.numeric_options.currency = 'JPY';
                                                    break;
                                                case 'dollard':
                                                    this._decodedFormat.kind = 'numeric';
                                                    this._decodedFormat.numeric_options.style = 'currency';
                                                    this._decodedFormat.numeric_options.currency = 'USD';
                                                    break;
                                            }
                                            break;
                                        case 'round':
                                            this._decodedFormat.numeric_options.minimumFractionDigits = Number(values[1]);
                                            this._decodedFormat.numeric_options.maximumFractionDigits = this._decodedFormat.numeric_options.minimumFractionDigits;
                                            break;
                                        case 'prefix':
                                            this._decodedFormat.prefix = values[1];
                                            break;
                                        case 'suffix':
                                            this._decodedFormat.suffix = values[1];
                                            break;
                                        case 'nullvalue':
                                            this._decodedFormat.nullvalue = values[1];
                                            break;
                                        case 'thousand_separator':
                                            this._decodedFormat.numeric_options.useGrouping = values[1] == '1' ? true : false;
                                            break;
                                        case 'custom_property':
                                        case 'custom_properyy':
                                            if (this._decodedFormat.kind === 'time' || this._decodedFormat.kind === 'date') {
                                                this._decodedFormat.formatters = _parseDateFormat(values[1]);
                                            }
                                            else {
                                                this._decodedFormat.custom_property = values[1];
                                            }
                                            break;
                                    }
                                }
                            });
                        }
                    }
                }
            }
            StringTools.FormatString = FormatString;
        })(StringTools = Tools.StringTools || (Tools.StringTools = {}));
    })(Tools = AFC.Tools || (AFC.Tools = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 27/01/2016.
 */
///<reference path="../../helpers/EventSink.ts" />
var AFC;
(function (AFC) {
    var Data;
    (function (Data) {
        const _dataSource = Symbol(), _where = Symbol();
        class DataSourceIterator {
            constructor(dataSource) {
                this[_dataSource] = dataSource;
                this[_where] = 0;
            }
            next() {
                let dataSource = this[_dataSource];
                return (this[_where] < dataSource.length) ?
                    {
                        value: dataSource.item(this[_where]++)
                    } : {
                    value: null,
                    done: true
                };
            }
        }
        function DataSourceMixin(Base) {
            class DataSourceBase extends Base {
                get length() {
                    return this.values && this.values.length;
                }
                item(index) {
                    return {
                        dataItem: AFC.Tools.Data.mapRow(this.columns, this.values[index]),
                        dataItemIndex: index
                    };
                }
                [Symbol.iterator]() {
                    return new DataSourceIterator(this);
                }
            }
            return DataSourceBase;
        }
        Data.DataSourceMixin = DataSourceMixin;
        Data.DataSource = DataSourceMixin(AFC.Tools.EventSink);
    })(Data = AFC.Data || (AFC.Data = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 11/02/2019.
 */
///<reference path="../../helpers/Tools.ts" />
///<reference path="DataSource.ts" />
var AFC;
(function (AFC) {
    var Data;
    (function (Data) {
        function compareValue(v0, v1) {
            return ((v0 < v1) && -1) || ((v0 > v1) && 1) || 0;
        }
        Data.compareValue = compareValue;
        function _compareValueWithRow(column, row, key) {
            return compareValue(row[column], key[0]);
        }
        function _compareValuesWithRow(columns, row, key) {
            let ret = 0;
            for (let i = 0, iLength = columns.length; !ret && (i < iLength); ++i) {
                ret = compareValue(row[columns[i]], key[i]);
            }
            return ret;
        }
        function _compareRowValue(column, row0, row1) {
            return compareValue(row0[column], row1[column]);
        }
        function compareRows(columns, row0, row1) {
            let ret = 0;
            for (let i = 0, iLength = columns.length, column; !ret && (i < iLength); ++i) {
                ret = compareValue(row0[column = columns[i]], row1[column]);
            }
            return ret;
        }
        Data.compareRows = compareRows;
        class RowComparator {
            constructor(columns) {
                if (columns.length > 1) {
                    this.compareKey = _compareValuesWithRow.bind(null, columns);
                    this.compareRow = compareRows.bind(null, columns);
                }
                else {
                    this.compareKey = _compareValueWithRow.bind(null, columns[0]);
                    this.compareRow = _compareRowValue.bind(null, columns[0]);
                }
                this.getKeyFromRow = (row) => columns.map((i) => row[i]);
            }
        }
        Data.RowComparator = RowComparator;
        class Index extends RowComparator {
            constructor(columns, rows) {
                super(columns);
                (this.values = rows.slice(0)).sort(compareRows.bind(null, columns));
            }
        }
        Data.Index = Index;
        class UniqueIndex extends Index {
            clone() {
                let clone = Object.create(this.constructor.prototype);
                clone.values = this.values.slice(0);
                clone.compareKey = this.compareKey;
                clone.compareRow = this.compareRow;
                clone.getKeyFromRow = this.getKeyFromRow;
                return clone;
            }
            find(key) {
                let i = AFC.Tools.lower_bound(this.values, key, this.compareKey);
                return (i >= this.values.length) || this.compareKey(this.values[i], key) ? -1 : i;
            }
            lowerKeyBound(value) {
                return AFC.Tools.lower_bound(this.values, value, this.compareKey);
            }
            indexOf(row) {
                let i = AFC.Tools.lower_bound(this.values, row, this.compareRow);
                return (i >= this.values.length) || this.compareRow(this.values[i], row) ? -1 : i;
            }
            lowerBound(row) {
                return AFC.Tools.lower_bound(this.values, row, this.compareRow);
            }
            insert(indice, row) {
                this.values.splice(indice, 0, row);
            }
            modify(indice, row) {
                this.values[indice] = row;
            }
            delete_(indice) {
                this.values.splice(indice, 1);
            }
        }
        Data.UniqueIndex = UniqueIndex;
    })(Data = AFC.Data || (AFC.Data = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 27/01/2016.
 */
///<reference path="../../helpers/Tools.ts" />
///<reference path="DataSource.ts" />
///<reference path="Index.ts" />
var AFC;
(function (AFC) {
    var Data;
    (function (Data) {
        class ModifiedArray extends Array {
            constructor(pos, row) {
                super();
                this.__pos = pos;
                if (row) {
                    this.length = row.length;
                    row.forEach((item, i) => this[i] = item);
                }
            }
            clone() {
                return Reflect.construct(ModifiedArray, [this.__pos, this], this.constructor);
            }
        }
        function _mergeSeed(next, seed) {
            if (next.type === 4 /* DataEventType.delete_ */) {
                if (seed.type === 1 /* DataEventType.create */) {
                    next.type = 0 /* DataEventType.none */;
                }
            }
            else {
                next.type = seed.type;
                if (seed.values) { // creation or modification
                    let values = next.values;
                    next.values = seed.values;
                    for (let i in values) {
                        next.values[i] = values[i];
                    }
                }
            }
        }
        class DataEventData {
            constructor(items, reset) {
                reset ? (this.reset = true) : items && (this.items = items);
            }
            concat(d) {
                if (d.reset) {
                    this.reset = true;
                    delete this.items;
                }
                else if (!this.reset) {
                    d.items && (this.items = this.items ? this.items.concat(d.items) : d.items);
                }
                return this;
            }
        }
        Data.DataEventData = DataEventData;
        class DBColumn {
            constructor(name, type, index, size, alias, readOnly, nullable = true, dataId) {
                this.name = name;
                this.type = type;
                this.index = index;
                this.size = size || 0;
                this.alias = alias || name;
                this.nullable = nullable;
                readOnly && (this.readOnly = readOnly);
                dataId && (this.dataId = dataId);
            }
            toJSON() {
                let o = {
                    name: this.name,
                    type: Data.dataKind(this.type)
                };
                this.size && (o.size = this.size);
                this.alias && (o.alias = this.alias);
                return o;
            }
        }
        Data.DBColumn = DBColumn;
        const _creationTypeLookup = {
            [1 /* CreationType.query */]: 'asteropTableTypeQuery',
            [2 /* CreationType.modification */]: 'asteropTableTypeModification',
            [3 /* CreationType.embedded */]: 'asteropTableTypeEmbedded',
            [4 /* CreationType.historyView */]: 'asteropTableTypeHistoryView'
        };
        class DataCreation {
            toJSON() {
                return { type: _creationTypeLookup[this.type] };
            }
        }
        class QueryCreation extends DataCreation {
            constructor(commandText, parameters) {
                super();
                this.commandText = commandText;
                this.parameters = parameters;
            }
            get type() {
                return 1 /* CreationType.query */;
            }
            toJSON() {
                let o = super.toJSON();
                o.commandText = this.commandText;
                o.parameters = this.parameters;
                return o;
            }
        }
        Data.QueryCreation = QueryCreation;
        class ModificationCreation extends DataCreation {
            constructor(reference, events, branchInfo) {
                super();
                this.reference = reference;
                this.events = events;
                this.branchInfo = branchInfo;
            }
            get type() {
                return 2 /* CreationType.modification */;
            }
            toJSON() {
                let o = super.toJSON();
                o.reference = this.reference;
                o.events = this.events;
                o.branchInfo = this.branchInfo;
                return o;
            }
        }
        Data.ModificationCreation = ModificationCreation;
        class EmbeddedCreation extends DataCreation {
            constructor(columns, primaryKey, values) {
                super();
                this.columns = columns;
                this.primaryKey = primaryKey;
                this.values = values;
            }
            get type() {
                return 3 /* CreationType.embedded */;
            }
            toJSON() {
                let o = super.toJSON();
                o.columns = this.columns;
                o.primaryKey = this.primaryKey;
                o.values = this.values;
                return o;
            }
        }
        Data.EmbeddedCreation = EmbeddedCreation;
        function isValidHistory(history) {
            return history && ((history.stamp !== void 0) || (history.refreshStamp !== void 0) || history.session);
        }
        Data.isValidHistory = isValidHistory;
        class HistoryView extends DataCreation {
            constructor(reference, history, branch) {
                super();
                this.reference = reference;
                isValidHistory(history) && (this.history = history);
                this.branch = branch;
            }
            get type() {
                return 4 /* CreationType.historyView */;
            }
            toJSON() {
                let o = super.toJSON();
                o.reference = this.reference;
                this.history && (o.history = this.history);
                o.branch = this.branch;
                return o;
            }
        }
        Data.HistoryView = HistoryView;
        function mapDataColumns(definition) {
            return definition.columns.map(column => new DBColumn(column.name, Data.dataKind(column.type), definition.primaryKey ? definition.primaryKey.indexOf(column.name) : -1, column.size, column.alias, column.isPseudoColumn, !column.notNullable, column.dataId));
        }
        Data.mapDataColumns = mapDataColumns;
        function updateDataRows(columns, rows) {
            rows && columns.forEach((column, indice) => {
                switch (column.type) {
                    case 5 /* DataKind.date */:
                    case 6 /* DataKind.time */:
                    case 7 /* DataKind.timestamp */:
                        rows.forEach(row => row[indice] && (row[indice] = new Date(row[indice])));
                }
            });
            return rows;
        }
        Data.updateDataRows = updateDataRows;
        function updateTableData(data) {
            let dataTable = data;
            data?.columns && updateDataRows(dataTable.columns = mapDataColumns(data), data.values);
            return dataTable;
        }
        Data.updateTableData = updateTableData;
        function compareKey(key0, key1) {
            let iLength = key0.length, ret = iLength - key1.length;
            for (let i = 0; !ret && (i < iLength); ++i) {
                ret = Data.compareValue(key0[i], key1[i]);
            }
            return ret;
        }
        Data.compareKey = compareKey;
        function getColumnIndex(columns) {
            let columnIndex = {};
            columns.forEach((item, i) => columnIndex[item.name] = columnIndex[item.alias] = i);
            return columnIndex;
        }
        Data.getColumnIndex = getColumnIndex;
        class DataModelBaseEx extends Data.DataSource {
            constructor(columns, values) {
                super();
                this.columnIndex = getColumnIndex(this.columns = columns);
                values && (this.values = values);
            }
            get type() {
                return 3 /* CreationType.embedded */;
            }
            toJSON() {
                return EmbeddedCreation.prototype.toJSON.call(this);
            }
        }
        class DataModelBase extends DataModelBaseEx {
            constructor(columns, primaryKey, values) {
                super(columns, values);
                primaryKey && (this.primaryKey = primaryKey);
            }
        }
        Data.DataModelBase = DataModelBase;
        function _createRow(model, key, row, values, newValues) {
            return model.columns.every((column, indice) => {
                let value;
                if (column.index === -1) {
                    if ((value = values[column.name]) !== void 0) {
                        newValues && (newValues[column.name] = value);
                    }
                    else {
                        value = null;
                    }
                }
                else {
                    value = key[column.index];
                }
                if (AFC.Tools.Data.isValid(column.type, value)) {
                    row[indice] = value;
                    return true;
                }
            });
        }
        function _compareValue(indice, column, row, value) {
            return column && (column.index === -1) && AFC.Tools.Data.isValid(column.type, value) && !AFC.Tools.Data.equalValue(column.type, row[indice], value);
        }
        function _fillRow(model, row, values, oldValues, newValues) {
            let name, indice, value;
            let changed = false, column;
            for (name in values) {
                if (_compareValue(indice = model.columnIndex[name], column = model.columns[indice], row, value = values[name])) {
                    oldValues && (oldValues[name] = row[indice]);
                    newValues && (newValues[name] = value);
                    row[indice] = value;
                    changed = true;
                }
            }
            return changed;
        }
        function createRowFromValues(model, key, values, newValues) {
            let row = new Array(model.columns.length);
            _createRow(model, key, row, values, newValues);
            return row;
        }
        Data.createRowFromValues = createRowFromValues;
        function modifyRowWithValues(model, row, values, oldValues, newValues) {
            let copy = row.slice();
            return _fillRow(model, copy, values, oldValues, newValues) && copy;
        }
        Data.modifyRowWithValues = modifyRowWithValues;
        class DataModel extends DataModelBaseEx {
            constructor(columns, primaryKey, values) {
                super(columns);
                this._primaryKey = primaryKey.map((item) => this.columnIndex[item]);
                this.setValues(values, true);
            }
            get primaryKey() {
                let columns = this.columns;
                return this._primaryKey && this._primaryKey.map((i) => columns[i].name);
            }
            setValues(values, noFire) {
                this._index = new Data.UniqueIndex(this._primaryKey, values || []);
                this.values = this._index.values;
                noFire || this.fireEvent(6 /* Tools.EventType.Dirty */, new DataEventData(void 0, true));
            }
            getKeyFromRow(row) {
                return this._index?.getKeyFromRow(row);
            }
            compareKey(row, key) {
                return this._index?.compareKey(row, key);
            }
            compareRow(row0, row1) {
                return this._index?.compareRow(row0, row1);
            }
            /** @internal */
            lowerKeyBound(key) {
                return this._index?.lowerKeyBound(key);
            }
            /** @internal */
            createAt(i, row) {
                this._index.insert(i, row);
                this.fireEvent(6 /* Tools.EventType.Dirty */, new DataEventData([{
                        type: 1 /* DataEventType.create */,
                        row: row,
                        committed: true
                    }]));
                return true;
            }
            create(key, values) {
                let i = this.lowerKeyBound(key), row0 = this.values[i], row;
                return (!row0 || this._index.compareKey(row0, key)) && _createRow(this, key, row = [], values) && this.createAt(i, row);
            }
            /**
             * AFC Internal method, ignore readonly
             */
            /** @internal */
            modifyAtEx(i, row) {
                let row0 = this.values[i];
                this.columns.some((column, indice) => _compareValue(indice, column, row0, row[indice])) && this.fireEvent(6 /* Tools.EventType.Dirty */, new DataEventData([{
                        type: 2 /* DataEventType.modify */,
                        row: this.values[i] = row,
                        committed: true
                    }]));
            }
            /** @internal */
            modifyAt(i, values) {
                let row;
                if ((i !== -1) && _fillRow(this, row = this.values[i], values)) {
                    this.fireEvent(6 /* Tools.EventType.Dirty */, new DataEventData([{
                            type: 2 /* DataEventType.modify */,
                            row: row,
                            committed: true
                        }]));
                    return true;
                }
            }
            modify(key, values) {
                let i = this.find(key);
                return this.modifyAt(i, values);
            }
            /** @internal */
            deleteAt(i) {
                this.fireEvent(6 /* Tools.EventType.Dirty */, new DataEventData([{
                        type: 4 /* DataEventType.delete_ */,
                        row: this.values[i],
                        committed: true
                    }]));
                this._index.delete_(i);
            }
            delete_(key) {
                let i = this.find(key);
                return (i !== -1) && (this.deleteAt(i), true);
            }
            indexOf(row) {
                return this._index ? this._index.indexOf(row) : -1;
            }
            find(key) {
                return this._index ? this._index.find(key) : -1;
            }
            getRow(index) {
                return this.values && this.values[index];
            }
        }
        Data.DataModel = DataModel;
        class DataModelMap {
            constructor() {
                this._counter = 1;
                this._dict = {};
            }
            add(value) {
                return (this._dict[value] || (this._dict[this._dict[++this._counter] = value] = this._counter));
            }
            remove(value) {
                let v = this._dict[value];
                delete this._dict[v];
                delete this._dict[value];
            }
            get(value) {
                return this._dict[value];
            }
        }
        const _rows = Symbol(), _dropInfo = Symbol(), _reset = Symbol(), _refreshRow = Symbol(), _refreshRows = Symbol();
        class BranchBaseEx extends Data.DataSource {
            constructor(pool, map, branch) {
                super();
                this._pool = pool;
                this._map = map;
                this._branch = branch;
                this.on(1073741824 /* Tools.EventType.Attach */, this._onAttach, this);
            }
            static _ready(branch, callback) {
                branch._index ? callback() : branch.notify(6 /* Tools.EventType.Dirty */, callback);
            }
            static getIndex(branch) {
                return branch._index;
            }
            static cloneIndex(branch) {
                return branch._index.clone();
            }
            static branchNb(branch) {
                return branch._branch;
            }
            static sessionNb(branch) {
                return branch._session;
            }
            _init(dataModel, dispatcher) {
                this._dataModel = dataModel;
                this._dispatcher = dispatcher;
                this._refresh();
            }
            _createInternal(i, key, values, pos = this._dataModel.create(), filteredValues) {
                let row = new ModifiedArray(pos);
                if (_createRow(this._dataModel, key, row, values, filteredValues)) {
                    this._index.insert(i, row);
                    this[_rows][row.__pos] = row;
                    return row;
                }
            }
            _create(key, values, committed, pos) {
                let filteredValues;
                let i = this._index.lowerKeyBound(key);
                if (i < this.values.length && (!this._index.compareKey(this.values[i], key))) {
                    return;
                }
                let row = this._createInternal(i, key, values, pos, filteredValues = {});
                return row && {
                    type: 1 /* DataEventType.create */,
                    row: row,
                    values: filteredValues,
                    committed: committed
                };
            }
            _modifyInternal(i, values, oldValues, filteredValues) {
                let ref = this.values[i];
                let pos = ref.__pos;
                let row = this[_rows][pos] || new ModifiedArray(pos, ref);
                if (_fillRow(this, row, values, oldValues, filteredValues)) {
                    this._index.modify(i, this[_rows][pos] = row);
                    return row;
                }
            }
            _modify(key, values, committed, oldValues) {
                let i = this._index.find(key);
                if (i === -1) {
                    return;
                }
                let filteredValues;
                let row = this._modifyInternal(i, values, oldValues, filteredValues = {});
                return row && {
                    type: 2 /* DataEventType.modify */,
                    row: row,
                    values: filteredValues,
                    committed: committed
                };
            }
            _deleteInternal(i) {
                let ref = this.values[i];
                this[_rows][ref.__pos] = void 0;
                this._index.delete_(i);
                return ref;
            }
            _delete(key) {
                let i = this._index.find(key);
                if (i === -1) {
                    return;
                }
                return {
                    type: 4 /* DataEventType.delete_ */,
                    row: this._deleteInternal(i),
                    committed: true
                };
            }
            _restoreRow(sample, reference) {
                let i = this._index.lowerBound(sample);
                if (reference) {
                    if ((i >= this._index.values.length) || this._index.compareRow(this._index.values[i], sample)) {
                        this._index.insert(i, reference);
                    }
                    else
                        this._index.modify(i, reference);
                }
                else if ((i < this._index.values.length) && !this._index.compareRow(this._index.values[i], sample)) {
                    this._index.delete_(i);
                }
                return i;
            }
            /** @internal */
            [_refreshRow](sample, committed, defaultEvent) {
                let e;
                let pos = sample.__pos;
                let modified = this[_rows].hasOwnProperty(pos);
                let reference = this._getReferenceRow(pos);
                let branch = this._branch;
                if (modified) {
                    let old = this[_rows][pos];
                    let values;
                    let info;
                    if (reference) {
                        let columns = this.columns;
                        values = {};
                        for (let s in this.columnIndex) {
                            if (columns[this.columnIndex[s]].name === s)
                                values[s] = reference[this.columnIndex[s]];
                        }
                    }
                    for (let j = 0; (j < this._dispatcher.dataEvents.length); ++j) {
                        info = this._dispatcher.dataEvents[j];
                        if ((info.branch === branch) && (info.row.__pos === pos)) {
                            if (info.type === 1 /* DataEventType.create */) {
                                values = $.extend({}, info.values);
                            }
                            else if ((info.type === 2 /* DataEventType.modify */) && values) {
                                $.extend(values, info.values);
                            }
                            else {
                                values = void 0;
                                break;
                            }
                        }
                    }
                    if (values) {
                        if (old) {
                            let filteredValues = {};
                            if (_fillRow(this, old, values, null, filteredValues)) {
                                e = {
                                    committed: committed,
                                    type: 2 /* DataEventType.modify */,
                                    row: old,
                                    values: filteredValues,
                                    branch: branch
                                };
                            }
                        }
                        else {
                            e = this._create(this.getKeyFromRow(sample), values, committed, pos);
                        }
                    }
                    else if (old) {
                        this._restoreRow(sample);
                        e = {
                            committed: true,
                            type: 4 /* DataEventType.delete_ */,
                            row: old,
                            branch: branch
                        };
                        defaultEvent ? this[_rows][pos] = void 0 : delete this[_rows][pos]; // delete modification if it's not a case of propagation (case of propagation = event from trunk -> branch)
                    }
                }
                else {
                    this._restoreRow(sample, reference);
                    e = defaultEvent;
                }
                return e;
            }
            _dropEvent(key, filter) {
                let h;
                if (filter && (filter.session !== void 0)) {
                    let session = this._map.get(filter.session);
                    if (session !== void 0) {
                        h = (info) => (info.session !== session);
                    }
                }
                else {
                    h = ( /*info: IDataEventInfo*/) => false;
                }
                return this[_dropInfo](key, h);
            }
            _refresh() {
                delete this._index;
                delete this[_rows];
                if (this._dataModel) {
                    this.fireEvent(1073741824 /* Tools.EventType.Attach */);
                }
            }
            _onAttach() {
                if (this._dataModel.values) {
                    this._index = this._createIndex();
                    this[_rows] = {};
                    this.fireEvent(6 /* Tools.EventType.Dirty */, new DataEventData(void 0, true));
                }
            }
            /** @internal */
            [_reset]() {
                throw new Error(); // not implemented !!!
            }
            getRow(pos) {
                return this[_rows].hasOwnProperty(pos) ? this[_rows][pos] : this._getReferenceRow(pos);
            }
            applySeeds(seeds, stamp, committed) {
                let events;
                let i = 0;
                let eventData;
                seeds.forEach(seed => {
                    let info, e;
                    switch (seed.type) {
                        case 1 /* DataEventType.create */:
                            info = this._create(seed.key, seed.values, committed);
                            break;
                        case 2 /* DataEventType.modify */:
                            info = this._modify(seed.key, seed.values, committed);
                            break;
                        case 4 /* DataEventType.delete_ */:
                            info = this._delete(seed.key);
                            break;
                        case 8 /* DataEventType.drop */:
                            e = this._dropEvent(seed.key, seed.filter);
                            break;
                    }
                    if (info) {
                        info.stamp = stamp;
                        info.branch = this._branch;
                        info.session = seed.session;
                        seed.info = info;
                        this._dispatcher.dataEvents.push(info);
                        e = info;
                    }
                    if (e) {
                        (events || (events = [])).push(e);
                        seeds[i++] = seed;
                    }
                });
                seeds.length = i;
                events && this.fireEvent(6 /* Tools.EventType.Dirty */, eventData = new DataEventData(events));
                return eventData;
            }
            set session(value) {
                let oldSession = this._session;
                if (oldSession) {
                    delete this._session;
                    this._map.remove(oldSession);
                    if (this._dataModel) {
                        this._dispatcher.dataEvents = this._dispatcher.dataEvents.filter(item => item.branch !== this._branch || !item.session || item.session === this._session);
                    }
                }
                if (value !== void 0) {
                    this._session = this._map.add(value);
                }
            }
            get session() {
                return this._session ? this._map.get(this._session) : void 0;
            }
            get columns() {
                return this._dataModel && this._dataModel.columns;
            }
            get primaryKey() {
                return this._dataModel && this._dataModel.primaryKey;
            }
            get values() {
                return this._index && this._index.values;
            }
            get columnIndex() {
                return this._dataModel && this._dataModel.columnIndex;
            }
            get type() {
                return 3 /* CreationType.embedded */;
            }
            getKeyFromRow(row) {
                return this._index && this._index.getKeyFromRow(row);
            }
            compareKey(row, key) {
                return this._index && this._index.compareKey(row, key);
            }
            compareRow(row0, row1) {
                return this._index && this._index.compareRow(row0, row1);
            }
            create(key, values) {
                this._dataModel && this._dispatcher.pushEvent({
                    type: 1 /* DataEventType.create */,
                    key: key,
                    values: values,
                    branch: this._branch,
                    session: this._session
                });
            }
            modify(key, values) {
                this._dataModel && this._dispatcher.pushEvent({
                    type: 2 /* DataEventType.modify */,
                    key: key,
                    values: values,
                    branch: this._branch,
                    session: this._session
                });
            }
            delete_(key) {
                this._dataModel && this._dispatcher.pushEvent({
                    type: 4 /* DataEventType.delete_ */,
                    key: key,
                    branch: this._branch,
                    session: this._session
                });
            }
            find(key) {
                return this._index.find(key);
            }
            indexOf(row) {
                return this._index.indexOf(row);
            }
            /** @internal */
            [_dropInfo](key, h) {
                let lastInfo;
                this._dispatcher.dataEvents = this._dispatcher.dataEvents.filter((info) => {
                    let b = true;
                    if ((info.branch === this._branch) && !this._index.compareKey(info.row, key)) {
                        (b = h(info)) || (lastInfo = info);
                    }
                    return b;
                });
                return lastInfo && this[_refreshRow](lastInfo.row, true);
            }
            dropEvents(key, filter) {
                this._dataModel && this._dispatcher.pushEvent({
                    type: 8 /* DataEventType.drop */,
                    key: key,
                    branch: this._branch,
                    session: this._session,
                    filter: filter
                });
            }
            reset(allSession) {
                this._dataModel && this._dispatcher.pushEvent({
                    type: 16 /* DataEventType.reset */,
                    branch: this._branch,
                    session: allSession ? void 0 : this._session
                });
            }
            toJSON() {
                return EmbeddedCreation.prototype.toJSON.call(this);
            }
            getVariations() {
                let row, reference, variations;
                for (let pos in this[_rows]) {
                    row = this[_rows][pos];
                    reference = this._getReferenceRow(parseInt(pos));
                    if ((!row !== !reference) ||
                        (row && this.columns.some((column, indice) => !AFC.Tools.Data.equalValue(column.type, row[indice], reference[indice])))) {
                        if (variations) {
                            variations.row.push(row);
                            variations.old.push(reference);
                        }
                        else {
                            variations = { row: [row], old: [reference] };
                        }
                    }
                }
                return variations;
            }
        }
        class Pool {
            constructor(map) {
                this._map = map;
                this.branches = [];
            }
            dispatchSeeds(branch, seeds, stamp, commit = false) {
                let event, committed = !commit;
                if (branch) {
                    let model = this.findBranch(branch);
                    model && (event = model.applySeeds(seeds, stamp, committed));
                }
                else {
                    event = this.trunk.applySeeds(seeds, stamp, committed);
                    event && event.items && this.branches.forEach(branch => branch[_refreshRows](event.items));
                }
                return event;
            }
            findBranch(b) {
                for (let branch of this.branches) {
                    if (BranchBaseEx.branchNb(branch) === b) {
                        return branch;
                    }
                }
            }
            attach(viewModel) {
                this.branches.push(viewModel);
            }
            detach(viewModel) {
                let i = this.branches.indexOf(viewModel);
                (i > -1) && this.branches.splice(i, 1);
            }
        }
        Data.Pool = Pool;
        class EventDispatcher extends AFC.Tools.EventSink {
            constructor(eventTarget, pool) {
                super(eventTarget);
                this.pool = pool;
                this.stamp = 0;
                this.dataEvents = [];
                this.on(5 /* Tools.EventType.Internal */, this._onEvents, this);
            }
            _filterResetEvents(seeds) {
                let resets = new Map, i = seeds.length, out = [], seed, branch, session, reset, fires;
                while (i--) {
                    seed = seeds[i];
                    if (seed.type !== 0 /* DataEventType.none */) {
                        branch = seed.branch;
                        session = seed.session || 0;
                        if (seed.type === 16 /* DataEventType.reset */) {
                            resets.has(branch) ? reset = resets.get(branch) : resets.set(branch, reset = {});
                            reset[session] = seed;
                        }
                        else if (!reset || !(reset[0] || reset[session])) {
                            out.push(seed);
                        }
                    }
                }
                resets.forEach((reset, branch) => {
                    let fire = false, session;
                    for (let key in reset) {
                        session = reset[key].session;
                        this.dataEvents = this.dataEvents.filter(dataEvent => dataEvent.branch !== branch || (session && (dataEvent.session !== session)) || (fire = true, false));
                    }
                    fire && (fires || (fires = [])).push(branch);
                });
                fires && fires.some(branch => {
                    let model = branch ? this.pool.findBranch(branch) : this.pool.trunk;
                    if (model) {
                        model[_reset]();
                        if (!branch) {
                            // trunk has been modified
                            this.pool.branches.forEach(model => model[_reset]());
                            return true;
                        }
                    }
                });
                return out.reverse();
            }
            _onEvents(e) {
                let stamp = this.stamp++;
                let seeds = e.data;
                let i;
                if (seeds && (i = seeds.length)) {
                    let filteredSeeds = this._filterResetEvents(seeds), seed, next, drop;
                    let pendings;
                    let committed = b => {
                        if (next) {
                            drop && (pendings || (pendings = [])).push(drop);
                            (next.type !== 0 /* DataEventType.none */) && (pendings || (pendings = [])).push(next);
                            if (b && pendings) {
                                this.pool.dispatchSeeds(next.branch, pendings, stamp);
                                pendings = void 0;
                            }
                        }
                    };
                    filteredSeeds.sort((a, b) => compareKey(a.key, b.key));
                    while (i--) {
                        seed = filteredSeeds[i];
                        if (!next || (next.branch !== seed.branch) || (next.session !== seed.session) || compareKey(next.key, seed.key)) {
                            committed(next && (next.branch !== seed.branch));
                            next = {
                                type: 0 /* DataEventType.none */,
                                key: seed.key,
                                branch: seed.branch,
                                session: seed.session
                            };
                            drop = void 0;
                        }
                        !drop && ((seed.type === 8 /* DataEventType.drop */) ? drop = seed : _mergeSeed(next, seed));
                    }
                    committed(true);
                }
            }
            pushEvent(e) {
                this.fireEvent(5 /* Tools.EventType.Internal */, [e]);
            }
        }
        Data.EventDispatcher = EventDispatcher;
        class DataModelRef extends DataModelBaseEx {
            constructor(columns, primaryKey, values) {
                values.forEach((row, i) => { row.__pos = i; });
                super(columns, values);
                this._primaryKey = primaryKey.map((item) => this.columnIndex[item]);
                this._cnt = 0;
            }
            get primaryKey() {
                let columns = this.columns;
                return this._primaryKey && this._primaryKey.map((i) => columns[i].name);
            }
            getKeyForContext(row) {
                return (this._primaryKey.length === 1) ? row[this._primaryKey[0]] : this._primaryKey.map(i => row[i]);
            }
            createContextInfo(row, old) {
                let indice, column;
                let values;
                let value;
                for (let name in this.columnIndex) {
                    indice = this.columnIndex[name];
                    column = this.columns[indice];
                    if (column && (column.index === -1) && !column.readOnly && column.name === name) {
                        value = row[indice];
                        if (old ? (value !== old[indice]) : (value !== void 0)) {
                            (values || (values = {}))[name] = value;
                        }
                    }
                }
                return values && { code: this.getKeyForContext(row), values: values };
            }
            createIndex() {
                return new Data.UniqueIndex(this._primaryKey, this.values);
            }
            getKeyFromRow(row) {
                return this._primaryKey.map((i) => row[i]);
            }
            create() {
                return --this._cnt;
            }
        }
        class TrunkModel extends BranchBaseEx {
            constructor(pool, map) {
                super(pool, map, 0);
            }
            _getReferenceRow(pos) {
                return this._dataModel.values[pos];
            }
            _createIndex() {
                return this._dataModel.createIndex();
            }
            get branch() {
                return;
            }
        }
        class BranchModel extends BranchBaseEx {
            constructor(pool, map, dataModel, dispatcher, branch) {
                super(pool, map, map.add(branch));
                super._init(dataModel, dispatcher);
                pool.attach(this);
            }
            _createIndex() {
                return BranchBaseEx.cloneIndex(this._pool.trunk);
            }
            _getReferenceRow(pos) {
                return this._pool.trunk.getRow(pos);
            }
            get branch() {
                return this._map.get(this._branch);
            }
            /** @internal */
            [_refreshRows](dataEvents) {
                let events2;
                dataEvents && dataEvents.forEach(dataEvent => {
                    let e2 = this[_refreshRow](dataEvent.row, dataEvent.committed, dataEvent);
                    e2 && (events2 || (events2 = [])).push(e2);
                });
                events2 && this.fireEvent(6 /* Tools.EventType.Dirty */, new DataEventData(events2));
                return events2;
            }
            release() {
                this._pool.detach(this);
            }
        }
        class DataRecordProvider extends AFC.Tools.AutoSubscribeForwarder {
            constructor(dataModel) {
                super();
                this._dataModel = dataModel;
                this._record = null;
                this._setForwards([{
                        type: 6 /* Tools.EventType.Dirty */,
                        observable: dataModel,
                        callback: this._onDirty
                    }]);
            }
            _onDirty(e) {
                let data = e.data, index, row;
                if (data && this._key && (index = this.index) && (data.reset || data.items.some(item => {
                    let b = index.compareKey(item.row, this._key) === 0;
                    b && (row = item.row);
                    return b;
                }))) {
                    row ? this._record = new Data.DataRecord(this._dataModel, row) : delete this._record;
                    this.fireEvent(6 /* Tools.EventType.Dirty */);
                }
            }
            get index() {
                let index = this._index;
                if (!index && this._key) {
                    this._index = index = this._dataModel instanceof BranchBaseEx ?
                        BranchBaseEx.getIndex(this._dataModel) :
                        new Data.UniqueIndex(this._dataModel.primaryKey.map((name) => AFC.Tools.indexOf(this._dataModel.columns, (column) => column.name === name)), this._dataModel.values);
                }
                return index;
            }
            set key(value) {
                if (compareKey(this._key || [], value || [])) {
                    delete this._record;
                    this._key = value;
                    this.fireEvent(6 /* Tools.EventType.Dirty */);
                }
            }
            getDataContainer() {
                let index;
                if ((index = this.index) && (this._record === void 0)) {
                    let i = this._index.find(this._key);
                    this._record = i === -1 ? null : new Data.DataRecord(this._dataModel, this._index.values[i]);
                }
                return Promise.resolve(this._record);
            }
        }
        Data.DataRecordProvider = DataRecordProvider;
        class HistorizedModelBase extends TrunkModel {
            constructor(pool, map) {
                super(pool, map);
                pool.trunk = this;
            }
            _getBranch(s) {
                return this.findBranch(s) || new BranchModel(this._pool, this._map, this._dataModel, this._dispatcher, s);
            }
            initFrom(columns, primaryKey, rows) {
                let dataModelRef = new DataModelRef(columns, primaryKey, rows), dispatcher = new EventDispatcher(dataModelRef, this._pool);
                super._init(dataModelRef, dispatcher);
            }
            ready() {
                return new Promise(resolve => BranchBaseEx._ready(this, resolve));
            }
            findBranch(s) {
                let b = this._map.get(s);
                return b && this._pool.findBranch(b);
            }
            getBranch(s) {
                let branch = this._getBranch(s);
                return new Promise(resolve => BranchBaseEx._ready(branch, () => resolve(branch)));
            }
            releaseBranch(s) {
                let branch = this.findBranch(s);
                branch && branch.release();
            }
            generateEvents(s) {
                //let branch: BranchModel = this.findBranch(s);
                let branch = s ? this.findBranch(s) : this;
                if (branch) {
                    let scn = branch.getVariations();
                    if (scn) {
                        let events = {};
                        scn.row.forEach((row, i) => {
                            let old = scn.old[i];
                            if (row) {
                                let info = this._dataModel.createContextInfo(row, old);
                                if (info) {
                                    if (old) {
                                        (events.modifications || (events.modifications = [])).push(info);
                                    }
                                    else {
                                        (events.creations || (events.creations = [])).push(info);
                                    }
                                }
                            }
                            else if (old) {
                                (events.deletions || (events.deletions = [])).push(this._dataModel.getKeyForContext(old));
                            }
                        });
                        return events;
                    }
                }
            }
            appendEvents(events, commit, branch, session) {
                if (events.fullDeletion) {
                    throw new Error();
                }
                else if (this._dataModel) {
                    let b = branch ? this._getBranch(branch) : this;
                    if (b) {
                        let converter = key => key instanceof Array ? key : [key];
                        let pendings;
                        let branchNb = BranchBaseEx.branchNb(b);
                        let sessionNb;
                        if (session) {
                            sessionNb = this._map.get(session);
                        }
                        events.creations && events.creations.forEach((o) => {
                            (pendings || (pendings = [])).push({
                                type: 1 /* DataEventType.create */,
                                key: converter(o.code),
                                branch: branchNb,
                                session: sessionNb,
                                values: o.values
                            });
                        });
                        events.modifications && events.modifications.forEach((o) => {
                            (pendings || (pendings = [])).push({
                                type: 2 /* DataEventType.modify */,
                                key: converter(o.code),
                                branch: branchNb,
                                session: sessionNb,
                                values: o.values
                            });
                        });
                        events.deletions && events.deletions.forEach((o) => {
                            (pendings || (pendings = [])).push({
                                type: 4 /* DataEventType.delete_ */,
                                key: converter(o),
                                branch: branchNb,
                                session: sessionNb,
                            });
                        });
                        if (pendings) {
                            let pool = this._pool;
                            let stamp = this._dispatcher.stamp++;
                            b.once(1073741824 /* Tools.EventType.Attach */, () => pool.dispatchSeeds(branchNb, pendings, stamp, commit), this, this);
                        }
                    }
                }
            }
        }
        function _compareFilter(filter0, filter1) {
            return (filter0 && filter0.session) === (filter1 && filter1.session);
        }
        function _exclude(content, values) {
            let v = {}, key;
            for (key in values) {
                let column = content.definition.columns.find(column => column.name === key);
                if (column && !column.readOnly) {
                    v[key] = values[key];
                }
            }
            return v;
        }
        function _isInteractive(result) {
            let status;
            return result.result || ((status = result.status) && (status.warnings?.length || status.errors?.length));
        }
        class CommitPool extends Pool {
            static _getKeyForContext(key) {
                return (key.length === 1) ? key[0] : key;
            }
            constructor(map, remote) {
                super(map);
                this.remote = remote;
            }
            _onCommand() {
                delete this._sequence;
                this._runCommand();
            }
            _updateRow(branch, info, modification) {
                $.extend(info.values, modification.values);
                info.committed = true;
                return branch[_refreshRow](info.row, true) || { row: info.row, type: 0 /* DataEventType.none */, committed: true };
            }
            async _onInteractive({ force }, pendings, results) {
                let retry, rollback;
                if (!force && results && this.remote?.confirmUpdate) {
                    for (let indice = 0, result; indice < results.length; ++indice) {
                        (_isInteractive(result = results[indice]) && await this.remote.confirmUpdate(result) ?
                            (retry || (retry = [])) :
                            (rollback || (rollback = [])))
                            .push(pendings[indice]);
                    }
                }
                else {
                    rollback = pendings;
                }
                rollback?.forEach(seeds => {
                    // roll back
                    let branchId = seeds[0].branch, branch = branchId ? this.findBranch(branchId) : this.trunk;
                    if (branch) {
                        seeds.sort((seed0, seed1) => compareKey(seed0.key, seed1.key));
                        for (let i = 0, j; i < seeds.length; i = j) {
                            let dataEvents, dataEvent, dataEventData, key = seeds[i].key;
                            for (j = i; j < seeds.length && !compareKey(key, seeds[j].key); ++j)
                                ;
                            dataEvent = branch[_dropInfo](key, (info) => {
                                for (let k = i; k < j; ++k) {
                                    if (info === seeds[k].info)
                                        return false;
                                }
                                return true;
                            }); // return true if kept
                            dataEvent && (dataEvents || (dataEvents = [])).push(dataEvent);
                            if (dataEvents) {
                                branch.fireEvent(6 /* Tools.EventType.Dirty */, dataEventData = (new DataEventData(dataEvents)));
                                branchId || this.branches.forEach(branch => branch[_refreshRows](dataEvents));
                            }
                        }
                    }
                });
                if (retry) {
                    // force update
                    let command = new CommitPool._UpdateCommand(this, this._onUpdate, retry.flat(), true);
                    this._sequence = command.run();
                }
            }
            _onUpdate(command, commandSeeds, results = []) {
                let pendings, remote = this.remote;
                commandSeeds.forEach((parameter, indice) => {
                    let result = results[indice];
                    let branch = parameter.branch ? this.findBranch(parameter.branch) : this.trunk;
                    let dataEvents;
                    if (branch) {
                        let check = (seeds, resultInfos = [], writer) => seeds?.forEach((seed, indice) => {
                            let result = resultInfos[indice];
                            result ?
                                writer?.(seed, result) :
                                ((pendings || (pendings = []))[indice] || (pendings[indice] = [])).push(seed);
                        }), writer = (seed, resultInfo) => {
                            let dataEvent = this._updateRow(branch, seed.info, resultInfo);
                            dataEvent && (dataEvents || (dataEvents = [])).push(dataEvent);
                        }, events = result?.events || {};
                        check(parameter.creations, events.creations, writer);
                        check(parameter.modifications, events.modifications, writer);
                        check(parameter.deletions, events.deletions);
                        if (dataEvents) {
                            let dataEventData = (new DataEventData(dataEvents));
                            branch.fireEvent(6 /* Tools.EventType.Dirty */, dataEventData);
                            parameter.branch || this.branches.forEach(branch => branch[_refreshRows](dataEvents));
                        }
                    }
                });
                remote?.onUpdate(results, command.force);
                pendings ?
                    this._onInteractive(command, pendings, results) : // async call
                    this._onCommand();
            }
            _runCommand() {
                if (this._pendings) {
                    let command;
                    let seed;
                    let i;
                    if (this._pendings[0].type === 8 /* DataEventType.drop */) {
                        let branch = this._pendings[0].branch;
                        let session = this._pendings[0].session;
                        let filter = this._pendings[0].filter;
                        for (i = 0; (i < this._pendings.length) && ((seed = this._pendings[i]).type === 8 /* DataEventType.drop */) && (seed.branch === branch) && (seed.session === session) && _compareFilter(seed.filter, filter); ++i)
                            ;
                        command = new CommitPool._DropCommand(this, this._onCommand, branch, session, filter, this._pendings.splice(0, i));
                    }
                    else {
                        for (i = 0; (i < this._pendings.length) && ((seed = this._pendings[i]).type & 0x7); ++i)
                            ;
                        command = new CommitPool._UpdateCommand(this, this._onUpdate, this._pendings.splice(0, i));
                    }
                    this._pendings.length || (delete this._pendings);
                    this._sequence = command.run();
                }
            }
            get commit() {
                return !!this.descriptor;
            }
            dispatchSeeds(branch, seeds, stamp, commit = this.commit) {
                let events = super.dispatchSeeds(branch, seeds, stamp, commit);
                if (commit && this.descriptor && events) {
                    seeds.sort((a, b) => (b.type - a.type) || (a.session - b.session)); // drops first (other type should be unaffected)
                    if (this._pendings)
                        this._pendings.concat(seeds);
                    else {
                        this._pendings = seeds;
                        this._runCommand();
                    }
                }
                return events;
            }
        }
        CommitPool._UpdateCommand = class _UpdateCommand {
            constructor(pool, callback, seeds, force) {
                this._pool = pool;
                this._callback = callback;
                this.seeds = seeds;
                this.force = force;
            }
            run() {
                let index;
                let iTable = 0;
                let commands = [];
                let commandSeeds = [];
                let parameters = [];
                let history = this._pool.content.history;
                for (let i = 0; i < this.seeds.length;) {
                    let seed = this.seeds[i];
                    let branch = seed.branch;
                    let session = seed.session;
                    let sessionString = this._pool._map.get(session);
                    let events = {};
                    let resource;
                    let command;
                    let parameter = {
                        branch: branch,
                        session: session
                    };
                    let seeds = {
                        branch: branch
                    };
                    do {
                        switch (seed.type) {
                            case 1 /* DataEventType.create */:
                                (events.creations || (events.creations = [])).push({ code: CommitPool._getKeyForContext(seed.key), values: _exclude(this._pool.content, seed.info.values) });
                                (parameter.creations || (seeds.creations = [], parameter.creations = [])).push(seed.info);
                                seeds.creations.push(seed);
                                break;
                            case 2 /* DataEventType.modify */:
                                (events.modifications || (events.modifications = [])).push({ code: CommitPool._getKeyForContext(seed.key), values: _exclude(this._pool.content, seed.info.values) });
                                (parameter.modifications || (seeds.modifications = [], parameter.modifications = [])).push(seed.info);
                                seeds.modifications.push(seed);
                                break;
                            case 4 /* DataEventType.delete_ */:
                                (events.deletions || (events.deletions = [])).push(CommitPool._getKeyForContext(seed.key));
                                (parameter.deletions || (seeds.deletions = [], parameter.deletions = [])).push(seed.info);
                                seeds.deletions.push(seed);
                                break;
                        }
                    } while ((++i < this.seeds.length) && ((seed = this.seeds[i]).branch === branch) && (seed.session === session));
                    if (!branch && history && (sessionString === history.session)) {
                        resource = this._pool.content.resource;
                    }
                    if (!resource) {
                        let key = `${branch}|${session}`;
                        let dataResource = (index || (index = {}))[key];
                        let resources = this._pool.resources;
                        let descriptor = this._pool.descriptor;
                        let name = AFC.Tools.Data.makeSQLName(descriptor.database.name, descriptor.name);
                        let localHistory = history ? {
                            stamp: history.stamp,
                            refreshStamp: history.refreshStamp
                        } : {};
                        session && (localHistory.session = sessionString);
                        (iTable < resources.length) ? dataResource = resources[iTable] : resources.push(dataResource = new AFC.Rest.DataResource());
                        ++iTable;
                        dataResource.create(this._pool.updates, new HistoryView(name, history, branch ? this._pool._map.get(branch) : void 0));
                        index[key] = dataResource;
                        resource = dataResource.id;
                    }
                    command = {
                        table: resource,
                        events: events
                    };
                    sessionString && (command.session = sessionString);
                    parameters.push(parameter);
                    commandSeeds.push(seeds);
                    commands.push(command);
                }
                return this._pool.updates.run(commands, this._callback.bind(this._pool, this, commandSeeds), this.force);
            }
        };
        CommitPool._DropCommand = class {
            constructor(pool, callback, branch, session, filter, seeds) {
                this._pool = pool;
                this._callback = callback;
                this._branch = branch;
                this._session = session;
                this._keys = seeds.map(seed => CommitPool._getKeyForContext(seed.key));
                this._filter = filter;
            }
            run() {
                let filter;
                let options;
                if (this._session) {
                    let session = this._pool._map.get(this._session);
                    options = { session: session };
                }
                this._branch && (filter = { branches: [this._pool._map.get(this._branch)] });
                if (this._filter) {
                    this._filter.session && ((filter || (filter = {})).session = this._filter.session);
                }
                filter && ((options || (options = {})).filter = filter);
                return this._pool.descriptor.rollbackEvents(this._keys, this._callback.bind(this._pool), options);
            }
        };
        function _clearColumn(branch, column, fire) {
            for (let key in branch[_rows]) {
                branch[_rows][key][column] = null;
            }
            fire && branch.fireEvent(6 /* Tools.EventType.Dirty */, new DataEventData(void 0, true));
        }
        class HistorizedModel extends HistorizedModelBase {
            constructor(remote) {
                let map = new DataModelMap();
                super(new CommitPool(map, remote), map);
            }
            initFrom(columns, primaryKey, rows, content) {
                let pool = this._pool;
                let descriptor = content?.descriptor;
                super.initFrom(columns, primaryKey, rows);
                delete pool.descriptor;
                if (descriptor && descriptor.isHistoricized) {
                    pool.descriptor = descriptor;
                    pool.content = content;
                    pool.updates = new Data.Updates(descriptor.database.schema.restModel);
                    pool.resources = [];
                }
            }
            /** @internal */
            /** Nullify all rows value for the specified columns without history */
            clearColumns(columns) {
                let fire = true;
                columns.forEach(column => {
                    let i = this.columnIndex[column.name];
                    if (i !== void 0) {
                        this._dataModel.values.forEach(row => row[i] = null);
                        _clearColumn(this, i, fire);
                        this._pool.branches.forEach((branch) => _clearColumn(branch, i, fire));
                        fire = false;
                    }
                });
            }
            /** @internal */
            /** Nullify all rows value for all branches for the specified columns without history and event emission */
            clearBranchesColumnsSilent(columns) {
                columns.forEach(column => {
                    let i = this.columnIndex[column.name];
                    if (i !== void 0) {
                        this._pool.branches.forEach((branch) => _clearColumn(branch, i));
                    }
                });
            }
            /** @internal */
            /** Apply values to the selected branch without history and event emission */
            applyValuesSilent(dataModel, columns, branch) {
                const branchBase = branch ? this.findBranch(branch) : this;
                if (branchBase && columns.length) {
                    dataModel.values.forEach(ref => {
                        const row = branchBase.values[branchBase.indexOf(ref)];
                        if (row) {
                            columns.forEach(column => {
                                let i = branchBase.columnIndex[column.name];
                                if (i !== void 0) {
                                    row[i] = ref[dataModel.columnIndex[column.name]];
                                }
                            });
                        }
                    });
                }
            }
        }
        Data.HistorizedModel = HistorizedModel;
    })(Data = AFC.Data || (AFC.Data = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 19/05/2016.
 */
///<reference path="Global.ts" />
///<reference path="Data.ts" />
///<reference path="../rest/RestModel.ts" />
var AFC;
(function (AFC) {
    var Data;
    (function (Data) {
        let DBOpenStatus;
        (function (DBOpenStatus) {
            DBOpenStatus[DBOpenStatus["open"] = 0] = "open";
            DBOpenStatus[DBOpenStatus["failed"] = 1] = "failed";
            DBOpenStatus[DBOpenStatus["closed"] = 2] = "closed";
        })(DBOpenStatus = Data.DBOpenStatus || (Data.DBOpenStatus = {}));
        let HistoryEventType;
        (function (HistoryEventType) {
            HistoryEventType[HistoryEventType["none"] = 0] = "none";
            HistoryEventType[HistoryEventType["backup"] = 1] = "backup";
            HistoryEventType[HistoryEventType["creation"] = 2] = "creation";
            HistoryEventType[HistoryEventType["modification"] = 3] = "modification";
            HistoryEventType[HistoryEventType["deletion"] = 4] = "deletion";
            HistoryEventType[HistoryEventType["cancel"] = 5] = "cancel";
        })(HistoryEventType = Data.HistoryEventType || (Data.HistoryEventType = {}));
        let HistoryBranchStatus;
        (function (HistoryBranchStatus) {
            HistoryBranchStatus[HistoryBranchStatus["none"] = 0] = "none";
            HistoryBranchStatus[HistoryBranchStatus["archive"] = 1] = "archive";
            HistoryBranchStatus[HistoryBranchStatus["remove"] = 2] = "remove";
        })(HistoryBranchStatus = Data.HistoryBranchStatus || (Data.HistoryBranchStatus = {}));
        let QualifierLookup;
        (function (QualifierLookup) {
            QualifierLookup[QualifierLookup["identifier"] = 1 /* Qualifier.identifier */] = "identifier";
            QualifierLookup[QualifierLookup["mainAddress"] = 2] = "mainAddress";
            QualifierLookup[QualifierLookup["address"] = 3] = "address";
            QualifierLookup[QualifierLookup["zipCode"] = 4] = "zipCode";
            QualifierLookup[QualifierLookup["city"] = 5] = "city";
            QualifierLookup[QualifierLookup["country"] = 6] = "country";
            QualifierLookup[QualifierLookup["totalSurface"] = 7] = "totalSurface";
            QualifierLookup[QualifierLookup["surface"] = 8] = "surface";
            QualifierLookup[QualifierLookup["symbol"] = 9] = "symbol";
            QualifierLookup[QualifierLookup["brand"] = 10] = "brand";
            QualifierLookup[QualifierLookup["businessCode"] = 11] = "businessCode";
            QualifierLookup[QualifierLookup["revenue"] = 12] = "revenue";
            QualifierLookup[QualifierLookup["changes"] = 13] = "changes";
        })(QualifierLookup || (QualifierLookup = {}));
        function qualifier(value) {
            return QualifierLookup[value];
        }
        Data.qualifier = qualifier;
        class DBColumnDefinition extends Data.DBColumn {
            constructor(name, type, index, size, alias, readOnly, qualifiers, geographicalLevel, isSearchable) {
                super(name, type, index, size, alias, readOnly);
                qualifiers && (this.qualifiers = qualifiers);
                geographicalLevel && (this.geographicalLevel = geographicalLevel);
                isSearchable && (this.isSearchable = isSearchable);
            }
        }
        Data.DBColumnDefinition = DBColumnDefinition;
        let DataKindLookup;
        (function (DataKindLookup) {
            DataKindLookup[DataKindLookup["asteropDataKindUnknown"] = 0] = "asteropDataKindUnknown";
            DataKindLookup[DataKindLookup["asteropDataKindCharacter"] = 1] = "asteropDataKindCharacter";
            DataKindLookup[DataKindLookup["asteropDataKindReal"] = 2] = "asteropDataKindReal";
            DataKindLookup[DataKindLookup["asteropDataKindInteger"] = 3] = "asteropDataKindInteger";
            DataKindLookup[DataKindLookup["asteropDataKindBool"] = 4] = "asteropDataKindBool";
            DataKindLookup[DataKindLookup["asteropDataKindDate"] = 5] = "asteropDataKindDate";
            DataKindLookup[DataKindLookup["asteropDataKindTime"] = 6] = "asteropDataKindTime";
            DataKindLookup[DataKindLookup["asteropDataKindTimestamp"] = 7] = "asteropDataKindTimestamp";
            DataKindLookup[DataKindLookup["asteropDataKindCurrency"] = 8] = "asteropDataKindCurrency";
            DataKindLookup[DataKindLookup["asteropDataKindBlob"] = 9] = "asteropDataKindBlob";
            DataKindLookup[DataKindLookup["asteropDataKindDynamic"] = 10] = "asteropDataKindDynamic";
            DataKindLookup[DataKindLookup["asteropDataKindFormula"] = 11] = "asteropDataKindFormula";
            DataKindLookup[DataKindLookup["asteropDataKindPoint"] = 1048576] = "asteropDataKindPoint";
            DataKindLookup[DataKindLookup["asteropDataKindLine"] = 2097152] = "asteropDataKindLine";
            DataKindLookup[DataKindLookup["asteropDataKindPoly"] = 4194304] = "asteropDataKindPoly";
            DataKindLookup[DataKindLookup["asteropDataKindGeometry"] = 7340032] = "asteropDataKindGeometry";
            DataKindLookup[DataKindLookup["asteropDataKindRect"] = 12] = "asteropDataKindRect";
        })(DataKindLookup || (DataKindLookup = {}));
        function dataKind(value) {
            return DataKindLookup[value];
        }
        Data.dataKind = dataKind;
        const _tableTypeLookup = {
            TABLETYPE_UNDEF: 0 /* TableType.undef */,
            TABLETYPE_TABLE: 1 /* TableType.table */,
            TABLETYPE_VIEW: 2 /* TableType.view */,
            TABLETYPE_QUERY: 3 /* TableType.query */,
            TABLETYPE_COMPOUND: 4 /* TableType.compound */,
            TABLETYPE_CUBEVIEW: 5 /* TableType.cubeView */,
            TABLETYPE_MEMORY: 6 /* TableType.memory */,
            TABLETYPE_FILTER: 7 /* TableType.filter */,
            TABLETYPE_SEAMLESS: 8 /* TableType.seamless */,
            TABLETYPE_HISTORY: 9 /* TableType.history */,
            TABLETYPE_SYNONYM: 10 /* TableType.synonym */
        };
        class TableDescriptor extends AFC.Tools.EventSink {
            constructor(d, i) {
                super();
                this.database = d;
                this.name = i.name;
                this.alias = i.alias;
                this.type = _tableTypeLookup[i.type];
                i.interactiveMode && (this.interactiveMode = true);
            }
            get id() {
                return this.name;
            }
            get fullName() {
                return `[${this.database.name}].[${this.name}]`;
            }
            get isHistoricized() {
                return false;
            }
            invalidate() {
                delete this._sequence;
                delete this._definition;
                this.fireEvent(6 /* Tools.EventType.Dirty */);
            }
            createAjaxRequest(path = '', bypassContext, options) {
                return this.database.createAjaxRequest(`/${this.name}${path}`, bypassContext, options);
            }
            _onRestAlways(sequence, jqXHR, textStatus) {
                let data = jqXHR.responseJSON;
                if (this._sequence === sequence) {
                    if (data) {
                        let definition = this._definition = {
                            columns: data.columns.map(column => new DBColumnDefinition(column.name, dataKind(column.type), data.primaryKey ? data.primaryKey.indexOf(column.name) : -1, column.size, column.alias, column.isPseudoColumn, column.qualifiers && column.qualifiers.map(value => (qualifier(value))), column.geographicalLevel, column.isSearchable))
                        };
                        data.primaryKey && (definition.primaryKey = data.primaryKey);
                        (data.stamp !== void 0) && (definition.stamp = data.stamp);
                        (data.refreshStamp !== void 0) && (definition.refreshStamp = data.refreshStamp);
                    }
                    else
                        delete this._sequence;
                    this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                }
            }
            getDefinition() {
                return this._definition ? Promise.resolve(this._definition) : new Promise(resolve => {
                    this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this._definition));
                    if (!this._sequence) {
                        let request = this.createAjaxRequest();
                        request.options.always = this._onRestAlways.bind(this);
                        this._sequence = request.call();
                    }
                });
            }
        }
        Data.TableDescriptor = TableDescriptor;
        let HistoryEventTypeLookup = {
            none: 0 /* HistoryEventType.none */,
            backup: 1 /* HistoryEventType.backup */,
            creation: 2 /* HistoryEventType.creation */,
            modification: 3 /* HistoryEventType.modification */,
            deletion: 4 /* HistoryEventType.deletion */,
            cancel: 5 /* HistoryEventType.cancel */
        };
        function _fetchEvent(event) {
            event.eventDate = new Date(event.eventDate);
            event.dateOfEffect = new Date(event.dateOfEffect);
            event.type = HistoryEventTypeLookup[event.type];
            return event;
        }
        let HistoryBranchStatusLookup;
        (function (HistoryBranchStatusLookup) {
            HistoryBranchStatusLookup[HistoryBranchStatusLookup["none"] = 0] = "none";
            HistoryBranchStatusLookup[HistoryBranchStatusLookup["archive"] = 1] = "archive";
            HistoryBranchStatusLookup[HistoryBranchStatusLookup["remove"] = 2] = "remove";
        })(HistoryBranchStatusLookup || (HistoryBranchStatusLookup = {}));
        function historyBranchStatus(value) {
            return HistoryBranchStatusLookup[value];
        }
        Data.historyBranchStatus = historyBranchStatus;
        function _fetchBranch(branch) {
            branch.creationDate = new Date(branch.creationDate);
            branch.status = historyBranchStatus(branch.status);
            branch.events && branch.events.forEach(_fetchEvent);
            return branch;
        }
        class HistoricizedTableDescriptor extends TableDescriptor {
            get isHistoricized() {
                return true;
            }
            requestStamps(callback) {
                let onAlways;
                if (this._definition) {
                    onAlways = (sequence, jqXHR, textStatus) => {
                        let data = jqXHR.responseJSON || {};
                        callback(data.stamp, data.refreshStamp, sequence);
                    };
                }
                else {
                    this.notify(65536 /* Tools.EventType.UserEvent */, () => callback(this._definition && this._definition.stamp, this._definition && this._definition.refreshStamp, this._sequence));
                    this._sequence || (onAlways = this._onRestAlways.bind(this));
                }
                if (onAlways) {
                    let request = this.createAjaxRequest();
                    request.options.always = onAlways;
                    this._sequence = request.call();
                }
                return this._sequence;
            }
            _doSingleOperation(operation) {
                return new Promise((resolve, reject) => {
                    let request = this.createAjaxRequest('/branches');
                    request.options.always = (sequence, jqXHR, textStatus) => {
                        let data = jqXHR.responseJSON;
                        data instanceof Array && data.length ? resolve(_fetchBranch(data[0])) : reject();
                    };
                    request.options.data.operation = operation;
                    request.call();
                });
            }
            insertBranch(options) {
                let operation = {
                    type: "insert"
                };
                if (options) {
                    options.properties == null || (operation.properties = options.properties);
                    options.description == null || (operation.description = options.description);
                    options.rating == null || (operation.rating = options.rating);
                    options.status && (operation.status = historyBranchStatus(options.status));
                }
                return this._doSingleOperation(operation);
            }
            deleteBranch(name) {
                let operation = { type: "delete", name: name };
                return this._doSingleOperation(operation);
            }
            updateBranch(name, { properties, description, rating, status }) {
                let operation = {
                    type: "update",
                    name: name
                };
                properties === void 0 || (operation.properties = properties);
                description === void 0 || (operation.description = description);
                rating === void 0 || (operation.rating = rating);
                status === void 0 || (operation.status = historyBranchStatus(status));
                return this._doSingleOperation(operation);
            }
            selectBranches(options) {
                return new Promise((resolve, reject) => {
                    let request = this.createAjaxRequest('/branches');
                    request.options.always = (sequence, jqXHR, textStatus) => {
                        let data = jqXHR.responseJSON;
                        data instanceof Array ? (data.forEach(_fetchBranch), resolve(data)) : reject();
                    };
                    let data = request.options.data;
                    data.operation = { type: "select" };
                    if (options) {
                        (options.filter !== void 0) && (data.operation.filter = options.filter);
                        (options.dataSelector !== void 0) && (data.operation.dataSelector = options.dataSelector);
                    }
                    request.call();
                });
            }
            getBranchInfo(id, history) {
                return new Promise((resolve, reject) => {
                    let request = this.createAjaxRequest(`/branches/${id}`);
                    request.options.always = (sequence, jqXHR, textStatus) => {
                        let data = jqXHR.responseJSON;
                        data ? resolve(_fetchBranch(data)) : reject();
                    };
                    Data.isValidHistory(history) && (request.options.data.history = history);
                    request.call();
                });
            }
            rollbackEvents(codes, callback, options) {
                if (codes.length > 0) {
                    let request = this.createAjaxRequest('/events'), data = request.options.data;
                    request.options.always = (sequence, jqXHR, textStatus) => {
                        let data = jqXHR.responseJSON;
                        let v;
                        if (data instanceof Array) {
                            data.forEach(_fetchEvent);
                            v = data;
                        }
                        callback(v);
                    };
                    data.operation = { type: "rollback", codes: codes };
                    if (options) {
                        options.session && (data.operation.session = options.session);
                        (options.filter !== void 0) && (data.operation.filter = options.filter);
                    }
                    return request.call();
                }
            }
        }
        Data.HistoricizedTableDescriptor = HistoricizedTableDescriptor;
        let DBOpenStatusLookup = {
            open: 0 /* DBOpenStatus.open */,
            failed: 1 /* DBOpenStatus.failed */,
            closed: 2 /* DBOpenStatus.closed */
        };
        class DatabaseDescriptor extends AFC.Tools.EventSink {
            constructor(schema, database) {
                super();
                this.schema = schema;
                this.id = database.id;
                this.name = database.name;
                this.status = DBOpenStatusLookup[database.status];
                (database.error !== void 0) && (this.error = database.error);
                this.readOnly = !!database.readOnly;
                this.noCache = !!database.noCache;
            }
            invalidate() {
                let tables = this._tables;
                this.fireEvent(6 /* Tools.EventType.Dirty */);
                if (tables) {
                    delete this._tables;
                    delete this._sequence;
                    tables.forEach((item) => { item.invalidate(); });
                }
            }
            createAjaxRequest(path = '', bypassContext, options) {
                return this.schema.createAjaxRequest(`/${this.id}${path}`, bypassContext, options);
            }
            _onRestAlways(sequence, jqXHR, textStatus) {
                let data = this._sequence === sequence && jqXHR.responseJSON;
                this._tables = data && (data instanceof Array) ? data.map(item => item.isHistorized ? new HistoricizedTableDescriptor(this, item) : new TableDescriptor(this, item)) : null;
                this.fireEvent(65536 /* Tools.EventType.UserEvent */);
            }
            getTables() {
                return new Promise((resolve, reject) => {
                    let sequence = this._sequence, h = () => sequence === this._sequence && this._tables ? resolve(this._tables) : reject();
                    if (this._tables !== void 0) {
                        h();
                    }
                    else {
                        this.notify(65536 /* Tools.EventType.UserEvent */, h);
                        if (!sequence) {
                            let request = this.createAjaxRequest();
                            request.options.always = this._onRestAlways.bind(this);
                            this._sequence = sequence = request.call();
                        }
                    }
                });
            }
            getInfo() {
                return new Promise(resolve => {
                    let request = this.createAjaxRequest();
                    request.options.data.operation = { type: 'info' };
                    request.options.always = (sequence, jqXHR, textStatus) => {
                        let database = jqXHR.responseJSON;
                        resolve(database);
                    };
                    request.call();
                });
            }
            refresh() {
                delete this._sequence;
                delete this._tables;
            }
        }
        Data.DatabaseDescriptor = DatabaseDescriptor;
        class SchemaDescriptor extends AFC.Tools.EventSink {
            constructor(restModel) {
                super();
                this.restModel = restModel;
            }
            invalidate() {
                let databases = this._databases;
                this.fireEvent(6 /* Tools.EventType.Dirty */);
                if (databases) {
                    delete this._databases;
                    delete this._sequence;
                    databases.forEach((item) => { item.invalidate(); });
                }
            }
            createAjaxRequest(path = '', bypassContext, options) {
                return this.restModel.createAjaxRequest(`/databases/schema${path}`, bypassContext, options);
            }
            _onRestAlways(sequence, jqXHR, textStatus) {
                let data = jqXHR.responseJSON;
                if (this._sequence === sequence) {
                    this._databases = data && (data instanceof Array) ? data.map((item) => new DatabaseDescriptor(this, item)) : [];
                    this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                }
            }
            getDatabases() {
                return this._databases ? Promise.resolve(this._databases) : new Promise(resolve => {
                    this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this._databases));
                    if (!this._sequence) {
                        let request = this.createAjaxRequest();
                        request.options.always = this._onRestAlways.bind(this);
                        this._sequence = request.call();
                    }
                });
            }
        }
        Data.SchemaDescriptor = SchemaDescriptor;
        function getDatabase(schema, dbName) {
            return schema.getDatabases().then((databases) => AFC.Tools.findByIdOrName(dbName, databases));
        }
        Data.getDatabase = getDatabase;
        async function getTable(schema, dbName, tableName) {
            let database = await getDatabase(schema, dbName), tables;
            if (database && (tables = await database.getTables())) {
                return tables.find(table => tableName === table.name || tableName === table.alias);
            }
        }
        Data.getTable = getTable;
    })(Data = AFC.Data || (AFC.Data = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 10/03/2016.
 */
///<reference types="leaflet" />
var AFC;
(function (AFC) {
    var Globals;
    (function (Globals) {
        let LayerType;
        (function (LayerType) {
            LayerType[LayerType["raster"] = -1] = "raster";
            LayerType[LayerType["unknown"] = 0] = "unknown";
            LayerType[LayerType["polygon"] = 1] = "polygon";
            LayerType[LayerType["line"] = 2] = "line";
            LayerType[LayerType["symbol"] = 3] = "symbol";
            LayerType[LayerType["pie"] = 4] = "pie";
            LayerType[LayerType["label"] = 5] = "label";
            LayerType[LayerType["olap"] = 100] = "olap";
            LayerType[LayerType["mxd"] = 200] = "mxd";
        })(LayerType = Globals.LayerType || (Globals.LayerType = {}));
        ;
        ;
        ;
        ;
        let LegendType;
        (function (LegendType) {
            LegendType[LegendType["fillColor"] = 0] = "fillColor";
            LegendType[LegendType["size"] = 1] = "size";
            LegendType[LegendType["icon"] = 2] = "icon";
        })(LegendType = Globals.LegendType || (Globals.LegendType = {}));
        let ProgressStatus;
        (function (ProgressStatus) {
            ProgressStatus[ProgressStatus["unknown"] = 0] = "unknown";
            ProgressStatus[ProgressStatus["notStarted"] = 1] = "notStarted";
            ProgressStatus[ProgressStatus["inProgress"] = 2] = "inProgress";
            ProgressStatus[ProgressStatus["completed"] = 3] = "completed";
            ProgressStatus[ProgressStatus["registered"] = 4] = "registered";
        })(ProgressStatus = Globals.ProgressStatus || (Globals.ProgressStatus = {}));
        const ProgressStatusLookup = {
            asteropTaskUnknown: 0 /* ProgressStatus.unknown */,
            asteropTaskNotStarted: 1 /* ProgressStatus.notStarted */,
            asteropTaskInProgress: 2 /* ProgressStatus.inProgress */,
            asteropTaskCompleted: 3 /* ProgressStatus.completed */,
            asteropTaskRegistered: 4 /* ProgressStatus.registered */,
        };
        function progressStatus(value) {
            return ProgressStatusLookup[value];
        }
        Globals.progressStatus = progressStatus;
    })(Globals = AFC.Globals || (AFC.Globals = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 29/09/2015.
 */
///<reference path="RequestBuilder.ts" />
///<reference path="AuthorizationPolicy.ts" />
///<reference path="../data/Schema.ts" />
///<reference path="../globals/Global.ts" />
var AFC;
(function (AFC) {
    let Rest;
    (function (Rest) {
        var _a;
        let RestFormat;
        (function (RestFormat) {
            RestFormat[RestFormat["json"] = 1] = "json";
            RestFormat[RestFormat["pdf"] = 2] = "pdf";
            RestFormat[RestFormat["xml"] = 3] = "xml";
            RestFormat[RestFormat["googleservice"] = 4] = "googleservice";
            RestFormat[RestFormat["geojson"] = 5] = "geojson";
            RestFormat[RestFormat["pptx"] = 6] = "pptx";
            RestFormat[RestFormat["jpeg"] = 7] = "jpeg";
            RestFormat[RestFormat["png4"] = 8] = "png4";
            RestFormat[RestFormat["png8"] = 9] = "png8";
            RestFormat[RestFormat["png24"] = 10] = "png24";
            RestFormat[RestFormat["png32"] = 11] = "png32";
            RestFormat[RestFormat["gif"] = 12] = "gif";
            RestFormat[RestFormat["bmp"] = 13] = "bmp";
            RestFormat[RestFormat["tiff"] = 14] = "tiff";
            RestFormat[RestFormat["xlsx"] = 15] = "xlsx";
            RestFormat[RestFormat["csv"] = 16] = "csv";
            RestFormat[RestFormat["native"] = 17] = "native";
        })(RestFormat = Rest.RestFormat || (Rest.RestFormat = {}));
        let RestMethod;
        (function (RestMethod) {
            RestMethod["POST"] = "POST";
            RestMethod["GET"] = "GET";
        })(RestMethod = Rest.RestMethod || (Rest.RestMethod = {}));
        let MimeType;
        (function (MimeType) {
            MimeType["xlsx"] = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
        })(MimeType = Rest.MimeType || (Rest.MimeType = {}));
        let LogAction;
        (function (LogAction) {
            LogAction[LogAction["authenticate"] = 0] = "authenticate";
            LogAction[LogAction["reset"] = 1] = "reset";
            LogAction[LogAction["forgotten"] = 2] = "forgotten";
            LogAction[LogAction["logout"] = 3] = "logout";
            LogAction[LogAction["openIdInvalidJWT"] = 1000] = "openIdInvalidJWT";
            LogAction[LogAction["openIdCheckFailed"] = 1001] = "openIdCheckFailed";
            LogAction[LogAction["openIdUnknownUser"] = 1002] = "openIdUnknownUser";
            LogAction[LogAction["reportGeneration"] = 10000] = "reportGeneration";
            LogAction[LogAction["user"] = 20000] = "user";
        })(LogAction = Rest.LogAction || (Rest.LogAction = {}));
        const RestFormatLookUp = {
            [1 /* RestFormat.json */]: "json",
            [2 /* RestFormat.pdf */]: "pdf",
            [3 /* RestFormat.xml */]: "xml",
            [4 /* RestFormat.googleservice */]: "googleservice",
            [5 /* RestFormat.geojson */]: "geojson",
            [6 /* RestFormat.pptx */]: "pptx",
            [7 /* RestFormat.jpeg */]: "jpeg",
            [8 /* RestFormat.png4 */]: "png4",
            [9 /* RestFormat.png8 */]: "png8",
            [10 /* RestFormat.png24 */]: "png24",
            [11 /* RestFormat.png32 */]: "png32",
            [12 /* RestFormat.gif */]: "gif",
            [13 /* RestFormat.bmp */]: "bmp",
            [14 /* RestFormat.tiff */]: "tiff",
            [15 /* RestFormat.xlsx */]: "xlsx",
            [16 /* RestFormat.csv */]: "csv",
            [17 /* RestFormat.native */]: "native",
        };
        class NetworkStatus {
            constructor(request, jqXHR, textStatus, errorThrown) {
                this.request = request;
                this.jqXHR = jqXHR;
                this.textStatus = textStatus;
                errorThrown && (this.errorThrown = errorThrown);
            }
        }
        Rest.NetworkStatus = NetworkStatus;
        function toUTF8Array(str) {
            var utf8 = new Uint8Array(str.length * 4);
            for (var i = 0, j = 0; i < str.length; i++) {
                var charcode = str.charCodeAt(i);
                if (charcode < 0x80)
                    utf8[j++] = charcode;
                else if (charcode < 0x800) {
                    utf8[j++] = 0xc0 | (charcode >> 6);
                    utf8[j++] = 0x80 | (charcode & 0x3f);
                }
                else if (charcode < 0xd800 || charcode >= 0xe000) {
                    utf8[j++] = 0xe0 | (charcode >> 12);
                    utf8[j++] = 0x80 | ((charcode >> 6) & 0x3f);
                    utf8[j++] = 0x80 | (charcode & 0x3f);
                }
                // surrogate pair
                else {
                    i++;
                    // UTF-16 encodes 0x10000-0x10FFFF by
                    // subtracting 0x10000 and splitting the
                    // 20 bits of 0x0-0xFFFFF into two halves
                    charcode = 0x10000 + (((charcode & 0x3ff) << 10)
                        | (str.charCodeAt(i) & 0x3ff));
                    utf8[j++] = 0xf0 | (charcode >> 18);
                    utf8[j++] = 0x80 | ((charcode >> 12) & 0x3f);
                    utf8[j++] = 0x80 | ((charcode >> 6) & 0x3f);
                    utf8[j++] = 0x80 | (charcode & 0x3f);
                }
            }
            return utf8.slice(0, j);
        }
        const LocaleLookup = {
            [1 /* Tools.Lang.Locale.fr */]: 'fr',
            [2 /* Tools.Lang.Locale.us */]: 'us',
            [3 /* Tools.Lang.Locale.en */]: 'en'
        };
        function _append(body, value) {
            return body ? `${body}&${value}` : value;
        }
        function _getAjaxBody(options, identity, progessId) {
            let data = Object.create(options.data || {}), body;
            if (!options?.skipDefaultParameters) {
                data.f = RestFormatLookUp[options.format] || 'json';
                options.locale && (data.lang = LocaleLookup[options.locale]);
                options.encoding && (data.encoding = options.encoding);
                progessId && (data.tid = progessId);
            }
            for (let i in data) {
                let val = data[i];
                if (val !== void 0) {
                    if (typeof val !== 'string')
                        val = JSON.stringify(val);
                    body = _append(body, `${i}=${encodeURIComponent(val)}`);
                }
            }
            return _append(body, identity.getAjaxBody());
        }
        function getServiceUrl(directory, baseUrl) {
            let uri = (directory[0] != '/') ? '/' : '';
            return `${(baseUrl || (window.location.protocol + '//' + window.location.host))}/asterop/rest${uri}${directory}`;
        }
        Rest.getServiceUrl = getServiceUrl;
        const _sequence = Symbol();
        class RestModel extends Rest.RequestBuilder {
            constructor(identity, url) {
                super();
                /** @internal */
                this[_a] = 0;
                this._pending = 0;
                this._zip = false;
                this.identity = identity;
                this.baseUrl = url;
                this.globals = new AFC.Globals.GlobalsDescriptor(this);
                this.dashboardsDescriptor = new AFC.Dashboards.DashboardsDescriptor(this);
            }
            get pending() {
                return this._pending;
            }
            get schema() {
                return this._schema || (this._schema = new AFC.Data.SchemaDescriptor(this));
            }
            set enableCompression(b) {
                this._zip = b;
            }
            set locale(locale) {
                this._locale = locale;
            }
            static createEntry(o, key) {
                return o[key] || (o[key] = {});
            }
            getVersion() {
                return new Promise(resolve => {
                    let request = this.createAjaxRequest('/version');
                    request.options.always = (sequence, jqXHR, textStatus) => {
                        let version = jqXHR.responseJSON;
                        version && (version.toString = function () {
                            return `${version.majorVersion}.${version.minorVersion}.${version.majorBuildNumber}.${("0" + version.minorBuildNumber).slice(-2)}`;
                        });
                        version.neighborhoodMatrices.forEach(matrix => { matrix.creationDate = new Date(matrix.creationDate); });
                        resolve(version);
                    };
                    request.call();
                });
            }
            _onRequestBegin(request) {
                ++this._pending;
                this.fireEvent(2 /* Tools.EventType.NetworkBegin */, [request]);
            }
            _onRequestComplete(request, jqXHR, textStatus) {
                --this._pending;
                this.fireEvent(3 /* Tools.EventType.NetworkComplete */, [new NetworkStatus(request, jqXHR, textStatus)]);
                request.options.always && request.options.always(request.sequence, jqXHR, textStatus);
            }
            _onRequestError(request, jqXHR, textStatus, errorThrown) {
                this.fireEvent(1 /* Tools.EventType.NetworkError */, [new NetworkStatus(request, jqXHR, textStatus, errorThrown)]);
                request.options.fail && request.options.fail(request.sequence, jqXHR, textStatus, errorThrown);
            }
            _onIdentityError(identity) {
                this.fireEvent(4 /* Tools.EventType.IdentityError */, [{ identity: identity }]);
            }
            createAjaxRequest(path = '', bypassContext = true, options) {
                let data = options?.data || {}, ajaxOptions = {
                    locale: options?.locale || this._locale,
                    data: data
                }, builder, modifierOptions, useProgressInfo, baseURL = this.baseUrl;
                if (options) {
                    ajaxOptions.format = options.format;
                    builder = options.builder;
                    modifierOptions = options.modifierOptions;
                    if (options.baseURL)
                        baseURL = options.baseURL;
                    useProgressInfo = options.useProgressInfo;
                }
                bypassContext || (builder || this).updateBody(data, modifierOptions);
                return new RestModel.AjaxRequest(this, ++this[_sequence], `${baseURL}${path}`, ajaxOptions, useProgressInfo, this._zip);
            }
            log(action, comment) {
                let data = this.identity.getCredentials();
                data.action = action;
                data.comment = comment;
                jQuery.ajax({
                    url: `${this.baseUrl}/log`,
                    method: 'POST',
                    processData: false,
                    async: true,
                    data: `content=${JSON.stringify(data)}`
                });
            }
        }
        _a = _sequence;
        RestModel.AjaxRequest = class {
            constructor(restModel, sequence, uri, options, useProgressInfo, enableCompression) {
                this.restModel = restModel;
                this.sequence = sequence;
                this.uri = uri;
                this.options = options;
                useProgressInfo && (this.progressId = AFC.Tools.Data.generateRndString(10));
                this.enableCompression = enableCompression;
                this._cnt = 0;
            }
            _call(identity, settings, enableCompression) {
                if (identity?.isAuthenticated) {
                    let body = _getAjaxBody(this.options, identity, this.progressId);
                    if (enableCompression) {
                        let gzip = new Zlib.Gzip(toUTF8Array(body));
                        body = new Blob([gzip.compress()], { type: "application/octet-binary" });
                    }
                    settings.data = body;
                    $.ajax(settings);
                }
            }
            getBody() {
                let identity = this.restModel.identity;
                return identity.isAuthenticated && _getAjaxBody(this.options, identity, this.progressId);
            }
            call() {
                let options = this.options, enableCompression = this.enableCompression, settings = {
                    url: this.uri,
                    method: options.method || 'POST',
                    async: options.async || true,
                    processData: false
                }, retry = 0, identity = this.restModel.identity, call = (identity) => {
                    identity.isAuthenticated ?
                        this._call(identity, settings, enableCompression) :
                        this.restModel._onIdentityError(identity);
                }, doRetry = (jqXHR, textStatus) => {
                    if (jqXHR.status == 401) {
                        if (!retry++) {
                            identity.refresh().then(call);
                        }
                        return retry <= 2;
                    }
                    return false;
                };
                options.converter && (settings.converters = { 'text json': options.converter });
                if (enableCompression) {
                    settings.headers = {
                        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
                        'Content-Encoding': 'gzip'
                    };
                }
                settings.complete = (jqXHR, textStatus) => {
                    if (!doRetry(jqXHR, textStatus)) {
                        this.restModel._onRequestComplete(this, jqXHR, textStatus);
                    }
                };
                settings.error = (jqXHR, textStatus, errorThrown) => {
                    if (!doRetry(jqXHR, textStatus)) {
                        this.restModel._onRequestError(this, jqXHR, textStatus, errorThrown);
                    }
                };
                if (options.xhrFields) {
                    settings.xhrFields = { ...options.xhrFields };
                }
                this.restModel._onRequestBegin(this);
                options.done && (settings.success = (data, textStatus, jqXHR) => options.done && options.done(this.sequence, data, textStatus, jqXHR));
                call(identity);
                return this.sequence;
            }
        };
        Rest.RestModel = RestModel;
        function getInfo(rest) {
            return Promise.all([
                rest.getVersion(),
                rest.schema.getDatabases().then((descriptors) => {
                    let promises = [];
                    descriptors.forEach((descriptor, indice) => {
                        indice && promises.push(descriptor.getInfo());
                    });
                    return Promise.all(promises);
                }),
                (new AFC.TradeArea.Networks(rest)).getNetworks(),
                (new AFC.TradeArea.DMAConfigsDescriptor(rest)).getConfigurations()
            ]).then((results) => {
                return {
                    afc: AFC.Version,
                    components: results[0],
                    databases: results[1],
                    networks: results[2],
                    dma: results[3]
                };
            });
        }
        Rest.getInfo = getInfo;
    })(Rest = AFC.Rest || (AFC.Rest = {}));
    function createRest(identity, url) {
        return new Rest.RestModel(identity, url);
    }
    AFC.createRest = createRest;
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 07/10/2015.
 */
/**
 * Created by jean.rennes on 02/10/2015.
 */
///<reference path="../../views/Global.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        let DataQualifier;
        (function (DataQualifier) {
            DataQualifier[DataQualifier["none"] = 0] = "none";
            DataQualifier[DataQualifier["code"] = 1] = "code";
            DataQualifier[DataQualifier["name"] = 2] = "name";
            DataQualifier[DataQualifier["bookmark"] = 3] = "bookmark";
            DataQualifier[DataQualifier["partition"] = 4] = "partition";
            DataQualifier[DataQualifier["proximity"] = 5] = "proximity";
            DataQualifier[DataQualifier["cannibalizationPct1"] = 65542] = "cannibalizationPct1";
            DataQualifier[DataQualifier["cannibalizationPct100"] = 131078] = "cannibalizationPct100";
            DataQualifier[DataQualifier["cannibalizationCount"] = 262150] = "cannibalizationCount";
            DataQualifier[DataQualifier["cannibalizationReverse"] = 524294] = "cannibalizationReverse";
            DataQualifier[DataQualifier["scoringValue"] = 65543] = "scoringValue";
            DataQualifier[DataQualifier["scoringRank"] = 131079] = "scoringRank";
            DataQualifier[DataQualifier["targetingCumulative"] = 65544] = "targetingCumulative";
            DataQualifier[DataQualifier["targetingPercentage"] = 131080] = "targetingPercentage";
            DataQualifier[DataQualifier["targetingRank"] = 262152] = "targetingRank";
            DataQualifier[DataQualifier["targetingpartition"] = 524296] = "targetingpartition";
        })(DataQualifier = Dashboards.DataQualifier || (Dashboards.DataQualifier = {}));
        let ZoneReaffectStorage;
        (function (ZoneReaffectStorage) {
            ZoneReaffectStorage[ZoneReaffectStorage["none"] = 0] = "none";
            ZoneReaffectStorage[ZoneReaffectStorage["incremental"] = 1] = "incremental";
            ZoneReaffectStorage[ZoneReaffectStorage["complete"] = 2] = "complete";
            ZoneReaffectStorage[ZoneReaffectStorage["editable"] = 3] = "editable";
        })(ZoneReaffectStorage = Dashboards.ZoneReaffectStorage || (Dashboards.ZoneReaffectStorage = {}));
        let RendererType;
        (function (RendererType) {
            RendererType[RendererType["unknown"] = 0] = "unknown";
            RendererType[RendererType["preview"] = 1] = "preview";
            RendererType[RendererType["infoPreview"] = 2] = "infoPreview";
            RendererType[RendererType["legend"] = 3] = "legend";
        })(RendererType = Dashboards.RendererType || (Dashboards.RendererType = {}));
        let RendererTypeLookup;
        (function (RendererTypeLookup) {
            RendererTypeLookup[RendererTypeLookup["unknown"] = 0] = "unknown";
            RendererTypeLookup[RendererTypeLookup["preview"] = 1] = "preview";
            RendererTypeLookup[RendererTypeLookup["infoPreview"] = 2] = "infoPreview";
            RendererTypeLookup[RendererTypeLookup["legend"] = 3] = "legend";
        })(RendererTypeLookup || (RendererTypeLookup = {}));
        function rendererType(value) {
            return RendererTypeLookup[value];
        }
        Dashboards.rendererType = rendererType;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 16/10/2015.
 */
///<reference path="Global.ts" />
///<reference path="Dashboard.ts" />
///<reference path="../data/Global.ts" />
/*
namespace AFC.Dashboards {
    interface ISiteFinderDescriptor {
        startRowIndex: number;
        maximumRows: number;
        columns: {
            name: string;
            type: string;
        }[];
        values: any[][];
    }

    interface ISiteFinderData {
        columns: AFC.Data.IDBColumn[];
        values?: any[][];
        totalRows?: number;
    }


    export class SiteFinderModel extends Tools.EventSink {
        private _zone: IZone;
        private _useContext: boolean;
        private _pattern: string;
        private _columns: string[];

        private _sequences: number[];
        private _siteData: ISiteFinderData;

        private _clear():void {
            delete this._siteData;
            delete this._sequences;
            this.fireEvent(Tools.EventType.Dirty);
        }

        private _onZoneDirty():void {
            this._clear();
        }

        public set zone(value: IZone) {
            if (this._zone !== value) {
                if (this._zone) this._zone.off(Tools.EventType.Dirty, this._onZoneDirty, this);
                if (this._zone = value) this._zone.on(Tools.EventType.Dirty, this._onZoneDirty, this);
                this._clear();
            }
        }

        public get zone(): IZone {
            return this._zone;
        }

        public set pattern(value:string) {
            if (this._pattern !== value) {
                this._pattern = value;
                this._clear();
            }
        }

        public get pattern():string {
            return this._pattern || '';
        }

        public set useContext(value:boolean) {
            if (this._useContext !== value) {
                this._useContext = value;
                this._clear();
            }
        }

        public get useContext():boolean {
            return !!this._useContext;
        }


        public set columnNames(value:string[]) {
            if (this._columns !== value) {
                this._columns = value;
                this._clear();
            }
        }

        protected _onAlways(sequence:number, jqXHR: JQueryXHR, textStatus: string): void {
            let sequences:number[] = this._sequences;
            let i: number;

            if (sequences && ((i = sequences.indexOf(sequence)) != -1))
            {
                let descriptor: ISiteFinderDescriptor = jqXHR.responseJSON;

                sequences.splice(i, 1);
                if (descriptor) {
                    let siteData: ISiteFinderData = this._siteData || (this._siteData = {columns: Data.mapDataColumns(descriptor)});
                    let values: any[][] = siteData.values || (siteData.values = []);
                    let iStart:number = descriptor.startRowIndex || 0;
                    let item:any[];
                    let input:any[][] = descriptor.values;

                    i = 0;
                    for (item of input) {
                        values[iStart + i++] = item;
                    }
                    if (i < (descriptor.maximumRows || 0)) {
                        siteData.totalRows = iStart + i;
                    }
                }
                if (!sequences.length)
                {
                    delete this._sequences;
                    this.fireEvent(Tools.EventType.UserEvent);
                }
            }
        }

        private queryValues(start: number, count: number):any[][] {
            let siteData: ISiteFinderData = this._siteData;
            let values: any[][];
            let ret:any[][];

            if (siteData && (values = siteData.values)) {
                let item:any[];

                ret = [];
                for (let i: number = 0; (i < count); ++i) {
                    item = values[start + i];
                    if (item === void 0) {
                        return (siteData.totalRows === void 0) || ((start + i) < siteData.totalRows) ? void 0 : ret;
                    }
                    else
                        ret.push(item);
                }
            }
            return ret;
        }

        private _request(columns: string[], start: number = 0, count: number = 0): void {
            let h = (request: Rest.IAjaxRequest)=> {
                let options: Rest.IAjaxOptions = request.options;
                let data: {
                    columns: ReadonlyArray<string>,
                    searchText: string,
                    startRowIndex: number,
                    maximumRows: number
                } = request.options.data;

                options.always = this._onAlways.bind(this);
                data.columns = columns;
                this._pattern && (data.searchText = this._pattern);
                (start!==void 0) && (data.startRowIndex = start);
                (count!==void 0) && (data.maximumRows = count);
                return request.call(`/sites/find`);
            };
            let sequence: number = this._useContext ?
                this._zone.createRequestAsync(h, this._request):
                h(this._zone.createRequestSync());
            (this._sequences || (this._sequences = [])).push(sequence);
        }

        public requestValues(start: number, count: number, callback:(columns: Data.IDBColumn[], values:any[][], start: number, count: number)=>void, context?:any):void {
            let values:any[][] = this.queryValues(start, count);
            let h:(event:Tools.IEvent)=>void;

            if (values) {
                h = (/*event: Tools.IEvent*)=>{
                    callback.call(context, this._siteData.columns, values, start, count);
                }
                (!this._sequences || (this._sequences.length === 0))&&this.fireEvent(Tools.EventType.UserEvent);
            }
            else if (this._zone) {
                h = (/*event: Tools.IEvent*)=>{
                    callback.call(context, this._siteData.columns, this.queryValues(start, count), start, count);
                }

                if (this._columns && this._columns.length)
                    this._request(this._columns, start, count);
                else if (this._zone) {
                    let h2 = (sites: ISitesData)=>this._request(sites.columns.map(column=>column.name), start, count);;
                    this._zone.requestSites(h2, this);
                }
            }
            h&&this.once(Tools.EventType.UserEvent, h, callback, context);
        }
    }
}*/ 
/**
 * Created by jean.rennes on 17/04/2019.
 */
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="Global.ts" />
///<reference path="DashboardView.ts" />
///<reference path="SiteFinder.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        function propertiesLookup(properties) {
            let index = {};
            let property, name;
            for (let i = 0, iLength = properties.length; i < iLength; ++i) {
                property = properties[i];
                name = property[1].toLowerCase();
                index[name] = i;
            }
            return index;
        }
        Dashboards.propertiesLookup = propertiesLookup;
        class DashboardContent {
            constructor(mainCluster, zones, views, reportTemplates) {
                this.mainCluster = mainCluster;
                this.zones = zones;
                this.views = views;
                this.reportTemplates = reportTemplates;
            }
            get zonesProperties() {
                return this._zonesProperties || (this._zonesProperties = this.zones.length ? propertiesLookup(this.zones[0].properties) : {});
            }
            get viewsProperties() {
                return this._viewsProperties || (this._viewsProperties = this.views.length ? propertiesLookup(this.views[0].properties) : {});
            }
        }
        class DashboardDescriptor extends AFC.Tools.EventSink {
            constructor(dashboards, data) {
                super();
                this.dashboards = dashboards;
                this.id = data.id;
                this.name = data.name;
                this.levels = data.levels;
                this.properties = data.properties;
            }
            _onAlways(sequence, jqXHR, textStatus) {
                if (this._sequence === sequence) {
                    let data = jqXHR.responseJSON, mainCluster, zones, views = [], templates = [];
                    if (data) {
                        zones = data.zones && data.zones.map(data => Dashboards.zoneDescriptor(this, data));
                        data.views && data.views.forEach(view => views.push(Dashboards.viewDescriptor(this, view)));
                        data.reports && data.reports.forEach(report => views.push(Dashboards.reportDescriptor(this, report)));
                        mainCluster = data.mainCluster;
                        if (data.templates)
                            templates = data.templates;
                    }
                    this._content = new DashboardContent(mainCluster || '', zones || [], views, templates);
                    this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                }
            }
            get restModel() {
                return this.dashboards.restModel;
            }
            getProperty(value) {
                let dashboardProperties = this._dashboardProperties || (this._dashboardProperties = this.properties.length ? propertiesLookup(this.properties) : {}), i = dashboardProperties[value.toLowerCase()];
                return (i !== void 0) ? this.properties[i][2] : null;
            }
            createRequest(path = '') {
                return this.dashboards.createRequest(`/${this.id}${path}`);
            }
            getContent() {
                return this._content ? Promise.resolve(this._content) : new Promise((resolve) => {
                    this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this._content));
                    if (!this._sequence) {
                        let request = this.createRequest();
                        request.options.always = this._onAlways.bind(this);
                        this._sequence = request.call();
                    }
                });
            }
        }
        //---------------------------------------------------------------------------
        class DashboardsDescriptor extends AFC.Tools.EventSink {
            constructor(restModel) {
                super();
                this.restModel = restModel;
            }
            _onAlways(sequence, jqXHR, textStatus) {
                if (this._sequence === sequence) {
                    let data = jqXHR.responseJSON;
                    data && (this._dashboards = data.map(dashboard => new DashboardDescriptor(this, dashboard)));
                    this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                }
            }
            createRequest(path = '', options) {
                return this.restModel.createAjaxRequest(`/dashboards${path}`, true, options);
            }
            getDashboards() {
                return this._dashboards ? Promise.resolve(this._dashboards) : new Promise((resolve) => {
                    this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this._dashboards));
                    if (!this._sequence) {
                        let request = this.createRequest();
                        request.options.always = this._onAlways.bind(this);
                        this._sequence = request.call();
                    }
                });
            }
        }
        Dashboards.DashboardsDescriptor = DashboardsDescriptor;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
;
/**
 * Created by jean.rennes on 27/03/2018.
 */
///<reference path="Global.ts" />
var AFC;
(function (AFC) {
    var Globals;
    (function (Globals) {
        let GridRenderer;
        (function (GridRenderer) {
            GridRenderer[GridRenderer["none"] = 0] = "none";
            GridRenderer[GridRenderer["text"] = 1] = "text";
            GridRenderer[GridRenderer["checkbox"] = 2] = "checkbox";
            GridRenderer[GridRenderer["color"] = 3] = "color";
            GridRenderer[GridRenderer["trend"] = 4] = "trend";
            GridRenderer[GridRenderer["trendAndText"] = 5] = "trendAndText";
        })(GridRenderer = Globals.GridRenderer || (Globals.GridRenderer = {}));
        let GridRendererLookup;
        (function (GridRendererLookup) {
            GridRendererLookup[GridRendererLookup["none"] = 0] = "none";
            GridRendererLookup[GridRendererLookup["text"] = 1] = "text";
            GridRendererLookup[GridRendererLookup["checkbox"] = 2] = "checkbox";
            GridRendererLookup[GridRendererLookup["color"] = 3] = "color";
            GridRendererLookup[GridRendererLookup["trend"] = 4] = "trend";
            GridRendererLookup[GridRendererLookup["trendAndText"] = 5] = "trendAndText";
        })(GridRendererLookup || (GridRendererLookup = {}));
        ;
        function gridRender(value) {
            return GridRendererLookup[value];
        }
        Globals.gridRender = gridRender;
        let SortOrientation;
        (function (SortOrientation) {
            SortOrientation[SortOrientation["none"] = 0] = "none";
            SortOrientation[SortOrientation["ascending"] = 1] = "ascending";
            SortOrientation[SortOrientation["descending"] = 2] = "descending";
        })(SortOrientation = Globals.SortOrientation || (Globals.SortOrientation = {}));
    })(Globals = AFC.Globals || (AFC.Globals = {}));
})(AFC || (AFC = {}));
/**
  * Created by jean.rennes on 17/04/2019.
*/
///<reference path="Global.ts" />
///<reference path="DashboardDescriptor.ts" />
///<reference path="../globals/Grid.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        let EventType;
        (function (EventType) {
            EventType[EventType["map"] = 65537] = "map";
            EventType[EventType["chart"] = 65538] = "chart";
            EventType[EventType["grid"] = 65539] = "grid";
            EventType[EventType["sheet"] = 65540] = "sheet";
            EventType[EventType["report"] = 65541] = "report";
        })(EventType || (EventType = {}));
        let ViewType;
        (function (ViewType) {
            ViewType[ViewType["unknown"] = 0] = "unknown";
            ViewType[ViewType["map"] = 1] = "map";
            ViewType[ViewType["detailedSheet"] = 2] = "detailedSheet";
            ViewType[ViewType["aggregatedSheet"] = 3] = "aggregatedSheet";
            ViewType[ViewType["chart"] = 4] = "chart";
            ViewType[ViewType["spreadSheet"] = 5] = "spreadSheet";
            ViewType[ViewType["detailedChart"] = 6] = "detailedChart";
            ViewType[ViewType["report"] = 100] = "report";
        })(ViewType = Dashboards.ViewType || (Dashboards.ViewType = {}));
        let ChartType;
        (function (ChartType) {
            ChartType[ChartType["undefined"] = 0] = "undefined";
            ChartType[ChartType["bar"] = 1] = "bar";
            ChartType[ChartType["invertedBar"] = 2] = "invertedBar";
            ChartType[ChartType["lines"] = 3] = "lines";
            ChartType[ChartType["symbol"] = 4] = "symbol";
            ChartType[ChartType["stackedBar"] = 5] = "stackedBar";
            ChartType[ChartType["stackedInvertedBar"] = 6] = "stackedInvertedBar";
            ChartType[ChartType["stackedLines"] = 7] = "stackedLines";
            ChartType[ChartType["stackedSymbol"] = 8] = "stackedSymbol";
            ChartType[ChartType["pie"] = 9] = "pie";
            ChartType[ChartType["pied3d"] = 10] = "pied3d";
            ChartType[ChartType["doughnut"] = 11] = "doughnut";
            ChartType[ChartType["doughnut3d"] = 12] = "doughnut3d";
            ChartType[ChartType["scatterLines"] = 13] = "scatterLines";
            ChartType[ChartType["scatterSymbol"] = 14] = "scatterSymbol";
            ChartType[ChartType["scatterString"] = 15] = "scatterString";
            ChartType[ChartType["boxPlot"] = 16] = "boxPlot";
            ChartType[ChartType["bubble"] = 17] = "bubble";
            ChartType[ChartType["bubbleAsymetric"] = 18] = "bubbleAsymetric";
            ChartType[ChartType["radar"] = 19] = "radar";
            ChartType[ChartType["radarFill"] = 20] = "radarFill";
            ChartType[ChartType["barHorizontal"] = 21] = "barHorizontal";
            ChartType[ChartType["stackedBarHorizontal"] = 22] = "stackedBarHorizontal";
            ChartType[ChartType["linesHorizontal"] = 23] = "linesHorizontal";
            ChartType[ChartType["stackedLinesHorizontal"] = 24] = "stackedLinesHorizontal";
            ChartType[ChartType["symbolHorizontal"] = 25] = "symbolHorizontal";
            ChartType[ChartType["stackedSymbolHorizontal"] = 26] = "stackedSymbolHorizontal";
        })(ChartType = Dashboards.ChartType || (Dashboards.ChartType = {}));
        let SpreadSheetDisplayType;
        (function (SpreadSheetDisplayType) {
            SpreadSheetDisplayType[SpreadSheetDisplayType["grid"] = 0] = "grid";
            SpreadSheetDisplayType[SpreadSheetDisplayType["chart"] = 1] = "chart";
        })(SpreadSheetDisplayType = Dashboards.SpreadSheetDisplayType || (Dashboards.SpreadSheetDisplayType = {}));
        let LayerType;
        (function (LayerType) {
            LayerType[LayerType["undefined"] = 0] = "undefined";
            LayerType[LayerType["thematic"] = 1] = "thematic";
            LayerType[LayerType["outline"] = 2] = "outline";
            LayerType[LayerType["symbol"] = 3] = "symbol";
            LayerType[LayerType["label"] = 4] = "label";
            LayerType[LayerType["graph"] = 5] = "graph";
        })(LayerType = Dashboards.LayerType || (Dashboards.LayerType = {}));
        let DataSourceKind;
        (function (DataSourceKind) {
            DataSourceKind[DataSourceKind["unknown"] = 1] = "unknown";
            DataSourceKind[DataSourceKind["zoneUnits"] = 2] = "zoneUnits";
            DataSourceKind[DataSourceKind["itemInfo"] = 3] = "itemInfo";
            DataSourceKind[DataSourceKind["filteredTable"] = 4] = "filteredTable";
            DataSourceKind[DataSourceKind["sites"] = 5] = "sites";
            DataSourceKind[DataSourceKind["cannibalization"] = 6] = "cannibalization";
            DataSourceKind[DataSourceKind["cannibalizationSites"] = 7] = "cannibalizationSites";
            DataSourceKind[DataSourceKind["DMAImpactedSites"] = 8] = "DMAImpactedSites";
            DataSourceKind[DataSourceKind["subset"] = 9] = "subset";
            DataSourceKind[DataSourceKind["subsetUnion"] = 10] = "subsetUnion";
            DataSourceKind[DataSourceKind["outOfZone"] = 11] = "outOfZone";
            DataSourceKind[DataSourceKind["siteFilteredTable"] = 12] = "siteFilteredTable";
        })(DataSourceKind = Dashboards.DataSourceKind || (Dashboards.DataSourceKind = {}));
        class ViewDescriptor extends AFC.Tools.EventSink {
            constructor(dashboard, type, data) {
                super();
                this.id = data.id;
                this.name = data.name;
                this.type = type;
                this.properties = data.properties;
                this.dashboard = dashboard;
            }
            createRequest(path = '') {
                return this.dashboard.createRequest(`/views/${this.id}${path}`);
            }
        }
        const stringToMapType = {
            ZM_MAP_LAYER_THEMATIC: 1 /* LayerType.thematic */,
            ZM_MAP_LAYER_OUTLINE: 2 /* LayerType.outline */,
            ZM_MAP_LAYER_SYMBOL: 3 /* LayerType.symbol */,
            ZM_MAP_LAYER_LABEL: 4 /* LayerType.label */
        };
        let DataSourceKindLookup;
        (function (DataSourceKindLookup) {
            DataSourceKindLookup[DataSourceKindLookup["unknown"] = 1] = "unknown";
            DataSourceKindLookup[DataSourceKindLookup["zoneUnits"] = 2] = "zoneUnits";
            DataSourceKindLookup[DataSourceKindLookup["itemInfo"] = 3] = "itemInfo";
            DataSourceKindLookup[DataSourceKindLookup["filteredTable"] = 4] = "filteredTable";
            DataSourceKindLookup[DataSourceKindLookup["sites"] = 5] = "sites";
            DataSourceKindLookup[DataSourceKindLookup["cannibalization"] = 6] = "cannibalization";
            DataSourceKindLookup[DataSourceKindLookup["cannibalizationSites"] = 7] = "cannibalizationSites";
            DataSourceKindLookup[DataSourceKindLookup["DMAImpactedSites"] = 8] = "DMAImpactedSites";
            DataSourceKindLookup[DataSourceKindLookup["subset"] = 9] = "subset";
            DataSourceKindLookup[DataSourceKindLookup["subsetUnion"] = 10] = "subsetUnion";
            DataSourceKindLookup[DataSourceKindLookup["outOfZone"] = 11] = "outOfZone";
            DataSourceKindLookup[DataSourceKindLookup["siteFilteredTable"] = 12] = "siteFilteredTable";
        })(DataSourceKindLookup || (DataSourceKindLookup = {}));
        function dataSourceKind(value) {
            return DataSourceKindLookup[value];
        }
        Dashboards.dataSourceKind = dataSourceKind;
        class LayerDescriptor {
            constructor(data, template) {
                this._type = stringToMapType[data.type] || 0 /* LayerType.undefined */;
                this.zone = data.zone;
                this.dataSourceKind = dataSourceKind(data.dataSourceKind) || 1 /* DataSourceKind.unknown */;
                this.selectable = data.selectable;
                this.hidden = data.hidden;
                this.hiddenClasses = data.hiddenClasses;
                this.zoomOnLayer = data.zoomOnLayer;
                this.template = template;
                this.dataNodes = data.dataNodes;
            }
            get name() {
                return this.template.name;
            }
            get type() {
                return this._type;
            }
        }
        class MapDescriptor extends ViewDescriptor {
            constructor(dashboard, data) {
                super(dashboard, 1 /* ViewType.map */, data);
                this.layerCount = data.layerCount;
                this.mapTemplate = data.mapTemplate;
            }
            _onAlways(sequence, jqXHR, textStatus) {
                if (sequence === this._sequence) {
                    let layersData = jqXHR.responseJSON || [];
                    Promise.all(layersData.map(layerData => AFC.Globals.convertMapLayerMetaData(layerData.layer, this.dashboard.restModel.globals)))
                        .then((results) => {
                        this._layers = layersData.map((layerData, indice) => new LayerDescriptor(layerData, results[indice]));
                        this.fireEvent(65537 /* EventType.map */);
                    });
                }
            }
            getLayer(indice) {
                return this._layers ? Promise.resolve(this._layers[indice]) : new Promise((resolve) => {
                    this.notify(65537 /* EventType.map */, ( /*event: Tools.IEvent*/) => resolve(this._layers[indice]));
                    if (!this._sequence) {
                        let request = this.createRequest(`/layers`);
                        request.options.always = this._onAlways.bind(this);
                        request.options.fail = () => false;
                        this._sequence = request.call();
                    }
                });
            }
        }
        const _sortOrientationLookup = {
            none: 0 /* Globals.SortOrientation.none */,
            ascending: 1 /* Globals.SortOrientation.ascending */,
            descending: 2 /* Globals.SortOrientation.descending */
        };
        function _convertCell(cell) {
            cell.renderer = cell.renderer ? AFC.Globals.gridRender(cell.renderer) : 1 /* Globals.GridRenderer.text */;
        }
        function convertSheetInfo(t) {
            if (t) {
                t.columnHeaders && t.columnHeaders.items.forEach(_convertCell);
                t.items.forEach(row => row.forEach(_convertCell));
                t.rowHeaders && t.rowHeaders.items.forEach(_convertCell);
                return t;
            }
        }
        Dashboards.convertSheetInfo = convertSheetInfo;
        class GridDescriptor extends ViewDescriptor {
            _bind(metadata) {
                metadata && (metadata.sheetProperties = convertSheetInfo(metadata.sheetProperties));
                return metadata;
            }
            _onAlways(sequence, jqXHR, textStatus) {
                if (this._sequence === sequence) {
                    this.fireEvent(65540 /* EventType.sheet */);
                    this._metadata = this._bind(jqXHR.responseJSON);
                }
            }
            getMetadata() {
                return this._metadata ? Promise.resolve(this._metadata) : new Promise((resolve) => {
                    this.notify(65540 /* EventType.sheet */, ( /*event: Tools.IEvent*/) => resolve(this._metadata));
                    if (!this._sequence) {
                        let request = this.createRequest('/metadata');
                        request.options.data.svg = 1;
                        request.options.always = this._onAlways.bind(this);
                        this._sequence = request.call();
                    }
                });
            }
        }
        class DetailedSheetDescriptor extends GridDescriptor {
            _bind(metadata) {
                if (metadata) {
                    metadata.dataSourceKind = dataSourceKind(metadata.dataSourceKind);
                    metadata.sheetProperties = convertSheetInfo(metadata.sheetProperties);
                    metadata.sheetProperties.sortColumns && metadata.sheetProperties.sortColumns.forEach((column) => column.orientation = _sortOrientationLookup[column.orientation] || 0 /* Globals.SortOrientation.none */);
                }
                return metadata;
            }
        }
        const _chartTypeLookUp = {
            undefined: 0 /* ChartType.undefined */,
            bar: 1 /* ChartType.bar */,
            invertedBar: 2 /* ChartType.invertedBar */,
            lines: 3 /* ChartType.lines */,
            symbol: 4 /* ChartType.symbol */,
            stackedBar: 5 /* ChartType.stackedBar */,
            stackedInvertedBar: 5 /* ChartType.stackedBar */,
            stackedLines: 7 /* ChartType.stackedLines */,
            stackedSymbol: 8 /* ChartType.stackedSymbol */,
            pie: 9 /* ChartType.pie */,
            pied3d: 10 /* ChartType.pied3d */,
            doughnut: 11 /* ChartType.doughnut */,
            doughnut3d: 12 /* ChartType.doughnut3d */,
            scatterLines: 13 /* ChartType.scatterLines */,
            scatterSymbol: 14 /* ChartType.scatterSymbol */,
            scatterString: 15 /* ChartType.scatterString */,
            boxPlot: 16 /* ChartType.boxPlot */,
            bubble: 17 /* ChartType.bubble */,
            bubbleAsymetric: 18 /* ChartType.bubbleAsymetric */,
            radar: 19 /* ChartType.radar */,
            radarFill: 20 /* ChartType.radarFill */,
            barHorizontal: 21 /* ChartType.barHorizontal */,
            stackedBarHorizontal: 22 /* ChartType.stackedBarHorizontal */,
            linesHorizontal: 23 /* ChartType.linesHorizontal */,
            stackedLinesHorizontal: 24 /* ChartType.stackedLinesHorizontal */,
            symbolHorizontal: 25 /* ChartType.symbolHorizontal */,
            stackedSymbolHorizontal: 26 /* ChartType.stackedSymbolHorizontal */
        };
        class ChartDescriptor extends ViewDescriptor {
            constructor(dashboard, type, data) {
                super(dashboard, type, data);
                this.chartType = _chartTypeLookUp[data.chartType];
            }
        }
        function _convertChartInfo(chartInfo) {
            // TO BE IMPLEMENTED
            /*let sheetProperties;
            if (chartInfo && chartInfo.chartProperties && (sheetProperties = chartInfo.sheetProperties)) {
                chartInfo.subtitles = {
                    columnHeaders: sheetProperties.columnHeaders.items.map(item => item.value),
                    rowHeaders: sheetProperties.rowHeaders.items.map(item => item.value)
                };
            }*/
            return chartInfo;
        }
        class SpreadSheetDescriptor extends GridDescriptor {
            constructor(dashboard, data) {
                super(dashboard, 5 /* ViewType.spreadSheet */, data);
                this.chartType = _chartTypeLookUp[data.chartType];
                this.displayType = data.displayType === 'chart' ? 1 /* SpreadSheetDisplayType.chart */ : 0 /* SpreadSheetDisplayType.grid */;
            }
            _bind(metadata) {
                return super._bind(metadata) && _convertChartInfo(metadata);
            }
        }
        class ReportDescriptor extends ViewDescriptor {
            constructor(dashboard, data) {
                super(dashboard, 100 /* ViewType.report */, data);
            }
            _onAlways(sequence, jqXHR, textStatus) {
                if (sequence === this._sequence) {
                    (this._metadata = jqXHR.responseJSON) && this._metadata.pages.forEach(page => {
                        page.objects.forEach((item) => {
                            item.type = AFC.Globals.reportObjectType(item.type);
                            if (item.type === 2 /* Globals.ReportObjectType.dashboardView */) {
                                item.rendererType = Dashboards.rendererType(item.rendererType);
                            }
                            else if (item.type === 3 /* Globals.ReportObjectType.grid */) {
                                item.content.items.forEach(row => row.forEach((cell) => cell.renderer = AFC.Globals.gridRender(cell.renderer)));
                            }
                        });
                    });
                    this.fireEvent(65541 /* EventType.report */);
                }
            }
            createRequest(path = '') {
                return this.dashboard.createRequest(`/reports/${this.id}${path}`);
            }
            getReportMetadata() {
                return this._metadata ? Promise.resolve(this._metadata) : new Promise((resolve) => {
                    this.notify(65541 /* EventType.report */, ( /*event: Tools.IEvent*/) => resolve(this._metadata));
                    if (!this._sequence) {
                        let request = this.createRequest();
                        request.options.data.svg = 1;
                        request.options.always = this._onAlways.bind(this);
                        this._sequence = request.call();
                    }
                });
            }
        }
        const viewDescriptorFactory = {
            asteropDashboardMap: (dashboard, data) => new MapDescriptor(dashboard, data),
            asteropDashboardDetailedSheet: (dashboard, data) => new DetailedSheetDescriptor(dashboard, 2 /* ViewType.detailedSheet */, data),
            asteropDashboardAggregatedSheet: (dashboard, data) => new GridDescriptor(dashboard, 3 /* ViewType.aggregatedSheet */, data),
            asteropDashboardChart: (dashboard, data) => new ChartDescriptor(dashboard, 4 /* ViewType.chart */, data),
            asteropDashboardSpreadSheet: (dashboard, data) => new SpreadSheetDescriptor(dashboard, data),
            asteropDashboardDetailedChart: (dashboard, data) => new ChartDescriptor(dashboard, 6 /* ViewType.detailedChart */, data)
        };
        function viewDescriptor(dashboard, data) {
            let h = viewDescriptorFactory[data.type] || ((dashboard, data) => new ViewDescriptor(dashboard, 0 /* ViewType.unknown */, data));
            return h(dashboard, data);
        }
        Dashboards.viewDescriptor = viewDescriptor;
        function reportDescriptor(dashboard, data) {
            return new ReportDescriptor(dashboard, data);
        }
        Dashboards.reportDescriptor = reportDescriptor;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 12/10/2015.
 */
///<reference path="Dashboard.ts" />
///<reference path="DashboardViewDescriptor.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        let EventType;
        (function (EventType) {
            EventType[EventType["chart"] = 65537] = "chart";
            EventType[EventType["grid"] = 65538] = "grid";
            EventType[EventType["layer"] = 65539] = "layer";
            EventType[EventType["report"] = 65540] = "report";
            EventType[EventType["data"] = 65541] = "data";
        })(EventType || (EventType = {}));
        const _makeKey = (width, height, options) => `${width}|${height}|${options.format}|${options.page || options.horizontal || ''}|${options.quality || ''}`;
        class Image {
            constructor(stamp) {
                this.stamp = stamp;
                this._handles = [];
                this.onAlways = (sequence, jqXHR, textStatus) => {
                    let data, indice = 1;
                    if (jqXHR.status === 200) {
                        data = this._data = jqXHR.responseText;
                        indice = 0;
                    }
                    this._handles.forEach(handle => handle(data));
                    delete this._handles;
                };
            }
            getData() {
                return this._handles ? new Promise(resolve => this._handles.push(resolve)) : Promise.resolve(this._data);
            }
        }
        const maxCacheLength = 3;
        class ImageCache {
            constructor() {
                this.counter = 0;
                this.remove = -maxCacheLength;
                this.dataSet = {};
            }
            get(key) {
                return this.dataSet[key];
            }
            create(key) {
                let remove = ++this.remove;
                if (remove >= 0) {
                    for (let key in this.dataSet) {
                        if (this.dataSet[key].stamp === remove) {
                            delete this.dataSet[key];
                            break;
                        }
                    }
                }
                return this.dataSet[key] = new Image(this.counter++);
            }
        }
        class View extends AFC.Tools.EventSink {
            constructor(dashboard, descriptor) {
                super();
                this.dashboard = dashboard;
                this.descriptor = descriptor;
            }
            async _requestImage(cache, width, height, opt) {
                if (!width || !height) {
                    return AFC.Tools.Style.transparent1Pixel.substr(22);
                }
                let options = $.extend({ format: 10 /* Rest.RestFormat.png24 */ }, opt), key = _makeKey(width, height, options), image = cache.get(key);
                if (!image) {
                    let request, promise = this.createRequest(options.path, { format: options.format });
                    image = cache.create(key);
                    request = await promise[1];
                    request.options.always = image.onAlways;
                    request.options.encoding = 'base64';
                    request.options.data.width = width;
                    request.options.data.height = height;
                    options.quality && (request.options.data.quality = options.quality);
                    options.page && (request.options.data.page = options.page);
                    options.horizontal && (request.options.data.horizontal = options.horizontal);
                    request.call();
                }
                return image.getData();
            }
            get id() {
                return this.descriptor.id;
            }
            get name() {
                return this.descriptor.name;
            }
            get type() {
                return this.descriptor.type;
            }
            get properties() {
                return this.descriptor.properties;
            }
            createRequest(path = '', options) {
                return this.dashboard.createRequest(`/views/${this.id}${path}`, options);
            }
            getLegend(width, height, horizontal, quality) {
                return this._requestImage(this._cache || (this._cache = new ImageCache()), width, height, { path: '/legend', horizontal: horizontal, quality: quality });
            }
            invalidate() {
                delete this._cache;
            }
            clone(dashboard) {
                return Reflect.construct(View, [dashboard, this.descriptor], this.constructor);
            }
        }
        class ReportTemplate extends AFC.Tools.EventSink {
            constructor(dashboard, descriptor) {
                super();
                this.dashboard = dashboard;
                this.descriptor = descriptor;
            }
            get id() {
                return this.descriptor.id;
            }
            get name() {
                return this.descriptor.name;
            }
            createRequest(path = '', options) {
                return this.dashboard.createRequest(`/templates/${this.id}${path}`, options);
            }
            getRequest(options) {
                let promise = this.createRequest(void 0, options);
                return promise[1];
            }
            invalidate() {
            }
            clone(dashboard) {
                return Reflect.construct(ReportTemplate, [dashboard, this.descriptor], this.constructor);
            }
        }
        const _cache = Symbol();
        function imageMixin(Base) {
            return class extends Base {
                getImage(width, height, quality) {
                    return this._requestImage(this[_cache] || (this[_cache] = new ImageCache()), width, height, { quality: quality });
                }
                invalidate() {
                    delete this[_cache];
                    super.invalidate();
                }
            };
        }
        const ImageView = imageMixin(View);
        class MapView extends ImageView {
            _onAlways(indice, layer, sequence, jqXHR, textStatus) {
                if (layer._sequence === sequence) {
                    let data = jqXHR.responseJSON, dataTable;
                    layer._loaded = true;
                    if (data) {
                        dataTable = AFC.Data.updateTableData(data.table);
                        dataTable && (layer.dataModel = new AFC.Data.DataModel(dataTable.columns, dataTable.primaryKey, dataTable.values));
                        data.legend && (layer.thematics = data.legend);
                    }
                    this.fireEvent(65539 /* EventType.layer */ + indice);
                }
            }
            _loadMetadata(indice, layer) {
                return this.descriptor.getLayer(indice).then((descriptor) => {
                    layer.descriptor = descriptor;
                });
            }
            _loadLayer(indice, layer) {
                return new Promise(async (resolve) => {
                    this.notify(65539 /* EventType.layer */ + indice, ( /*event: Tools.IEvent*/) => resolve());
                    if (!layer._sequence) {
                        let promise = this.createRequest(`/layers/${indice}`), request;
                        layer._sequence = promise[0];
                        request = await promise[1];
                        request.options.always = this._onAlways.bind(this, indice, layer);
                        request.options.fail = () => false;
                        request.call();
                    }
                });
            }
            getLayer(indice) {
                let layer = (this._layers || (this._layers = []))[indice] || (this._layers[indice] = {}), promises = [];
                layer.descriptor || promises.push(this._loadMetadata(indice, layer));
                layer._loaded || promises.push(this._loadLayer(indice, layer));
                return Promise.all(promises).then(( /*value: any*/) => layer);
            }
            getBbox() {
                return this._bbox ? Promise.resolve(this._bbox) : new Promise(async (resolve) => {
                    this.notify(65541 /* EventType.data */, ( /*event: Tools.IEvent*/) => resolve(this._bbox));
                    if (!this._sequence) {
                        let promise = this.createRequest('/content'), request;
                        this._sequence = promise[0];
                        request = await promise[1];
                        request.options.always = (sequence, jqXHR, textStatus) => {
                            if (this._sequence === sequence) {
                                this.fireEvent(65541 /* EventType.data */);
                                this._bbox = jqXHR.responseJSON.bbox;
                            }
                        };
                        request.call();
                    }
                    ;
                });
            }
            invalidate() {
                super.invalidate();
                delete this._sequence;
                delete this._bbox;
                if (this._layers) {
                    this._layers.forEach(layer => (delete layer._sequence, delete layer._loaded));
                    delete this._layers;
                }
            }
            clone(dashboard) {
                let clone = super.clone(dashboard);
                this._layers && (clone._layers = this._layers);
                return clone;
            }
        }
        class Sheet extends View {
            _onAlways(sequence, jqXHR, textStatus) {
                if (this._gridSequence === sequence) {
                    this.fireEvent(65538 /* EventType.grid */);
                    return !!(this._gridData = Dashboards.convertSheetInfo(jqXHR.responseJSON));
                }
            }
            _bind(info) {
                return Dashboards.convertSheetInfo(info);
            }
            getMetadata() {
                return this.descriptor.getMetadata();
            }
            getData() {
                return this._data ? Promise.resolve(this._data) : new Promise(async (resolve) => {
                    this.notify(65541 /* EventType.data */, ( /*event: Tools.IEvent*/) => resolve(this._data));
                    if (!this._sequence) {
                        let promise = this.createRequest('/content'), request;
                        this._sequence = promise[0];
                        request = await promise[1];
                        request.options.always = (sequence, jqXHR, textStatus) => {
                            if (this._sequence === sequence) {
                                this.fireEvent(65541 /* EventType.data */);
                                this._data = this._bind(jqXHR.responseJSON);
                            }
                        };
                        request.call();
                    }
                    ;
                });
            }
            getGridData() {
                return this._gridData ? Promise.resolve(this._gridData) : new Promise(async (resolve) => {
                    this.notify(65538 /* EventType.grid */, ( /*event: Tools.IEvent*/) => resolve(this._gridData));
                    if (!this._gridSequence) {
                        let promise = this.createRequest(), request;
                        this._gridSequence = promise[0];
                        request = await promise[1];
                        request.options.data.svg = 1;
                        request.options.always = this._onAlways.bind(this);
                        request.call();
                    }
                    ;
                });
            }
            invalidate() {
                super.invalidate();
                delete this._gridData;
                delete this._gridSequence;
                delete this._data;
                delete this._sequence;
            }
            clone(dashboard) {
                let clone = super.clone(dashboard);
                this._gridData && (clone._gridData = this._gridData);
                return clone;
            }
            getRequest(options) {
                let promise = this.createRequest('/content', options);
                return promise[1];
            }
        }
        class DetailedSheet extends Sheet {
            constructor() {
                super(...arguments);
                this.sortable = true;
            }
            _bind(info) {
                let dataTable = info && AFC.Data.updateTableData(info.table), data = {};
                dataTable && (data.dataModel = new AFC.Data.DataModelBase(dataTable.columns, dataTable.primaryKey, dataTable.values));
                info.thematic && (data.thematic = info.thematic);
                return data;
            }
            _onAlways(sequence, jqXHR, textStatus) {
                let ret = super._onAlways(sequence, jqXHR, textStatus), columnHeaders = ret && this._gridData.columnHeaders;
                if (columnHeaders) {
                    columnHeaders.items.forEach((cell) => cell.type = AFC.Data.dataKind(cell.type));
                    columnHeaders.ordering && !this._sortedColumns && (this._sortedColumns = columnHeaders.ordering.reduceRight((accumulator, order) => (accumulator.push({ name: columnHeaders.items[order.index].name, descending: order.descending }), accumulator), []));
                }
                return ret;
            }
            async getSortedColumns() {
                return this._sortedColumns || this.getMetadata().then(metadata => this._sortedColumns = metadata.sheetProperties.sortColumns?.map(column => ({ name: column.column, descending: column.orientation === 2 /* Globals.SortOrientation.descending */ })).reverse() || []);
            }
            clone(dashboard) {
                let clone = super.clone(dashboard);
                this._sortedColumns && (clone._sortedColumns = this._sortedColumns);
                return clone;
            }
        }
        function chartMixin() {
            function _convertPie(chartModel) {
                return chartModel.chartProperties.parts && chartModel.chartProperties.parts.map(part => ({
                    value: part.fillColor,
                    pattern: part.name
                }));
            }
            function _convertBar(chartModel) {
                return chartModel.chartProperties.series && chartModel.chartProperties.series.map(serie => ({
                    value: serie.bar.color,
                    pattern: serie.name
                }));
            }
            function _convertRadar(chartModel) {
                return chartModel.chartProperties.series && chartModel.chartProperties.series.map(serie => ({
                    value: serie.line.color,
                    pattern: serie.name
                }));
            }
            const _sequence = Symbol(), _data = Symbol(), _onAlways = Symbol(), _converters = {
                [1 /* Globals.ChartType.pie */]: (chartModel) => _convertPie(chartModel),
                [6 /* Globals.ChartType.doughnut */]: (chartModel) => _convertPie(chartModel),
                [12 /* Globals.ChartType.barHorizontal */]: (chartModel) => _convertBar(chartModel),
                [4 /* Globals.ChartType.bar */]: (chartModel) => _convertBar(chartModel),
                [11 /* Globals.ChartType.radar */]: (chartModel) => _convertRadar(chartModel)
            };
            return function (Base) {
                class Derived extends imageMixin(Base) {
                    [_onAlways](sequence, jqXHR, textStatus) {
                        if (this[_sequence] === sequence) {
                            let data = jqXHR.responseJSON;
                            delete this[_data];
                            if (data) {
                                data.chartProperties.type = AFC.Globals.chartType(data.chartProperties.type);
                                this[_data] = {
                                    chartDataTransposed: data.chartDataTransposed,
                                    chartProperties: data.chartProperties,
                                    subtitles: {
                                        columnHeaders: data.columnHeaders.items.map(item => item.name),
                                        rowHeaders: data.rowHeaders && data.rowHeaders.items.map(item => item.name)
                                    },
                                    data: data.items
                                };
                            }
                            this.fireEvent(65537 /* EventType.chart */);
                        }
                    }
                    getChartData() {
                        return this[_data] ? Promise.resolve(this[_data]) : new Promise(async (resolve) => {
                            this.notify(65537 /* EventType.chart */, ( /*event: Tools.IEvent*/) => resolve(this[_data]));
                            if (!this[_sequence]) {
                                let promise = this.createRequest(), request;
                                this[_sequence] = promise[0];
                                request = await promise[1];
                                request.options.always = this[_onAlways].bind(this);
                                request.options.data.metadata = true;
                                request.call();
                            }
                        });
                    }
                    getLegendInfo() {
                        return this.getChartData().then((chartModel) => {
                            if (chartModel) {
                                let properties = chartModel.chartProperties, converter = properties && _converters[properties.type], classes = converter && converter(chartModel);
                                return classes && {
                                    type: 0 /* Globals.LegendType.fillColor */,
                                    property: {
                                        thematic: {
                                            title: properties.title && properties.title.text,
                                            classes: classes
                                        }
                                    }
                                };
                            }
                        });
                    }
                    invalidate() {
                        delete this[_sequence];
                        delete this[_data];
                        super.invalidate();
                    }
                    clone(dashboard) {
                        let clone = super.clone(dashboard);
                        this[_data] && (clone[_data] = this[_data]);
                        return clone;
                    }
                }
                return Derived;
            };
        }
        const Chart = chartMixin()(View);
        const SpreadSheet = chartMixin()(Sheet);
        const _replacements = {
            [1 /* Globals.ReportObjectType.text */]: (item) => ({ text: item.value }),
            [3 /* Globals.ReportObjectType.grid */]: (item) => item.content,
            [2 /* Globals.ReportObjectType.dashboardView */]: (item) => ({
                renderer: Dashboards.rendererType(item.renderer),
                view: item.view
            })
        };
        class Report extends View {
            createRequest(path = '', options) {
                return this.dashboard.createRequest(`/reports/${this.id}${path}`, options);
            }
            getRequest(options) {
                let promise = this.createRequest(void 0, options);
                return promise[1].then((request) => {
                    let pageFilter;
                    if (options && (pageFilter = (options.pageFilter && (options.pageFilter.show || options.pageFilter.hide))) || options.replacements) {
                        let data = request.options.data;
                        let context = data.context || (data.context = {});
                        let reports = context.reports || (context.reports = []);
                        let report = { id: this.id };
                        reports.push(report);
                        if (pageFilter) {
                            report.pageFilter = options.pageFilter;
                        }
                        if (options.replacements) {
                            let replacements = report.objects = {}, h;
                            for (let item of options.replacements) {
                                (h = _replacements[item.type]) && (replacements[item.id] = { content: h(item) });
                            }
                        }
                    }
                    return request;
                });
            }
            _onAlways(sequence, jqXHR, textStatus) {
                if (sequence === this._sequence) {
                    this._data = jqXHR.responseJSON;
                    this.fireEvent(65540 /* EventType.report */);
                }
            }
            getReportData() {
                return this._data ? Promise.resolve(this._data) : new Promise(async (resolve) => {
                    this.notify(65540 /* EventType.report */, ( /*event: Tools.IEvent*/) => resolve(this._data));
                    if (!this._sequence) {
                        let promise = this.createRequest('/content'), request;
                        this._sequence = promise[0];
                        request = await promise[1];
                        request.options.always = this._onAlways.bind(this);
                        request.call();
                    }
                });
            }
            invalidate() {
                super.invalidate();
                delete this[_cache];
                delete this._sequence;
                delete this._data;
            }
            clone(dashboard) {
                let clone = super.clone(dashboard);
                this._data && (clone._data = this._data);
                return clone;
            }
            getImage(width, height, page, quality) {
                return page >= 0 && this._requestImage(this[_cache] || (this[_cache] = new ImageCache()), width, height, { page: page, quality: quality });
            }
        }
        const viewFactory = {
            [0 /* ViewType.unknown */]: (dashboard, descriptor) => new View(dashboard, descriptor),
            [1 /* ViewType.map */]: (dashboard, descriptor) => new MapView(dashboard, descriptor),
            [2 /* ViewType.detailedSheet */]: (dashboard, descriptor) => new DetailedSheet(dashboard, descriptor),
            [3 /* ViewType.aggregatedSheet */]: (dashboard, descriptor) => new Sheet(dashboard, descriptor),
            [4 /* ViewType.chart */]: (dashboard, descriptor) => new Chart(dashboard, descriptor),
            [5 /* ViewType.spreadSheet */]: (dashboard, descriptor) => new SpreadSheet(dashboard, descriptor),
            [6 /* ViewType.detailedChart */]: (dashboard, descriptor) => new Chart(dashboard, descriptor),
            [100 /* ViewType.report */]: (dashboard, descriptor) => new Report(dashboard, descriptor)
        };
        function view(dashboard, descriptor) {
            let h = viewFactory[descriptor.type];
            return h && h(dashboard, descriptor);
        }
        Dashboards.view = view;
        function reportTemplate(dashboard, descriptor) {
            return new ReportTemplate(dashboard, descriptor);
        }
        Dashboards.reportTemplate = reportTemplate;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 23/09/2015.
 */
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="Global.ts" />
///<reference path="DashboardView.ts" />
///<reference path="SiteFinder.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        //---------------------------------------------------------------------------
        const _sitesTable = Symbol(), _updateContext = Symbol(), _clone = Symbol();
        class DashboardEventData {
            constructor(views) {
                this.views = views;
            }
            concat(d) {
                !d.views && (this.views = false);
                !d.districting && (this.districting = false);
                return this;
            }
        }
        class Dashboard extends AFC.Tools.EventSink {
            constructor(descriptor, content, branch, builder) {
                super();
                this.branch = branch;
                this.descriptor = descriptor;
                this._content = content;
                this.zones = [];
                this.views = [];
                this.reportTemplates = [];
                this.clusters = [];
                this.reaffectStorages = Dashboards.reaffectStorages(this);
                this.requestBuilder = builder || new AFC.Rest.RequestBuilder(descriptor.restModel);
                this.on(1073741824 /* Tools.EventType.Attach */, this._onAttach, this);
            }
            _onAttach(event) {
                this.fireEvent(6 /* Tools.EventType.Dirty */, event?.data);
            }
            _onSiteChange(zones) {
                zones && zones.forEach(zone => { zone.invalidate(true); });
                this.invalidateViews();
            }
            get id() {
                return this.descriptor.id;
            }
            get name() {
                return this.descriptor.name;
            }
            get properties() {
                return this._properties || (this._properties = Dashboards.propertiesLookup(this.descriptor.properties));
            }
            get viewsProperties() {
                return this._content.viewsProperties;
            }
            init() {
                let clusters = {};
                this._content.zones.forEach(descriptor => {
                    let cluster = clusters[descriptor.cluster] || (this.clusters.push(clusters[descriptor.cluster] = new Dashboard._ZoneCluster(descriptor.cluster, this)), clusters[descriptor.cluster]), item = Dashboards.zone(this, descriptor, cluster);
                    cluster.zones.push(item);
                    this.zones.push(item);
                });
                this._content.views.forEach(descriptor => {
                    this.views.push(Dashboards.view(this, descriptor));
                });
                this._content.reportTemplates.forEach(descriptor => {
                    this.reportTemplates.push(Dashboards.reportTemplate(this, descriptor));
                });
                this.mainCluster = clusters[this._content.mainCluster];
                return this;
            }
            get site() {
                return this.mainCluster.current;
            }
            async _apply(data, modifierOptions) {
                let reaffectStorages;
                await this.requestBuilder.load(modifierOptions);
                this.clusters.forEach(cluster => cluster[_updateContext](data));
                modifierOptions || (reaffectStorages = await this.reaffectStorages.load());
                this.zones.forEach((zone, indice) => zone.updateContext(data, reaffectStorages && reaffectStorages[indice], zone.cluster[_sitesTable]));
                return this.requestBuilder.updateBody(data, modifierOptions);
            }
            async getContextDashboard() {
                return this._apply({ id: this.id });
            }
            createRequest(path, options, districtType) {
                let descriptor = this.descriptor, request = descriptor.restModel.createAjaxRequest(`/dashboards/${descriptor.id}${path}`, false, options), modifierOptions = districtType !== void 0 && districtType !== 2 /* DistrictType.full */ && { districtType: districtType };
                return [request.sequence, this._apply(request.options.data, modifierOptions).then(() => request)];
            }
            clone(branch = this.branch) {
                let clone = Reflect.construct(Dashboard, [this.descriptor, this._content, branch, this.requestBuilder.clone()], this.constructor), clusters = {};
                this.clusters.forEach(cluster => clone.clusters.push(clusters[cluster.id] = cluster[_clone](clone)));
                this.zones.forEach(zone => {
                    let descriptor = zone.reference, cluster = clusters[descriptor.cluster], item = zone.clone(clone, cluster);
                    cluster.zones.push(item);
                    clone.zones.push(item);
                });
                this.views.forEach(view => {
                    clone.views.push(view.clone(clone));
                });
                this.reportTemplates.forEach(reportTemplate => {
                    clone.reportTemplates.push(reportTemplate.clone(clone));
                });
                clone.mainCluster = clusters[this._content.mainCluster];
                clone._properties = this._properties;
                return clone;
            }
            getProperty(value) {
                return this.descriptor.getProperty(value);
            }
            invalidateReportTemplates() {
                this.reportTemplates && this.reportTemplates.forEach(reportTemplate => { reportTemplate.invalidate(); });
            }
            invalidateViews(districtOperation) {
                if (this.views) {
                    let eventData = new DashboardEventData(true);
                    districtOperation && (eventData.districting = districtOperation.type !== 1 /* OperationType.reset */);
                    this.views.forEach(view => view.invalidate());
                    this.fireEvent(1073741824 /* Tools.EventType.Attach */, eventData);
                }
            }
            invalidate() {
                this.zones && this.zones.forEach(zone => zone.invalidate(true));
                this.invalidateViews();
                this.invalidateReportTemplates();
            }
        }
        Dashboard._ZoneCluster = class {
            constructor(id, dashboard) {
                this.id = id;
                this.dashboard = dashboard;
                this.zones = [];
            }
            set current(value) {
                delete this[_sitesTable];
                this._dataCreation && this._dataCreation.release();
                this._current = value;
                this.dashboard._onSiteChange(this.zones);
            }
            get current() {
                return this._current;
            }
            setSite(point) {
                let dataCreation;
                let codeColumn, nameColumn;
                let bk = new AFC.Data.DBColumn(codeColumn = nameColumn = 'bookmark', 3 /* AFC.Data.DataKind.integer */, 0, 4);
                let geometry = new AFC.Data.DBColumn('geometry', 1048576 /* AFC.Data.DataKind.point */, -1);
                dataCreation = new AFC.Data.EmbeddedCreation([bk, geometry], [codeColumn], [[this._current = 1, point]]);
                (this._dataCreation || (this._dataCreation = new AFC.Rest.DataResource())).create(this.dashboard.requestBuilder, dataCreation);
                this[_sitesTable] = {
                    table: this._dataCreation.id,
                    codecolumn: codeColumn,
                    namecolumn: nameColumn
                };
                this.dashboard._onSiteChange(this.zones);
            }
            [_updateContext](data) {
                let current = this.current;
                (current !== void 0) && (data.sites || (data.sites = [])).push({ zone: this.zones[0].id, site: current });
            }
            [_clone](dashboard) {
                let clone = new Dashboard._ZoneCluster(this.id, dashboard);
                this[_sitesTable] && (clone[_sitesTable] = this[_sitesTable]);
                this._dataCreation && (clone._dataCreation = this._dataCreation.clone(dashboard.requestBuilder));
                this._current && (clone._current = this._current);
                return clone;
            }
        };
        async function dashboard(descriptor, branch) {
            const content = await descriptor.getContent();
            return content && (new Dashboard(descriptor, content, branch)).init();
        }
        Dashboards.dashboard = dashboard;
        async function getDashboard(restModel, id, branch) {
            const descriptors = await restModel.dashboardsDescriptor.getDashboards();
            let descriptor = id !== void 0 ? AFC.Tools.findByIdOrName(id, descriptors) : descriptors[0];
            return descriptor && dashboard(descriptor, branch);
        }
        Dashboards.getDashboard = getDashboard;
        async function getDashboards(restModel, branch) {
            const descriptors = await restModel.dashboardsDescriptor.getDashboards();
            return Promise.all(descriptors.map(descriptor => descriptor && dashboard(descriptor, branch)));
        }
        Dashboards.getDashboards = getDashboards;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
;
/**
 * Created by jean.rennes on 13/09/2016.
 */
///<reference path="../../helpers/EventSink.ts" />
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        class ControlLoadingState {
            constructor(parent, force) {
                this._displayloading = false;
                if (parent) {
                    if (force || (parent.getAttribute('enableLoading') == '1')) {
                        this._parent = parent;
                        this._displayloading = true;
                        this._waitElement = document.createElement('div');
                        $(this._waitElement).addClass('loader');
                        if (parent.getAttribute('autoStartLoading') != '0')
                            this.show();
                    }
                }
            }
            show() {
                if (this._parent && this._displayloading) {
                    if (!$(this._parent).hasClass('controlLoading'))
                        $(this._parent).addClass('controlLoading');
                    if (this._waitElement && ($(this._parent).find(this._waitElement).length == 0))
                        $(this._parent).append(this._waitElement);
                }
            }
            hide() {
                $(this._parent).removeClass('controlLoading');
                if (this._waitElement && ($(this._parent).find(this._waitElement).length != 0))
                    $(this._waitElement).detach();
            }
            isLoading() {
                let isLoading = false;
                if (this._parent && $(this._parent).hasClass('controlLoading'))
                    isLoading = true;
                return isLoading;
            }
        }
        Controls.ControlLoadingState = ControlLoadingState;
        ;
        class Control {
            constructor(node, forceLoadingState = false) {
                this.node = typeof node === 'string' ? document.getElementById(node) : node;
                this._loadingState = new ControlLoadingState(this.node, forceLoadingState);
            }
            isLoading() {
                return this._loadingState ? this._loadingState.isLoading() : false;
            }
            loadingStart() {
                if (this._loadingState)
                    this._loadingState.show();
            }
            loadingEnd() {
                if (this._loadingState)
                    this._loadingState.hide();
            }
            _dispatchChange() {
                this.dispatchChange && this.dispatchChange();
            }
            get width() {
                return Math.floor($(this.node).width());
            }
            get height() {
                return Math.floor($(this.node).height());
            }
            set visible(b) {
                this.node.style.visibility = b ? 'visible' : 'hidden';
            }
        }
        Controls.Control = Control;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 08/10/2015.
 */
///<reference path="Control.ts" />
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        class Image extends Controls.Control {
            setUrl(url) {
                var container = $(this.node);
                container.empty();
                if (url) {
                    let img = document.createElement('img');
                    img.src = url;
                    container.append(img);
                    return img;
                }
            }
        }
        Controls.Image = Image;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 03/02/2016.
 */
///<reference path="../AFC.ts" />
///<reference path="EventSink.ts" />
var AFC;
(function (AFC) {
    var Tools;
    (function (Tools) {
        const _disabled = Symbol(), _muted = Symbol(), _dirty = Symbol(), _refresh = Symbol(), _update = Symbol();
        function _doUpdate(adapter, event) {
            adapter[_dirty] = true;
            adapter[_update](event);
        }
        class AdapterBase extends Tools.EventSink {
            static disable(adapter, value) {
                value = !!value;
                if (!adapter[_disabled] === value) {
                    adapter[_disabled] = value;
                    adapter[_update]();
                }
            }
            constructor() {
                super();
            }
            /** @internal */
            [_update](event) {
                if (this.ready && this[_dirty]) {
                    this._update(this.model, event);
                    delete this[_dirty];
                }
            }
            /** @internal */
            [_refresh]() {
                this.once(1073741824 /* Tools.EventType.Attach */, (e) => {
                    let model = e?.data.find(model => model === this.model);
                    if (model) {
                        _doUpdate(this);
                        model?.on && model.on(6 /* Tools.EventType.Dirty */, this._onDirty, this);
                    }
                }, _doUpdate, this);
                this.fireEvent(1073741824 /* Tools.EventType.Attach */, [this.model]);
            }
            set mute(value) {
                value = !!value;
                if (this.mute !== value) {
                    this[_muted] = value;
                    this[_update]();
                }
            }
            get model() {
                return this._model;
            }
            get mute() {
                return !!this[_muted];
            }
            get ready() {
                return !this[_muted] && !this[_disabled];
            }
            _onDirty(event) {
                event?.target === this._model && _doUpdate(this, event);
            }
            bindTo(model) {
                if (model !== this.model) {
                    this.unbind();
                    model && (this._model = model);
                    this[_refresh]();
                }
            }
            unbind() {
                let model = this.model;
                if (model) {
                    delete this._model;
                    model.off && model.off(6 /* Tools.EventType.Dirty */, this._onDirty, this);
                }
            }
            refresh() {
                this.model && this[_refresh]();
            }
        }
        Tools.AdapterBase = AdapterBase;
    })(Tools = AFC.Tools || (AFC.Tools = {}));
})(AFC || (AFC = {}));
;
/**
 * Created by jean.rennes on 20/07/2017.
 */
///<reference path="../../models/dashboards/Dashboard.ts" />
///<reference path="../../views/controls/Image.ts" />
///<reference path="../../helpers/AdapterBase.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        class ImageAdapter extends AFC.Tools.AdapterBase {
            constructor(image) {
                super();
                this.control = image;
            }
            _onImageReady(data) {
                this.control.loadingEnd();
                this.control.setUrl(data && `${ImageAdapter.header}${data}`);
            }
            _update(model) {
                if (!this.control.isLoading()) {
                    this.control.setUrl();
                    this.control.loadingStart();
                }
                model.getImage(this.control.width, this.control.height).then(data => this._onImageReady(data));
            }
            unbind() {
                if (!this.control.isLoading()) {
                    this.control.setUrl();
                    this.control.loadingStart();
                }
                super.unbind();
            }
        }
        ImageAdapter.header = 'data:image/png;base64,';
        Dashboards.ImageAdapter = ImageAdapter;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
;
/**
 * Created by jean.rennes on 08/10/2015.
 */
///<reference path="ImageAdapter.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        function _getViewType(view, reportObject) {
            let descriptor = view.descriptor, viewType = view.type;
            if (viewType === 5 /* ViewType.spreadSheet */) {
                viewType = (descriptor.displayType === 0 /* SpreadSheetDisplayType.grid */ ? 1 /* RendererType.preview */ : 2 /* RendererType.infoPreview */) === reportObject.rendererType ? 5 /* ViewType.spreadSheet */ : 4 /* ViewType.chart */;
            }
            return viewType;
        }
        function _canRender(dashboard, reportObject) {
            let view = AFC.Tools.findById(reportObject.viewId, dashboard.views);
            return view && ((reportObject.rendererType === 1 /* RendererType.preview */) || ((reportObject.rendererType === 2 /* RendererType.infoPreview */) && (view.type === 5 /* ViewType.spreadSheet */)));
        }
        function _renderImage(reportObject, view) {
            let width = Math.floor(reportObject.width * 72 / 25.4), // pixel at 72 dpi
            height = Math.floor(reportObject.height * 72 / 25.4);
            return view.getImage(width, height).then((data) => ({
                type: 1 /* Controls.ReportViewBlockType.image */,
                data: `${Dashboards.ImageAdapter.header}${data}`
            }));
        }
        function _renderLegend(reportObject, view) {
            let width = Math.floor(reportObject.width * 72 / 25.4), // pixel at 72 dpi
            height = Math.floor(reportObject.height * 72 / 25.4);
            return view.getLegend(width, height, reportObject.horizontal).then((data) => ({
                type: 1 /* Controls.ReportViewBlockType.image */,
                data: `${Dashboards.ImageAdapter.header}${data}`
            }));
        }
        function _check(dashboard, reportObject) {
            let view;
            return (reportObject.type !== 2 /* Globals.ReportObjectType.dashboardView */) || !(view = AFC.Tools.findById(reportObject.viewId, dashboard.views)) || (view.type !== 0 /* ViewType.unknown */);
        }
        class ChartAdapter extends Dashboards.ImageAdapter {
            constructor(control, chartData) {
                super(control);
                this._data = chartData;
                this._sequence = 0;
            }
            _onChartReady(chart, sequence) {
                this.control.setData(chart);
            }
            _onReport(model, metadata, data, indice, sequence) {
                let dashboard, page;
                if (sequence === this._sequence) {
                    if (metadata && metadata.pages && (page = metadata.pages[indice]) && data && (dashboard = model.dashboard) && page.objects.every((reportObject) => _check(dashboard, reportObject))) {
                        let promises = [];
                        this._isData = true;
                        page.objects.forEach((reportObject, indice) => {
                            if (reportObject.type === 2 /* Globals.ReportObjectType.dashboardView */) {
                                let view = AFC.Tools.findById(reportObject.viewId, dashboard.views);
                                if (view) {
                                    if (reportObject.rendererType === 3 /* RendererType.legend */) {
                                        promises[indice] = _renderLegend(reportObject, view);
                                    }
                                    else if (_canRender(dashboard, reportObject)) {
                                        switch (_getViewType(view, reportObject)) {
                                            case 2 /* Dashboards.ViewType.detailedSheet */:
                                            case 3 /* Dashboards.ViewType.aggregatedSheet */:
                                            case 5 /* Dashboards.ViewType.spreadSheet */:
                                                promises[indice] = view.getGridData().then((gridData) => ({
                                                    type: 3 /* Controls.ReportViewBlockType.gridView */,
                                                    data: new Dashboards.GridApp(gridData, view.type === 2 /* ViewType.detailedSheet */)
                                                }));
                                                break;
                                            case 4 /* Dashboards.ViewType.chart */:
                                            case 6 /* Dashboards.ViewType.detailedChart */:
                                                promises[indice] = Dashboards.checkChartData(view) ? view.getChartData().then((chart) => ({
                                                    type: 2 /* Controls.ReportViewBlockType.charts */,
                                                    data: chart
                                                })) :
                                                    _renderImage(reportObject, view);
                                                break;
                                            case 1 /* Dashboards.ViewType.map */:
                                                promises[indice] = _renderImage(reportObject, view);
                                                break;
                                            default:
                                                break;
                                        }
                                    }
                                }
                            }
                        });
                        let report = {
                            metadata: metadata,
                            data: {
                                tokens: data.tokens,
                                views: promises
                            }
                        };
                        this.control.setPage(report, indice);
                    }
                    else {
                        this._updateReport(model, indice, sequence);
                    }
                }
            }
            _updateReport(model, indice, sequence) {
                if (!this.control.isLoading()) {
                    this.control.setUrl();
                    this.control.loadingStart();
                }
                model.getImage(this.control.width, this.control.height, indice).then(data => sequence === this._sequence && this._onImageReady(data));
            }
            _update(model) {
                let data = this._data, sequence = ++this._sequence;
                this._isData = false;
                this.control.clear();
                if (model) {
                    model.getType().then(viewType => {
                        if (viewType === 100 /* Dashboards.ViewType.report */) {
                            let reportModel = model, indice = (this.options && this.options.page) || 0;
                            data ?
                                Promise.all([reportModel.getReportMetadata(), reportModel.getReportData()]).then(([metadata, data]) => this._onReport(reportModel, metadata, data, indice, sequence)) :
                                this._updateReport(reportModel, indice, sequence);
                        }
                        else if ((viewType === 4 /* Dashboards.ViewType.chart */) || (viewType === 5 /* Dashboards.ViewType.spreadSheet */)) {
                            let chartModel = model;
                            (this._isData = data && chartModel.drawable) ?
                                chartModel.getChartData().then(chart => this._onChartReady(chart, sequence)) :
                                super._update(model);
                        }
                    });
                }
            }
            get options() {
                return this._options;
            }
            set options(value) {
                this._options = value;
                this.refresh();
            }
            get isData() {
                return this._data && this._model && this._isData;
            }
        }
        Dashboards.ChartAdapter = ChartAdapter;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
;
///<reference path="../../AFC.ts" />
///<reference path="../../models/data/Data.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        const KEYWORD_MODE_COLLAPSED = "collapsed";
        ;
        ;
        class ConfigGroupModel extends AFC.Tools.EventSink {
            constructor(handlers, curSelDefault, maxListSize, maxItem) {
                super();
                this._curSel = null;
                this._list = [];
                this._defaultList = [];
                this._mode = KEYWORD_MODE_COLLAPSED;
                this._sortedList = [];
                this._fnCompare = null;
                this._maxListSize = 10;
                this._curSel = curSelDefault ?? null;
                this._maxListSize = maxListSize ?? this._maxListSize;
                this._fnCompare = handlers.fnCompare ?? this._fnCompare;
                this.formatItem = handlers.fnFormatItem ?? this.formatItem;
            }
            addItem(item) {
                const model = this;
                if (void 0 === this._list.find(e => 0 === model._compareItems(e, item))) {
                    this._list.push(item);
                    this._sortList();
                }
            }
            get maxListSize() {
                return this._maxListSize;
            }
            set maxListSize(maxListSize) {
                let index = this._curSel ?? 0;
                let item = this.item(index, true);
                this._maxListSize = maxListSize;
                this._list = this._list.slice(0, this._maxListSize);
                this.select(item.dataItem);
                this._sortList();
            }
            get length() {
                return this._mode === KEYWORD_MODE_COLLAPSED && this.maxItem !== void 0 ?
                    Math.min(this.maxItem, this._sortedList.length) : this._sortedList.length;
            }
            set mode(collapse) {
                this._mode = collapse ?? "";
            }
            get mode() {
                return this._mode;
            }
            get list() {
                return this._list;
            }
            set selection(index) {
                this._curSel = index;
            }
            get selection() {
                return this._curSel;
            }
            get fnCompare() {
                return this._fnCompare;
            }
            set fnCompare(fnCompare) {
                this._fnCompare = fnCompare;
            }
            /**
             * Construct data from default list and storage, then sort
             * @returns ConfigGroupModel self for chaining
             */
            _buildData() {
                const model = this;
                if (model._list.length === 0) {
                    model._list = model.getDefaultList();
                }
                model._sortList();
                return model;
            }
            /**
             * Select item from group
             * @param item
             * @returns ConfigGroupModel self for chaining
             */
            select(item) {
                const model = this;
                let index;
                if (item) {
                    index = this._list.findIndex(e => model._fnCompare(e, item) === 0);
                    if (index > 0) {
                        var tmp = model._list[index];
                        model._list.splice(index, 1);
                        model._list.unshift(tmp);
                    }
                    else if (index === -1) {
                        model._list.unshift(item);
                        model._list = model._list.slice(0, model.maxListSize);
                        model._sortList();
                        this.fireEvent(6 /* Tools.EventType.Dirty */);
                    }
                    model._curSel = model._selectItem(item);
                }
                return model;
            }
            /**
             * Format item for display, eg. override for Config list
             * @param item
             * @returns
             */
            formatItem(item) {
                return item;
            }
            /**
             * Return item value in sortedList or list, according to given index
             * @param itemIndex
             * @param rawIndex
             * @returns
             */
            item(itemIndex, rawIndex) {
                var item;
                if (rawIndex || this.mode !== KEYWORD_MODE_COLLAPSED) {
                    if (itemIndex >= 0 && itemIndex < this._sortedList.length) {
                        item = this._sortedList[itemIndex];
                    }
                }
                else {
                    item = this._list[itemIndex];
                    itemIndex = this._selectItem(item);
                }
                return { dataItem: this.formatItem(item), dataItemIndex: itemIndex };
            }
            _selectItem(item) {
                const model = this;
                return model._list.findIndex((__e, __i) => {
                    return model._compareItems(item, model.item(__i, true).dataItem) === 0;
                });
            }
            _compareItems(a, b) {
                if (this._fnCompare) {
                    return this._fnCompare(a, b);
                }
                if (a < b) {
                    return -1;
                }
                if (a > b) {
                    return 1;
                }
                return 0;
            }
            _sortList() {
                this._sortedList = this.copyList(this._list);
                this._sortedList.sort(this._compareItems.bind(this));
                return this;
            }
            copyList(list) {
                return JSON.parse(JSON.stringify(list));
            }
            setDefaultList(data) {
                this._defaultList = data;
                this.setList(this._defaultList);
                return this;
            }
            getDefaultList() {
                return this._defaultList;
            }
            setList(data) {
                this._list = data;
                this._buildData();
                return this;
            }
        }
        Dashboards.ConfigGroupModel = ConfigGroupModel;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
;
/**
 * Created by jean.rennes on 19/09/2017.
 */
///<reference path="../Global.ts" />
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        function _check(value) {
            return (value === null) ? void 0 : value;
        }
        function _f1(key, value) {
            return value && _check(value[key]);
        }
        function _f2(key0, key1, value) {
            return value && value[key0] && _check(value[key0][key1]);
        }
        function _fn(keys, value) {
            for (let i = 0; i < keys.length; ++i) {
                if (_check(value) === void 0)
                    return;
                value = value[keys[i]];
            }
            return value;
        }
        function resolveTemplate(templateName, template, value, key, dataBinder, formatNumbers) {
            let ret = dataBinder && dataBinder(templateName, key, value);
            if (ret === void 0) {
                let accelerator = (template.accelerators || (template.accelerators = {}))[key];
                if (!accelerator) {
                    let items = Repeater.splitKey(key);
                    accelerator = template.accelerators[key] = items.length < 2 ? _f1.bind(null, items[0]) : (items.length < 3 ? _f2.bind(null, items[0], items[1]) : _fn.bind(null, items));
                }
                ret = accelerator(value);
            }
            if (formatNumbers && AFC.Tools.Data.isNumber(ret)) {
                let formatHelper = new AFC.Tools.StringTools.FormatString('', 2 /* AFC.Data.DataKind.real */);
                ret = formatHelper.getFormated(ret);
            }
            return ret === void 0 ? '' : ret;
        }
        class Repeater extends Controls.Control {
            static splitKey(key) {
                let regex = /(\[\s*("|')(.*)\2\])|(\.(\w*))/g, result, items;
                do {
                    result = regex.exec(key);
                    if (!items) {
                        let lastIndex;
                        if (result) {
                            lastIndex = result.index;
                        }
                        items = [key.substring(0, lastIndex)];
                    }
                    result && items.push(result[3] || result[5]);
                } while (result);
                return items;
            }
            setFormatNumbers(formatNumbers) {
                this._formatNumbers = formatNumbers;
            }
            static generateContent(container, templateName, template, value, dataBinder, formatNumbers) {
                let div = document.createElement('div');
                div.innerHTML = (template && template.content.replace(/{{([^}]+)}}/ig, (match, p1) => resolveTemplate(templateName, template, value, p1, dataBinder, formatNumbers))) || '';
                while (div.childNodes.length) {
                    container.appendChild(div.firstChild);
                }
            }
            setTemplate(value, name) {
                if (name === void 0) {
                    value ? this._template = { content: value } : delete this._template;
                }
                else if (value) {
                    (this._templates || (this._templates = {}))[name] = { content: value };
                }
                else if (this._templates) {
                    delete this._templates[name];
                }
            }
            addItem(value, templateName) {
                let template = (templateName && this._templates && this._templates[templateName]) || this._template;
                Repeater.generateContent(this.node, templateName, template, value, this.dataBinder, this._formatNumbers);
            }
            empty() {
                $(this.node).empty();
            }
        }
        Controls.Repeater = Repeater;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 19/09/2017.
 */
///<reference path="../../models/data/Data.ts" />
///<reference path="../../views/controls/Repeater.ts" />
///<reference path="../../helpers/AdapterBase.ts" />
var AFC;
(function (AFC) {
    var Data;
    (function (Data) {
        class RepeaterAdapter extends AFC.Tools.AdapterBase {
            constructor(control) {
                super();
                this.control = control;
            }
            _update(model) {
                this.onClear && this.onClear();
                this.control.empty();
                if (model) {
                    let containers = [], maxItem = model.length, compare = (container0, container1) => {
                        let ret = this.compare(container0, container1);
                        return ret || (container0.dataItemIndex - container1.dataItemIndex);
                    }, push = this.compare ?
                        (container) => {
                            let i = AFC.Tools.lower_bound(containers, container, compare);
                            if (i < containers.length) {
                                (i < maxItem) && containers.splice(i, 0, container);
                                (containers.length > maxItem) && containers.pop();
                            }
                            else if (i < maxItem) {
                                containers.push(container);
                            }
                            return true;
                        } : (container) => {
                        if (containers.length < maxItem) {
                            containers.push(container);
                            return true;
                        }
                    }, container;
                    (this.maxItem !== void 0) && (maxItem = Math.min(this.maxItem, maxItem));
                    for (let i = 0; i < model.length; ++i) {
                        container = model.item(i);
                        if ((!this.filter || this.filter(container)) && !push(container)) {
                            break;
                        }
                    }
                    for (let i = 0; i < containers.length; ++i) {
                        this.control.addItem(container = containers[i], this.template ? this.template(container) : void 0);
                    }
                }
                this.onGenerate && this.onGenerate();
            }
            unbind() {
                this.control.empty();
                super.unbind();
            }
        }
        Data.RepeaterAdapter = RepeaterAdapter;
    })(Data = AFC.Data || (AFC.Data = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 19/09/2017.
 */
///<reference path="../../models/data/Data.ts" />
///<reference path="../../models/dashboards/ConfigGroupModel.ts" />
///<reference path="../../views/controls/Repeater.ts" />
///<reference path="../../helpers/AdapterBase.ts" />
///<reference path="../../adapters/data/RepeaterAdapter.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        const KEYWORD_MODE_COLLAPSED = "collapsed";
        ;
        ;
        class StorageHelper {
            constructor(mruId, storageActive) {
                this.mruSize = 10;
                this.storageActive = true;
                this.setItems = (key, item) => {
                    this.storageActive && this._setItems && this._setItems(key, item);
                };
                this.getItems = (key) => {
                    return this.storageActive && this._getItems ? this._getItems(key) : null;
                };
                if (mruId)
                    this.mruId = mruId;
                if (void 0 !== storageActive)
                    this.storageActive = storageActive;
            }
            set customSetItems(fnSetItems) {
                this._setItems = fnSetItems;
            }
            get customSetItems() {
                return this._setItems;
            }
            set customGetItems(fnGetItems) {
                this._getItems = fnGetItems;
            }
            get customGetItems() {
                return this._getItems;
            }
        }
        class ConfigGroupAdapter extends AFC.Data.RepeaterAdapter {
            constructor(control) {
                super(control);
                this._list = [];
                this._sortedList = [];
                this.defaultSelection = null;
                /**
                 * Return template name according to current model.mode
                 *
                 * @param item
                 * @returns "collapsed-selected" | "collapsed" | "selected"
                 */
                this.template = (item) => {
                    let templateNames = [];
                    if (this._model.mode === "collapsed") {
                        templateNames.push("collapsed");
                    }
                    if (item.dataItemIndex === this._model.selection) {
                        templateNames.push("selected");
                    }
                    return templateNames.join("-");
                };
                this.storageHelper = new StorageHelper();
            }
            get storageSetItems() {
                return (items) => this.storageHelper.setItems(this.storageHelper.mruId, items);
            }
            get storageGetItems() {
                return () => this.storageHelper.getItems(this.storageHelper.mruId);
            }
            get mruId() {
                return this.storageHelper.mruId;
            }
            set mruId(mruId) {
                this.storageHelper.mruId = mruId;
            }
            get mruSize() {
                return this.storageHelper.mruSize;
            }
            set mruSize(mruSize) {
                if (mruSize <= 0 || mruSize >= 20) {
                    throw new Error("Incorrect value for mruSize (must be between 0 and 20).");
                }
                this.storageHelper.mruSize = mruSize;
                this.model.maxListSize = mruSize;
                this.storageSetItems(this.model.list);
                this.refresh();
            }
            set storageHandlers(handlers) {
                if (handlers.setItems)
                    this.storageHelper.customSetItems = handlers.setItems;
                if (handlers.getItems)
                    this.storageHelper.customGetItems = handlers.getItems;
            }
            set model(model) {
                this._model = model;
            }
            get model() {
                return this._model;
            }
            set mode(collapse) {
                if (this._model)
                    this._model.mode = collapse;
            }
            get mode() {
                return this._model?.mode;
            }
            selectByDefault(item) {
                if (this.defaultSelection === null) {
                    this.select(item);
                }
            }
            select(item) {
                this._model?.select(item);
            }
            bindTo(model) {
                let newListnewList = this.storageGetItems() || [];
                model.setList(newListnewList);
                // Save to datastorage
                this.storageSetItems(model.list);
                super.bindTo(model);
            }
            toggleCollapse(forceCollapse) {
                this.mode = forceCollapse ? KEYWORD_MODE_COLLAPSED : "";
                this.refresh();
            }
            /**
             * Do something before show or hide manual edition box (DOM elem #manualEdition),
             * then triggers control AfcGuiConfigGroup toggleManualEdition default function
             * @see AFC.gui.AfcGuiConfigGroup.toggleManualEdition
             * @param event
             * @param itemElem
             * @param forceCollapse
             * @returns
             */
            toggleManualEdition(event, itemElem, forceCollapse) {
                const handlers = this.handlers;
                return void 0 !== handlers.fnToggleManualEdition ?
                    handlers.fnToggleManualEdition(event, itemElem, forceCollapse)
                    : Promise.resolve();
            }
            async onListItemClick(event, itemElem) {
                const currAdapter = this;
                const handlers = currAdapter.handlers;
                const clickedValue = parseInt(itemElem.dataset.value, 10);
                const model = currAdapter.model;
                let item;
                if (!Number.isNaN(clickedValue)) {
                    if (clickedValue !== model.selection) {
                        item = model.item(clickedValue, true);
                        if (void 0 !== handlers.fnOnListItemClick) {
                            return handlers.fnOnListItemClick(event, item.dataItem).then(() => {
                                model.select(item.dataItem);
                                currAdapter.refresh();
                                return Promise.resolve(false);
                            }, () => Promise.reject());
                        }
                    }
                }
                else {
                    return Promise.reject();
                }
                return Promise.resolve(true);
            }
            onListBtnClick(event, params) {
                const handlers = this.handlers;
                let item;
                if (params && params.length) {
                    item = handlers.fnCreateItemFromInput(params);
                    if (void 0 !== handlers.fnOnListItemClick) {
                        return handlers.fnOnListItemClick(event, item).then(() => {
                            this.model.select(item);
                            this.refresh();
                            return Promise.resolve(); // Click "Valider"
                        }, () => Promise.reject());
                    }
                }
                return Promise.resolve(); // Click "Annuler"
            }
        }
        Dashboards.ConfigGroupAdapter = ConfigGroupAdapter;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 06/10/2015.
 */
///<reference path="../Global.ts" />
///<reference path="Control.ts" />
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        class ListBox extends Controls.Control {
            constructor(element) {
                super(element);
                this._multiSelect = false;
                this.node.addEventListener('click', this._onClick.bind(this));
            }
            get selected() {
                return this._selected || [];
            }
            _build(container, items) {
                let ul = document.createElement('ul');
                let query = $(ul);
                items.forEach((item) => { query.append(`<li><a id='${item.id}' href='javascript:void 0;'>${item.name || ''}</a></li>`); });
                container.append(ul);
                return query.find('a');
            }
            _checkSelection(oldItems, oldSelected) {
                if (this._items && oldItems && oldSelected) {
                    oldSelected.forEach((j) => {
                        for (let i = 0; i < this._items.length; ++i) {
                            if (this._items[i].id === oldItems[j].id) {
                                (this._selected || (this._selected = [])).push(i);
                                break;
                            }
                        }
                    });
                }
            }
            _refresh() {
                if (this._pending === void 0) {
                    this._pending = setTimeout(() => {
                        delete this._pending;
                        this._list.removeClass('selected');
                        this._selected && this._selected.forEach((i) => $(this._list[i]).addClass('selected'));
                    }, 0);
                }
            }
            _onClick(e) {
                if (this._multiSelect)
                    throw new Error('Not implemented');
                let selection = e && this._list.index(e.target);
                (selection !== void 0) && (selection >= 0) ? (this._selected = [selection]) : delete this._selected;
                this._refresh();
                this._dispatchChange();
            }
            set multiSelect(value) {
                this._multiSelect = value;
            }
            get multiSelect() {
                return this._multiSelect;
            }
            setItems(items) {
                let oldItems = this._items;
                let oldSelected = this._selected;
                let container = $(this.node);
                container.empty();
                delete this._items;
                delete this._selected;
                delete this._list;
                if (items && items.length) {
                    this._list = this._build(container, this._items = items);
                    this._checkSelection(oldItems, oldSelected);
                    this._refresh();
                }
            }
            getItems() {
                return this._items;
            }
            select(selection) {
                if (selection && selection.length) {
                    this._selected = this._multiSelect ? selection.filter((i) => i < this._items.length) : [selection[0]];
                }
                else
                    delete this._selected;
                this._refresh();
            }
        }
        Controls.ListBox = ListBox;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 28/09/2015.
 */
///<reference path="../../models/dashboards/Dashboard.ts" />
///<reference path="../../views/controls/ListBox.ts" />
///<reference path="../../helpers/AdapterBase.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        function _viewComp(pos, view0, view1) {
            let str0, str1;
            if (pos !== void 0) {
                view0.properties[pos] && (str0 = view0.properties[pos][2]);
                view1.properties[pos] && (str1 = view1.properties[pos][2]);
            }
            if ((str0 === str1) && (view0.name === view1.name))
                return 0;
            if (str0)
                return str1 ? parseInt(str0) - parseInt(str1) : -1;
            return str1 ? 1 : (view0.name < view1.name ? -1 : 1);
        }
        function _filterView(dashboard, visible, view) {
            return (visible === void 0) || view.properties[visible][2];
        }
        function _filterNone(dashboard, visible, filter) {
            let views = dashboard.views.filter((view) => filter ? filter(dashboard, view) : _filterView(dashboard, visible, view));
            views.sort(_viewComp.bind(null, dashboard.viewsProperties.order));
            return [{ id: '', items: views || [] }];
        }
        let SelectorType;
        (function (SelectorType) {
            SelectorType[SelectorType["map"] = 1] = "map";
            SelectorType[SelectorType["grid"] = 2] = "grid";
            SelectorType[SelectorType["chart"] = 3] = "chart";
        })(SelectorType = Dashboards.SelectorType || (Dashboards.SelectorType = {}));
        const SelectorTypeMap = {
            map: 1 /* SelectorType.map */,
            grid: 2 /* SelectorType.grid */,
            chart: 3 /* SelectorType.chart */
        };
        const TypeMap = {
            [1 /* Dashboards.ViewType.map */]: 1 /* SelectorType.map */,
            [2 /* Dashboards.ViewType.detailedSheet */]: 2 /* SelectorType.grid */,
            [3 /* Dashboards.ViewType.aggregatedSheet */]: 2 /* SelectorType.grid */,
            [4 /* Dashboards.ViewType.chart */]: 3 /* SelectorType.chart */,
            [100 /* Dashboards.ViewType.report */]: 3 /* SelectorType.chart */
        };
        function _getType(view, viewsProperties) {
            return (view.type === 5 /* Dashboards.ViewType.spreadSheet */) ?
                (( /*viewsProperties.isgrid ? view.properties[viewsProperties.isgrid][2] :*/(view.descriptor.displayType === 0 /* Dashboards.SpreadSheetDisplayType.grid */)) ? 2 /* SelectorType.grid */ : 3 /* SelectorType.chart */) :
                TypeMap[view.type];
        }
        function _filterByType(dashboard, visible, filter) {
            let viewsProperties = dashboard.viewsProperties;
            let a1 = [];
            let a0 = [];
            dashboard
                .views
                .slice()
                .sort(_viewComp.bind(null, viewsProperties.order))
                .forEach((view) => {
                let _type;
                (filter ? filter(dashboard, view) : _filterView(dashboard, visible, view)) && (_type = _getType(view, viewsProperties)) && (a0[_type] || (a0[_type] = [])).push(view);
            });
            a0[1 /* SelectorType.map */] && a1.push({ id: 'map', items: a0[1 /* SelectorType.map */] });
            a0[2 /* SelectorType.grid */] && a1.push({ id: 'grid', items: a0[2 /* SelectorType.grid */] });
            a0[3 /* SelectorType.chart */] && a1.push({ id: 'chart', items: a0[3 /* SelectorType.chart */] });
            return a1;
        }
        function _filterByLink(dashboard, visible, filter) {
            let viewsProperties = dashboard.viewsProperties;
            let link = viewsProperties.link;
            let a, b = [];
            if (link !== void 0) {
                let label, ref = {};
                a = dashboard.views.filter((view) => (filter ? filter(dashboard, view) : _filterView(dashboard, visible, view)) && view.properties[link][2]);
                a.sort((view0, view1) => {
                    let p0 = _getType(view0, viewsProperties), p1 = _getType(view1, viewsProperties);
                    return p0 === p1 ? _viewComp(viewsProperties.order, view0, view1) : p0 - p1;
                });
                a.forEach((view) => {
                    let holder, group;
                    view.properties[link][2].split(',').map((label) => label.trim()).forEach((label) => {
                        if (!(holder = ref[label])) {
                            ref[label] = holder = { id: view.id, name: label, properties: view.properties };
                            b.push(holder);
                        }
                        group = _getType(view, viewsProperties);
                        !holder[group] && (holder[group] = view);
                    });
                });
            }
            return [{ id: '', items: b }];
        }
        let SelectorMode;
        (function (SelectorMode) {
            SelectorMode[SelectorMode["none"] = 0] = "none";
            SelectorMode[SelectorMode["type"] = 1] = "type";
            SelectorMode[SelectorMode["link"] = 2] = "link";
        })(SelectorMode = Dashboards.SelectorMode || (Dashboards.SelectorMode = {}));
        const SelectorFilters = {
            [0 /* SelectorMode.none */]: _filterNone,
            [1 /* SelectorMode.type */]: _filterByType,
            [2 /* SelectorMode.link */]: _filterByLink
        };
        class SelectorAdapter extends AFC.Tools.AdapterBase {
            constructor(selector) {
                super();
                (this._selector = selector).dispatchChange = this._onClick.bind(this);
                this._mode = 0 /* SelectorMode.none */;
                this[1 /* SelectorType.map */] = new Dashboards.MapModel();
                this[2 /* SelectorType.grid */] = new Dashboards.GridModel();
                this[3 /* SelectorType.chart */] = new Dashboards.ChartModel();
                this.on(6 /* Tools.EventType.Dirty */, AFC.Tools.AfcReferenceMixin(async (event) => {
                    let groups = this._groups;
                    if (!this.map.id && !this.grid.id && !this.chart.id) {
                        this._selector.setGroups(groups);
                        if (this._selection) {
                            this._selector.select(groups[0].id);
                        }
                        else {
                            let eventData = (this._initial && await this.selectItem(this._initial)) || this._selectItem(groups[0], 0);
                            delete this._initial;
                            this.onChange && this.onChange(eventData);
                        }
                    }
                }, this._refresh), this);
            }
            _update(model, event) {
                const dashboard = model.dashboard;
                if (dashboard !== this._dashboard) {
                    delete this._selection;
                    this._dashboard = dashboard;
                    this._refresh();
                }
            }
            _refresh() {
                let dashboard = this._dashboard, groups;
                if (dashboard && (this._groups = groups = SelectorFilters[this._mode](this._dashboard, this._dashboard.viewsProperties.visible, this._filter))) {
                    //                delete this._selection;
                    this.fireEvent(6 /* Tools.EventType.Dirty */);
                }
            }
            set filter(value) {
                this._filter = value;
                this._refresh();
            }
            get filter() {
                return this._filter;
            }
            set mode(value) {
                if (this._mode !== value) {
                    this._mode = value;
                    this._refresh();
                }
            }
            get mode() {
                return this._mode;
            }
            get map() {
                return this[1 /* SelectorType.map */];
            }
            get grid() {
                return this[2 /* SelectorType.grid */];
            }
            get chart() {
                return this[3 /* SelectorType.chart */];
            }
            _updateView(view, group, item, _type, eventData) {
                let id = view && view.id;
                eventData || (eventData = { group: group, item: item });
                if (id !== this[_type].id) {
                    this[_type].setId(id);
                    switch (_type) {
                        case 1 /* SelectorType.map */:
                            eventData.map = view;
                            break;
                        case 2 /* SelectorType.grid */:
                            eventData.grid = view;
                            break;
                        case 3 /* SelectorType.chart */:
                            eventData.chart = view;
                            break;
                    }
                }
                return eventData;
            }
            _onClick() {
                let eventData = this._setViews(this._selector.selected);
                eventData && this.onChange && this.onChange(eventData);
            }
            _setViews(selection) {
                let group = selection.group, item = selection.item, eventData;
                if (group && (item !== void 0)) {
                    let view;
                    let _type;
                    this._selection = selection;
                    if (this._mode === 1 /* SelectorMode.type */) {
                        (_type = SelectorTypeMap[group.id]) && (eventData = this._updateView(view = group.items[item], group.id, view.id, _type));
                    }
                    else if (this._mode === 2 /* SelectorMode.link */) {
                        let holder = group.items[item];
                        eventData = this._updateView(holder[1 /* SelectorType.map */], group.id, holder.id, 1 /* SelectorType.map */);
                        eventData = this._updateView(holder[2 /* SelectorType.grid */], group.id, holder.id, 2 /* SelectorType.grid */, eventData);
                        eventData = this._updateView(holder[3 /* SelectorType.chart */], group.id, holder.id, 3 /* SelectorType.chart */, eventData);
                    }
                    else {
                        (view = group.items[item]) && (_type = _getType(view, this._dashboard.viewsProperties)) && (eventData = this._updateView(view, group.id, view.id, _type));
                    }
                }
                return eventData;
            }
            _selectItem(group, indice) {
                let items = group.items;
                if (items.length > 0) {
                    this._selector.select(group.id, items[indice < items.length ? indice : 0].id);
                    return this._setViews({
                        group: group,
                        item: indice
                    });
                }
                return null;
            }
            bindTo(model) {
                this[1 /* SelectorType.map */].dashboardModel = model;
                this[2 /* SelectorType.grid */].dashboardModel = model;
                this[3 /* SelectorType.chart */].dashboardModel = model;
                super.bindTo(model);
            }
            unbind() {
                this._selector.setGroups();
                delete this._selection;
                super.unbind();
            }
            async next() {
                if (this._groups) {
                    let selected = this._selection;
                    let group;
                    if (group = selected.group || this._groups[0]) {
                        let next = selected.item !== void 0 ? (selected.item + 1) % group.items.length : 0;
                        return this._selectItem(group, next); // To do : do real async someday :(
                    }
                }
            }
            async previous() {
                if (this._groups) {
                    let selected = this._selection;
                    let group;
                    if (group = selected.group || this._groups[0]) {
                        let previous = selected.item !== void 0 ? (group.items.length + selected.item - 1) % group.items.length : group.items.length - 1;
                        return this._selectItem(group, previous); // To do : do real async someday :(
                    }
                }
            }
            async selectItem(value) {
                if (this._groups) {
                    let selected = this._selection, group, name, indice;
                    if (group = (selected && selected.group) || this._groups[0]) {
                        indice = value !== void 0 ?
                            (name = value.toLowerCase(), AFC.Tools.indexOf(group.items, (item) => (item.id === value) || (item.name.toLowerCase() === name))) :
                            0;
                        return (indice !== -1) && this._selectItem(group, indice); // To do : do real async someday :(
                    }
                }
                else {
                    this._initial = value;
                }
            }
            getDashboardFilter(mode) {
                return (dashboard) => dashboard && SelectorFilters[mode](dashboard, dashboard.viewsProperties.visible, this._filter);
            }
        }
        1 /* SelectorType.map */, 2 /* SelectorType.grid */, 3 /* SelectorType.chart */;
        Dashboards.SelectorAdapter = SelectorAdapter;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
;
/**
 * Created by jean.rennes on 03/02/2016.
 */
///<reference path="../Global.ts" />
///<reference path="Control.ts" />
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        class RadioGroup extends Controls.Control {
            constructor(element, name) {
                super(element);
                this._name = name || `__radioGroup${RadioGroup._cnt++}`;
                this.node.addEventListener('click', this._onClick.bind(this));
            }
            get checked() {
                return this._checked;
            }
            _build(items, query, name) {
                items.forEach((item, indice) => {
                    let s = `${name}|${indice}`, checked = indice === this._checked ? 'checked' : '';
                    query.append(`<div><input name='${name}' id='${s}' ${checked} type='radio' value='${indice}' /><span><label for='${s}'>${item.name || ''}</label></span></div>`);
                });
            }
            _onClick(event) {
                let id = event.target.value;
                let i = parseInt(id);
                if (!isNaN(i) && (this._checked !== i)) {
                    this._checked = i;
                    this._dispatchChange();
                }
            }
            setItems(items) {
                let container = $(this.node);
                delete this._checked;
                container.empty();
                items ? this._build(this._items = items, container, this._name) : delete this._items;
            }
            getItems() {
                return this._items;
            }
            check(i) {
                let u = this._checked;
                if (this._checked !== i) {
                    let inputs = this.node.getElementsByTagName("input");
                    delete this._checked;
                    $(inputs).prop("checked", false);
                    if (i !== void 0) {
                        this._checked = i;
                        inputs[i].checked = true;
                    }
                }
                return u;
            }
        }
        RadioGroup._cnt = 0;
        Controls.RadioGroup = RadioGroup;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 03/02/2016.
 */
///<reference path="../../models/dashboards/Dashboard.ts" />
///<reference path="../../views/controls/RadioGroup.ts" />
///<reference path="../../helpers/AdapterBase.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        class RedistrictAdapter extends AFC.Tools.AdapterBase {
            constructor(radioGroup) {
                super();
                this._control = radioGroup;
                this._codeColumn = -1;
            }
            _onDescriptor(descriptor) {
                let partition = descriptor && descriptor.partition, subsets = partition && partition.subsets.filter((subset) => subset.type !== 11 /* ZoneType.subsetUnion */);
                this._codeColumn = descriptor.dataNodes.findIndex(dataNode => dataNode.qualifier === 1 /* DataQualifier.code */);
                this._control.setItems(subsets || []);
                this._control.check(0);
            }
            _update(model) {
                model.getDescriptor().then(this._onDescriptor.bind(this));
            }
            affectRow(row) {
                let i = this._control.checked, codeColumn = this._codeColumn;
                if ((i !== void 0) && (codeColumn !== -1)) {
                    let subsets = this._control.getItems(), subset = subsets && subsets[0];
                    this._model.district.affect(row[codeColumn], subset.id);
                }
            }
        }
        Dashboards.RedistrictAdapter = RedistrictAdapter;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 08/10/2015.
 */
///<reference path="../Global.ts" />
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        const _px2pt = 0.75;
        function _size(size, autoSize) {
            return autoSize ? `${Math.round(size * 100) / 100}px` : `${Math.round(size * _px2pt * 10) / 100}em`; // reference is 10 pt
        }
        function _setWidth(element, widths) {
            widths && widths.length && (element.style.width = element.style.minWidth = `${widths.shift()}%`);
        }
        function _getAlignment(cell) {
            return cell && cell.textAlign ? cell.textAlign : 'left';
        }
        function _getVAlignment(cell) {
            return cell && cell.verticalAlign ? cell.verticalAlign : 'center';
        }
        function _getFontSize(cell, autoSize) {
            let fontSize = cell && cell.fontSize;
            return fontSize && (autoSize ? `calc(${fontSize} + 0.1em)` : _pt2em(fontSize));
        }
        let cssImageClasses;
        function _setCellData(grid, gridApp, element, container, cell, fontSize, x, y) {
            let renderer = cell.renderer, value, templateName, template;
            cell.className && (element.className = cell.className);
            if (!renderer || (renderer == 1 /* Globals.GridRenderer.text */) || (renderer == 5 /* Globals.GridRenderer.trendAndText */) || grid.template) {
                templateName = grid.template && grid.templates && grid.template(value = {
                    positionX: x,
                    positionY: y,
                    templateCell: cell
                });
                template = (templateName !== void 0) && grid.templates[templateName];
                if (template) {
                    Controls.Repeater.generateContent(container, templateName, template, value, grid.dataBinder);
                }
                else {
                    container.innerHTML = cell.text ?? '';
                }
            }
            if (cell.image || cell.symbol) {
                let align, valign, image, style = element.style;
                if (cell.image) {
                    style.background = `url('${cell.image}') no-repeat padding-box border-box`;
                }
                else if (image = gridApp.getSymbol(cell.symbol)) {
                    let key = `CTA-RULE-${cell.symbol}`;
                    element.className = key;
                    if (!(cssImageClasses || (cssImageClasses = {}))[key]) {
                        let rule = document.createElement('style');
                        rule.type = 'text/css';
                        rule.innerHTML = `.${key} { background: url('data:image/svg+xml;utf8,${image.replace(/#/g, '%23')}') no-repeat padding-box border-box;}`;
                        document.getElementsByTagName('head')[0].appendChild(rule);
                        cssImageClasses[key] = true;
                    }
                    element.className = key;
                }
                align = _getAlignment(cell);
                if (renderer !== 4 /* Globals.GridRenderer.trend */) {
                    align = (align === 'left') ? 'right' : 'left';
                }
                valign = _getVAlignment(cell);
                if (valign === 'middle') {
                    valign = '';
                }
                else {
                    align = align === 'center' ? valign : `${align} ${valign}`;
                }
                align && (style.backgroundPosition = align);
                fontSize && (style.backgroundSize = `${fontSize} ${fontSize}`);
                cell.backgroundColor && (style.backgroundColor = cell.backgroundColor);
            }
        }
        function _pt2em(str) {
            return `${parseInt(str) / 10}em`; // 10 pt is the reference
        }
        function _makeCell(grid, gridApp, element, cell, widths, height, autoSize, x, y) {
            let container = element, fontSize = _getFontSize(cell, autoSize);
            _setWidth(element, widths);
            height && (element.style.height = _size(height, autoSize));
            if (cell) {
                let style = element.style, paddingSize = cell.padding;
                style.boxSizing = 'border-box';
                if (paddingSize) {
                    container = document.createElement('SPAN');
                    style.padding = autoSize ? paddingSize : paddingSize.split(' ').map(_pt2em).join(' ');
                    element.appendChild(container);
                }
                fontSize && (element.style.lineHeight = container.style.fontSize = fontSize);
                style.color = cell.color;
                style.backgroundColor = cell.backgroundColor;
                style.textAlign = _getAlignment(cell);
                style.verticalAlign = _getVAlignment(cell);
                style.fontWeight = cell.fontWeight;
                style.fontFamily = cell.fontFamily;
                style.borderStyle = cell.borderStyle;
                style.borderWidth = cell.borderWidth;
                style.borderColor = cell.borderColor;
                style.textDecoration = cell.textDecoration;
                style.fontStyle = cell.fontStyle;
                cell.whiteSpace && (style.whiteSpace = cell.whiteSpace);
                _setCellData(grid, gridApp, element, container, cell, fontSize, x, y);
            }
        }
        function _setSize(container, width, initialWidth) {
            let ratio = width / initialWidth, style = container.style;
            style.fontSize = `${Math.round(ratio * 1333) / 100}px`;
            return [width, initialWidth];
        }
        class GridView extends Controls.Control {
            constructor(element, noAutoSize) {
                super(element);
                this.autoSize = !noAutoSize;
                this.node.addEventListener('click', this._onClick.bind(this));
            }
            _onClick(e) {
                if (this.onCellClick) {
                    let cell = e.target;
                    while (cell && cell !== this.node) {
                        if (cell instanceof HTMLTableCellElement) {
                            let line = cell.parentNode, offsetX = this._gridApp.hasRowHeader ? -1 : 0, offsetY = this._gridApp.hasColumnHeader ? -1 : 0;
                            this.onCellClick(cell.cellIndex + offsetX, line.rowIndex + offsetY);
                            return;
                        }
                        cell = cell.parentNode;
                    }
                }
            }
            _highlight(tbody, indice, oldIndice) {
                if (indice !== void 0 || oldIndice !== void 0) {
                    let rows = tbody?.rows, row;
                    if (rows) {
                        oldIndice !== void 0 && rows[oldIndice]?.removeAttribute('selected');
                        if (indice !== void 0 && (row = rows[indice])) {
                            row.setAttribute('selected', '');
                            row.scrollIntoView({ behavior: "auto", block: "nearest", inline: "nearest" });
                        }
                    }
                }
            }
            _buildFromGridApp(gridApp) {
                let table = document.createElement('table'), tbody, line, xCount = gridApp.getColumnCount(), yCount = gridApp.getRowCount(), widths = [], width = 0, height, x, y;
                table.style.tableLayout = 'fixed';
                if (gridApp.hasRowHeader) {
                    width = gridApp.getRowHeaderWidth();
                    widths.push(width);
                }
                for (x = 0; x < xCount; ++x) {
                    let value = gridApp.getColumnWidth(x);
                    widths.push(value);
                    width += value;
                }
                widths[0] = widths.reduce((accumulator, value, indice) => {
                    return accumulator - (widths[indice] = Math.round(100 * value / width));
                }, 100) + widths[0];
                if (this.autoSize) {
                    this._widths = _setSize(table, this.width, width);
                    table.style.width = '100%';
                }
                else {
                    table.style.width = _size(width, false);
                }
                if (gridApp.hasColumnHeader) {
                    let element, cell;
                    height = gridApp.getColumnHeaderHeight();
                    line = table.createTHead().insertRow();
                    if (gridApp.hasRowHeader) {
                        element = document.createElement('th');
                        _setWidth(element, widths);
                        line.appendChild(element);
                    }
                    for (x = 0; x < xCount; ++x) {
                        cell = gridApp.getColumnHeader(x);
                        element = document.createElement('th');
                        _makeCell(this, gridApp, element, cell, widths, height, this.autoSize, x, -1);
                        line.appendChild(element);
                    }
                }
                tbody = table.createTBody();
                for (y = 0; y < yCount; ++y) {
                    height = gridApp.getRowHeight(y);
                    line = tbody.insertRow();
                    this._allowSelection && (line.className = 'gridViewSelectableLine');
                    gridApp.hasRowHeader && _makeCell(this, gridApp, line.insertCell(), gridApp.getRowHeader(y), widths, height, this.autoSize, -1, y);
                    for (x = 0; x < xCount; ++x) {
                        _makeCell(this, gridApp, line.insertCell(), gridApp.getCell(x, y), widths, height, this.autoSize, x, y);
                    }
                }
                this._highlight(tbody, this._highlighted);
                this.node.appendChild(table);
            }
            refreshCell(positionX, positionY) {
                let gridApp = this._gridApp, table, x, y, rows, cells, container, gridAppCell;
                if (gridApp && this.node && (table = this.node.getElementsByTagName('table')[0])) {
                    y = positionY + (gridApp.hasColumnHeader ? 1 : 0);
                    if ((y >= 0) && (y < (rows = table.rows).length)) {
                        x = positionX + (gridApp.hasRowHeader ? 1 : 0);
                        if ((x >= 0) && (x < (cells = rows[y].cells).length)) {
                            if (positionX === -1) {
                                if (positionY !== -1)
                                    gridAppCell = gridApp.getRowHeader(positionY);
                            }
                            else if (positionY === -1) {
                                gridAppCell = gridApp.getColumnHeader(positionX);
                            }
                            else {
                                gridAppCell = gridApp.getCell(positionX, positionY);
                            }
                            $(container = gridAppCell && gridAppCell.padding ? cells[x].firstChild : cells[x]).empty();
                            _setCellData(this, gridApp, cells[x], container, gridAppCell, _getFontSize(gridAppCell, this.autoSize), positionX, positionY);
                        }
                    }
                }
            }
            _build() {
                $(this.node).empty();
                if (this._gridApp) {
                    this.loadingEnd();
                    this._buildFromGridApp(this._gridApp);
                }
                else {
                    this.loadingStart();
                }
            }
            get selection() {
                return this._highlighted;
            }
            get gridApp() {
                return this._gridApp;
            }
            setTemplate(value, name) {
                if (value) {
                    (this.templates || (this.templates = {}))[name] = { content: value };
                }
                else if (this.templates) {
                    delete this.templates[name];
                }
            }
            setGrid(gridApp, allowSelection) {
                delete this._highlighted;
                this._allowSelection = allowSelection;
                gridApp ? this._gridApp = gridApp : delete this._gridApp;
                this._build();
            }
            highlight(indice) {
                if (this._highlighted !== indice) {
                    let tbody = this.node.querySelector('tbody');
                    tbody && this._highlight(tbody, indice, this._highlighted);
                    this._highlighted = indice;
                }
            }
            invalidateSize() {
                if (this.autoSize) {
                    let width, table;
                    if (this._widths && this._widths[0] !== (width = this.width) && (table = this.node.getElementsByTagName('table')[0])) {
                        this._widths = _setSize(table, width, this._widths[1]);
                    }
                }
            }
        }
        Controls.GridView = GridView;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 08/10/2015.
 */
///<reference path="../../models/dashboards/Dashboard.ts" />
///<reference path="../../views/controls/GridView.ts" />
///<reference path="../../helpers/AdapterBase.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        function _compare(gridApp, sortedColumns, line0, line1) {
            let value0, value1, ret = 0, collator, sortedColumn;
            for (let i = sortedColumns.length; !ret && (i > 0); --i) {
                sortedColumn = sortedColumns[i - 1];
                value0 = gridApp.getValue(sortedColumn.name, line0);
                value1 = gridApp.getValue(sortedColumn.name, line1);
                if ((value0 === null) || (value1 === null)) {
                    if (value0 === null) {
                        ret = (value1 === null) ? 0 : 1;
                    }
                    else
                        ret = -1;
                }
                else {
                    ret = typeof value0 === 'string' ? (collator || (collator = new Intl.Collator(void 0, { sensitivity: 'base' }))).compare(value0, value1) : (((value0 < value1) && -1) || ((value0 > value1) && 1) || 0);
                    if (sortedColumn.descending)
                        ret *= -1;
                }
            }
            return ret || (line0 - line1);
        }
        function _buildIndex(gridApp, sortedColumns, index) {
            let a = index || Array.from(Array(gridApp.getRowCount()).keys());
            a.sort(_compare.bind(null, gridApp, sortedColumns));
            return a;
        }
        class SortableGridApp {
            constructor(gridApp) {
                let sortedColumns = gridApp.sortedColumns;
                this.gridApp = gridApp;
                this.allowOrdering = true;
                if (sortedColumns) {
                    this.sortedColumns = sortedColumns;
                    sortedColumns.length && (this._index = _buildIndex(gridApp, sortedColumns));
                }
            }
            getOriginalLine(line) {
                return this._index ? this._index[line] : line;
            }
            getTargetLine(line) {
                return this._index ? this._index.indexOf(line) : line;
            }
            get hasRowHeader() {
                return this.gridApp.hasRowHeader;
            }
            get hasColumnHeader() {
                return this.gridApp.hasColumnHeader;
            }
            getRowCount() {
                return this.gridApp.getRowCount();
            }
            getRowHeader(line) {
                return this.gridApp.getRowHeader(this.getOriginalLine(line));
            }
            getRowHeaderWidth() {
                return this.gridApp.getRowHeaderWidth();
            }
            getRowHeight(line) {
                return this.gridApp.getRowHeight(this.getOriginalLine(line));
            }
            getColumnInfo(column) {
                return this.gridApp.getColumnInfo(column);
            }
            getColumnCount() {
                return this.gridApp.getColumnCount();
            }
            getColumnHeader(column) {
                let cell = this.gridApp.getColumnHeader(column), columnInfo = this.gridApp.getColumnInfo(column), sortedColumn;
                if (columnInfo) {
                    if (this.sortedColumns && (sortedColumn = this.sortedColumns.find(sortedColumn => sortedColumn.name === columnInfo.name))) {
                        cell.className = 'gridViewSorted';
                        sortedColumn.descending && (cell.className += ' descending');
                    }
                    else if (columnInfo.supportOrdering) {
                        cell.className = 'gridViewSortable';
                    }
                }
                return cell;
            }
            getColumnHeaderHeight() {
                return this.gridApp.getColumnHeaderHeight();
            }
            getColumnWidth(column) {
                return this.gridApp.getColumnWidth(column);
            }
            getCell(column, line) {
                return this.gridApp.getCell(column, this.getOriginalLine(line));
            }
            getValue(column, line) {
                return this.gridApp.getValue(column, this.getOriginalLine(line));
            }
            getSymbol(key) {
                return this.gridApp.getSymbol(key);
            }
            sort(column) {
                let columnInfo = this.gridApp.getColumnInfo(column), sortedColumns, sortedColumn, indice;
                if (columnInfo?.supportOrdering && columnInfo.name) {
                    sortedColumns = this.sortedColumns || (this.sortedColumns = []);
                    indice = sortedColumns.findIndex(sortedColumn => sortedColumn.name === columnInfo.name);
                    if (indice === -1) {
                        sortedColumn = {
                            name: columnInfo.name,
                            descending: false
                        };
                        (sortedColumns.length > 2) && sortedColumns.shift();
                    }
                    else {
                        sortedColumn = sortedColumns.splice(indice, 1)[0];
                        if (indice === sortedColumns.length)
                            sortedColumn.descending = !sortedColumn.descending;
                    }
                    sortedColumns.push(sortedColumn);
                    this._index = _buildIndex(this.gridApp, sortedColumns, this._index);
                    return true;
                }
            }
        }
        let ConversionDirection;
        (function (ConversionDirection) {
            ConversionDirection[ConversionDirection["positionToNative"] = 0] = "positionToNative";
            ConversionDirection[ConversionDirection["nativeToPosition"] = 1] = "nativeToPosition";
        })(ConversionDirection = Dashboards.ConversionDirection || (Dashboards.ConversionDirection = {}));
        class GridAdapter extends AFC.Tools.AdapterBase {
            constructor(grid) {
                super();
                this.control = grid;
                this.enableSelection = false;
            }
            _update(model, event) {
                let data = event?.data;
                if (data instanceof Array) {
                    // column mode
                    data.forEach(column => {
                        let gridApp = this.control.gridApp;
                        if (gridApp) {
                            for (let y = 0, yMax = gridApp.getRowCount(); y < yMax; ++y) {
                                this.control.refreshCell(column, y);
                            }
                        }
                    });
                }
                else if (!data?.districting) {
                    this.control.setGrid();
                    this.control.onCellClick = null;
                    this._sortableGridApp = null;
                    model && model.getGridApp().then(gridApp => {
                        if (gridApp) {
                            let enableSelection = this.enableSelection, setGrid = (gridApp) => (this.control.setGrid(gridApp, enableSelection), this.onGenerate && this.onGenerate()), sortableGridApp = gridApp.allowOrdering && gridApp.hasColumnHeader && new SortableGridApp(gridApp);
                            this.control.onCellClick = (column, line) => {
                                if (sortableGridApp && line === -1 && column > -1) {
                                    let selection;
                                    if (enableSelection)
                                        selection = sortableGridApp.getOriginalLine(this.control.selection);
                                    if (sortableGridApp.sort(column)) {
                                        setGrid(sortableGridApp);
                                        enableSelection && this.control.highlight(sortableGridApp.getTargetLine(selection));
                                    }
                                }
                                if (enableSelection && (line !== -1)) {
                                    this.control.highlight(line);
                                }
                                this.onCellClick && this.onCellClick(column, line);
                            };
                            setGrid(sortableGridApp ? this._sortableGridApp = sortableGridApp : gridApp);
                        }
                    });
                }
            }
            convertLine(line, conversionDirection /* positionToNative */) {
                let indice = line;
                if (this._sortableGridApp) {
                    indice = conversionDirection === 1 /* ConversionDirection.nativeToPosition */ ?
                        this._sortableGridApp.getTargetLine(line) :
                        this._sortableGridApp.getOriginalLine(line);
                }
                return indice;
            }
            unbind() {
                this.control.setGrid();
                super.unbind();
            }
        }
        Dashboards.GridAdapter = GridAdapter;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
;
/**
 * Created by jean.rennes on 04/10/2016.
 */
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        function registerElement(name, constructor, options) {
            customElements.define(name, constructor, options);
        }
        gui.registerElement = registerElement;
        function _dispatchEvent(element, name, eventInitDict) {
            element.dispatchEvent(new CustomEvent(name, $.extend({ bubbles: true, cancelable: true }, eventInitDict)));
        }
        gui._dispatchEvent = _dispatchEvent;
        function StringToObject(s, converters) {
            let regex = /\s*(\S*)\s*:\s*([^;\s]*)\s*;?/g, result, ret = {};
            if (s) {
                while ((result = regex.exec(s)) !== null) {
                    try {
                        let name = result[1], value = result[2], converter = converters[name];
                        ret[name] = converter ? converter(value) : value;
                    }
                    catch (e) {
                    }
                }
            }
            return ret;
        }
        gui.StringToObject = StringToObject;
        function StringToFunction(s) {
            let f;
            try {
                f = eval(`(${s})`);
            }
            catch (e) {
            }
            return (f instanceof Function) ? f : void 0;
        }
        gui.StringToFunction = StringToFunction;
        function onSaveInstanceState(context, node, savedInstanceState) {
            let children = node.childNodes;
            if (children) {
                for (let i = 0; i < children.length; ++i) {
                    AfcGuiElement.onSaveInstanceState(context, children[i], savedInstanceState);
                }
            }
        }
        gui.onSaveInstanceState = onSaveInstanceState;
        function onRestoreViewState(context, node, fragmentManager, savedInstanceState) {
            let children = node.childNodes;
            if (children) {
                for (let i = 0; i < children.length; ++i) {
                    AfcGuiElement.onRestoreViewState(context, children[i], fragmentManager, savedInstanceState);
                }
            }
        }
        gui.onRestoreViewState = onRestoreViewState;
        const _top = Symbol(), _left = Symbol(), _width = Symbol(), _height = Symbol(), _hidden = Symbol();
        function _assign(style, field, value) {
            style[field] = value !== 0 ? `${value}px` : null;
        }
        class AfcGuiElement extends HTMLElement {
            static _setMute(mute, element) {
                (element instanceof AfcGuiElement) && element._setMute(element.hidden || mute);
            }
            static onSaveInstanceState(context, node, savedInstanceState) {
                let element = node;
                switch (element.tagName) {
                    case 'INPUT':
                        if (element.id) {
                            let value;
                            switch (element.type) {
                                case 'checkbox':
                                case 'radio':
                                    value = element.checked;
                                    break;
                                default:
                                    value = element.value;
                                    break;
                            }
                            savedInstanceState.putValue(element.id, value);
                        }
                        break;
                    default:
                        element instanceof AfcGuiElement ? element._onSaveInstanceState(context, savedInstanceState) : onSaveInstanceState(context, node, savedInstanceState);
                        break;
                }
            }
            static onRestoreViewState(context, node, fragmentManager, savedInstanceState) {
                let element = node;
                switch (element.tagName) {
                    case 'INPUT':
                        if (savedInstanceState && element.id) {
                            let value = savedInstanceState.getValue(element.id);
                            if (value !== void 0) {
                                switch (element.type) {
                                    case 'checkbox':
                                    case 'radio':
                                        element.checked = value;
                                        break;
                                    default:
                                        element.value = value;
                                        break;
                                }
                            }
                        }
                        break;
                    default:
                        element instanceof AfcGuiElement ? element._onRestoreViewState(context, fragmentManager, savedInstanceState) : onRestoreViewState(context, node, fragmentManager, savedInstanceState);
                        break;
                }
            }
            static _resize(screenRect, element) {
                (element instanceof AfcGuiElement) && element._resize(screenRect);
            }
            get hidden() {
                return this[_hidden];
            }
            set hidden(value) {
                let hidden = !!value;
                if (this[_hidden] !== hidden) {
                    this._setHide(this[_hidden] = hidden);
                }
            }
            _setMute(bMute) { }
            _setHide(bHide) {
                this._setMute(bHide);
                bHide ? $(this).hide() : $(this).show();
            }
            _onSaveInstanceState(context, savedInstanceState) {
                onSaveInstanceState(context, this, savedInstanceState);
            }
            _onRestoreViewState(context, fragmentManager, savedInstanceState) {
                onRestoreViewState(context, this, fragmentManager, savedInstanceState);
            }
            _resize(screenRect) {
            }
            init({ top, left, width, height }) {
                let style = this.style;
                _assign(style, 'top', this[_top] = top);
                _assign(style, 'left', this[_left] = left);
                _assign(style, 'width', this[_width] = width);
                _assign(style, 'height', this[_height] = height);
                return this;
            }
            set top(value) {
                _assign(this.style, 'top', this[_top] = value);
            }
            get top() {
                return this[_top] ?? (this[_top] = this.offsetTop);
            }
            set left(value) {
                _assign(this.style, 'left', this[_left] = value);
            }
            get left() {
                return this[_left] ?? (this[_left] = this.offsetLeft);
            }
            set width(value) {
                _assign(this.style, 'width', this[_width] = value);
            }
            get width() {
                return this[_width] ?? (this[_width] = this.offsetWidth);
            }
            set height(value) {
                _assign(this.style, 'height', this[_height] = value);
            }
            get height() {
                return this[_height] ?? (this[_height] = this.offsetHeight);
            }
            invalidateSize() {
                console.log('invalidateSize should not be called !');
            }
            isEmpty() {
                return false;
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                (attrName === 'hidden') && (this.hidden = newVal !== null);
            }
        }
        AfcGuiElement.observedAttributes = ['hidden'];
        gui.AfcGuiElement = AfcGuiElement;
        class AfcBindableElement extends AfcGuiElement {
            _setMute(bMute) {
                AFC.Tools.AdapterBase.disable(this._adapter, bMute);
                super._setMute(bMute);
            }
            _bindTo(model) {
                this._adapter.bindTo(model);
                //this.dispatchEvent(new CustomEvent('modelChange', {bubbles: false, detail: model}));
            }
            get model() {
                return this._model;
            }
            connectedCallback() {
                this._connected = true;
                this._model && this._bindTo(this._model);
            }
            disconnectedCallback() {
                this._adapter.unbind();
                this._connected = false;
            }
            bindTo(model) {
                if (this._model !== model) {
                    model ? this._model = model : delete this._model;
                    this._connected && this._bindTo(model);
                }
            }
            unbind() {
                this._adapter.unbind();
                delete this._model;
            }
        }
        AfcBindableElement.observedAttributes = AfcGuiElement.observedAttributes;
        gui.AfcBindableElement = AfcBindableElement;
        function _onAnimationClick(e) {
            this.guiAnimate();
            e.stopPropagation();
        }
        function _trapEvent(e) {
            e.stopPropagation();
        }
        function _getFinalClass(animation) {
            return animation.getAttribute('finalClass') || 'final';
        }
        function _hasContent(animation) {
            let children = animation.children;
            let empty = true;
            if (children) {
                for (let i = 0; (i < children.length) && empty; ++i) {
                    empty = (children[i] instanceof AfcGuiElement) && children[i].isEmpty();
                }
            }
            return !empty;
        }
        class AfcGuiAnimation extends AfcGuiElement {
            constructor() {
                super();
                this.addEventListener('click', _onAnimationClick, true);
                this.addEventListener('mousewheel', _trapEvent, true);
                this.addEventListener('mousemove', _trapEvent, true);
                this.addEventListener('dataChange', (e) => this.hidden || !((e.detail && e.detail.hasData) || _hasContent(this)) ? $(this).hide() : $(this).show(), true);
            }
            _setHide(bHide) {
                bHide || !_hasContent(this) ? $(this).hide() : $(this).show();
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                switch (attrName) {
                    case 'finalClass':
                        this._toggle && (this.className = this.className.replace(new RegExp(oldVal, 'g'), newVal));
                        break;
                    default:
                        super.attributeChangedCallback(attrName, oldVal, newVal);
                        break;
                }
            }
            guiAnimate() {
                let final = ` ${_getFinalClass(this)}`;
                (this._toggle = !this._toggle) ? this.className += final : this.className = this.className.replace(new RegExp(final, 'g'), '');
            }
        }
        AfcGuiAnimation.observedAttributes = AfcGuiElement.observedAttributes.concat(['finalClass']);
        gui.AfcGuiAnimation = AfcGuiAnimation;
        registerElement("afc-gui-animation", AfcGuiAnimation);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 18/01/2017.
 */
///<reference path="../../models/globals/Global.ts" />
///<reference path="../Globals.ts" />
///<reference path="../../helpers/Data.ts" />
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        var _a;
        ;
        const _configuration = Symbol(), _dataModel = Symbol();
        class MapLayerProvider extends AFC.Tools.EventSink {
            constructor(id, descriptor, configuration) {
                super();
                this.id = id;
                this.descriptor = descriptor;
                this.filterable = true;
                this[_configuration] = configuration || {};
            }
            get name() {
                return this.descriptor.name;
            }
            set hidden(value) {
                this[_configuration].hidden = value;
                this._layerModel && (this._layerModel.hidden = value);
            }
            get hidden() {
                return this[_configuration].hidden ?? this._layerModel?.hidden;
            }
            set clusteringMaxZoom(value) {
                this[_configuration].clusteringMaxZoom = value;
                this._layerModel && (this._layerModel.clusteringMaxZoom = value);
            }
            get clusteringMaxZoom() {
                return this[_configuration].clusteringMaxZoom ?? this._layerModel?.clusteringMaxZoom;
            }
            set clustering(value) {
                this[_configuration].clustering = value;
                this._layerModel && (this._layerModel.clustering = value);
            }
            get clustering() {
                return this[_configuration].clustering ?? this._layerModel?.clustering;
            }
            set filter(value) {
                this[_configuration].filter = value;
                this._layerModel && (this._layerModel.data.filter = value);
            }
            get filter() {
                return this[_configuration].filter;
            }
            set options(value) {
                this[_configuration].options = value;
                this._layerModel && (this._layerModel.options = value);
            }
            get options() {
                return this[_configuration].options ?? this._layerModel?.options;
            }
            set minZ(value) {
                this[_configuration].minZ = value;
                this._layerModel && (this._layerModel.minZ = value);
            }
            get minZ() {
                return this[_configuration].minZ ?? this._layerModel?.minZ;
            }
            refresh() {
                let filter = this.filter;
                this.filter = null;
                this.filter = filter;
            }
            async getLayer() {
                let layerModel = this._layerModel;
                if (layerModel === void 0) {
                    layerModel = await new Promise(async (resolve, reject) => {
                        let sequence = this._sequence;
                        this.notify(65536 /* Tools.EventType.UserEvent */, () => sequence === this._sequence ? resolve(this._layerModel) : reject());
                        if (!sequence) {
                            sequence = this._sequence = Symbol();
                            if (AFC.Globals.isVectorLayer(this)) {
                                let layerModel = this._layerModel = await this._getLayerModel();
                                layerModel.hidden = this.hidden;
                                layerModel.clustering = this.clustering;
                                layerModel.clusteringMaxZoom = this.clusteringMaxZoom;
                                layerModel.data.filter = this.filter;
                                layerModel.options = this.options;
                                layerModel.minZ = this.minZ;
                            }
                            else {
                                this._layerModel = null;
                            }
                            this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                        }
                    });
                }
                return { id: this.id, layerModel: layerModel };
            }
        }
        gui.MapLayerProvider = MapLayerProvider;
        class GlobalLayerProvider extends MapLayerProvider {
            constructor(descriptor, configuration) {
                super(descriptor.id, descriptor, configuration);
            }
            get type() {
                return this.descriptor.type;
            }
            async getDrawingInfo() {
                let descriptor = this.descriptor, [map, layer, thematics] = await Promise.all([descriptor.mapView.getMetadata(), descriptor.getMetadata(), this.getLegendData()]);
                ;
                return {
                    descriptor: descriptor,
                    map: map,
                    layer: layer,
                    thematics: thematics
                };
            }
            async getLegendData() {
                return this.descriptor.getLegendData();
            }
        }
        class TileLayerProvider extends GlobalLayerProvider {
            constructor(descriptor, configuration, dataModel) {
                super(descriptor, configuration);
                this[_dataModel] = dataModel;
            }
            async _getLayerModel() {
                let drawingInfo = await this.getDrawingInfo();
                return AFC.Globals.mapLayerTiledModel(this.descriptor, drawingInfo.layer, drawingInfo.thematics, this[_dataModel]);
            }
        }
        gui.TileLayerProvider = TileLayerProvider;
        class StaticLayerProvider extends GlobalLayerProvider {
            constructor(descriptor, configuration, dataModel) {
                super(descriptor, configuration);
                this[_dataModel] = dataModel;
            }
            async _getLayerModel() {
                let descriptor = this.descriptor, drawingInfo = await this.getDrawingInfo(), dataModel = this[_dataModel] || (await descriptor.getContent()).table;
                return new AFC.Globals.MapLayerStaticModel(drawingInfo.layer, dataModel, drawingInfo.thematics);
            }
        }
        gui.StaticLayerProvider = StaticLayerProvider;
        function getProviderInfoFromMapMetadata(metadata) {
            let raster = metadata && metadata.layers.find(layer => layer.type === -1 /* Globals.LayerType.raster */);
            return raster && raster.getMetadata().then(metadata => metadata && {
                grayLevelsEnabled: metadata.grayLevels,
                grayLevelsRaster: metadata.grayLevels,
                provider: metadata.provider
            });
        }
        gui.getProviderInfoFromMapMetadata = getProviderInfoFromMapMetadata;
        let LayerDataMode;
        (function (LayerDataMode) {
            LayerDataMode[LayerDataMode["none"] = 0] = "none";
            LayerDataMode[LayerDataMode["static"] = 1] = "static";
            LayerDataMode[LayerDataMode["tiled"] = 2] = "tiled";
        })(LayerDataMode = gui.LayerDataMode || (gui.LayerDataMode = {}));
        const LayerDataModeLookup = {
            none: 0 /* LayerDataMode.none */,
            static: 1 /* LayerDataMode.static */,
            tiled: 2 /* LayerDataMode.tiled */
        };
        const _rest = Symbol(), _sequence = Symbol(), _layerProvider = Symbol(), _onDirty = Symbol(), _state = Symbol(), _bindTo = Symbol();
        class AfcGuiLayer extends gui.AfcGuiElement {
            constructor() {
                super(...arguments);
                /** @internal */
                this[_a] = { mode: 0 /* LayerDataMode.none */, layer: {} };
            }
            /** @internal */
            [(_a = _state, _onDirty)]( /*event: Tools.IEvent*/) {
                gui._dispatchEvent(this, 'layersChange');
            }
            /** @internal */
            async [_bindTo]() {
                let rest = this[_rest], layerProvider = this[_layerProvider], dataModel, sequence = this[_sequence] = Symbol();
                delete this[_layerProvider];
                if (rest && (this.mode !== 0 /* LayerDataMode.none */ || (dataModel = this[_dataModel]))) {
                    let state = this[_state], mapView = AFC.Tools.findByIdOrName(state.mapView, await rest.globals.getMapViews()), mapViewMetadata = mapView && await mapView.getMetadata(), descriptor = mapViewMetadata && AFC.Tools.findByIdOrName(state.name, mapViewMetadata.layers);
                    if (descriptor) {
                        this[_layerProvider] = this.mode === 2 /* LayerDataMode.tiled */ ?
                            new TileLayerProvider(descriptor, state.layer) :
                            new StaticLayerProvider(descriptor, state.layer, dataModel);
                    }
                }
                layerProvider !== this[_layerProvider] && sequence === this[_sequence] && this[_onDirty]();
            }
            _setHide(bHide) {
                this._setMute(bHide);
                this[_state].layer.hidden = bHide;
                if (this[_layerProvider]) {
                    this[_layerProvider].hidden = bHide;
                }
            }
            _onRestoreViewState(activity, fragmentManager, savedInstanceState) {
                if (activity.getRestModel) {
                    let state = this.id && savedInstanceState && savedInstanceState.getValue(this.id);
                    if (state) {
                        this[_state] = state.state;
                        this[_layerProvider] = state.provider;
                    }
                    this[_rest] = activity.getRestModel();
                    this[_layerProvider] || this[_bindTo]();
                }
            }
            _onSaveInstanceState(context, savedInstanceState) {
                savedInstanceState.putValue(this.id, { state: this[_state], provider: this[_layerProvider] });
                super._onSaveInstanceState(context, savedInstanceState);
            }
            set template(value) {
                let arg = AFC.Tools.Data.splitSQLName(value), mapView = arg.dbName, name = mapView && arg.name, configuration = this[_state];
                if ((configuration.mapView !== mapView) || (configuration.name !== name)) {
                    configuration.mapView = mapView;
                    configuration.name = name;
                    this[_bindTo]();
                }
            }
            set mode(value) {
                this[_state].mode = value || 0 /* LayerDataMode.none */;
                this[_bindTo]();
            }
            get mode() {
                return this[_state].mode;
            }
            set dataModel(value) {
                this[_dataModel] = value;
                this.mode = 0 /* LayerDataMode.none */;
            }
            get dataModel() {
                return this[_dataModel];
            }
            set noClustering(value) {
                (this[_layerProvider] || this[_state].layer).clustering = !value;
            }
            set clusteringMaxZoom(value) {
                (this[_layerProvider] || this[_state].layer).clusteringMaxZoom = value;
            }
            set filter(value) {
                (this[_layerProvider] || this[_state].layer).filter = value;
            }
            get filter() {
                return this[_state].layer.filter;
            }
            set minZ(value) {
                (this[_layerProvider] || this[_state].layer).minZ = value;
            }
            getCount() {
                return this[_layerProvider] ? 1 : 0;
            }
            getLayerProvider(indice) {
                if (indice < this.getCount())
                    return this[_layerProvider];
            }
            async getInfo() {
                let drawingInfo = await this[_layerProvider]?.getDrawingInfo();
                return drawingInfo && getProviderInfoFromMapMetadata(drawingInfo.map);
            }
            async getBbox() {
                let layer = this.mode !== 2 /* LayerDataMode.tiled */ && this[_layerProvider] && await this[_layerProvider].getLayer(), layerModel = layer && layer.layerModel, geoJSON = layerModel && layerModel.geoJSON;
                return geoJSON && (geoJSON.bbox || AFC.Tools.Geometry.getBoundRect(geoJSON));
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                switch (attrName) {
                    case 'template':
                        this.template = newVal;
                        break;
                    case 'filter':
                        this.filter = gui.StringToFunction(newVal);
                        break;
                    case 'no-clustering':
                        this.noClustering = newVal !== null;
                        break;
                    case 'clustering-max-zoom':
                        let value = parseInt(newVal);
                        this.clusteringMaxZoom = isNaN(value) ? void 0 : value;
                        break;
                    case 'mode':
                        this.mode = LayerDataModeLookup[newVal] || 0 /* LayerDataMode.none */;
                        break;
                    default:
                        super.attributeChangedCallback(attrName, oldVal, newVal);
                        break;
                }
            }
            refresh() {
                this[_layerProvider]?.refresh();
            }
        }
        AfcGuiLayer.observedAttributes = gui.AfcGuiElement.observedAttributes.concat(['template', 'filter', 'no-clustering', 'clustering-max-zoom', 'mode']);
        gui.AfcGuiLayer = AfcGuiLayer;
        function _createMap(mapHolder) {
            let control;
            control = L.map(mapHolder, { zoomControl: false, attributionControl: false }).setView(mapHolder.center, mapHolder.scale); // Leaflet object
            L.control.scale({ position: 'bottomright', imperial: false }).addTo(control);
            /*
                    // needs something better to decide if the control is shown or not !
                    L.control.zoom({position: 'bottomright'}).addTo(control);
            */
            return control;
        }
        function _compare(a, b) {
            return (a.layer.type - b.layer.type) || (a.container - b.container) || (a.loc - b.loc);
        }
        class MapLegends extends AFC.Tools.EventSink {
            constructor(control) {
                super();
                (this._control = control).on('zoom', this._refresh, this);
            }
            _refresh() {
                this._update() && this.fireEvent(6 /* Tools.EventType.Dirty */);
            }
            _update() {
                let hasChanged = !this._legends, legends = [];
                if (this._infos) {
                    let zoom = this._control.getZoom();
                    this._infos.forEach(info => {
                        let layer = info.layer;
                        if (((layer.minZ === void 0) || (layer.minZ <= zoom)) && ((layer.maxZ === void 0) || (layer.maxZ >= zoom))) {
                            let legend;
                            if ((this._filterables || (this._filterables = {})).hasOwnProperty(info.id))
                                legend = this._filterables[info.id];
                            else {
                                legend = this._filterables[info.id] = AFC.Globals.MapModel.getLegendInfo(info.layer);
                                if (legend) {
                                    if (info.filterable) {
                                        legend.id = info.id;
                                        legend.filterable = info.filterable;
                                    }
                                }
                            }
                            hasChanged = hasChanged || (this._legends[legends.length] !== legend);
                            legend && legends.push(legend);
                        }
                    });
                }
                else {
                    hasChanged = !!(this._legends && this._legends.length);
                }
                this._legends = legends;
                return hasChanged;
            }
            get legends() {
                return this._legends || [];
            }
            setLayers(model, infos) {
                this._model = model;
                this._infos = infos;
                delete this._filterables;
                delete this._legends;
                this._update();
                this.fireEvent(6 /* Tools.EventType.Dirty */);
            }
        }
        const _rasterProvider = Symbol(), _rasterLayer = Symbol(), _defaultProvider = {
            name: 'default',
            host: '{s}.tile.openstreetmap.org',
            path: '{z}/{x}/{y}.png'
        };
        function _onMapComplete(holder, model, adapter, infos, legends, info) {
            model.clearLayers();
            if (infos) {
                infos.sort(_compare);
                infos.forEach((info, indice) => {
                    info.pos = indice;
                    model.addLayer(info.layer);
                });
            }
            legends.setLayers(model, infos);
            adapter.handlers.layers = infos || [];
            let control = holder.control, pane = control.getPane('tilePane'), grayLevelsRaster = 0, provider, oldProvider = holder[_rasterProvider], layer;
            if (info) {
                grayLevelsRaster = info.grayLevelsRaster ? 1 : 0;
                provider = info.provider;
            }
            if (!oldProvider || (provider && (oldProvider.name !== provider.name))) {
                holder[_rasterProvider] = provider || (provider = _defaultProvider);
                holder[_rasterLayer] && control.removeLayer(holder[_rasterLayer]);
                if (provider.external) {
                    if (provider.name == 'Google Maps') {
                        layer = L.Google && new L.Google('ROADMAP');
                    }
                }
                else {
                    layer = L.tileLayer(AFC.Tools.StringTools.buildUrl(provider.host, provider.path, provider.secure, provider.port), provider.subdomains && { subdomains: provider.subdomains });
                }
                layer && control.addLayer(holder[_rasterLayer] = layer);
            }
            $(pane).css('filter', `grayscale(${grayLevelsRaster})`);
        }
        function generateTooltips(info, dataReader) {
            let tooltips = info?.model.tooltips, dataModel, row;
            return (tooltips &&
                (dataModel = info.model.data) &&
                (row = info.feature.feature?.properties?.data) &&
                tooltips.reduce((acc, tooltip) => {
                    let i = tooltip.id ? dataModel.columns.findIndex(column => column.dataId === tooltip.id) : -1, column, text;
                    if (i === -1)
                        i = dataModel.columnIndex[tooltip.name];
                    if (column = dataModel.columns[i]) {
                        let formatHelper = new AFC.Tools.StringTools.FormatString(tooltip.format === void 0 ? '' : tooltip.format, column.type);
                        if ((row[i] !== null) && (!dataReader || ((text = dataReader(row, i)) === void 0)))
                            text = formatHelper.getFormated(row[i]);
                        else
                            text = formatHelper.getFormated(void 0);
                        acc += `<tr><td class="mapTooltipColumn">${tooltip.name}</td><td class="${formatHelper.isNumeric() ? 'mapTooltipNumericValue' : 'mapTooltipValue'}">${text}</td></tr>`;
                    }
                    return acc;
                }, '')) || '';
        }
        gui.generateTooltips = generateTooltips;
        class MapEventHandlers {
            constructor(holder, layers, adapter) {
                this._holder = holder;
                this.layers = layers;
                this._adapter = adapter;
            }
            _reset() {
                if (this._current) {
                    let polygon = this._current.feature;
                    let layer = this._adapter.layers[this._current.index];
                    if (layer.featureGroup === this._current.featureGroup) {
                        let refStyle = layer.options.style(polygon.feature);
                        polygon.setStyle(refStyle);
                    }
                    delete this._current;
                }
            }
            click(event, info) {
                let latLng = event.latlng;
                let globalHandlers = this._holder.handlers;
                let handlers;
                let param;
                let layer;
                if (info) {
                    layer = this.layers[info.index];
                    handlers = layer.handlers;
                    param = {
                        model: info.model,
                        options: info.options,
                        featureGroup: info.featureGroup,
                        feature: info.feature,
                        index: layer.pos,
                        provider: layer.provider
                    };
                }
                if (!globalHandlers || !globalHandlers.click || globalHandlers.click.call(globalHandlers, latLng, param, event)) {
                    if (!handlers || !handlers.click || handlers.click.call(handlers, latLng, param, event)) {
                        let model = info?.model, selectable = model ? model.selectable : true, pin;
                        if (selectable) {
                            pin = this._holder.highlight(model && { model: model, keys: [model.data.getKeyFromRow(info.feature.feature.properties.data)] });
                            if (this._holder.dispatchEvent(new CustomEvent('mapEvent', { detail: { kind: 'click', latlng: latLng, param: param, pin: pin }, cancelable: true }))) {
                                let s = generateTooltips(param, layer && layer.dataReader);
                                s && this._adapter.control.openPopup(`<table class="mapTooltipPopup">${s}</table>`, latLng);
                            }
                            L.DomEvent.stopPropagation(event);
                        }
                    }
                }
            }
            mouseDefaultHandler(event, mouseEventType, info) {
                let latLng = event.latlng;
                let globalHandlers = this._holder.handlers;
                let handlers;
                let param;
                let layer;
                if (info) {
                    layer = this.layers[info.index];
                    handlers = layer.handlers;
                    param = {
                        model: info.model,
                        options: info.options,
                        featureGroup: info.featureGroup,
                        feature: info.feature,
                        index: layer.pos,
                        provider: layer.provider
                    };
                }
                if (!globalHandlers || !globalHandlers[mouseEventType] || globalHandlers[mouseEventType].call(globalHandlers, latLng, param, event)) {
                    return handlers && handlers[mouseEventType] && handlers[mouseEventType].call(handlers, latLng, param, event);
                }
            }
            mousedown(event, info) {
                this.mouseDefaultHandler(event, "mousedown", info);
            }
            mouseup(event, info) {
                this.mouseDefaultHandler(event, "mouseup", info);
            }
            mouseover(event, info) {
                if (info) {
                    let latLng = event.latlng;
                    let param;
                    let layer = this.layers[info.index];
                    let globalHandlers = this._holder.handlers;
                    let handlers = layer.handlers;
                    param = {
                        model: info.model,
                        options: info.options,
                        featureGroup: info.featureGroup,
                        feature: info.feature,
                        index: layer.loc,
                        provider: layer.provider
                    };
                    if (!globalHandlers || !globalHandlers.mouseover || globalHandlers.mouseover.call(globalHandlers, latLng, param, event)) {
                        if (!handlers || !handlers.mouseover || handlers.mouseover.call(handlers, latLng, param, event)) {
                            if (this._holder.dispatchEvent(new CustomEvent('mapEvent', { detail: { kind: 'over', latlng: latLng, param: param }, cancelable: true }))) {
                                let polygon;
                                this._reset();
                                if (info && (polygon = info.feature) && polygon.setStyle && info.options && info.options.style && polygon.feature && (info.model.tooltips || info.model.selectable)) {
                                    let style = $.extend({}, info.options.style(polygon.feature));
                                    let opacity = style.fillOpacity;
                                    style.fillOpacity = opacity >= 0.5 ? opacity / 2 : opacity * 2;
                                    polygon.setStyle(style);
                                    this._current = info;
                                }
                            }
                        }
                    }
                }
            }
            mouseout(event, info) {
                if (info) {
                    let latLng = event.latlng;
                    let param;
                    let layer = this.layers[info.index];
                    let handlers = layer.handlers;
                    param = {
                        model: info.model,
                        options: info.options,
                        featureGroup: info.featureGroup,
                        feature: info.feature,
                        index: layer.loc,
                        provider: layer.provider
                    };
                    if (!handlers || !handlers.mouseout || handlers.mouseout.call(handlers, latLng, param, event)) {
                        if (this._holder.dispatchEvent(new CustomEvent('mapEvent', { detail: { kind: 'out', latlng: latLng, param: param }, cancelable: true }))) {
                            this._reset();
                        }
                    }
                }
            }
            animationend(event, info) {
                let globalHandlers = this._holder.handlers;
                let handlers;
                let param;
                let layer;
                if (info) {
                    layer = this.layers[info.index];
                    handlers = layer.handlers;
                    param = {
                        model: info.model,
                        options: info.options,
                        featureGroup: info.featureGroup,
                        feature: info.feature,
                        index: layer.pos,
                        provider: layer.provider
                    };
                }
                if (!globalHandlers || !globalHandlers.animationend || globalHandlers.animationend.call(globalHandlers, event, param)) {
                    if (handlers && handlers.animationend)
                        handlers.animationend.call(handlers, event, param);
                }
            }
            release() {
                delete this._current;
            }
        }
        ;
        function _refreshLayer(holder, model, adapter, legends) {
            let infos;
            let sequence = ++holder[_sequence];
            let providerInfo;
            let promises0 = [], promises1 = [];
            jQuery(holder).children().each(function (container) {
                if (this.getCount && this.getLayerProvider) {
                    let count = this.getCount();
                    promises0.push(this.getInfo());
                    if (count) {
                        for (let i = 0; i < count; ++i) {
                            let layerProvider = this.getLayerProvider(i);
                            promises1.push(layerProvider.getLayer().then((layer) => {
                                let layerModel = layer?.layerModel;
                                if (layerModel) {
                                    let info = {
                                        id: layer.id,
                                        pos: (infos || (infos = [])).length,
                                        loc: i,
                                        layer: layerModel,
                                        container: container,
                                        provider: this
                                    };
                                    this.handlers && (info.handlers = this.handlers);
                                    if (layerProvider.filterable && layerModel.legend && layerModel.type === 3 /* Globals.LayerType.symbol */) {
                                        info.filterable = layerProvider;
                                    }
                                    infos.push(info);
                                }
                            }));
                        }
                    }
                }
            });
            promises1.push(Promise.all(promises0).then((providerInfos) => {
                if (providerInfos.length) {
                    let provider, grayLevelsRaster;
                    providerInfos.some(providerInfo => {
                        if (providerInfo) {
                            provider = provider || providerInfo.provider;
                            grayLevelsRaster = grayLevelsRaster || providerInfo.grayLevelsRaster;
                        }
                        return provider && grayLevelsRaster;
                    });
                    providerInfo = {
                        provider: provider,
                        grayLevelsRaster: grayLevelsRaster,
                        grayLevelsEnabled: true
                    };
                }
            }));
            Promise.all(promises1).then(() => (sequence === holder[_sequence]) && _onMapComplete(holder, model, adapter, infos, legends, providerInfo));
        }
        const _smartZoom = Symbol(), _buttons = Symbol(), _center = Symbol(), _scale = Symbol(), _selection = Symbol(), _mapHolder = 'AFC-GUI-MAP-HOLDER', _reattach = (button) => {
            button[_sequence] || (button[_sequence] = setTimeout(() => {
                button.disconnectedCallback();
                button.connectedCallback();
                delete button[_sequence];
            }, 0));
        }, _converter = {
            toggle: AFC.Tools.Data.toBoolean,
            hideText: AFC.Tools.Data.toBoolean
        }, _hideButton = (button, hide) => {
            if (button) {
                let container = button.getContainer();
                hide ? $(container).hide() : $(container).show();
            }
        };
        class AfcGuiMapButton extends HTMLElement {
            constructor() {
                super();
                this.options = {};
                this._hidden = false;
            }
            set name(value) {
                if (this._name !== value) {
                    this._name = value;
                    _reattach(this);
                }
            }
            get name() {
                return this._name;
            }
            set position(value) {
                if (this._position !== value) {
                    this._position = value;
                    _reattach(this);
                }
            }
            get position() {
                return this._position;
            }
            get hidden() {
                return this._hidden;
            }
            set hidden(value) {
                let show = !value;
                if (show === this._hidden) {
                    _hideButton(this._button, this._hidden = !show);
                }
            }
            set options(value) {
                this._options = {
                    text: value.text,
                    iconUrl: value.iconUrl,
                    onClick: (event) => this.onButtonClick && this.onButtonClick(event),
                    toggle: value.toggle,
                    hideText: value.hideText,
                    maxWidth: value.maxWidth || AfcGuiMapButton.defaultSize
                };
                _reattach(this);
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                switch (attrName) {
                    case 'name':
                        this.name = newVal;
                        break;
                    case 'options':
                        this.options = gui.StringToObject(newVal, _converter);
                        break;
                    case 'position':
                        this.position = newVal;
                        break;
                    case 'onbuttonclick':
                        this.onButtonClick = gui.StringToFunction(`function() {${newVal}}`).bind(this);
                        break;
                    case 'hidden':
                        this.hidden = (newVal !== null);
                        break;
                }
            }
            connectedCallback() {
                let parent = this.parentNode;
                if (parent && parent.tagName === _mapHolder) {
                    this._button = parent.addButton(this._options, this._name, this._position, this._hidden);
                }
            }
            disconnectedCallback() {
                if (this._button) {
                    let parent = this.parentNode;
                    if (parent && parent.tagName === _mapHolder) {
                        parent.removeButton(this._button);
                    }
                    delete this._button;
                }
            }
        }
        AfcGuiMapButton.observedAttributes = ['name', 'options', 'position', 'onbuttonclick', 'hidden'];
        gui.AfcGuiMapButton = AfcGuiMapButton;
        const _getZoomPromise = (control) => new Promise(resolve => control.once('zoomend moveend', resolve));
        function autoZoom(map) {
            map.addEventListener('dataReady', (event) => {
                const map = event.target;
                map.smartZoom();
            }, { once: true });
        }
        gui.autoZoom = autoZoom;
        const _disableSmartZoom = 'disable-smart-zoom';
        class AfcGuiMapHolder extends gui.AfcGuiElement {
            _setHide(bHide) {
                this._setMute(bHide);
                !bHide && this.refresh();
            }
            _setMute(bMute) {
                AFC.Tools.AdapterBase.disable(this._adapter, bMute);
                super._setMute(bMute);
            }
            constructor() {
                super();
                let map = _createMap(this);
                this[_sequence] = 0;
                this.legends = new MapLegends(map);
                this._adapter = new AFC.Globals.MapAdapter(this.control = map);
                this._adapter.bindTo(this.model = new AFC.Globals.MapModel());
                this._adapter.handlers = new MapEventHandlers(this, [], this._adapter);
                this._adapter.onComplete = (layers) => gui._dispatchEvent(this, 'dataReady', { detail: layers });
                this.addEventListener('layersChange', ( /*e: CustomEvent*/) => {
                    delete this[_selection];
                    this._adapter.handlers.release();
                    this._adapter.clearMap();
                    this.legends && this.legends.setLayers(this.model);
                    this.model.notify(1073741825 /* Tools.EventType.Ready */, () => _refreshLayer(this, this.model, this._adapter, this.legends));
                    this.model.fireEvent(1073741825 /* Tools.EventType.Ready */);
                });
                this[_buttons] = {};
                this.disableSmartZoom = this.getAttribute(_disableSmartZoom) !== null;
            }
            get adapter() {
                return this._adapter;
            }
            set center(value) {
                this[_center] = value;
            }
            get center() {
                return this[_center] || L.latLng(46.75, 2.45);
            }
            set scale(value) {
                this[_scale] = value;
            }
            get scale() {
                return this[_scale] || 6;
            }
            get providers() {
                let handlers = this._adapter.handlers;
                if (handlers instanceof MapEventHandlers) {
                    return handlers.layers;
                }
            }
            _onSaveInstanceState(context, savedInstanceState) {
                super._onSaveInstanceState(context, savedInstanceState);
                this.id && savedInstanceState.putValue(this.id, {
                    currentCenter: this.control.getCenter(),
                    currentScale: this.control.getZoom(),
                    center: this.center,
                    scale: this.scale
                });
            }
            _onRestoreViewState(context, fragmentManager, savedInstanceState) {
                let value;
                super._onRestoreViewState(context, fragmentManager, savedInstanceState);
                if (savedInstanceState && this.id && (value = savedInstanceState.getValue(this.id))) {
                    this.control.setView(value.currentCenter, value.currentScale);
                    value.center && (this[_center] = value.center);
                    (value.scale !== void 0) && (this[_scale] = value.scale);
                }
            }
            set disableSmartZoom(value) {
                value ?
                    this._removeButton(_smartZoom) :
                    this.addButton({
                        iconUrl: 'css/images/smartzoom.png',
                        onClick: this.smartZoom.bind(this)
                    }, _smartZoom);
            }
            get disableSmartZoom() {
                return !this[_buttons][_smartZoom];
            }
            get layers() {
                return this._adapter.layers || [];
            }
            get selection() {
                return this[_selection];
            }
            get buttons() {
                return this[_buttons];
            }
            setView(center, zoom, options) {
                let promise = _getZoomPromise(this.control);
                this.control.setView(center, zoom, options);
                return promise;
            }
            fitBounds(bounds) {
                let promise = _getZoomPromise(this.control);
                this.control.fitBounds(bounds);
                return promise;
            }
            async smartZoom() {
                let symbolBounds, bboxes = await Promise.all(this.providers?.reduce((acc, layerInfo) => {
                    let provider = layerInfo.provider;
                    !provider.hidden && provider.getBbox && acc.push(provider.getBbox());
                    return acc;
                }, [])), bbox = bboxes.length && bboxes.reduce((acc, bbox) => bbox && acc ? (AFC.Tools.Geometry.inflateRectWithRect(acc, bbox), acc) : acc || bbox), bounds = bbox && L.latLngBounds([bbox[1], bbox[0]], [bbox[3], bbox[2]]);
                bounds || this.model.layers.forEach((layer) => {
                    let geoJSON = layer.geoJSON;
                    let bbox;
                    let latlngs;
                    if (geoJSON && (bbox = geoJSON.bbox)) {
                        latlngs = [[bbox[1], bbox[0]], [bbox[3], bbox[2]]];
                        if (layer.type !== 3 /* Globals.LayerType.symbol */) {
                            bounds ? bounds.extend(latlngs) : bounds = L.latLngBounds(latlngs);
                        }
                        else {
                            symbolBounds ? symbolBounds.extend(latlngs) : symbolBounds = L.latLngBounds(latlngs);
                        }
                    }
                });
                return bounds || (bounds = symbolBounds) ? this.fitBounds(bounds) : this.setView(this.center, this.scale);
            }
            addButton(options, key, position = 'topright', hidden) {
                let button = new L.Control.Button($.extend({
                    text: '',
                    hideText: true,
                    toogle: false,
                    maxWidth: AfcGuiMapButton.defaultSize
                }, options));
                button.options = {
                    position: position
                };
                key && this._removeButton(key);
                _hideButton(button, hidden);
                this.control.addControl(this[_buttons][key || Symbol()] = button);
                return button;
            }
            _removeButton(key) {
                let button = this[_buttons][key];
                if (button) {
                    delete this[_buttons][key];
                    this.control.removeControl(button);
                    return true;
                }
            }
            removeButton(button) {
                for (let key in this[_buttons]) {
                    if (this[_buttons][key] === button) {
                        this._removeButton(key);
                        return;
                    }
                }
            }
            refresh() {
                this._adapter.refresh();
            }
            connectedCallback() {
                let attribute = this.getAttribute('center'), scale;
                if (attribute) {
                    let aTmp = attribute.split(',');
                    let lat, lng;
                    if (aTmp.length === 2) {
                        lng = parseFloat(aTmp[0]);
                        lat = parseFloat(aTmp[1]);
                        if (!isNaN(lng) && !isNaN(lat)) {
                            this[_center] = L.latLng(lat, lng);
                        }
                    }
                }
                attribute = this.getAttribute('scale');
                if (attribute && !isNaN(scale = parseInt(attribute))) {
                    this[_scale] = scale;
                }
                this.control.invalidateSize(false);
                gui._dispatchEvent(this, 'layersChange');
            }
            disconnectedCallback() {
                this.model.clearLayers();
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                attrName === _disableSmartZoom ? this.disableSmartZoom = (newVal !== null) : super.attributeChangedCallback(attrName, oldVal, newVal);
            }
            _resize(screenRect) {
                super._resize(screenRect);
                this.control.invalidateSize(false);
            }
            highlight(selection) {
                let layers = this._adapter.layers, layer = layers && selection && layers.find(layer => layer.model === selection.model), old = this[_selection], ret, same = layer && old && (old.group === layer.featureGroup);
                if (same && !AFC.Tools.arrayCompare(old.keys, selection.keys))
                    return true; // already highlighted
                delete this[_selection];
                if (layer) {
                    layer.featureGroup.highlight(selection.keys);
                    this[_selection] = {
                        group: layer.featureGroup,
                        keys: selection.keys
                    };
                    ret = true;
                }
                !same && old?.group.highlight();
                return ret;
            }
        }
        AfcGuiMapHolder.observedAttributes = gui.AfcGuiElement.observedAttributes.concat([_disableSmartZoom]);
        AfcGuiMapHolder.Button = AfcGuiMapButton;
        gui.AfcGuiMapHolder = AfcGuiMapHolder;
        const _holder = Symbol(), _onMapEventHandler = Symbol(), _onMapEvent = Symbol();
        class TooltipPin {
            constructor(tooltip) {
                let pin = document.createElement('div');
                this.tooltip = tooltip;
                pin.classList.add("mapTooltipPopupHeader");
                tooltip.appendChild(pin).addEventListener('click', this.onClick.bind(this));
            }
            onClick(event) {
                this.tooltip.hideTT(true);
                event.stopPropagation();
            }
        }
        class AfcGuiLayerTooltip extends gui.AfcGuiElement {
            _setHide(bHide) {
                super._setHide(bHide || this._hidden);
            }
            constructor() {
                super();
                this._ttIsEmpty = true;
                this._pinned = null;
                this._ttFeatureId = "";
            }
            hideTT(fromPin) {
                if (!this._pinned || fromPin) {
                    this._pinned = null;
                    this._setHide(this._hidden = true);
                    this._ttFeatureId = "";
                }
                return true;
            }
            pinTT(latlng, info) {
                this.showTT(latlng, info, true);
                return false;
            }
            onShowTT(latlng, info) {
                return this.showTT(latlng, info, false);
            }
            onHideTT(latlng, info) {
                return this.hideTT(false);
            }
            showTT(latlng, info, fromPin) {
                let table = document.createElement('table');
                let divPreview = document.createElement('div');
                let feature = info && info.feature;
                let previewWidth = 50;
                let previewHeight = 50;
                let ttText = AFC.gui.generateTooltips(info);
                if (this._pinned && !fromPin)
                    return true;
                this._ttIsEmpty = false;
                if (!ttText || (ttText == "")) {
                    this._ttIsEmpty = true;
                    this.hideTT(fromPin);
                    return true;
                }
                if (this._pinned && (this._ttFeatureId === feature._leaflet_id))
                    return true;
                this.innerHTML = "";
                if (fromPin && this[_holder]) {
                    this._pinned = new TooltipPin(this);
                }
                this._ttFeatureId = feature._leaflet_id;
                table.classList.add("mapTooltipPopup");
                table.innerHTML = ttText;
                this.appendChild(table);
                divPreview.classList.add("mapTooltipPopupPreview");
                if (feature._path || feature._icon) {
                    let previewShadowId = "previewShadow";
                    let svg = d3.select(divPreview)
                        .append("svg")
                        .attr("width", previewWidth * 2)
                        .attr("height", previewHeight * 2);
                    let svgDefs = svg.append('defs');
                    let shadowFilter = svgDefs.append('filter')
                        .attr("id", previewShadowId)
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("width", "200%")
                        .attr("height", "200%");
                    shadowFilter.append('feOffset')
                        .attr("result", "offOut")
                        .attr("in", "SourceAlpha")
                        .attr("dx", 5)
                        .attr("dy", 5);
                    shadowFilter.append('feGaussianBlur')
                        .attr("result", "blurOut")
                        .attr("in", "offOut")
                        .attr("stdDeviation", 5);
                    shadowFilter.append('feBlend')
                        .attr("mode", "normal")
                        .attr("in", "SourceGraphic")
                        .attr("in2", "blurOut");
                    if (!feature._path) {
                        let g = svg.append("g").attr("filter", "url(#" + previewShadowId + ")");
                        g.append("image")
                            .attr("xlink:href", feature._icon.src)
                            .attr("width", previewWidth)
                            .attr("height", previewHeight);
                        this.appendChild(divPreview);
                    }
                    else {
                        let pathWidth = feature._pxBounds.max.x - feature._pxBounds.min.x;
                        let pathHeight = feature._pxBounds.max.y - feature._pxBounds.min.y;
                        let pathMax = Math.max(pathWidth, pathHeight);
                        let g = svg.append("g").attr("filter", "url(#" + previewShadowId + ")");
                        let defaultOpacity = "";
                        g = g.append("g").attr("transform", "scale(" + (previewWidth / pathMax) + " " + (previewHeight / pathMax) + ")");
                        g = g.append("g").attr("transform", "translate(" + (-feature._pxBounds.min.x) + " " + (-feature._pxBounds.min.y) + ")");
                        g.html(feature._path.outerHTML);
                        let polygon = info.feature;
                        if (info.options.style) {
                            let refStyle = info.options.style(polygon.feature);
                            defaultOpacity = refStyle && refStyle.fillOpacity.toString();
                        }
                        this.appendChild(divPreview);
                        if (defaultOpacity != "")
                            d3.select(this).select("path").attr("fill-opacity", defaultOpacity);
                        if (info.feature && info.feature.feature.geometry.type === "Point")
                            d3.select(this).select("path").attr("stroke-width", "0");
                    }
                }
                this._hidden = false;
                this._setHide(this.hidden);
                return true;
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                switch (attrName) {
                    case 'for':
                        let holder = document.getElementById(newVal);
                        this.disconnectedCallback();
                        if (holder) {
                            holder.addEventListener('mapEvent', this[_onMapEventHandler] = this[_onMapEvent].bind(this));
                            holder.addEventListener('layersChange', this[_onMapEventHandler]);
                        }
                        this[_holder] = holder;
                        break;
                    default:
                        super.attributeChangedCallback(attrName, oldVal, newVal);
                        break;
                }
            }
            connectedCallback() {
                if (!this.getAttribute('for')) {
                    let parent = this;
                    while (parent = parent.parentNode) {
                        if (parent && parent.tagName === _mapHolder) {
                            parent.addEventListener('mapEvent', this[_onMapEventHandler] = this[_onMapEvent].bind(this));
                            parent.addEventListener('layersChange', this[_onMapEventHandler]);
                            this[_holder] = parent;
                            break;
                        }
                    }
                }
                this._setHide(this._hidden = true);
            }
            disconnectedCallback() {
                if (this[_onMapEventHandler]) {
                    this[_holder].removeEventListener('mapEvent', this[_onMapEventHandler]);
                    this[_holder].removeEventListener('layersChange', this[_onMapEventHandler]);
                    delete this[_onMapEventHandler];
                }
            }
            refresh() {
            }
            /** @internal */
            [_onMapEvent](event) {
                if (event.type === 'layersChange') {
                    this.hideTT(true);
                }
                else {
                    let kind = event.detail.kind;
                    let preventDefault = false;
                    if (event.detail.kind === 'click') {
                        preventDefault = event.detail.pin ?
                            !this.pinTT(event.detail.latlng, event.detail.param) :
                            this.hideTT(true);
                    }
                    else if (event.detail.kind === 'out') {
                        preventDefault = !this.onHideTT(event.detail.latlng, event.detail.param);
                    }
                    else if (event.detail.kind === 'over') {
                        preventDefault = !this.onShowTT(event.detail.latlng, event.detail.param);
                    }
                    if (preventDefault)
                        event.preventDefault();
                }
            }
        }
        AfcGuiLayerTooltip.observedAttributes = gui.AfcGuiElement.observedAttributes.concat(['for']);
        gui.AfcGuiLayerTooltip = AfcGuiLayerTooltip;
        gui.registerElement(_mapHolder.toLowerCase(), AfcGuiMapHolder);
        gui.registerElement("afc-gui-map-button", AfcGuiMapButton);
        gui.registerElement("afc-gui-layer", AfcGuiLayer);
        gui.registerElement("afc-gui-layer-tooltip", AfcGuiLayerTooltip);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 03/02/2016.
 */
///<reference types="leaflet" />
///<reference path="../../models/dashboards/Dashboard.ts" />
///<reference path="../../helpers/AdapterBase.ts" />
///<reference path="../../gui/map/Map.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        class DashboardLayer extends AFC.gui.MapLayerProvider {
            constructor(model, descriptor, offset) {
                super(`${model.id}_${offset}`, descriptor);
                this.model = model;
                this.offset = offset;
            }
            get type() {
                return this.descriptor.template.type;
            }
            async _getLayerModel() {
                return this.model.getLayer(this.offset);
            }
        }
        function _addLayerIndicators(descriptor, dataNodes, dict, indicators) {
            let template = descriptor.template, properties = template.properties, push = (indicator) => dict[indicator] || (dict[indicator] = true, indicator && indicators.push(indicator));
            indicators.forEach(indicator => dict[indicator] = true);
            template.tooltips.forEach(tooltip => push(tooltip.id));
            for (let key in properties) {
                let property = properties[key];
                property.column && push(dataNodes[property.column]);
                property.thematic && property.thematic.columns.forEach(column => push(descriptor.dataNodes[column]));
            }
        }
        function _getMetadata(reference, library) {
            let template = Object.create(reference), properties = Object.create(reference.properties);
            properties.visibility = library.properties.visibility;
            template.properties = properties;
            return template;
        }
        function _getThematicData(partition) {
            let classes = [];
            partition.subsets.forEach(subset => {
                if ((subset.type === 10 /* Dashboards.ZoneType.subset */) || (subset.type === 12 /* Dashboards.ZoneType.outOfZone */)) {
                    let value = subset.value;
                    classes.push({
                        '<TKVALUE>': {
                            text: value,
                            value: value
                        }
                    });
                }
            });
            return {
                fillColor: {
                    thematic: {
                        classes: classes
                    }
                }
            };
        }
        function _getLayerMapping(zoneUnits, cannibalization) {
            let ret = {};
            zoneUnits.dataNodes && Object.entries(zoneUnits.dataNodes).forEach(([key, value]) => ret[value] = key);
            cannibalization?.dataNodes && Object.entries(cannibalization.dataNodes).forEach(([key, value]) => ret[value] = key);
            return ret;
        }
        function _getPattern(cannibalization, dataNodes) {
            let properties = cannibalization.template.properties;
            return properties.pattern && {
                properties: properties,
                legendData: {
                    thematic: {
                        classes: [{
                                "<TKLB>": { value: Number.NEGATIVE_INFINITY, text: "-INF" },
                                "<TKUB>": { value: 1, text: "1" }
                            }, {
                                "<TKLB>": { value: 1, text: "1" },
                                "<TKUB>": { value: Number.POSITIVE_INFINITY, text: "+INF" }
                            }
                        ]
                    }
                }
            };
        }
        const _timeout = 1000;
        class TableUpdater {
            constructor(layer, zone, dataModel) {
                this._sequence = 0;
                this.layer = layer;
                this.zone = zone;
                this.dataModel = dataModel;
            }
            _update() {
                let layerInfo = this.layer.layerInfo, dataModel = this.dataModel, promises, sequence = ++this._sequence;
                delete this._timeout;
                if (dataModel && layerInfo) {
                    if (layerInfo.tile) {
                        promises = [this.zone.getData(11 /* DataSourceKind.outOfZone */, layerInfo.indicators)];
                        layerInfo.cannibalization && promises.push(this.zone.getData(6 /* DataSourceKind.cannibalization */, layerInfo.indicators));
                    }
                    else {
                        promises = [this.zone.getData(1 /* DataSourceKind.unknown */, layerInfo.indicators)];
                    }
                    Promise.all(promises).then(results => {
                        if (sequence == this._sequence) {
                            let reader = new AFC.Tools.Data.TableReader(dataModel, results[0], results[1]), values = this.dataModel.values, component, i = 0, iCount = 0;
                            for (component of reader) {
                                let diff;
                                diff = -1;
                                iCount++;
                                while (i < values.length) {
                                    let key = dataModel.getKeyFromRow(values[i]);
                                    diff = AFC.Data.compareKey(component.key, key);
                                    if (diff > 0) {
                                        dataModel.deleteAt(i);
                                    }
                                    else {
                                        break;
                                    }
                                }
                                diff < 0 ? dataModel.createAt(i++, component.row) : dataModel.modifyAtEx(i++, component.row);
                            }
                            while (values.length > iCount) {
                                dataModel.deleteAt(values.length - 1);
                            }
                        }
                    });
                }
            }
            update(delay) {
                this._timeout && clearTimeout(this._timeout);
                delay ? this._timeout = setTimeout(() => this._update(), _timeout) : this._update();
            }
            clear() {
                if (this._timeout) {
                    clearTimeout(this._timeout);
                    delete this._timeout;
                    delete this.layer.updater;
                }
            }
        }
        class DistrictLayer extends AFC.Tools.EventSink {
            constructor(dashboard, template, name, indicators) {
                super();
                this._dashboard = dashboard;
                this._template = template;
                this.name = name;
                this.indicators = indicators;
            }
            _buildTable(zone, descriptor, zoneUnits, cannibalization) {
                let dataNodes = {}, dict = {}, indicators = this.indicators ? this.indicators.slice(0) : [], promises;
                descriptor.dataNodes.forEach(dataNode => {
                    dataNodes[dataNode.name] = dataNode.id;
                    if (dataNode.qualifier === 4 /* DataQualifier.partition */) {
                        indicators.push(dataNode.id);
                    }
                    else if (cannibalization && (dataNode.qualifier === 262150 /* DataQualifier.cannibalizationCount */)) {
                        indicators.push(dataNode.id);
                    }
                });
                _addLayerIndicators(zoneUnits, dataNodes, dict, indicators);
                cannibalization && _addLayerIndicators(cannibalization, dataNodes, dict, indicators);
                promises = [zone.getData(11 /* DataSourceKind.outOfZone */, indicators)];
                cannibalization && promises.push(zone.getData(6 /* DataSourceKind.cannibalization */, indicators));
                this.layerInfo = {
                    cannibalization: !!cannibalization,
                    indicators: indicators,
                    tile: true
                };
                return Promise.all(promises).then(results => AFC.Tools.Data.mergeTables(results[0], results[1]));
            }
            async _buildStaticTable(zone, descriptor, zoneUnits) {
                let dataNodes = {}, dict = {}, indicators = this.indicators ? this.indicators.slice(0) : [], dataModelBase;
                descriptor.dataNodes.forEach(dataNode => {
                    dataNodes[dataNode.name] = dataNode.id;
                    if (dataNode.qualifier === 4 /* DataQualifier.partition */) {
                        indicators.push(dataNode.id);
                    }
                });
                _addLayerIndicators(zoneUnits, dataNodes, dict, indicators);
                this.layerInfo = {
                    indicators: indicators,
                    tile: false
                };
                dataModelBase = await zone.getData(1 /* DataSourceKind.unknown */, indicators);
                return new AFC.Data.DataModel(dataModelBase.columns, dataModelBase.primaryKey, dataModelBase.values);
            }
            async _buildLayer(zoneUnits, cannibalization) {
                let layerModel, zone = AFC.Tools.findById(zoneUnits.zone, this._dashboard.zones), descriptor = await zone.getDescriptor(), dataModel;
                if (descriptor.partition) {
                    let globals = this._dashboard.descriptor.restModel.globals, [info, geographicalLevels] = await Promise.all([
                        AFC.Globals.getMapLayerDrawingInfo(globals, this._template, this.name),
                        globals.getGeographicalLevels()
                    ]);
                    if (info && (dataModel = await this._buildTable(zone, descriptor, zoneUnits, cannibalization))) {
                        let level = geographicalLevels.levels[descriptor.geographicalLevels.detailed.id], dataModelView = new AFC.Data.DataModelView(dataModel, _getLayerMapping(this._zoneUnits, this._cannibalization)), layerModelEx = AFC.Globals.compoundMapLayerTiledModel(info.descriptor, info.layer.table, _getThematicData(descriptor.partition), dataModelView, _getMetadata(zoneUnits.template, info.layer), this.name, info.layer);
                        if (level.table !== info.layer.table.name) { // Check tile layer geographical level
                            let contextSubstitute = new AFC.Rest.ContextSubstitute(info.layer.table.name);
                            contextSubstitute.replacement = level.table;
                            layerModelEx.data.provider.pushModifier(contextSubstitute);
                        }
                        layerModel = layerModelEx;
                        cannibalization && (layerModel.override = _getPattern(cannibalization, descriptor.dataNodes));
                    }
                    else if (dataModel = await this._buildStaticTable(zone, descriptor, zoneUnits)) {
                        layerModel = new AFC.Globals.MapLayerStaticModel(zoneUnits.template, dataModel, _getThematicData(descriptor.partition));
                    }
                    if (layerModel) {
                        this._zone = zone;
                        this._descriptor = descriptor;
                        this._dataModel = dataModel;
                        this._colorProperty = zoneUnits.template.properties.fillColor;
                    }
                }
                return layerModel;
            }
            refresh() {
                (this.updater || (this.updater = new TableUpdater(this, this._zone, this._dataModel))).update(true);
            }
            getQualifiedColumn(data, dataQualifier) {
                let descriptor = this._descriptor, dataNode, indice;
                return descriptor && (dataNode = descriptor.dataNodes.find(dataNode => dataNode.qualifier === dataQualifier)) && ((indice = data.columns.findIndex(column => column.alias === dataNode.name)) !== void 0) ? indice : -1;
            }
            async getLayer() {
                return this._layer || new Promise(async (resolve) => {
                    this.notify(6 /* Tools.EventType.Dirty */, () => resolve(this._layer));
                    if (!this._loading) {
                        let layerModel, zoneUnits = this._zoneUnits;
                        this._loading = true;
                        if (zoneUnits) {
                            let cannibalization;
                            if (this._cannibalization && this._cannibalization.zone === this._zoneUnits.zone) {
                                cannibalization = this._cannibalization;
                            }
                            layerModel = await this._buildLayer(zoneUnits, cannibalization);
                        }
                        this._layer = {
                            id: AFC.Tools.Data.generateRndString(10),
                            layerModel: layerModel
                        };
                        this.fireEvent(6 /* Tools.EventType.Dirty */);
                    }
                });
            }
            addSource(descriptor) {
                delete this._layer;
                if ((descriptor.dataSourceKind === 2 /* DataSourceKind.zoneUnits */) || (descriptor.dataSourceKind === 11 /* DataSourceKind.outOfZone */)) {
                    this._zoneUnits = descriptor;
                }
                else if (descriptor.dataSourceKind === 6 /* DataSourceKind.cannibalization */) {
                    this._cannibalization = descriptor;
                }
            }
            async getDistrictParameters() {
                const layer = await this.getLayer();
                if (this._dataModel && layer) {
                    let subset = this._descriptor.partition.subsets.find(subset_1 => subset_1.type === 12 /* ZoneType.outOfZone */), filter;
                    if (subset || this.layerInfo?.cannibalization) {
                        let column = this.getQualifiedColumn(this._dataModel, 4 /* DataQualifier.partition */), value = subset.value;
                        filter = row_2 => row_2[column] !== null && row_2[column] !== value;
                    }
                    return {
                        zone: this._zone,
                        descriptor: this._descriptor,
                        dataModel: filter ? new AFC.Data.FilterModel(filter, this._dataModel) : this._dataModel,
                        colorProperty: this._colorProperty,
                        layerModel: layer?.layerModel
                    };
                }
            }
            isRedistricted() {
                return this._zone && !!this._zone.district.isRedistricted;
            }
            reset() {
                this._zone?.district.reset();
            }
            async affectRow(data, row, id) {
                let descriptor = this._descriptor, dataModel, subset;
                if (descriptor && (dataModel = this._dataModel) && (subset = descriptor.partition.subsets.find(item => item.id === id))) {
                    let partition = this.getQualifiedColumn(dataModel, 4 /* DataQualifier.partition */), partitionColumn = dataModel.columns[partition], key = data.getKeyFromRow(row), indice = dataModel.lowerKeyBound(key), row1 = dataModel.getRow(indice), affect;
                    if (row1 && !dataModel.compareKey(row1, key)) {
                        affect = dataModel.modifyAt(indice, { [partitionColumn.name]: subset.value });
                    }
                    else {
                        row1 = dataModel.columns.map((column, indice) => {
                            let value = null, position;
                            if (column.index === -1) {
                                if (partition === indice) {
                                    value = subset.value;
                                }
                                else if (((position = data.columnIndex[column.name]) !== void 0) || ((position = data.columnIndex[column.alias]) !== void 0)) {
                                    value = row[position];
                                }
                            }
                            else {
                                value = key[column.index];
                            }
                            return value;
                        });
                        affect = dataModel.createAt(indice, row1);
                    }
                    if (affect) {
                        this.refresh();
                        return this._zone.district.affect(row[this.getQualifiedColumn(data, 1 /* DataQualifier.code */)], id);
                    }
                }
            }
            async getOwnership(data, row) {
                let dataModel = this._dataModel, zone;
                if (dataModel && (zone = this._zone)) {
                    let key = data.getKeyFromRow(row), indice = dataModel.find(key), row1 = dataModel.getRow(indice), codeColumn, countColumn, name;
                    if (row1) {
                        codeColumn = this.getQualifiedColumn(dataModel, 1 /* DataQualifier.code */);
                        if ((countColumn = this.getQualifiedColumn(dataModel, 262150 /* DataQualifier.cannibalizationCount */)) !== -1) {
                            name = dataModel.columns[countColumn].name;
                            dataModel.modifyAt(indice, { [name]: 0 });
                        }
                        this.refresh();
                        return zone.district.getOwnership(row1[codeColumn]);
                    }
                }
            }
            async deleteUnit(data, row) {
                let dataModel = this._dataModel, zone;
                if (dataModel && (zone = this._zone)) {
                    let key = data.getKeyFromRow(row), indice = dataModel.find(key), row1 = dataModel.getRow(indice), codeColumn, partition;
                    if (row1) {
                        codeColumn = this.getQualifiedColumn(dataModel, 1 /* DataQualifier.code */);
                        partition = this.getQualifiedColumn(dataModel, 4 /* DataQualifier.partition */);
                        dataModel.modifyAt(indice, { [dataModel.columns[partition].name]: null });
                        this.refresh();
                        return zone.district.delete(row1[codeColumn]);
                    }
                }
            }
            release() {
                this.updater && this.updater.clear();
                delete this._dataModel;
            }
        }
        class MapAdapter extends AFC.Tools.AdapterBase {
            constructor() {
                super();
                this.layers = [];
                this._redistrict = false;
                this._sequence = 0;
            }
            _update(model, event) {
                if (!event?.data?.districting) {
                    let sequence = ++this._sequence;
                    delete this._district;
                    this.layers.forEach(layer => layer.release && layer.release());
                    this.layers.length = 0;
                    model.getMapTemplate().then(template => {
                        let dashboard = model.dashboard;
                        if (dashboard) {
                            let properties = model.properties, redistrict = dashboard.viewsProperties.redistrict, name;
                            if (this._redistrict && (redistrict !== void 0) && properties[redistrict]) {
                                name = properties[redistrict][2];
                                name && (name = name.toLowerCase());
                            }
                            model.getDescriptors().then(descriptors => descriptors && this._onLayers(sequence, model, dashboard, descriptors, template, name));
                        }
                    });
                }
            }
            _onLayers(sequence, model, dashboard, descriptors, template, name) {
                if (sequence === this._sequence) {
                    let districtLayer;
                    descriptors && descriptors.forEach((descriptor, indice) => {
                        if (name && descriptor && (descriptor.type === 1 /* Dashboards.LayerType.thematic */) && (descriptor.name.toLowerCase() === name)) {
                            if (!districtLayer) {
                                this.layers.push(districtLayer = new DistrictLayer(dashboard, template, descriptor.name, this._indicators));
                                this._district = indice;
                            }
                            districtLayer.addSource(descriptor);
                        }
                        else {
                            this.layers.push(new DashboardLayer(model, descriptor, indice));
                        }
                    });
                    this.onUpdate && this.onUpdate(districtLayer);
                }
            }
            canDistrict() {
                return this._district !== void 0;
            }
            isRedistricted() {
                return this.canDistrict() && this.layers[this._district].isRedistricted();
            }
            resetDistrict() {
                if (this.canDistrict()) {
                    let districtLayer = this.layers[this._district];
                    districtLayer.reset();
                    this.refresh();
                    //this.onUpdate && this.onUpdate(districtLayer);
                }
            }
            getCount() {
                return /*this.ready &&*/ this.layers ? this.layers.length : 0;
            }
            getLayerProvider(indice) {
                return this.layers[indice];
            }
            async getInfo() {
                let globals = this._model.dashboard?.descriptor.restModel.globals;
                if (globals) {
                    let results = await Promise.all([this._model.getMapTemplate(), globals.getMapViews()]), mapView = results[0] && results[1] && AFC.Tools.findById(results[0], results[1]), metadata = mapView && await mapView.getMetadata();
                    return AFC.gui.getProviderInfoFromMapMetadata(metadata);
                }
            }
            enableDistricting(enable, indicators) {
                if ((this._redistrict !== enable) || (this._indicators !== indicators)) {
                    let id = this._model.id;
                    this._redistrict = enable;
                    this._indicators = indicators;
                    this._model.setId();
                    this._model.setId(id);
                }
            }
        }
        Dashboards.MapAdapter = MapAdapter;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
;
/**
 * Created by jean.rennes on 19/09/2017.
 */
///<reference path="../Global.ts" />
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        class ComboBox extends Controls.Control {
            constructor(element) {
                super(element);
                this._disabled = false;
                this.empty();
            }
            _onclick(ev) {
                let options = this._select.getElementsByTagName("option");
                $(options).css("background", $(this._select).css("background-color"));
                $(options).css("color", $(this._select).css("color"));
                $(options).css("font", $(this._select).css("font"));
            }
            _onover(ev) {
                $(this._select).css("background-image", this._getBckImage(true));
            }
            _onout(ev) {
                $(this._select).css("background-image", this._getBckImage(false));
            }
            _onSelChange(ev) {
                this.onSelChange(ev);
            }
            onSelChange(ev) {
            }
            get disabled() {
                return this._disabled;
            }
            set disabled(newVal) {
                if (this._disabled != newVal) {
                    this._disabled = newVal;
                    if (this._select)
                        this._select.disabled = this._disabled;
                }
            }
            set value(newVal) {
                if (this._select)
                    this._select.value = newVal;
            }
            get value() {
                if (this._select)
                    return this._select.value;
                return '';
            }
            addItem(value, templateName) {
                let option = document.createElement('option');
                option.value = value.dataItem['id'];
                option.label = value.dataItem['name'];
                option.text = value.dataItem['name'];
                this._select.appendChild(option);
            }
            empty() {
                $(this.node).empty();
                this._select = document.createElement('select');
                $(this._select).css("background-color", $(this.node).css("background-color"));
                $(this._select).css("color", $(this.node).css("color"));
                $(this._select).css("font", $(this.node).css("font"));
                $(this._select).css("background-image", this._getBckImage(false));
                this._select.disabled = this._disabled;
                this.node.appendChild(this._select);
                this._select.onchange = this._onSelChange.bind(this);
                this._select.onclick = this._onclick.bind(this);
                this._select.onmouseover = this._onover.bind(this);
                this._select.onmouseout = this._onout.bind(this);
            }
            _getBckImage(hover) {
                if (this.disabled)
                    return "none";
                var hexDigits = new Array("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f");
                var rgb2hex = function (rgb) {
                    var hex = function (x) {
                        return isNaN(x) ? "00" : hexDigits[(x - x % 16) / 16] + hexDigits[x % 16];
                    };
                    let rgbMatch = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
                    if (rgbMatch && rgbMatch.length >= 4)
                        return "%23" + hex(+rgbMatch[1]) + hex(+rgbMatch[2]) + hex(+rgbMatch[3]);
                    return "%23000000";
                };
                let color = rgb2hex($(this._select).css("color"));
                let transform = hover ? '' : 'translate(0%20292.4)%20rotate(-90)';
                return "url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20transform%3D%22" + transform + "%22%20fill%3D%22" + color + "%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E')";
            }
        }
        Controls.ComboBox = ComboBox;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 19/09/2017.
 */
///<reference path="../../models/data/Data.ts" />
///<reference path="../../views/controls/ComboBox.ts" />
///<reference path="../../helpers/AdapterBase.ts" />
var AFC;
(function (AFC) {
    var Data;
    (function (Data) {
        class ComboBoxAdapter extends AFC.Tools.AdapterBase {
            constructor(control) {
                super();
                this.control = control;
                this.control.onSelChange = this.onControlChange;
                this._value = '';
            }
            onControlChange(ev) {
            }
            set value(newVal) {
                this._value = newVal;
            }
            get value() {
                return this.control && this.control.value;
            }
            empty() {
                if (this.control) {
                    let v = this.control.value;
                    if (v && v != "")
                        this._value = v;
                }
                this.control.empty();
            }
            _update(model) {
                this.empty();
                if (model) {
                    let getContainer;
                    let maxItem = model.length, container;
                    let found = false;
                    getContainer = (i) => model.item(i);
                    for (let i = 0; i < maxItem; ++i) {
                        container = getContainer(i);
                        if (container.dataItem['id'] == this._value)
                            found = true;
                        this.control.addItem(container, void 0);
                    }
                    if (!found && (model.length > 0))
                        this._value = getContainer(0).dataItem['id'];
                    this.control.value = this._value;
                }
                this.onGenerate && this.onGenerate();
            }
            unbind() {
                this.empty();
                super.unbind();
            }
        }
        Data.ComboBoxAdapter = ComboBoxAdapter;
    })(Data = AFC.Data || (AFC.Data = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 08/09/2016.
 */
///<reference path="../Global.ts" />
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        class Label {
            constructor(element) {
                let parent = jQuery(typeof element === 'string' ? document.getElementById(element) : element);
                this._label = document.createElement('span');
                this._displayloading = false;
                if (parent.attr('enableLoading') == '1')
                    this._displayloading = true;
                parent.append(this._label);
            }
            setHTML(html) {
                if (!html) {
                    if (this._displayloading) {
                        $(this._label).addClass('loading');
                        this._label.innerHTML = "&nbsp;";
                    }
                    else
                        this._label.innerHTML = "";
                }
                else {
                    this._label.innerHTML = html;
                    if (this._displayloading)
                        $(this._label).removeClass('loading');
                }
            }
        }
        Controls.Label = Label;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 31/03/2017.
 */
///<reference path="../../models/data/Global.ts" />
///<reference path="../../views/controls/Label.ts" />
///<reference path="../../helpers/AdapterBase.ts" />
var AFC;
(function (AFC) {
    var Data;
    (function (Data) {
        class LabelPanel {
            constructor(named, label) {
                this._named = named;
                this._label = label;
            }
            update(dataContainer) {
                this._label.setHTML(this._named.name && dataContainer ? dataContainer.getData(this._named.name, true) : null);
            }
        }
        Data.LabelPanel = LabelPanel;
        class PanelAdapter extends AFC.Tools.AdapterBase {
            constructor() {
                super(...arguments);
                this._cnt = 0;
            }
            _onContainer(dataContainer) {
                this._dataContainer = dataContainer;
                this._refresh();
            }
            _refresh() {
                if (this._panels) {
                    for (let key in this._panels) {
                        this._panels[key].update(this._dataContainer);
                    }
                }
            }
            _update(model) {
                this._dataContainer = null;
                this._refresh();
                model.getDataContainer().then(dataContainer => this._onContainer(dataContainer));
            }
            add(panel) {
                let key = ++this._cnt;
                (this._panels || (this._panels = {}))[key] = panel;
                panel.update(this._dataContainer);
                return key;
            }
            remove(key) {
                let panel = this._panels[key];
                if (panel) {
                    delete this._panels[key];
                    panel.update();
                }
            }
            unbind() {
                delete this._dataContainer;
                this._refresh();
                super.unbind();
            }
            refresh(key) {
                key ? this._panels[key] && this._panels[key].update(this._dataContainer) : this._refresh();
            }
        }
        Data.PanelAdapter = PanelAdapter;
    })(Data = AFC.Data || (AFC.Data = {}));
})(AFC || (AFC = {}));
;
/**
 * Created by jean.rennes on 08/09/2016.
 */
///<reference path="../../helpers/AdapterBase.ts" />
///<reference path="../../views/controls/Label.ts" />
var AFC;
(function (AFC) {
    var Globals;
    (function (Globals) {
        class LabelAdapter extends AFC.Tools.AdapterBase {
            constructor(label) {
                super();
                this.control = label;
            }
            _update(model) {
                this.control.setHTML(model.label);
            }
        }
        Globals.LabelAdapter = LabelAdapter;
    })(Globals = AFC.Globals || (AFC.Globals = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 17/03/2016.
 */
///<reference path="Global.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="../../helpers/Tools.ts" />
var AFC;
(function (AFC) {
    var Globals;
    (function (Globals) {
        function _compare0(collator, brands, i0, str1) {
            return collator.compare(brands[i0], str1);
        }
        function _compare1(collator, brands, i0, i1) {
            return _compare0(collator, brands, i0, brands[i1]);
        }
        class SymbolFactory {
            constructor(descriptor, widths, heights) {
                let reverse = this._reverse = {};
                let collator = new Intl.Collator(void 0, { sensitivity: 'base' });
                descriptor.symbols.forEach((item, indice) => reverse[item.toLowerCase()] = indice);
                this._data = descriptor;
                (this._index = this._data.brands.map((item, indice) => indice)).sort(_compare1.bind(null, collator, this._data.brands));
                this._widths = widths;
                this._heights = heights;
            }
            get brands() {
                return this._data.brands;
            }
            get businessCodes() {
                return this._data.types;
            }
            indexOf(brand) {
                let brands = this._data.brands;
                let collator = new Intl.Collator(void 0, { sensitivity: 'base' });
                let i = AFC.Tools.lower_bound(this._index, brand, _compare0.bind(null, collator, brands));
                return (i < this._index.length) && (_compare0(collator, brands, this._index[i], brand) === 0) ? i : -1;
            }
            symbols(brand) {
                if (brand) {
                    let i = this.indexOf(brand);
                    let s;
                    if (i !== -1) {
                        let keys = this._data.index.keys;
                        let j = AFC.Tools.lower_bound(keys, this._index[i]);
                        while ((j < keys.length) && (keys[j] === this._index[i])) {
                            let _type = this._data.index.values[j] & 0xFFFF;
                            let symbol = this._data.index.values[j] >> 16;
                            ++j;
                            (s || (s = {}))[this._data.types[_type]] = this._data.symbols[symbol];
                        }
                    }
                    return s;
                }
            }
            symbol(symbol) {
                if (symbol) {
                    let i = this._reverse[symbol.toLowerCase()];
                    if (i !== void 0) {
                        let s = this._data.images[i];
                        let width = this._widths[i];
                        return { url: s, width: width, height: this._heights[i] };
                    }
                }
            }
        }
        Globals.SymbolFactory = SymbolFactory;
    })(Globals = AFC.Globals || (AFC.Globals = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 27/06/2016.
 */
///<reference path="../../helpers/Tools.ts" />
var AFC;
(function (AFC) {
    var Data;
    (function (Data) {
        class FilterIndex extends Data.UniqueIndex {
            get length() {
                return this.values.length;
            }
            getRow(index) {
                return this.values[index];
            }
        }
        function _getValues(dataModel, filter) {
            const values = [];
            for (let i = 0, iLength = dataModel.length, row; i < iLength; ++i) {
                row = dataModel.getRow(i);
                (!filter || filter(row)) && values.push(row);
            }
            return values;
        }
        class FillerIndex {
            constructor(filterModel, model) {
                this.filterModel = filterModel;
                this.model = model;
            }
            get length() {
                const model = this.model;
                return model ? model.length : 0;
            }
            getRow(index) {
                const model = this.model;
                return model && model.getRow(index);
            }
            get values() {
                return this._values || (this._values = this.model && (this.model.values || _getValues(this.model)));
            }
            indexOf(row) {
                const model = this.model;
                return model ? model.indexOf(row) : -1;
            }
            find(key) {
                const model = this.model;
                return model ?
                    (model.find ? model.find(key) : this.indexOf(Data.createRowFromValues(this.filterModel, key, {}))) :
                    -1;
            }
        }
        function _setModel(dataModel) {
            let forwards = [];
            if (dataModel) {
                this._dataModel = dataModel;
                dataModel.on && forwards.push({
                    type: 6 /* Tools.EventType.Dirty */,
                    callback: this._onDirty,
                    observable: dataModel
                });
            }
            else {
                delete this._dataModel;
            }
            this._setForwards(forwards);
        }
        class FilterModel extends AFC.Tools.AutoSubscribeForwarder {
            constructor(filter, dataModel) {
                super();
                this._filter = filter;
                _setModel.call(this, dataModel);
            }
            _getIndex() {
                let index = this._index;
                if (!index) {
                    const dataModel = this._dataModel, filter = dataModel && this._filter;
                    if (filter) {
                        const values = _getValues(dataModel, row => filter(row, this)), columnIndex = this.columnIndex;
                        index = new FilterIndex(this.primaryKey.map(name => columnIndex[name]), values);
                    }
                    else {
                        index = new FillerIndex(this, dataModel);
                    }
                    this._index = index;
                }
                return index;
            }
            _filterEvent(item, a) {
                switch (item.type) {
                    case 1 /* DataEventType.create */:
                    case 4 /* DataEventType.delete_ */:
                    case 0 /* DataEventType.none */:
                        this._filter(item.row, this) && a.push(item);
                        break;
                    case 2 /* DataEventType.modify */:
                        a.push({
                            type: 4 /* DataEventType.delete_ */,
                            row: item.row,
                            committed: item.committed
                        });
                        this._filter(item.row, this) && a.push({
                            type: 1 /* DataEventType.create */,
                            row: item.row,
                            committed: item.committed
                        });
                    default:
                        break;
                }
            }
            _onDirty(event) {
                let data = event.data;
                delete this._index;
                if (data && (data.reset || data.items)) {
                    if (data.reset) {
                        this.fireEvent(6 /* Tools.EventType.Dirty */, new Data.DataEventData(void 0, true));
                    }
                    else {
                        let a;
                        if (this._filter) {
                            a = [];
                            data.items.forEach((item) => this._filterEvent(item, a));
                        }
                        else {
                            a = data.items;
                        }
                        a.length && this.fireEvent(6 /* Tools.EventType.Dirty */, new Data.DataEventData(a));
                    }
                }
            }
            set filter(filter) {
                if (this._filter !== filter) {
                    delete this._index;
                    this._filter = filter;
                    this.fireEvent(6 /* Tools.EventType.Dirty */, new Data.DataEventData(void 0, true));
                }
            }
            get filter() {
                return this._filter;
            }
            set dataModel(dataModel) {
                if (this._dataModel !== dataModel) {
                    delete this._index;
                    delete this._columnIndex;
                    _setModel.call(this, dataModel);
                    this.fireEvent(6 /* Tools.EventType.Dirty */, new Data.DataEventData(void 0, true));
                }
            }
            get dataModel() {
                return this._dataModel;
            }
            get columns() {
                return this._dataModel && this._dataModel.columns;
            }
            get primaryKey() {
                return this._dataModel && this._dataModel.primaryKey;
            }
            get length() {
                return this._getIndex().length;
            }
            getRow(index) {
                return this._getIndex().getRow(index);
            }
            get values() {
                return this._getIndex().values;
            }
            item(index) {
                let dataModel = this._dataModel;
                if (dataModel) {
                    let item = dataModel.item ?
                        dataModel.item(this._filter ? dataModel.indexOf(this.values[index]) : index) :
                        AFC.Tools.Data.mapRow(this.columns, this._getIndex().getRow(index));
                    return item && {
                        dataItem: item.dataItem,
                        dataItemIndex: index
                    };
                }
            }
            get columnIndex() {
                return this._dataModel && (this._columnIndex || (this._columnIndex = this._dataModel.columnIndex || Data.getColumnIndex(this.columns)));
            }
            getKeyFromRow(row) {
                return this._dataModel && this._dataModel.getKeyFromRow(row);
            }
            compareKey(row, key) {
                return this._dataModel && this._dataModel.compareKey(row, key);
            }
            compareRow(row0, row1) {
                return this._dataModel && this._dataModel.compareRow(row0, row1);
            }
            create(key, values) {
                let dataModel = this._dataModel;
                delete this._index;
                return dataModel && dataModel.create && dataModel.create(key, values);
            }
            modify(key, values) {
                let dataModel = this._dataModel;
                delete this._index;
                return dataModel && dataModel.modify && dataModel.modify(key, values);
            }
            delete_(key) {
                let dataModel = this._dataModel;
                delete this._index;
                dataModel && dataModel.delete_ && dataModel.delete_(key);
            }
            dropEvents(key) {
                let dataModel = this._dataModel;
                delete this._index;
                return dataModel && dataModel.dropEvents && dataModel.dropEvents(key);
            }
            indexOf(row) {
                return this._getIndex().indexOf(row);
            }
            find(key) {
                return this._getIndex().find(key);
            }
            refresh() {
                delete this._index;
                this.fireEvent(6 /* Tools.EventType.Dirty */, new Data.DataEventData(void 0, true));
            }
            createStore() {
                let dataModel = this._dataModel;
                return dataModel && dataModel.createStore && dataModel.createStore();
            }
        }
        Data.FilterModel = FilterModel;
    })(Data = AFC.Data || (AFC.Data = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 03/02/2016.
 */
///<reference path="../AFC.ts" />
var AFC;
(function (AFC) {
    var Tools;
    (function (Tools) {
        var Geometry;
        (function (Geometry) {
            function _inflate(geoJsonObject, bbox) {
                let inflater;
                return geoJsonObject && (inflater = _inflaters[geoJsonObject.type]) && (inflater(geoJsonObject, bbox), true);
            }
            const _inflaters = {
                Point: (geometry, bbox) => inflateRect(bbox, geometry.coordinates),
                LineString: (geometry, bbox) => geometry.coordinates.forEach(item => inflateRect(bbox, item)),
                Polygon: (geometry, bbox) => geometry.coordinates[0].forEach(item => inflateRect(bbox, item)),
                MultiPoint: (geometry, bbox) => geometry.coordinates.forEach(item => inflateRect(bbox, item)),
                MultiLineString: (geometry, bbox) => geometry.coordinates.forEach(item => item.forEach(item => inflateRect(bbox, item))),
                MultiPolygon: (geometry, bbox) => geometry.coordinates.forEach(item => item[0].forEach(item => inflateRect(bbox, item))),
                GeometryCollection: (geometry, bbox) => geometry.geometries.forEach((item) => _inflate(item, bbox)),
                Feature: (feature, bbox) => _inflate(feature.geometry, bbox),
                FeatureCollection: (featureCollection, bbox) => featureCollection.features.forEach((item) => _inflate(item, bbox))
            };
            function inflateRect(bbox, position) {
                bbox[0] = Math.min(bbox[0], position[0]);
                bbox[1] = Math.min(bbox[1], position[1]);
                bbox[2] = Math.max(bbox[2], position[0]);
                bbox[3] = Math.max(bbox[3], position[1]);
            }
            Geometry.inflateRect = inflateRect;
            function inflateRectWithRect(bbox0, bbox1) {
                bbox0[0] = Math.min(bbox0[0], bbox1[0]);
                bbox0[1] = Math.min(bbox0[1], bbox1[1]);
                bbox0[2] = Math.max(bbox0[2], bbox1[2]);
                bbox0[3] = Math.max(bbox0[3], bbox1[3]);
            }
            Geometry.inflateRectWithRect = inflateRectWithRect;
            function getBoundRect(geometry) {
                let rect = [180, 90, -180, -90];
                if (_inflate(geometry, rect) && rect[0] !== 180) {
                    return rect;
                }
            }
            Geometry.getBoundRect = getBoundRect;
            function equalPoint(g0, g1) {
                return (g0 === g1) || (g0 && g1 && _pointEqual(g0.coordinates, g1.coordinates));
            }
            Geometry.equalPoint = equalPoint;
            function makePoint(x, y) {
                return {
                    type: "Point",
                    coordinates: [x, y]
                };
            }
            Geometry.makePoint = makePoint;
            function _getLength(positions, lengths) {
                let length = 0;
                for (let i = 1; i < positions.length; ++i) {
                    lengths.push(length += Math.sqrt(Math.pow(positions[i][0] - positions[i - 1][0], 2) + Math.pow(positions[i][1] - positions[i - 1][1], 2)));
                }
                return length;
            }
            function _getLineCentroid(positions, lengths, length) {
                if (length === 0) {
                    return makePoint(positions[0][0], positions[0][1]);
                }
                let i = Tools.lower_bound(lengths, length), ratio = (lengths[i] - length) / (lengths[i] - (lengths[i - 1] || 0)), end = positions[i];
                return makePoint(end[0] - ratio * (end[0] - positions[i - 1][0]), end[1] - ratio * (end[1] - positions[i - 1][1]));
            }
            function _getCentroid(ring, point) {
                let x, y, w;
                for (let i = 1; i < ring.length; ++i) {
                    x = (ring[i][0] + ring[i - 1][0]) / 2;
                    y = (ring[i][1] + ring[i - 1][1]) / 2;
                    w = Math.abs((ring[i][1] + ring[i - 1][1]) * (ring[i][0] - ring[i - 1][0]) / 2);
                    point.x += x * w;
                    point.y += y * w;
                    point.w += w;
                }
            }
            function _nearest(pt, ring) {
                let distance = Number.MAX_SAFE_INTEGER, position = -1, local;
                ring.forEach((point, indice) => {
                    local = Math.pow(point[0] - pt[0], 2) + Math.pow(point[1] - pt[1], 2);
                    if (local < distance) {
                        distance = local;
                        position = indice;
                    }
                });
                return position === -1 ? pt : ring[position];
            }
            function _checkCentroid(rings, point) {
                let pt = [point.x / point.w, point.y / point.w];
                if (_pointInRing(pt, rings[0])) {
                    for (let i = 1; i < rings.length; ++i) {
                        if (_pointInRing(pt, rings[i])) {
                            pt = _nearest(pt, rings[i]);
                            break;
                        }
                    }
                }
                else {
                    pt = _nearest(pt, rings[0]);
                }
                return makePoint(pt[0], pt[1]);
            }
            const centroids = {
                Point: function (geometry) {
                    return geometry;
                },
                MultiPoint: function (geometry) {
                    let position = geometry.coordinates[0];
                    return position && makePoint(position[0], position[1]);
                },
                LineString: function (geometry) {
                    let positions = geometry.coordinates;
                    if (positions.length > 0) {
                        let lengths = [], length = _getLength(positions, lengths);
                        return _getLineCentroid(positions, lengths, length);
                    }
                },
                MultiLineString: function (geometry) {
                    let positions = geometry.coordinates, current = -1, currents, pos;
                    if (positions.length > 0) {
                        for (let i = 0; i < positions.length; ++i) {
                            let locs = [];
                            let loc = _getLength(positions[i], locs);
                            if (loc > current) {
                                current = loc;
                                currents = locs;
                                pos = i;
                            }
                        }
                        return _getLineCentroid(positions[pos], currents, current);
                    }
                },
                Polygon: function (geometry) {
                    let point = { x: 0, y: 0, w: 0 };
                    _getCentroid(geometry.coordinates[0], point);
                    return _checkCentroid(geometry.coordinates, point);
                },
                MultiPolygon: function (geometry) {
                    let positions = geometry.coordinates, maxArea = -1, pos;
                    for (let i = 0; i < positions.length; ++i) {
                        let rect = [180, 90, -180, -90];
                        positions[i][0].forEach(item => inflateRect(rect, item));
                        let x = rect[2] - rect[0], y = rect[2] - rect[0], area;
                        if ((x > 0) && (y > 0)) {
                            area = x * y;
                            if (maxArea < area) {
                                maxArea = area;
                                pos = i;
                            }
                        }
                    }
                    if (maxArea > 0) {
                        let point = { x: 0, y: 0, w: 0 };
                        _getCentroid(geometry.coordinates[pos][0], point);
                        return _checkCentroid(geometry.coordinates[pos], point);
                    }
                },
                GeometryCollection: function (geometry) {
                    throw new Error('Not implemented');
                }
            };
            function getCentroid(geometry) {
                let f;
                return geometry && (f = centroids[geometry.type]) && f(geometry);
            }
            Geometry.getCentroid = getCentroid;
            function _isLeft(p0, p1, p2) {
                return ((p1[0] - p0[0]) * (p2[1] - p0[1]) - (p2[0] - p0[0]) * (p1[1] - p0[1]));
            }
            function _pointInRing(pt, ring) {
                let x = pt[0], y = pt[1], wn = 0;
                for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                    let xi = ring[i][0], yi = ring[i][1], xj = ring[j][0], yj = ring[j][1];
                    if (yj <= y) {
                        if (yi > y) {
                            if (_isLeft([xj, yj], [xi, yi], [x, y]) > 0) {
                                wn++;
                            }
                        }
                    }
                    else {
                        if (yi <= y) {
                            if (_isLeft([xj, yj], [xi, yi], [x, y]) < 0) {
                                wn--;
                            }
                        }
                    }
                }
                return wn !== 0;
            }
            function _pointInPolygon(pt, coordinates) {
                return coordinates.length && coordinates.every((ring, indice) => indice ? !_pointInRing(pt, ring) : _pointInRing(pt, ring));
            }
            function _pointEqual(pt0, pt1) {
                return (Math.abs(pt0[0] - pt1[0]) < 10E-8) && (Math.abs(pt0[1] - pt1[1]) < 10E-8);
            }
            function _pointOnSegment(pt, pt1, pt2) {
                let c = pt2[0] - pt1[0], d = pt2[1] - pt1[1], len_sq = c * c + d * d, ptCalc;
                if (!len_sq) {
                    ptCalc = pt1;
                }
                else {
                    let a = pt[0] - pt1[0], b = pt[1] - pt1[1], fact = (a * c + b * d) / len_sq;
                    ;
                    if ((fact < 0) || (fact > 1)) {
                        return;
                    }
                    ptCalc = [pt1[0] + fact * c, pt1[1] + fact * d];
                }
                return _pointEqual(ptCalc, pt);
            }
            function _pointOnLineString(pt, coordinates) {
                let l = coordinates.length;
                if (l) {
                    return l === 1 ?
                        _pointEqual(pt, coordinates[0]) :
                        coordinates.some((position, indice) => indice && _pointOnSegment(pt, coordinates[indice - 1], position));
                }
            }
            const _pointInGeometry = {
                Point: (point, geometry) => _pointEqual(point, geometry.coordinates),
                MultiPoint: (point, geometry) => geometry.coordinates.some(point2 => _pointEqual(point, point2)),
                LineString: (point, geometry) => _pointOnLineString(point, geometry.coordinates),
                MultiLineString: (point, geometry) => geometry.coordinates.some(lineString => _pointOnLineString(point, lineString)),
                Polygon: (point, geometry) => _pointInPolygon(point, geometry.coordinates),
                MultiPolygon: (point, geometry) => geometry.coordinates.some(polygon => _pointInPolygon(point, polygon)),
            };
            function pointInGeometry(point, geometry) {
                let f;
                return geometry && (f = _pointInGeometry[geometry.type]) && f(point, geometry);
            }
            Geometry.pointInGeometry = pointInGeometry;
        })(Geometry = Tools.Geometry || (Tools.Geometry = {}));
    })(Tools = AFC.Tools || (AFC.Tools = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 08/04/2016.
 */
///<reference path="../models/data/Global.ts" />
///<reference path="../models/globals/Global.ts" />
var AFC;
(function (AFC) {
    var Tools;
    (function (Tools) {
        var Cartographer;
        (function (Cartographer) {
            const _byPass = (geometry) => geometry;
            const _concat = (a, b) => {
                b.forEach((item) => { a.push(item); });
            };
            const _polygonConcats = {
                Polygon: (coordinates, geometry) => {
                    coordinates.push(geometry.coordinates);
                },
                MultiPolygon: (coordinates, geometry) => {
                    _concat(coordinates, geometry.coordinates);
                },
                GeometryCollection: (coordinates, geometry) => {
                    geometry.geometries.forEach(geometry => {
                        let concat = geometry && _polygonConcats[geometry.type];
                        concat && concat(coordinates, geometry);
                    });
                }
            };
            const _polygonConverters = {
                Polygon: _byPass,
                MultiPolygon: _byPass,
                GeometryCollection: (geometry) => {
                    let coordinates = [];
                    _polygonConcats.GeometryCollection(coordinates, geometry);
                    if (coordinates.length) {
                        return coordinates.length > 1 ? {
                            type: 'MultiPolygon',
                            coordinates: coordinates
                        } : {
                            type: 'Polygon',
                            coordinates: coordinates[0]
                        };
                    }
                }
            };
            function _buildLineString(coordinates) {
                if (coordinates.length) {
                    return coordinates.length > 1 ? {
                        type: 'MultiLineString',
                        coordinates: coordinates
                    } : {
                        type: 'LineString',
                        coordinates: coordinates[0]
                    };
                }
            }
            const _lineConcats = {
                LineString: (coordinates, geometry) => {
                    coordinates.push(geometry.coordinates);
                },
                MultiLineString: (coordinates, geometry) => {
                    _concat(coordinates, geometry.coordinates);
                },
                Polygon: (coordinates, geometry) => {
                    _concat(coordinates, geometry.coordinates);
                },
                MultiPolygon: (coordinates, geometry) => {
                    geometry.coordinates.forEach(item => _concat(coordinates, item));
                },
                GeometryCollection: (coordinates, geometry) => {
                    geometry.geometries.forEach(geometry => {
                        let concat = geometry && _lineConcats[geometry.type];
                        concat && concat(coordinates, geometry);
                    });
                }
            };
            const _lineConverters = {
                LineString: _byPass,
                MultiLineString: _byPass,
                Polygon: (geometry) => _buildLineString(geometry.coordinates),
                MultiPolygon: (geometry) => {
                    let coordinates = [];
                    _lineConcats.MultiPolygon(coordinates, geometry);
                    return _buildLineString(coordinates);
                },
                GeometryCollection: (geometry) => {
                    let coordinates = [];
                    _lineConcats.GeometryCollection(coordinates, geometry);
                    return _buildLineString(coordinates);
                }
            };
            const _converters = {
                [1 /* Globals.LayerType.polygon */]: (geometry) => geometry && _polygonConverters[geometry.type] && _polygonConverters[geometry.type](geometry),
                [2 /* Globals.LayerType.line */]: (geometry) => geometry && _lineConverters[geometry.type] && _lineConverters[geometry.type](geometry),
                [3 /* Globals.LayerType.symbol */]: Tools.Geometry.getCentroid
            };
            function getRowConverter(layerType, iGeometry) {
                let f = _converters[layerType];
                return f ? (row) => f(row[iGeometry]) : (() => { });
            }
            Cartographer.getRowConverter = getRowConverter;
            function feature(geometry, properties) {
                return {
                    type: 'Feature',
                    geometry: geometry,
                    properties: properties
                };
            }
            Cartographer.feature = feature;
            function getGeoJSONFromCollection(collection, iGeometry, layerType, options) {
                let geometries = [];
                let bbox;
                let converter = getRowConverter(layerType, iGeometry);
                for (let i = 0, iCount = collection.length; i < iCount; ++i) {
                    let row = collection.getRow(i);
                    if (!options || !options.allow || options.allow(row)) {
                        let geometry = converter(row);
                        if (geometry) {
                            if (!options || !options.toBBox || options.toBBox(row)) {
                                let rect = Tools.Geometry.getBoundRect(geometry);
                                Tools.Geometry.inflateRectWithRect(bbox || (bbox = [180, 90, -180, -90]), rect);
                            }
                            geometries.push(feature(geometry, { data: row }));
                        }
                    }
                }
                let json = {
                    bbox: bbox,
                    type: 'FeatureCollection',
                    features: geometries
                };
                return json;
            }
            Cartographer.getGeoJSONFromCollection = getGeoJSONFromCollection;
        })(Cartographer = Tools.Cartographer || (Tools.Cartographer = {}));
    })(Tools = AFC.Tools || (AFC.Tools = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 10/03/2016.
 */
///<reference path="Global.ts" />
///<reference path="Symbol.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="../data/Data.ts" />
///<reference path="../data/Filter.ts" />
///<reference path="../../views/Global.ts" />
///<reference path="../../helpers/Geometry.ts" />
///<reference path="../../helpers/Data.ts" />
///<reference path="../../helpers/Cartographer.ts" />
var AFC;
(function (AFC) {
    var Globals;
    (function (Globals) {
        class MapEventData {
            constructor(layer) {
                layer && (this.layers = [layer]);
            }
            concat(d) {
                if (d.layers && d.layers.length) {
                    if (this.layers) {
                        let e = {};
                        this.layers.forEach(item => e[item.indice] = item.data);
                        d.layers.forEach(item => e[item.indice] ? e[item.indice].concat(item.data) : this.layers.push(item));
                    }
                    else {
                        this.layers = d.layers;
                    }
                }
                return this;
            }
            onDispatch() {
                if (this.layers) {
                    this.layers.forEach(item => item.data && item.data.onDispatch && item.data.onDispatch());
                }
                return this;
            }
        }
        ;
        class MapLayerModelEventData {
            constructor(reset, visibility, data, filter, style) {
                if (reset) {
                    this.data = new AFC.Data.DataEventData(void 0, true);
                }
                else {
                    this.visibility = visibility;
                    this.data = data;
                    this.style = style;
                    this.filter = filter;
                }
            }
            concat(d) {
                if (!this.data || !this.data.reset) {
                    if (d.data) {
                        if (d.data.reset) {
                            this.data = d.data;
                            return this;
                        }
                        this.data = this.data ? this.data.concat(d.data) : d.data;
                    }
                    d.visibility && (this.visibility = true);
                    d.style && (this.style = true);
                    d.filter && (this.filter = true);
                }
                return this;
            }
        }
        Globals.mapLayerModelEventData = (reset, visibility, data, filter, style) => new MapLayerModelEventData(reset, visibility, data, filter, style);
        class MapLayerModel extends AFC.Tools.AutoSubscribeForwarder {
            constructor(template, thematics) {
                super();
                this._template = template;
                this.minZ = template.minZ;
                (template.maxZ !== void 0) && (this.maxZ = template.maxZ - 1);
                this._hidden = !!template.hidden;
                this.selectable = !!template.selectable;
                this._thematics = thematics;
                (template.type === 3 /* LayerType.symbol */) && (this._clustering = template.properties.clustering ? template.properties.clustering.value : true);
            }
            get name() {
                return this._template.name;
            }
            get type() {
                return this._template.type;
            }
            get properties() {
                return this._template.properties;
            }
            get symbolFactory() {
                return this._template.symbolFactory;
            }
            get tooltips() {
                return this._template.tooltips;
            }
            set filter(filter) {
                if (filter !== this._filter) {
                    this.fireEvent(1073741824 /* Tools.EventType.Attach */, new MapLayerModelEventData(false, false, void 0, true));
                    this._filter = filter;
                }
            }
            get filter() {
                return this._filter;
            }
            set options(options) {
                if (options !== this._options) {
                    if ((this._options && this._options.coordsToLatLng) !== (options && options.coordsToLatLng)) {
                        this.fireEvent(1073741824 /* Tools.EventType.Attach */, new MapLayerModelEventData(true));
                    }
                    else if (this.type === 3 /* LayerType.symbol */ ?
                        (this._options && this._options.pointToLayer) !== (options && options.pointToLayer) :
                        (this._options && this._options.style) !== (options && options.style)) {
                        this.fireEvent(1073741824 /* Tools.EventType.Attach */, new MapLayerModelEventData(false, false, void 0, false, true));
                    }
                    this._options = options;
                }
            }
            get options() {
                return this._options;
            }
            set hidden(value) {
                value = !!value;
                if (this._hidden !== value) {
                    this._hidden = value;
                    this.fireEvent(1073741824 /* Tools.EventType.Attach */, new MapLayerModelEventData(false, true));
                }
            }
            get hidden() {
                return this._hidden;
            }
            get legend() {
                return this._thematics;
            }
            set clustering(value) {
                this._clustering = !!value;
            }
            get clustering() {
                return this._clustering && (this.type === 3 /* LayerType.symbol */);
            }
            set clusteringMaxZoom(value) {
                this._clusteringMaxZoom = value;
            }
            get clusteringMaxZoom() {
                return this._clusteringMaxZoom;
            }
        }
        Globals.MapLayerModel = MapLayerModel;
        class MapLayerData extends AFC.Data.FilterModel {
            constructor(name) {
                super();
                this.name = name;
            }
            get geometryIndice() {
                return this._geometryIndice;
            }
            set dataModel(value) {
                super.dataModel = value;
                this._geometryIndice = AFC.Tools.Data.findFirstGeometry(value.columns);
            }
            get dataModel() {
                return super.dataModel;
            }
        }
        class MapLayerStaticModel extends MapLayerModel {
            constructor(template, dataModel, thematics) {
                const data = new MapLayerData(template?.table?.name || AFC.Tools.Data.generateRndString(10));
                super(template, thematics);
                this._setForwards([{
                        type: 1073741824 /* Tools.EventType.Attach */,
                        targetType: 6 /* Tools.EventType.Dirty */,
                        observable: this.data = data,
                        callback: this._onDirty
                    }]);
                dataModel && (this.dataModel = dataModel);
            }
            _onDirty(e) {
                delete this._geoJSON;
                this.fireEvent(1073741824 /* Tools.EventType.Attach */, new MapLayerModelEventData(false, false, e.data));
            }
            set dataModel(dataModel) {
                if (dataModel !== this.data.dataModel) {
                    this.data.dataModel = dataModel;
                    delete this._geoJSON;
                }
            }
            set thematics(value) {
                this._thematics = value;
                delete this._geoJSON;
            }
            set converter(value) {
                this._converter = value;
                delete this._geoJSON;
            }
            set hidden(value) {
                super.hidden = value;
                delete this._geoJSON;
            }
            get hidden() {
                return super.hidden;
            }
            clone() {
                let clone = Reflect.construct(MapLayerStaticModel, [this._template, this.data?.dataModel, this.legend], this.constructor);
                clone._geoJSON = this._geoJSON;
                clone._clustering = this._clustering;
                clone.override = this.override;
                clone.clusteringMaxZoom = this.clusteringMaxZoom;
                this._converter && (clone._converter = this._converter);
                return clone;
            }
            get geoJSON() {
                return this._geoJSON || (this._geoJSON = AFC.Tools.Cartographer.getGeoJSONFromCollection(this.data, this.data.geometryIndice, this.type, this._converter));
            }
            refresh() {
                delete this._geoJSON;
                this.fireEvent(1073741824 /* Tools.EventType.Attach */, new AFC.Data.DataEventData(void 0, true));
            }
        }
        Globals.MapLayerStaticModel = MapLayerStaticModel;
        function _getLegendInfo(layer, prop, _type) {
            let legend;
            let properties = layer.properties;
            let property;
            let datas = layer.legend;
            let data;
            if (properties && datas && (property = properties[prop]) && (data = datas[prop])) {
                legend = {
                    type: _type,
                    property: property,
                    data: data
                };
            }
            return legend;
        }
        class MapModel extends AFC.Tools.EventSink {
            constructor() {
                super();
                this._layers = [];
                this.on(1073741824 /* Tools.EventType.Attach */, this._onAttach, this);
            }
            _onAttach(event) {
                this.fireEvent(6 /* Tools.EventType.Dirty */, event.data);
            }
            _onDirty(event) {
                let layer = event.target;
                let i = this._layers.indexOf(layer);
                if (i !== -1) {
                    let data = event.data;
                    this.fireEvent(1073741824 /* Tools.EventType.Attach */, new MapEventData({ data: data.data, layer: layer, indice: i, style: data.style, filter: data.filter, visibility: data.visibility }));
                }
            }
            static getLegendInfo(layer) {
                let legend;
                switch (layer.type) {
                    case 3 /* LayerType.symbol */:
                        legend = _getLegendInfo(layer, 'fillColor', 0 /* LegendType.fillColor */) ||
                            _getLegendInfo(layer, 'size', 1 /* LegendType.size */) ||
                            _getLegendInfo(layer, 'icon', 2 /* LegendType.icon */);
                        break;
                    case 1 /* LayerType.polygon */:
                        legend = _getLegendInfo(layer, 'fillColor', 0 /* LegendType.fillColor */);
                        break;
                }
                return legend;
            }
            get layers() {
                return this._layers;
            }
            addLayer(layer) {
                this._layers.push(layer);
                layer.on(1073741824 /* Tools.EventType.Attach */, this._onDirty, this);
                this.fireEvent(6 /* Tools.EventType.Dirty */, new MapEventData());
            }
            clearLayers() {
                this._layers.forEach(layer => {
                    layer.off(1073741824 /* Tools.EventType.Attach */, this._onDirty, this);
                });
                this._layers = [];
                this.fireEvent(6 /* Tools.EventType.Dirty */, new MapEventData());
            }
        }
        Globals.MapModel = MapModel;
        let LayerTypeLookup = {
            asteropLayerUnknown: 0 /* LayerType.unknown */,
            asteropLayerPolygon: 1 /* LayerType.polygon */,
            asteropLayerLine: 2 /* LayerType.line */,
            asteropLayerSymbol: 3 /* LayerType.symbol */,
            asteropLayerLabel: 5 /* LayerType.label */,
            asteropLayerPie: 4 /* LayerType.pie */,
            asteropLayerOlap: 100 /* LayerType.olap */,
            asteropLayerRaster: -1 /* LayerType.raster */,
            asteropLayerMXD: 200 /* LayerType.mxd */
        };
        function layerType(value) {
            return LayerTypeLookup[value];
        }
        Globals.layerType = layerType;
        const _sequence = Symbol();
        function convertMapLayerMetaData(value, globals) {
            return new Promise(async (resolve) => {
                let metadata = value;
                if (value) {
                    ((metadata.type = layerType(value.type) || 0 /* LayerType.unknown */) === 3 /* LayerType.symbol */) && !!(metadata.properties.icon) && (metadata.symbolFactory = await globals.getSymbolFactory());
                    metadata.table && (metadata.table.columns = AFC.Data.mapDataColumns(value.table));
                }
                resolve(metadata || { type: 0 /* LayerType.unknown */ });
            });
        }
        Globals.convertMapLayerMetaData = convertMapLayerMetaData;
        ;
        class MapLayerDescriptor extends AFC.Tools.EventSink {
            constructor(globals, descriptor, data, type) {
                super();
                this._globals = globals;
                this.mapView = descriptor;
                this.id = data.id;
                this.name = data.name;
                this.type = type;
                this.filterable = true;
            }
            createRequest(path, bypassContext, options) {
                return this.mapView.createRequest(`/layers/${this.id}${path || ''}`, bypassContext, options);
            }
            _onDataDone(metadata, sequence, jqXHR, textStatus) {
                if (this._seqData === sequence) {
                    let data = jqXHR?.responseJSON, dataTable, dataModel;
                    data && (dataTable = AFC.Data.updateTableData(data.table)) && (dataModel = new AFC.Data.DataModel(dataTable.columns, dataTable.primaryKey, dataTable.values));
                    isVectorLayer(metadata) && (this._content = {
                        table: dataModel,
                        legend: this._legend = data.legend
                    });
                    this.fireEvent(65536 /* Tools.EventType.UserEvent */ + 1);
                    this.fireEvent(65536 /* Tools.EventType.UserEvent */ + 2);
                }
            }
            _onLegendDone(sequence, jqXHR, textStatus) {
                if (this._seqLegend === sequence) {
                    this._legend = jqXHR.responseJSON;
                    this.fireEvent(65536 /* Tools.EventType.UserEvent */ + 1);
                }
            }
            _onAlways(sequence, jqXHR, textStatus) {
                if (this[_sequence] === sequence) {
                    convertMapLayerMetaData(jqXHR.responseJSON, this._globals).then(metadata => {
                        this._metadata = metadata;
                        this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                    });
                }
            }
            getMetadata() {
                return this.hasOwnProperty('_metadata') ? Promise.resolve(this._metadata) : new Promise((resolve) => {
                    this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this._metadata));
                    if (!this[_sequence]) {
                        let request = this.createRequest();
                        request.options.always = this._onAlways.bind(this);
                        this[_sequence] = request.call();
                    }
                });
            }
            getLegendData() {
                return this.hasOwnProperty('_legend') ? Promise.resolve(this._legend) : new Promise((resolve) => {
                    this.notify(65536 /* Tools.EventType.UserEvent */ + 1, ( /*event: Tools.IEvent*/) => resolve(this._legend));
                    if (!this._seqLegend) {
                        let request = this.createRequest('/legend', false);
                        request.options.always = this._onLegendDone.bind(this);
                        this._seqLegend = request.call();
                    }
                });
            }
            getContent() {
                return this._content ? Promise.resolve(this._content) : new Promise((resolve) => {
                    this.notify(65536 /* Tools.EventType.UserEvent */ + 2, ( /*event: Tools.IEvent*/) => resolve(this._content));
                    if (!this._seqData) {
                        this._seqData = this._seqLegend = -1;
                        delete this._legend;
                        this.getMetadata().then(metadata => {
                            if (metadata.type !== 0 /* LayerType.unknown */) {
                                let request = this.createRequest('/content', false);
                                request.options.always = this._onDataDone.bind(this, metadata);
                                this._seqData = this._seqLegend = request.call();
                            }
                            else {
                                this._onDataDone(metadata, -1);
                            }
                        });
                    }
                });
            }
            invalidate() {
                delete this._seqData;
                delete this._content;
                delete this._seqLegend;
                delete this._legend;
            }
        }
        Globals.MapLayerDescriptor = MapLayerDescriptor;
        class MapViewDescriptor extends AFC.Tools.EventSink {
            constructor(d, i) {
                super();
                this.id = i.id;
                this.name = i.name;
                this.globals = d;
            }
            _onAlways(sequence, jqXHR, textStatus) {
                if (this[_sequence] === sequence) {
                    let data = jqXHR.responseJSON;
                    this._metadata = {
                        layers: data?.layers ? data.layers.map(item => new MapLayerDescriptor(this.globals, this, item, layerType(item.type))) : [],
                    };
                    data && data.grayLevelsEnabled && (this._metadata.grayLevelsEnabled = true);
                    this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                }
            }
            createRequest(path = '', bypassContext, options) {
                return this.globals.createAjaxRequest(`/mapviews/${this.id}${path}`, bypassContext, options);
            }
            getMetadata() {
                return this._metadata ? Promise.resolve(this._metadata) : new Promise((resolve) => {
                    this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this._metadata));
                    if (!this[_sequence]) {
                        let request = this.createRequest();
                        request.options.always = this._onAlways.bind(this);
                        this[_sequence] = request.call();
                    }
                });
            }
            invalidate() {
                delete this[_sequence];
                delete this._metadata;
            }
        }
        Globals.MapViewDescriptor = MapViewDescriptor;
        const c_ImageLoading = 100;
        class GlobalsDescriptor extends AFC.Tools.EventSink {
            constructor(restModel) {
                super();
                this.restModel = restModel;
            }
            invalidate() {
                let mapViews = this._mapViews;
                this.fireEvent(6 /* Tools.EventType.Dirty */);
                if (mapViews) {
                    delete this._mapViews;
                    delete this[_sequence];
                    delete this.symbols;
                    delete this._symbolSequence;
                    mapViews.forEach((item) => item.invalidate());
                }
            }
            createAjaxRequest(path = '', bypassContext, options) {
                return this.restModel.createAjaxRequest(`/globals${path}`, bypassContext, options);
            }
            _onAlways(sequence, jqXHR, textStatus) {
                if (this[_sequence] === sequence) {
                    let data = jqXHR.responseJSON;
                    this._mapViews = data ? data.map(item => new MapViewDescriptor(this, item)) : [];
                    this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                }
            }
            getMapViews() {
                return this._mapViews ? Promise.resolve(this._mapViews) : new Promise((resolve) => {
                    this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this._mapViews));
                    if (!this[_sequence]) {
                        let request = this.createAjaxRequest('/mapviews');
                        request.options.always = this._onAlways.bind(this);
                        this[_sequence] = request.call();
                    }
                });
            }
            _onSymbolRestDone(sequence, jqXHR, textStatus) {
                if (this._symbolSequence === sequence) {
                    let data = jqXHR.responseJSON;
                    if (data) {
                        let iToLoad = data.images ? data.images.length : 0, iLoading = 1;
                        const widths = [], heights = [], onEnd = () => {
                            if (iToLoad === 0) {
                                this.symbols = new Globals.SymbolFactory(data, widths, heights);
                                this.fireEvent(65536 /* Tools.EventType.UserEvent */ + 1);
                            }
                            else if (--iLoading === 0) {
                                loadNext();
                            }
                        }, loadNext = () => {
                            const offset = data.images.length - iToLoad;
                            iLoading = Math.min(iToLoad, c_ImageLoading);
                            iToLoad -= iLoading;
                            for (let i = 0; i < iLoading; ++i) {
                                const img = new Image(), j = offset + i;
                                img.onload = () => {
                                    widths[j] = img.width;
                                    heights[j] = img.height;
                                    onEnd();
                                };
                                img.onerror = img.onabort = onEnd;
                                img.src = data.images[j];
                            }
                        };
                        onEnd();
                        widths.length = heights.length = iToLoad;
                    }
                }
            }
            getSymbolFactory() {
                return this.symbols ? Promise.resolve(this.symbols) : new Promise(resolve => {
                    this.notify(65536 /* Tools.EventType.UserEvent */ + 1, ( /*event: Tools.IEvent*/) => resolve(this.symbols));
                    if (!this._symbolSequence) {
                        let request = this.createAjaxRequest('/symbols');
                        request.options.always = this._onSymbolRestDone.bind(this);
                        this._symbolSequence = request.call();
                    }
                });
            }
            _onLevelsRestDone(sequence, jqXHR, textStatus) {
                if (this._levelsSequence === sequence) {
                    let data = jqXHR.responseJSON;
                    data && (this._levels = data);
                    this.fireEvent(65536 /* Tools.EventType.UserEvent */ + 2);
                }
            }
            getGeographicalLevels() {
                return this._levels ? Promise.resolve(this._levels) : new Promise(resolve => {
                    this.notify(65536 /* Tools.EventType.UserEvent */ + 2, ( /*event: Tools.IEvent*/) => resolve(this._levels));
                    if (!this._levelsSequence) {
                        let request = this.createAjaxRequest('/levels');
                        request.options.always = this._onLevelsRestDone.bind(this);
                        this._levelsSequence = request.call();
                    }
                });
            }
        }
        Globals.GlobalsDescriptor = GlobalsDescriptor;
        function isVectorLayer(metadata) {
            switch (metadata.type) {
                case 1 /* LayerType.polygon */:
                case 2 /* LayerType.line */:
                case 3 /* LayerType.symbol */:
                    return true;
            }
        }
        Globals.isVectorLayer = isVectorLayer;
        async function getMapLayerDrawingInfo(globals, mapViewName, mapLayerName) {
            let mapView = AFC.Tools.findByIdOrName(mapViewName, await globals.getMapViews()), mapViewMetadata = mapView && await mapView.getMetadata(), descriptor = mapViewMetadata && AFC.Tools.findByIdOrName(mapLayerName, mapViewMetadata.layers);
            return descriptor && Promise.all([descriptor.getMetadata(), descriptor.getLegendData()]).then(([layer, thematics]) => ({
                descriptor: descriptor,
                map: mapViewMetadata,
                layer: layer,
                thematics: thematics
            }));
        }
        Globals.getMapLayerDrawingInfo = getMapLayerDrawingInfo;
    })(Globals = AFC.Globals || (AFC.Globals = {}));
})(AFC || (AFC = {}));
;
/**
 * Created by jean.rennes on 20/02/2017.
 */
///<reference path="../../models/globals/MapView.ts" />
///<reference path="../../helpers/AdapterBase.ts" />
var AFC;
(function (AFC) {
    var Globals;
    (function (Globals) {
        class Filter {
            constructor(legend) {
                this.legend = legend;
                this.map = [];
            }
            _convert(solver, row) {
                return this.map[solver(row)] || 0;
            }
            assign(mask) {
                let solver;
                this.legend.filterable.filter = (row, dataModel) => !!(this._convert(solver || (solver = Globals.getThematicSolver(this.legend.property, this.legend.data, dataModel.columnIndex)), row) & mask);
            }
            update(inputs) {
                let mask = 0;
                for (let i = 0; i < inputs.length; ++i) {
                    mask += (inputs[i].checked && this.map[parseInt(inputs[i].value)]) || 0;
                }
                this.assign(mask);
                return mask;
            }
        }
        class LegendsAdapter extends AFC.Tools.AdapterBase {
            constructor(control) {
                super();
                this.control = control;
                control.node.addEventListener('change', this._onChange.bind(this));
            }
            _onChange(e) {
                let element = e.target;
                let key;
                let filter;
                if ((element.tagName === 'INPUT') && (key = element.getAttribute('name')) && (filter = this._filters[key])) {
                    filter.legend.states = filter.update(this.control.node.querySelectorAll(`input[name="${key}"]`));
                }
            }
            _update(model) {
                let legends = model.legends;
                if (this.enableFiltering) {
                    this._filters = {};
                    legends.forEach((legend) => {
                        if (legend.filterable) {
                            let thematic = legend.property.thematic;
                            if (thematic) {
                                let mask = 1;
                                let filter = this._filters[legend.id] = new Filter(legend);
                                thematic.classes.forEach(() => {
                                    filter.map.push(mask);
                                    mask <<= 1;
                                });
                                if (legend.states === void 0) {
                                    legend.states = mask - 1;
                                }
                                filter.assign(legend.states);
                            }
                        }
                    });
                }
                this.control.update(legends, this.enableFiltering);
            }
            isEmpty() {
                let legends = this._model && this._model.legends;
                return !(legends && legends.length);
            }
        }
        Globals.LegendsAdapter = LegendsAdapter;
    })(Globals = AFC.Globals || (AFC.Globals = {}));
})(AFC || (AFC = {}));
///<reference types="leaflet" />
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        let GridLayerPrototype = L.GridLayer.prototype;
        function _mapFeature(tile) {
            return tile.features.map(feature => feature.properties.layer);
        }
        ;
        function _comparePoint(pt0, pt1) {
            return (pt0.x - pt1.x) || (pt1.y - pt1.y);
        }
        function _compareReference(geometry0, geometry1) {
            return _comparePoint(geometry0.bounds.min, geometry1.bounds.min);
        }
        Controls.TileLayer = L.FeatureGroup.extend({
            options: {
                tileSize: 256,
                updateWhenIdle: L.Browser.mobile,
                updateWhenZooming: false,
                updateInterval: 200,
                zIndex: 1,
                bounds: null,
                minZoom: 0,
                maxZoom: undefined,
                maxNativeZoom: undefined,
                minNativeZoom: undefined,
                noWrap: false,
                pane: 'tilePane',
                className: '',
                keepBuffer: 2
            },
            initialize: function (tileVectorModel, options, geojsonOptions) {
                this._layers = {};
                this._features = tileVectorModel;
                L.Util.setOptions(this, options);
                this._geoJSON = (this.options.layerProvider || ((options) => new Controls.GeoJSON(tileVectorModel, null, options)))(this._getGeoJSONOptions(geojsonOptions));
                this._callback = this._tilesReady.bind(this);
            },
            onAdd: function (map) {
                this._geoJSON.addTo(this);
                this._tiles = {};
                this._resetView();
                this._update();
            },
            beforeAdd: GridLayerPrototype.beforeAdd,
            onRemove: function (map) {
                this._removeAllTiles();
                this._geoJSON.remove();
                /*DomUtil.remove(this._container);*/
                // map._removeZoomLimit(this);
                /*this._container = null;
                this._tileZoom = undefined;*/
            },
            // @method isLoading: Boolean
            // Returns `true` if any tile in the grid layer has not finished loading.
            isLoading: GridLayerPrototype.isLoading,
            // @method redraw: this
            // Causes the layer to clear all the tiles and request them again.
            redraw: GridLayerPrototype.redraw,
            getEvents: GridLayerPrototype.getEvents,
            // @section
            // @method getTileSize: Point
            // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
            getTileSize: GridLayerPrototype.getTileSize,
            _resetView: function (e) {
                this._map && GridLayerPrototype._resetView.call(this, e); // prevent js error when adding this while smart zooming
            },
            _animateZoom: GridLayerPrototype._animateZoom,
            _clampZoom: GridLayerPrototype._clampZoom,
            _resetGrid: GridLayerPrototype._resetGrid,
            _getTiledPixelBounds: GridLayerPrototype._getTiledPixelBounds,
            _onMoveEnd: GridLayerPrototype._onMoveEnd,
            _pxBoundsToTileRange: GridLayerPrototype._pxBoundsToTileRange,
            _isValidTile: GridLayerPrototype._isValidTile,
            _tileCoordsToNwSe: GridLayerPrototype._tileCoordsToNwSe,
            _tileCoordsToBounds: GridLayerPrototype._tileCoordsToBounds,
            _setZoomTransforms: L.Util.falseFn,
            _updateLevels: L.Util.falseFn,
            _retainParent: GridLayerPrototype._retainParent,
            _retainChildren: GridLayerPrototype._retainChildren,
            _pruneTiles: GridLayerPrototype._pruneTiles,
            _noTilesToLoad: GridLayerPrototype._noTilesToLoad,
            _setView: GridLayerPrototype._setView,
            _getGeoJSONOptions: function (options) {
                let local = Object.create(options || null), onEachFeatureOption = options?.onEachFeature;
                onEachFeatureOption && (this._onEachFeatureOption = onEachFeatureOption);
                local.onEachFeature = this._onEachFeature.bind(this);
                return local;
            },
            _tileCoordsToKey: function (coords) {
                let key = '';
                const map = '0123';
                let value;
                for (let precision = coords.z; precision > 0;) {
                    --precision;
                    value = 2 * (coords.y >> precision & 1) + (coords.x >> precision & 1);
                    key += map.charAt(value);
                }
                return key;
            },
            _keyToTileCoords: function (key) {
                let coords = L.point(0, 0);
                coords.z = 0;
                for (const c of key) {
                    ++coords.z;
                    coords.y <<= 1;
                    coords.x <<= 1;
                    switch (c) {
                        case '3':
                            ++coords.y;
                        case '1':
                            ++coords.x;
                            break;
                        case '2':
                            ++coords.y;
                            break;
                    }
                }
                return coords;
            },
            _invalidateAll: function () {
                this._removeAllTiles();
                this._tileZoom = undefined;
            },
            _update: function (center) {
                let map = this._map;
                if (!map) {
                    return;
                }
                if (this._tileZoom === undefined) {
                    return;
                } // if out of minzoom/maxzoom
                let zoom = this._clampZoom(map.getZoom());
                if (center === undefined) {
                    center = map.getCenter();
                }
                let pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), margin = this.options.keepBuffer, noPruneRange = new L.Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));
                // Sanity check: panic if the tile range contains Infinity somewhere.
                if (!(isFinite(tileRange.min.x) &&
                    isFinite(tileRange.min.y) &&
                    isFinite(tileRange.max.x) &&
                    isFinite(tileRange.max.y))) {
                    throw new Error('Attempted to load an infinite number of tiles');
                }
                for (let key in this._tiles) {
                    let c = this._tiles[key].coords;
                    if (c.z !== this._tileZoom || !noPruneRange.contains(L.point(c.x, c.y))) {
                        this._tiles[key].current = false;
                    }
                }
                // _update just loads more tiles. If the tile zoom level differs too much
                // from the map's, let _setView reset levels and prune old tiles.
                if (Math.abs(zoom - this._tileZoom) > 1) {
                    this._setView(center, zoom);
                    return;
                }
                // create a queue of coordinates to load tiles from
                for (let j = tileRange.min.y; j <= tileRange.max.y; ++j) {
                    for (let i = tileRange.min.x; i <= tileRange.max.x; ++i) {
                        let coords = L.point(i, j);
                        coords.z = this._tileZoom;
                        if (!this._isValidTile(coords)) {
                            continue;
                        }
                        let tile = this._tiles[this._tileCoordsToKey(coords)];
                        if (tile) {
                            tile.current = true;
                        }
                        else {
                            if (!this._loading) {
                                this._loading = true;
                                // @event loading: Event
                                // Fired when the grid layer starts loading tiles.
                                this.fire('loading');
                            }
                            this._addTile(coords);
                        }
                    }
                }
                this._loadTiles();
            },
            _removeAllTiles: function () {
                this._geoJSON.clearLayers();
                this._features.empty();
                this._tiles = {};
            },
            _addTile: function (coords) {
                let key = this._tileCoordsToKey(coords);
                this._tiles[key] = {
                    coords: coords,
                    current: true
                };
            },
            _onEachFeature: function (feature, layer) {
                feature.properties.layer = layer;
                if (this._onEachFeatureOption) {
                    this._onEachFeatureOption(feature, layer);
                }
            },
            _getPixelBoundsFromRect: function (rectangle, zoom) {
                let map = this._map, pt0 = map.project([rectangle[1], rectangle[0]], zoom), pt1 = map.project([rectangle[3], rectangle[2]], zoom);
                return L.bounds(pt0, pt1);
            },
            _tilesReady: function (keys, rows) {
                let date = +new Date(), allFeatures;
                this._pending = false;
                keys.forEach((key, indice) => {
                    let tile = this._tiles[key], references, event, features;
                    if (tile) {
                        tile.loaded = date;
                        if (rows) {
                            features = [];
                            tile.active = true;
                            if (!references) {
                                references = [];
                                for (let i = 0; i < rows.length; ++i) {
                                    let geometry = this.getGeometryFromResult(rows[i]);
                                    if (geometry) {
                                        let rectangle = AFC.Tools.Geometry.getBoundRect(geometry), bounds = this._getPixelBoundsFromRect(rectangle, tile.coords.z);
                                        references.push({
                                            bounds: this._pxBoundsToTileRange(bounds),
                                            geometry: geometry,
                                            row: rows[i]
                                        });
                                    }
                                }
                                references.sort(_compareReference);
                            }
                            for (let j = 0; (j < references.length) && (_comparePoint(references[j].bounds.min, tile.coords) <= 0); ++j) {
                                if (references[j].bounds.contains(tile.coords)) {
                                    let reference = references[j], bookmark = this._features.lowerBound(reference.geometry, reference.row);
                                    bookmark.insert() && (allFeatures || (allFeatures = [])).push(bookmark.feature);
                                    features.push(bookmark.feature);
                                }
                            }
                            tile.features = features;
                            event = 'tileload';
                        }
                        else {
                            event = 'tileerror';
                        }
                        this.fire(event, {
                            tile: tile,
                            key: key
                        });
                    }
                });
                allFeatures && this._geoJSON.addData(allFeatures);
                if (!this._loadTiles()) {
                    this._loading = false;
                    // @event load: Event
                    // Fired when the grid layer loaded all visible tiles.
                    this.fire('load');
                    /* if (Browser.ielt9 || !this._map._fadeAnimated) {
                         Util.requestAnimFrame(this._pruneTiles, this);
                     } else*/ {
                        // Wait a bit more than 0.2 secs (the duration of the tile fade-in)
                        // to trigger a pruning.
                        setTimeout(() => {
                            this._pruneTiles();
                            this._features.dispatchChange && this._features.dispatchChange();
                        }, 250);
                    }
                }
            },
            _loadTiles: function () {
                if (this._pending) {
                    return;
                }
                let queue = [], tile;
                for (let key in this._tiles) {
                    tile = this._tiles[key];
                    if (!tile.loaded && (this._tileZoom === tile.coords.z)) {
                        queue.push(key);
                    }
                }
                if (queue.length > 0) {
                    this._pending = true;
                    this.requestTiles(queue, this._callback);
                }
                return this._pending;
            },
            _removeFeature: function (feature) {
                let layer = feature.properties.layer;
                layer && this._features.remove(feature) && this._geoJSON.removeLayer(layer);
            },
            _removeTile: function (key) {
                let tile = this._tiles[key];
                if (tile) {
                    tile.features && tile.features.forEach(this._removeFeature.bind(this));
                    delete this._tiles[key];
                }
            },
            _eachIntersectingTile: function (rectangle, method) {
                let zoom, bounds, str, tile;
                for (str in this._tiles) {
                    tile = this._tiles[str];
                    if (tile.loaded) {
                        if (zoom !== tile.coords.z) {
                            bounds = this._pxBoundsToTileRange(this._getPixelBoundsFromRect(rectangle, zoom = tile.coords.z));
                        }
                        bounds.contains(tile.coords) && method.call(null, tile);
                    }
                }
            },
            getFeatureFromResult: L.Util.falseFn,
            requestTiles: L.Util.falseFn,
            dispatchChange: L.Util.falseFn,
            getLayers: function () {
                return this._geoJSON.getLayers();
            },
            setFilter: function (filter) {
                this._geoJSON.clearLayers();
                this._features.entities.forEach(feature => {
                    this._geoJSON.addData(feature);
                });
                return this;
            },
            addData: function (data) {
                let features = data instanceof Array ? data : data.features;
                if (features) {
                    features.forEach(feature => this.addData(feature));
                }
                else {
                    let feature = L.GeoJSON.asFeature(data), bookmark = this._features.lowerBound(feature.geometry, feature.properties.data);
                    if (!bookmark.feature) {
                        let rectangle = AFC.Tools.Geometry.getBoundRect(data);
                        this._eachIntersectingTile(rectangle, tile => {
                            if (bookmark.insert()) {
                                this._geoJSON.addData(bookmark.feature);
                            }
                            tile.features.push(bookmark.feature);
                        });
                    }
                }
                return this;
            },
            removeLayer: function (layer) {
                let rectangle = AFC.Tools.Geometry.getBoundRect(layer.feature);
                this._eachIntersectingTile(rectangle, tile => {
                    tile.features = tile.features.filter(feature => {
                        if (feature !== layer.feature)
                            return true;
                        this._removeFeature(feature);
                    });
                });
                return this;
            },
            findItem: function (key) {
                //let layers = this.getLayers();
                //return layers.find(layer => !this._features.compareKey(layer.feature.properties.data, key));
                return this._geoJSON.findItem(key);
            },
            getTileFeaturesForLatLng: function (latLng, zoom = this._map.getZoom()) {
                let promise = new Promise((resolve, reject) => {
                    if (this._map && this._tiles) {
                        zoom = this._clampZoom(zoom);
                        let tileSize = this.getTileSize(), pixelPoint = this._map.project(latLng, zoom).floor(), coords = pixelPoint.unscaleBy(tileSize).floor();
                        coords.z = zoom;
                        let key = this._tileCoordsToKey(coords), tile = this._tiles[key];
                        if (tile && tile.active) {
                            resolve(_mapFeature(tile));
                        }
                        else {
                            let f = ( /*event: L.LeafletEvent*/) => {
                                let tile = this._tiles[key];
                                resolve(tile && _mapFeature(tile));
                            };
                            this.once('load', f, this);
                        }
                    }
                });
                return promise;
            },
            zoomToShowLayer: function (layer, callback) {
                let markerClusterGroup = this._geoJSON;
                /*if (markerClusterGroup && markerClusterGroup.zoomToShowLayer)
                    return markerClusterGroup.zoomToShowLayer(layer, callback);*/
                this._map.once('zoomend moveend', callback);
                layer.getLatLng ?
                    this._map.panTo(layer.getLatLng()) :
                    this._map.fitBounds(layer.getBounds());
            },
            isVisible: function () {
                let visible = false, tileZoom;
                if (this._map) {
                    tileZoom = this._clampZoom(this._map.getZoom());
                    visible = (this.options.maxZoom === undefined || tileZoom <= this.options.maxZoom) &&
                        (this.options.minZoom === undefined || tileZoom >= this.options.minZoom);
                }
                return visible;
            },
            highlight: function (keys) {
                this._geoJSON.highlight(keys);
            }
        });
        // @factory L.tileLayer(options?: tileLayer options, geojsonOptions?: geojson options)
        // Creates a new instance of tileLayer with the supplied options.
        function tileLayer(model, options, geojsonOptions) {
            return new Controls.TileLayer(model, options, geojsonOptions);
        }
        Controls.tileLayer = tileLayer;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 30/06/2016.
 */
///<reference path="../../models/globals/MapView.ts" />
///<reference path="../../helpers/AdapterBase.ts" />
///<reference path="../../views/controls/TileLayer.ts" />
///<reference types="leaflet" />
var AFC;
(function (AFC) {
    var Globals;
    (function (Globals) {
        class TileLayer extends AFC.Controls.TileLayer {
            constructor(tiledModel, geojsonOptions) {
                let data = tiledModel.data;
                let options = {
                    minZoom: tiledModel.minZ,
                    maxZoom: tiledModel.maxZ,
                    minNativeZoom: tiledModel.minNativeZ,
                    maxNativeZoom: tiledModel.maxNativeZ
                };
                let clustered = tiledModel.clustering && (tiledModel.type === 3 /* Globals.LayerType.symbol */);
                if (clustered) {
                    options.layerProvider = ((options) => AFC.Controls.markerClusterGroup(tiledModel.data, options, { disableClusteringAtZoom: tiledModel.clusteringMaxZoom }));
                }
                super(data, options, geojsonOptions);
                this.tiledModel = tiledModel;
                this._counter = 0;
                this._clustered = clustered;
                this.getGeometryFromResult = AFC.Tools.Cartographer.getRowConverter(tiledModel.type, data.geometryIndice);
            }
            get geoJSONOptions() {
                return this._clustered ? this._geoJSON.geoJSONOptions : this._geoJSON.options;
            }
            requestTiles(tiles, callback) {
                this.tiledModel.data.provider.requestTiles(this, tiles, callback);
            }
            getBoundsFromKeys(keys) {
                let bounds;
                keys.forEach(key => {
                    let tile = this._tiles[key], loc;
                    if (tile) {
                        loc = this._tileCoordsToBounds(tile.coords);
                        bounds ? bounds.extend(loc) : bounds = loc;
                    }
                });
                return bounds;
            }
            intersect(keys, rectangle) {
                let zoom, bounds;
                return keys.some(key => {
                    let tile = this._tiles[key];
                    if (tile && !tile.loaded) {
                        if (tile.coords.z !== zoom) {
                            bounds = this._pxBoundsToTileRange(this._getPixelBoundsFromRect(rectangle, zoom = tile.coords.z));
                        }
                        return bounds.contains(tile.coords);
                    }
                });
            }
        }
        const _mouseEvents = ['click', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'animationend'];
        const _tokenValue = '<TKVALUE>';
        const _tokenBound = '<TKUB>';
        function _alignClasses(classes, data) {
            let len = classes.length, dataLen = data.length, ret;
            if (dataLen < 2 || len <= dataLen)
                return data;
            ret = [...data];
            while (ret.length < len) {
                ret.splice(ret.length - 1, 0, data[dataLen - 1]);
            }
            return ret;
        }
        function isQuali(data) {
            return data.length > 0 && data[0].hasOwnProperty(_tokenValue);
        }
        Globals.isQuali = isQuali;
        function getMonoThematicSolver(column, classes, legendData, columnIndex) {
            let thematic = legendData && legendData.thematic, solver, indice = columnIndex[column];
            if ((indice !== void 0) && thematic) {
                let data = thematic.classes;
                if (isQuali(data)) {
                    let index = {};
                    data.forEach((info, indice) => {
                        info && (index[info[_tokenValue].value] = indice);
                    });
                    solver = (row) => index[row[indice]];
                }
                else {
                    data = _alignClasses(classes, data);
                    solver = (row) => {
                        let value = row[indice], i, iLength;
                        if (value !== null) {
                            for (i = 0, iLength = data.length - 1; i < iLength; ++i) {
                                if (value < data[i][_tokenBound].value) {
                                    break;
                                }
                            }
                        }
                        return i;
                    };
                }
            }
            return solver;
        }
        Globals.getMonoThematicSolver = getMonoThematicSolver;
        function getThematicSolver(property, legendData, columnIndex) {
            let thematic = property.thematic, columns = thematic && thematic.columns;
            return columns && columns.length === 1 && getMonoThematicSolver(columns[0], thematic.classes, legendData, columnIndex);
        }
        Globals.getThematicSolver = getThematicSolver;
        function _checkValue(property, value) {
            return value === null ? property.value : value;
        }
        function _getPropertyReader(property, legendData, columnIndex) {
            if (columnIndex) {
                let reader, solver, index;
                if (property.column) {
                    index = columnIndex[property.column];
                    reader = (row) => row[index];
                }
                else if (solver = getThematicSolver(property, legendData, columnIndex)) {
                    reader = (row) => {
                        let value = solver(row), _class = property.thematic.classes[value];
                        return _class ? _class.value : null;
                    };
                }
                return reader;
            }
        }
        class LayerPropertyReader {
            constructor(property, legendData, columnIndex, converter) {
                let reader = _getPropertyReader(property, legendData, columnIndex);
                this._reader = reader ? ((row) => _checkValue(property, reader(row))) : ((row) => property.value);
                this._converter = converter;
            }
            readValue(row) {
                let t = this._reader(row);
                return this._converter ? this._converter(t) : t;
            }
        }
        Globals.LayerPropertyReader = LayerPropertyReader;
        var convertColor = AFC.Tools.Style.convertColor;
        function convertTransparency(v) {
            return Math.min((100 - v) / 100);
        }
        class Style {
            constructor(properties, data) {
                let visibility;
                if (properties.visibility && properties.visibility.column && properties.visibility.column != "") {
                    visibility = new LayerPropertyReader(properties.visibility, void 0, data.columnIndex);
                    this.filter = (feature) => visibility.readValue(feature.properties.data);
                }
            }
            build(filter, options) {
                let instance;
                if (filter || options) {
                    instance = Object.create(this);
                    filter && (instance.filter = (feature) => filter(!this.filter || this.filter(feature), feature));
                    if (options) {
                        options.pane && (instance.pane = options.pane);
                        options.attribution && (instance.attribution = options.attribution);
                        options.pointToLayer && (instance.pointToLayer = options.pointToLayer.bind(options, this));
                        options.style && (instance.style = typeof options.style === 'function' ? options.style.bind(options, this) : options.style);
                        options.onEachFeature && (instance.onEachFeature = options.onEachFeature.bind(options, this));
                        options.coordsToLatLng && (instance.coordsToLatLng = options.coordsToLatLng.bind(options, this));
                    }
                }
                else {
                    instance = this;
                }
                return instance;
            }
        }
        function pointToLayer(parameters, symbolFactory, symbolIndex, feature, latlng, pane) {
            let row = feature.properties.data;
            let icon;
            ;
            let size = parameters.size.readValue(row);
            let markerOptions;
            if (symbolFactory && (icon = parameters.icon.readValue(row))) {
                let key = icon + '|' + size;
                if (!(markerOptions = symbolIndex[key])) {
                    let symbol = symbolFactory.symbol(icon);
                    if (symbol) {
                        let maxPixelWidth = 0.010 * size; // 0.8*96/7200
                        let iconStyle = {
                            iconUrl: symbol.url,
                            iconSize: (symbol.width > symbol.height) ? [maxPixelWidth, maxPixelWidth * (symbol.height / symbol.width)] : [maxPixelWidth * (symbol.width / symbol.height), maxPixelWidth]
                        };
                        markerOptions = symbolIndex[key] = {
                            icon: L.icon(iconStyle)
                        };
                        pane && (markerOptions.pane = pane);
                    }
                }
            }
            if (markerOptions)
                return L.marker(latlng, markerOptions);
            let weight = 100, options = {
                weight: weight / 100,
                color: parameters.color.readValue(row),
                opacity: 1,
                fillOpacity: 1,
                fillColor: parameters.fillColor.readValue(row),
                bubblingMouseEvents: false,
                //   fillOpacity: this._opacity.readValue(row),
                radius: (size - weight) * 0.0027 // 0.8*96/(7200*4)
            };
            options.pane = pane || 'markerPane';
            return L.circleMarker(latlng, options);
        }
        class PointStyle extends Style {
            constructor(properties, thematics, data, symbolFactory, pane) {
                let parameters = {
                    color: new LayerPropertyReader(properties.color, thematics.color, data.columnIndex, convertColor),
                    fillColor: new LayerPropertyReader(properties.fillColor, thematics.fillColor, data.columnIndex, convertColor),
                    //opacity: new LayerPropertyReader(properties.transparency, void 0, dataInfo.columnIndex, convertTransparency),
                    size: new LayerPropertyReader(properties.size, thematics.size, data.columnIndex),
                    icon: new LayerPropertyReader(properties.icon, thematics.icon, data.columnIndex)
                }, symbolIndex = {};
                super(properties, data);
                this.pointToLayer = (feature, latlng) => pointToLayer(parameters, symbolFactory, symbolIndex, feature, latlng, pane);
            }
        }
        function styleLine(parameters, feature) {
            let row = feature.properties.data;
            return {
                weight: 0.010 * parameters.weight.readValue(row),
                color: parameters.color.readValue(row),
                bubblingMouseEvents: false
            };
        }
        class PolylineStyle extends Style {
            constructor(properties, thematics, data, pane) {
                let parameters = {
                    color: new LayerPropertyReader(properties.color, thematics.color, data.columnIndex, convertColor),
                    weight: new LayerPropertyReader(properties.weight, thematics.weight, data.columnIndex)
                };
                super(properties, data);
                this.style = (feature) => styleLine(parameters, feature);
                this.pane = pane;
            }
        }
        let PatternStyle;
        (function (PatternStyle) {
            PatternStyle[PatternStyle["empty"] = 0] = "empty";
            PatternStyle[PatternStyle["solid"] = 1] = "solid";
            PatternStyle[PatternStyle["hatch"] = 10] = "hatch";
            PatternStyle[PatternStyle["thickHatch"] = 11] = "thickHatch";
            PatternStyle[PatternStyle["crossHatch"] = 15] = "crossHatch";
            PatternStyle[PatternStyle["cross"] = 16] = "cross";
            PatternStyle[PatternStyle["emptyCircle"] = 20] = "emptyCircle";
            PatternStyle[PatternStyle["circle"] = 21] = "circle";
            PatternStyle[PatternStyle["emptyDiamond"] = 25] = "emptyDiamond";
            PatternStyle[PatternStyle["diamond"] = 26] = "diamond";
            PatternStyle[PatternStyle["checkered"] = 30] = "checkered";
        })(PatternStyle = Globals.PatternStyle || (Globals.PatternStyle = {}));
        class PatternReader {
            constructor(mapAdapter, pattern, color, bkColor, angle, space) {
                this.mapAdapter = mapAdapter;
                this.pattern = pattern;
                this.color = color;
                this.bkColor = bkColor;
                this.angle = angle;
                this.space = space;
            }
            readValue(row) {
                let value = this.pattern.readValue(row), pattern = value & 0xFFFF, bNoBackground = value & 0x10000, color = convertColor(this.color.readValue(row));
                switch (pattern) {
                    case 10 /* PatternStyle.hatch */:
                    case 11 /* PatternStyle.thickHatch */:
                        let weight = pattern === 11 /* PatternStyle.thickHatch */ ? 2.66 : 1.33, spaceWeight = Math.round(weight + this.space.readValue(row) * 1.33) / 100, width = spaceWeight + weight, options = {
                            color: color,
                            spaceColor: convertColor(bNoBackground ? -1 : this.bkColor.readValue(row)),
                            spaceOpacity: 1,
                            angle: -this.angle.readValue(row),
                            weight: weight,
                            spaceWeight: spaceWeight,
                            width: width,
                            height: width
                        }, key = `${options.color}|${options.spaceColor}|${options.angle}|${options.weight}|${options.spaceWeight}`;
                        return { pattern: this.mapAdapter.addPattern(key, options) };
                }
                return { color: color };
            }
        }
        class CompositeReader {
            constructor(color0, color1, defaultColor, pattern) {
                this.color0 = color0;
                this.color1 = color1;
                this.defaultColor = defaultColor;
                this.pattern = pattern;
            }
            readValue(row) {
                let color0 = this.color0(row), b0 = (color0 !== null) && (color0 !== -1), color1 = this.color1(row), b1 = (color1 !== null) && (color1 !== -1), pattern = b0 && b1 && this.pattern.readValue(row);
                if (!pattern) {
                    if (b0 || b1) {
                        color0 = b0 ? color0 : color1;
                    }
                    else {
                        color0 = this.defaultColor;
                    }
                    pattern = { color: convertColor(color0) };
                }
                return pattern;
            }
        }
        function compositeReader(mapAdapter, properties0, thematics, override, columnIndex) {
            let reader0 = _getPropertyReader(properties0.fillColor, thematics.fillColor, columnIndex), reader1 = reader0 && _getPropertyReader(override.properties.fillColor, override.legendData, columnIndex);
            if (reader1) {
                let properties1 = override.properties, pattern = new LayerPropertyReader(properties1.pattern, {}, columnIndex), fillColor = new LayerPropertyReader({ value: override.properties.fillColor.value }, {}, columnIndex), bkColor = { readValue: (row) => reader0(row) }, angle = new LayerPropertyReader(properties1.patternAngle, {}, columnIndex), space = new LayerPropertyReader(properties1.patternSpacing, {}, columnIndex), reader = new PatternReader(mapAdapter, pattern, fillColor, bkColor, angle, space);
                return new CompositeReader(reader0, reader1, properties0.fillColor.value, reader);
            }
        }
        function stylePolygon(parameters, feature) {
            let row = feature.properties.data, opacity = parameters.opacity.readValue(row), style = {
                weight: 0.010 * parameters.weight.readValue(row),
                color: parameters.color.readValue(row),
                opacity: opacity,
                fillOpacity: opacity,
                bubblingMouseEvents: false
            }, background = parameters.background.readValue(row);
            background.pattern ? style.fillPattern = background.pattern : style.fillColor = background.color;
            return style;
        }
        class PolygonStyle extends Style {
            constructor(mapAdapter, properties, thematics, data, pane, override) {
                let parameters = {
                    color: new LayerPropertyReader(properties.color, thematics.color, data.columnIndex, convertColor),
                    opacity: new LayerPropertyReader(properties.transparency, thematics.transparency, data.columnIndex, convertTransparency),
                    weight: new LayerPropertyReader(properties.weight, thematics.weight, data.columnIndex)
                }, background;
                if (!override || !(background = compositeReader(mapAdapter, properties, thematics, override, data.columnIndex))) {
                    if (properties.pattern) {
                        let pattern = new LayerPropertyReader(properties.pattern, {}, data.columnIndex), fillColor = new LayerPropertyReader(properties.fillColor, thematics.fillColor, data.columnIndex), bkColor = new LayerPropertyReader(properties.patternBkColor, {}, data.columnIndex), angle = new LayerPropertyReader(properties.patternAngle, {}, data.columnIndex), space = new LayerPropertyReader(properties.patternSpacing, {}, data.columnIndex);
                        background = new PatternReader(mapAdapter, pattern, fillColor, bkColor, angle, space);
                    }
                    else {
                        background = new LayerPropertyReader(properties.fillColor, thematics.fillColor, data.columnIndex, (color) => ({ color: convertColor(color) }));
                    }
                }
                parameters.background = background;
                super(properties, data);
                this.style = (feature) => stylePolygon(parameters, feature);
                this.pane = pane;
            }
        }
        function _buildOptions(mapAdapter, mapLayerModel, pane) {
            let properties = mapLayerModel.properties, data, thematics, builder;
            if (properties && (data = mapLayerModel.data)) {
                thematics = mapLayerModel.legend || {};
                switch (mapLayerModel.type) {
                    case 3 /* LayerType.symbol */:
                        builder = new PointStyle(properties, thematics, data, mapLayerModel.symbolFactory, pane);
                        break;
                    case 1 /* LayerType.polygon */:
                        builder = new PolygonStyle(mapAdapter, properties, thematics, data, pane, mapLayerModel.override);
                        break;
                    case 2 /* LayerType.line */:
                        builder = new PolylineStyle(properties, thematics, data, pane);
                        break;
                }
                return builder.build(mapLayerModel.filter, mapLayerModel.options);
            }
        }
        const _implemented = (model) => model.type === 3 /* LayerType.symbol */ || model.type === 1 /* LayerType.polygon */ || model.type === 2 /* LayerType.line */;
        const _paneLookup = {
            [3 /* LayerType.symbol */]: [600, 'markerPane'],
            [2 /* LayerType.line */]: [400, 'overlayPane'],
            [1 /* LayerType.polygon */]: [400, 'overlayPane']
        };
        const _layers = Symbol(), _onChange = Symbol();
        class MapAdapter extends AFC.Tools.AdapterBase {
            constructor(mapControl) {
                super();
                this.control = mapControl;
                this._attachHandlers(_mouseEvents, this.control, this._onMapEvent);
            }
            _buildFeature({ model, options }) {
                let featureGroup;
                if (model.isTiled) {
                    featureGroup = new TileLayer(model, options);
                }
                else {
                    let geoJSON = model.geoJSON;
                    if (geoJSON?.type) {
                        let data = model.data, exOptions = { minZoom: model.minZ, maxZoom: model.maxZ, disableClusteringAtZoom: model.clusteringMaxZoom };
                        featureGroup = model.clustering && model.type == 3 /* Globals.LayerType.symbol */ ?
                            AFC.Controls.markerClusterGroup(data, options, exOptions).addData(geoJSON) :
                            new AFC.Controls.GeoJSON(data, geoJSON, $.extend(exOptions, options));
                    }
                }
                featureGroup && this._attachLayerHandlers(featureGroup);
                return featureGroup;
            }
            /** @internal */
            [_onChange](layers) {
                delete this[_layers];
                if (layers) {
                    let featureGroup, shadow = {};
                    (this[_layers] = layers).forEach(descriptor => {
                        let pane = descriptor.pane || _paneLookup[descriptor.model.type]?.[1];
                        shadow[pane] = !!descriptor.model.properties.shadow;
                        if (descriptor?.featureGroup) {
                            descriptor.model.hidden || (featureGroup || (featureGroup = L.featureGroup())).addLayer(descriptor.featureGroup);
                        }
                    });
                    featureGroup && (this._featureGroup = featureGroup).addTo(this.control);
                    Object.entries(shadow).forEach(([key, value]) => {
                        let pane = this.control.getPane(key), classList = pane?.classList;
                        if (classList) {
                            value ? classList.add('drop-shadow') : classList.remove('drop-shadow');
                        }
                    });
                }
                this.onComplete && this.onComplete(layers);
            }
            _addItem(layerModel, modelData, featureGroup, row, iGeometry) {
                let geometry = (featureGroup.getGeometryFromResult ?
                    featureGroup.getGeometryFromResult :
                    AFC.Tools.Cartographer.getRowConverter(layerModel.type, iGeometry))(row);
                featureGroup.addData(AFC.Tools.Cartographer.feature(geometry, { data: row }));
            }
            _modifyItem(layerModel, modelData, featureGroup, row, iGeometry) {
                let items = featureGroup.getLayers(), item, feature, properties;
                for (let i = 0, iLength = items.length; i < iLength; ++i) {
                    item = items[i];
                    if ((feature = item.feature) && (properties = feature.properties) && (modelData.compareRow(properties.data, row) === 0)) {
                        featureGroup.removeLayer(item);
                        return this._addItem(layerModel, modelData, featureGroup, row, iGeometry);
                    }
                }
            }
            _removeItem(modelData, featureGroup, row) {
                let items = featureGroup.getLayers(), item, feature, properties;
                for (let i = 0, iLength = items.length; i < iLength; ++i) {
                    item = items[i];
                    if ((feature = item.feature) && (properties = feature.properties) && (modelData.compareRow(properties.data, row) === 0)) {
                        featureGroup.removeLayer(item);
                        return;
                    }
                }
            }
            _needReset(item) {
                let b = (item.data && item.data.reset), featureGroup;
                if (!b && (featureGroup = this[_layers]?.[item.indice].featureGroup) && (item.filter || item.style)) {
                    b = (item.style && item.layer.type === 3 /* Globals.LayerType.symbol */) || (item.filter && !(featureGroup instanceof TileLayer));
                }
                return b;
            }
            _createPane(layerModel, counters) {
                let template = _paneLookup[layerModel.type], i, pane, cnt;
                if (template) {
                    cnt = counters[i = layerModel.type === 3 /* LayerType.symbol */ ? 1 : 0]++;
                    if (cnt) {
                        pane = template[1] + cnt;
                        if (!this.control.getPane(pane))
                            this.control.createPane(pane).style.zIndex = `${template[0] + cnt}`;
                    }
                }
                return pane;
            }
            _update(model, event) {
                let data = event && event.data;
                if (data && data.layers && !data.layers.some(this._needReset.bind(this))) {
                    this[_layers] && data.layers.forEach(item => {
                        let layer = this[_layers][item.indice], featureGroup = layer?.featureGroup;
                        if (featureGroup) {
                            if (item.visibility) {
                                // hide layer
                                layer.model.hidden && this._featureGroup.removeLayer(featureGroup);
                                delete layer.featureGroup;
                            }
                            else {
                                let data = item.data, layerModel = item.layer;
                                if (item.style || item.filter) {
                                    let destination = featureGroup instanceof AFC.Controls.GeoJSON ? featureGroup.options : featureGroup.geoJSONOptions, source = layer.options = _buildOptions(this, layerModel, layer.pane);
                                    destination.style = source.style;
                                    if (item.filter) {
                                        featureGroup.setFilter(destination.filter = source.filter);
                                    }
                                    else {
                                        featureGroup.setStyle(destination.style);
                                    }
                                }
                                if (data && layerModel.data && !item.filter) {
                                    let modelData = layerModel.data, iGeometry = modelData.geometryIndice;
                                    data.items && data.items.forEach((event) => {
                                        switch (event.type) {
                                            case 1 /* Data.DataEventType.create */:
                                                this._addItem(layerModel, modelData, featureGroup, event.row, iGeometry);
                                                break;
                                            case 2 /* Data.DataEventType.modify */:
                                                this._modifyItem(layerModel, modelData, featureGroup, event.row, iGeometry);
                                                break;
                                            case 4 /* Data.DataEventType.delete_ */:
                                                this._removeItem(modelData, featureGroup, event.row);
                                                break;
                                        }
                                    });
                                }
                            }
                        }
                        else if (_implemented(layer.model) && !layer.model.hidden) {
                            if (item.style || item.filter || item.visibility) {
                                layer.options = _buildOptions(this, layer.model, layer.pane);
                            }
                            if (item.visibility)
                                this._featureGroup.addLayer(layer.featureGroup = this._buildFeature(layer));
                        }
                    });
                }
                else {
                    let counters = [0, 0], layers;
                    this.clearMap();
                    model.layers.forEach(model => {
                        let layer = {
                            model: model
                        };
                        if (_implemented(model)) {
                            if (!model.hidden) {
                                layer.options = _buildOptions(this, model, layer.pane = this._createPane(model, counters));
                                layer.featureGroup = this._buildFeature(layer);
                            }
                            (layers || (layers = [])).push(layer);
                        }
                    });
                    this[_onChange](layers);
                }
            }
            _raiseLayerEvent(e, handlers, fn) {
                fn && this[_layers].some((layer, indice) => {
                    if (layer?.featureGroup === e.target) {
                        let info = {
                            model: layer.model,
                            options: layer.options,
                            featureGroup: e.target,
                            feature: e.propagatedFrom,
                            index: indice
                        };
                        fn.call(handlers, e, info);
                        return true;
                    }
                });
            }
            _handleClick(e) {
                if (e.originalEvent._stopped) {
                    return;
                }
                // get the target pane
                let currentTarget = e.originalEvent.target, stopped;
                // hide the target node
                let removed = { node: currentTarget, pointerEvents: currentTarget.style.pointerEvents };
                currentTarget.style.pointerEvents = 'none';
                // attempt to grab the next layer below
                let nextTarget = document.elementFromPoint(e.originalEvent.clientX, e.originalEvent.clientY);
                // we keep drilling down until we get stopped,
                // or we reach the map container itself
                if (nextTarget?.nodeName.toLowerCase() !== 'body') {
                    let ev = new MouseEvent(e.originalEvent.type, e.originalEvent);
                    stopped = !nextTarget.dispatchEvent(ev);
                    if (stopped || ev._stopped) {
                        L.DomEvent.stop(e);
                    }
                }
                // restore pointerEvents
                removed.node.style.pointerEvents = removed.pointerEvents;
            }
            _onLayerEvent(e) {
                let handlers = this.handlers, fn = handlers && handlers[e.type];
                fn && this._raiseLayerEvent(e, handlers, fn);
            }
            _onMapEvent(e) {
                let handlers = this.handlers, fn = handlers && handlers[e.type];
                fn && fn.call(handlers, e);
            }
            _attachHandlers(events, o, fn) {
                events.forEach(event => { o.on(event, fn, this); });
            }
            _attachLayerHandlers(o) {
                this._attachHandlers(_mouseEvents, o, this._onLayerEvent);
                o.on('click', this._handleClick, this);
            }
            _detachHandlers(events, o, fn) {
                events.forEach(event => { o.off(event, fn, this); });
            }
            _detachLayerHandlers(o) {
                o.off();
            }
            clearMap() {
                let layers = this[_layers], patterns = this._patterns, key;
                if (layers) {
                    let featureGroup = this._featureGroup;
                    //this._detachHandlers(_mouseEvents, this.control, this._onMapEvent);
                    if (featureGroup) {
                        this.control.removeLayer(featureGroup);
                        this.control.closePopup();
                        delete this._featureGroup;
                    }
                    layers.forEach(descriptor => descriptor && descriptor.featureGroup && this._detachLayerHandlers(descriptor.featureGroup));
                    delete this[_layers];
                }
                if (patterns) {
                    for (key in patterns) {
                        try {
                            patterns[key].remove();
                        }
                        catch (e) { // catch an error in library implementation
                        }
                    }
                    delete this._patterns;
                }
            }
            get featureGroup() {
                return this._featureGroup;
            }
            get layers() {
                return this[_layers];
            }
            addPattern(key, options) {
                let patterns = this._patterns || (this._patterns = {});
                return patterns[key] || (patterns[key] = L.stripePattern(options).addTo(this.control));
            }
            unbind() {
                this.clearMap();
                super.unbind();
            }
        }
        Globals.MapAdapter = MapAdapter;
    })(Globals = AFC.Globals || (AFC.Globals = {}));
})(AFC || (AFC = {}));
;
///<reference path="../../helpers/AdapterBase.ts" />
///<reference path="../../views/controls/Label.ts" />
var AFC;
(function (AFC) {
    var Globals;
    (function (Globals) {
        class TemplateElemAdapter extends AFC.Tools.AdapterBase {
            constructor(elem) {
                super();
                this.control = elem;
            }
            _update(model) {
                this.control.empty();
                this.control.generateContent(model);
                this.onGenerate && this.onGenerate();
            }
        }
        Globals.TemplateElemAdapter = TemplateElemAdapter;
    })(Globals = AFC.Globals || (AFC.Globals = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 29/07/2022.
 */
var AFC;
(function (AFC) {
    var Globals;
    (function (Globals) {
        let _requestCounter;
        const _notify = Symbol();
        const _pollingRequestTimeout = 10000; // rest request progress timeout in ms
        const _intervalValue = 1000; // progress info bar refresh interval in ms
        let TaskStatus;
        (function (TaskStatus) {
            TaskStatus[TaskStatus["idle"] = 0] = "idle";
            TaskStatus[TaskStatus["updating"] = 1] = "updating";
            TaskStatus[TaskStatus["completed"] = 2] = "completed";
        })(TaskStatus || (TaskStatus = {}));
        class ProgressInfoBarRestTask {
            constructor(progressInfoBar, restModel, tid) {
                this.progressInfoBar = progressInfoBar;
                this.restModel = restModel;
                this.tid = tid;
                this.progressData = {
                    title: '',
                    step: '',
                    tid: tid,
                    completed: 0,
                    progress: '',
                    status: 1 /* ProgressStatus.notStarted */
                };
                this.status = 0 /* TaskStatus.idle */;
            }
            update() {
                let progressData = this.progressData;
                if (this.status === 0 /* TaskStatus.idle */) {
                    let request = this.restModel.createAjaxRequest('/progress'), data = request.options.data;
                    this.status = 1 /* TaskStatus.updating */;
                    data.tid = this.tid;
                    data.uid = progressData.uid;
                    data.wait = _pollingRequestTimeout;
                    request.options.always = (sequence, jqXHR, textStatus) => {
                        let data = jqXHR.status === 200 && jqXHR.responseJSON;
                        if (data) {
                            data.status = AFC.Globals.progressStatus(data.status);
                            this.progressData = progressData = data;
                        }
                        else {
                            progressData.status = 0 /* ProgressStatus.unknown */;
                        }
                        this.status = progressData.status === 0 /* ProgressStatus.unknown */ || progressData.status === 3 /* ProgressStatus.completed */ ? 2 /* TaskStatus.completed */ : 0 /* TaskStatus.idle */;
                        this.progressInfoBar.notify(this);
                    };
                    request.call();
                }
            }
        }
        class ProgressInfoBar {
            constructor(waitModel) {
                this._interval = null;
                this._enabled = false;
                this.waitModel = waitModel;
                this.tasks = [];
            }
            _dec() {
                if (--this._counter <= 0) {
                    this.stop();
                    this.waitModel.notify(true);
                }
            }
            _count(update) {
                return this._counter = this.tasks.reduce((acc, task) => {
                    if (task.status !== 2 /* TaskStatus.completed */) {
                        update && task.update();
                        ++acc;
                    }
                    return acc;
                }, 0);
            }
            start() {
                if (this._enabled && this._count() && this._interval === null) {
                    this._interval = setInterval(() => {
                        this._count(true) || this.stop();
                        this.waitModel.notify(true);
                    }, _intervalValue);
                }
            }
            stop() {
                if (this._interval !== null) {
                    clearInterval(this._interval);
                    this._interval = null;
                }
            }
            enable(enable) {
                if (this._enabled !== enable) {
                    this._enabled = enable;
                    enable ? this.start() : this.stop();
                }
            }
            push(task) {
                let tasks = this.tasks;
                if (!tasks.some(item => task.tid === item.tid)) {
                    tasks.push(task);
                    task.status !== 2 /* TaskStatus.completed */ && this.start();
                }
            }
            pop(tid) {
                this.tasks = this.tasks.filter(item => {
                    let keep = item.tid !== tid;
                    if (!keep && item.status !== 2 /* TaskStatus.completed */) {
                        this._dec();
                    }
                    return keep;
                });
            }
            notify(task) {
                task.status === 2 /* TaskStatus.completed */ && this._dec();
            }
        }
        const _timeThreshold = 30000; // 30 s
        const _from = 0.1; // min percent
        const _to = 0.9; // min percent
        const _dummy = 'dummy';
        function _getTime() {
            return new Date().getTime();
        }
        function _ease(x) {
            return x * (2 - x); // ease out quad
        }
        class WaitModel {
            constructor() {
                this.value = 0;
                this.adapters = [];
                this.bar = new ProgressInfoBar(this);
                /* IProgressInfoBarTask */
                this.tid = _dummy;
                this.progressData = {
                    tid: _dummy,
                    uid: -1,
                    status: 2 /* ProgressStatus.inProgress */
                };
            }
            _start() {
                this.status = 1 /* TaskStatus.updating */;
                this.update();
                this.bar.push(this);
            }
            _stop() {
                this.status = 2 /* TaskStatus.completed */;
                this.bar.pop(this.tid);
            }
            update() {
                if (this._begin) {
                    let progress = _getTime() - this._begin, step = (_to - _from) / _timeThreshold, value = _ease(progress * step + _from);
                    this.progressData.completed = value < _to ?
                        value :
                        (delete this._begin, _to);
                }
            }
            /* IProgressInfoBarTask */
            notify(progress, value) {
                this.adapters.forEach(adapter => adapter[_notify](progress, value));
            }
            inc(restModel, tid) {
                let value = ++this.value;
                restModel && tid && this.bar.push(new ProgressInfoBarRestTask(this.bar, restModel, tid));
                if (value === 1) {
                    this._begin = _getTime();
                    this._start();
                }
                this.notify(false, value);
                return value;
            }
            dec(tid) {
                let value = --this.value;
                tid && this.bar.pop(tid);
                value || this._stop();
                this.notify(false, value);
                return value;
            }
        }
        class WaitAdapter {
            constructor({ waitBar, progressBar }) {
                this.dummyEnabled = false;
                _requestCounter || (_requestCounter = new WaitModel());
                this.waitBar = waitBar;
                this.progressBar = progressBar;
            }
            register() {
                if ((this.waitBar || this.progressBar) && !_requestCounter.adapters.some(adapter => adapter === this)) {
                    this.progressBar && _requestCounter.bar.enable(true);
                    _requestCounter.adapters.push(this);
                    _requestCounter.value > 0 && this[_notify](false, 1);
                }
            }
            unregister() {
                let counter = 0;
                _requestCounter.adapters = _requestCounter.adapters.filter(adapter => {
                    let keep = adapter !== this;
                    if (keep && adapter.progressBar) {
                        ++counter;
                    }
                    return keep;
                });
                _requestCounter.bar.enable(counter > 0);
                this[_notify](false, 0);
            }
            push(restModel, tid) {
                _requestCounter.inc(restModel, tid);
            }
            pop(restModel, tid) {
                _requestCounter.dec(tid);
            }
            /** @internal */
            [_notify](progress, value) {
                if (progress) {
                    let tasks = _requestCounter.bar.tasks;
                    this.progressBar?.refresh(this.dummyEnabled ? tasks : tasks.filter(task => task.tid !== _dummy));
                }
                if (value === 1) {
                    this.waitBar?.show();
                }
                else if (value === 0) {
                    this.waitBar?.hide();
                }
            }
        }
        Globals.WaitAdapter = WaitAdapter;
    })(Globals = AFC.Globals || (AFC.Globals = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 06/12/2019.
 */
///<reference path="Activity.ts" />
var AFC;
(function (AFC) {
    var Application;
    (function (Application) {
        var _a, _b;
        const _activity = Symbol(), _tag = Symbol(), _childFragmentManager = Symbol(), _fragmentManager = Symbol(), _parentFragment = Symbol(), _status = Symbol(), _instances = Symbol(), _state = Symbol(), _viewState = Symbol(), _arguments = Symbol(), _view = Symbol(), _host = Symbol(), _performSaveInstanceState = Symbol(), _performDestroyView = Symbol(), _performDestroy = Symbol(), _ctor = Symbol(), _instance = Symbol();
        let FragmentStatus;
        (function (FragmentStatus) {
            FragmentStatus[FragmentStatus["initializing"] = 0] = "initializing";
            FragmentStatus[FragmentStatus["created"] = 1] = "created";
            FragmentStatus[FragmentStatus["attached"] = 2] = "attached";
        })(FragmentStatus || (FragmentStatus = {}));
        class Bundle {
            constructor() {
                /** @internal */
                this[_a] = {};
            }
            getKeys() {
                return Object.keys(this[_state]);
            }
            getValue(key) {
                return this[_state][key];
            }
            putValue(key, value) {
                value === void 0 ? delete this[_state][key] : this[_state][key] = value;
            }
            getBundle(key) {
                let bundle = new Bundle();
                bundle[_state] = this.getValue(key);
                return bundle;
            }
            putBundle(key, value) {
                this.putValue(key, value && value[_state]);
            }
            isEmpty() {
                return !(this.getKeys().length || Object.getOwnPropertySymbols(this[_state]).length);
            }
        }
        _a = _state;
        Application.Bundle = Bundle;
        class FragmentState {
            constructor() { }
            initFrom(fragment) {
                this[_tag] = fragment[_tag];
                this[_arguments] = fragment.getArguments();
                return this;
            }
            instantiate(activity, parent) {
                let fragment = this[_instance];
                if (!fragment) {
                    fragment = this[_instance] = new this[_ctor]();
                    fragment[_tag] = this[_tag];
                    fragment.setArguments(this[_arguments]);
                }
                return fragment;
            }
        }
        class Fragment {
            constructor() {
                /** @internal */
                this[_b] = 0 /* FragmentStatus.initializing */;
            }
            /** @internal */
            [(_b = _status, _performSaveInstanceState)](savedInstanceState) {
                this.onSaveInstanceState(savedInstanceState);
                if (this[_childFragmentManager]) {
                    let state = this[_childFragmentManager].saveAllState();
                    if (state.length) {
                        savedInstanceState.putValue("FRAGMENTS_TAG", state);
                    }
                }
            }
            /** @internal */
            [_performDestroyView]() {
                if (this[_status] === 2 /* FragmentStatus.attached */) {
                    if (this[_childFragmentManager]) {
                        this[_childFragmentManager].dispatchDestroyView();
                    }
                    this.onDestroyView();
                    delete this[_view];
                    this[_status] = 1 /* FragmentStatus.created */;
                }
            }
            /** @internal */
            [_performDestroy]() {
                if (this[_status] === 1 /* FragmentStatus.created */) {
                    if (this[_childFragmentManager]) {
                        this[_childFragmentManager].dispatchDestroy();
                        delete this[_childFragmentManager];
                    }
                    this.onDestroy();
                    this[_status] = 0 /* FragmentStatus.initializing */;
                }
                else if (this[_status] === 2 /* FragmentStatus.attached */) {
                    console.log('Cannot destroy an attached fragment');
                }
            }
            getTag() {
                return this[_tag];
            }
            getActivity() {
                return this[_activity];
            }
            getView() {
                return this[_view];
            }
            addEventListener(view, query, event, listener, options) {
                let children = view.querySelectorAll(query);
                children.forEach(child => child.addEventListener(event, listener, options));
            }
            getArguments() {
                return this[_arguments];
            }
            setArguments(bundle) {
                this[_arguments] = bundle;
            }
            onAttach(context) {
            }
            onAttachFragment(childFragment) {
            }
            onCreate(savedInstanceState) {
                // restoreChildFragmentState
                if (savedInstanceState) {
                    let state = savedInstanceState.getValue("FRAGMENTS_TAG");
                    if (state) {
                        let childFragmentManager = this.getChildFragmentManager();
                        childFragmentManager.restoreAllState(state);
                        childFragmentManager.dispatchCreate();
                    }
                }
            }
            onCreateView(inflater, container, savedInstanceState) {
                return;
            }
            onActivityCreated(savedInstanceState) {
            }
            onViewStateRestored(savedInstanceState) {
            }
            onSaveInstanceState(savedInstanceState) {
            }
            onDestroyView() {
            }
            onDestroy() {
            }
            getChildFragmentManager() {
                return this[_childFragmentManager] || (this[_childFragmentManager] = new Fragment.FragmentManager(this[_activity], this[_host], this));
            }
            getFragmentManager() {
                return this[_fragmentManager];
            }
            getParentFragment() {
                return this[_fragmentManager][_parentFragment];
            }
            getLayoutInflater(savedInstanceState) {
                return this[_host].onGetLayoutInflater();
            }
        }
        Fragment.SavedState = FragmentState;
        /** @internal */
        Fragment.FragmentManager = class {
            saveFragmentViewState(fragment) {
                let view = fragment.getView();
                if (view) {
                    let savedInstanceState = fragment[_viewState] || new Bundle();
                    AFC.gui.onSaveInstanceState(fragment[_activity], view, savedInstanceState);
                    savedInstanceState.isEmpty() || (fragment[_viewState] = savedInstanceState);
                }
            }
            static detachView(fragment, noDestroy) {
                if (fragment[_status] === 2 /* FragmentStatus.attached */) {
                    let view = fragment.getView(), fragmentManager = fragment.getFragmentManager(), tag = fragment[_tag];
                    tag && (fragment[_state] = fragmentManager._saveFragmentBasicState(fragment));
                    fragment[_performDestroyView]();
                    view && view.parentNode.removeChild(view);
                    noDestroy || tag || fragment[_performDestroy](); // immediate destruction if no tag
                    delete fragment[_tag];
                    delete fragment[_view];
                    delete fragment.containerId;
                }
            }
            static destroyFragment(fragment) {
                let fragmentManager = fragment.getFragmentManager(), tag;
                if (fragmentManager) {
                    tag = fragment[_tag];
                    Application.FragmentManager.detachView(fragment);
                    fragment[_performDestroy]();
                    if (tag) {
                        delete fragmentManager[_instances][tag];
                    }
                }
            }
            constructor(activity, host, parentFragment) {
                this[_activity] = activity;
                //this[_clsFactory] = new FragmentFactory();
                this[_instances] = {};
                this[_parentFragment] = parentFragment;
                this[_host] = host;
            }
            findFragmentByTag(tag) {
                return this[_instances][tag];
            }
            _saveFragmentBasicState(fragment) {
                let savedInstanceState = new Bundle();
                fragment[_performSaveInstanceState](savedInstanceState);
                this.saveFragmentViewState(fragment);
                if (fragment[_viewState]) {
                    savedInstanceState.putBundle('VIEW_STATE_TAG', fragment[_viewState]);
                }
                return savedInstanceState.isEmpty() ? null : savedInstanceState;
            }
            saveAllState() {
                return Object.values(this[_instances]).map(fragment => {
                    let fragmentState = (new Fragment.SavedState()).initFrom(fragment);
                    fragmentState[_state] = this._saveFragmentBasicState(fragment);
                    return fragmentState;
                });
            }
            restoreAllState(state) {
                state.forEach(fragmentState => {
                    let fragment = fragmentState.instantiate(this[_activity], this[_parentFragment]);
                    fragment[_viewState] = fragmentState[_state].getBundle('VIEW_STATE_TAG');
                    fragment[_state] = fragmentState[_state];
                    this[_instances][fragment[_tag]] = fragment;
                });
            }
            dispatchCreate() {
                Object.values(this[_instances]).forEach(fragment => {
                    fragment.onCreate();
                });
            }
            attachView(container, fragment, tag) {
                let savedInstanceState = fragment[_state], view, inflater, visibility;
                delete fragment[_state];
                if (tag && (this[_instances][tag] !== fragment)) {
                    this[_instances][tag] && Application.FragmentManager.detachView(fragment);
                    fragment[_tag] && Application.FragmentManager.detachView(fragment);
                    this[_instances][tag] = fragment;
                }
                fragment[_tag] = tag;
                if (fragment[_status] === 0 /* FragmentStatus.initializing */) {
                    fragment[_host] = this[_host];
                    fragment[_fragmentManager] = this;
                    container && (fragment.containerId = container.id);
                    fragment.onAttach(fragment[_activity] = this[_activity]);
                    this[_parentFragment] && this[_parentFragment].onAttachFragment(fragment);
                    fragment.onCreate(savedInstanceState);
                }
                fragment[_status] = 2 /* FragmentStatus.attached */;
                inflater = fragment.getLayoutInflater(savedInstanceState);
                view = fragment[_view] = fragment.onCreateView(inflater, container, savedInstanceState);
                if (view) {
                    AFC.gui.onRestoreViewState(this[_activity], view, fragment.getChildFragmentManager(), fragment[_viewState]);
                    fragment.onViewStateRestored(savedInstanceState);
                    visibility = view.style.visibility;
                    view.style.visibility = 'hidden';
                    if (container) {
                        container.appendChild(view);
                    }
                }
                fragment.onActivityCreated(savedInstanceState);
                if (view) {
                    view.style.visibility = visibility;
                }
                return view;
            }
            dispatchDestroyView() {
                Object.values(this[_instances]).forEach(fragment => {
                    fragment[_performDestroyView]();
                });
            }
            dispatchDestroy() {
                Object.values(this[_instances]).forEach(fragment => {
                    fragment[_performDestroy]();
                });
                this[_instances] = {};
            }
        };
        Application.Fragment = Fragment;
        Application.FragmentManager = Fragment.FragmentManager;
    })(Application = AFC.Application || (AFC.Application = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 18/09/2020.
 */
///<reference path="Fragment.ts" /> 
var AFC;
(function (AFC) {
    var Application;
    (function (Application) {
        class Intent extends Application.Bundle {
            constructor(packageContext, cls) {
                super();
                this.packageContext = packageContext;
                this.cls = cls;
            }
        }
        Application.Intent = Intent;
        const _context = Symbol(), _intent = Symbol(), _fragmentManager = Symbol(), _layoutInflater = Symbol(), _attach = Symbol(), _window = Symbol();
        class Context {
            constructor(base) {
                this[_context] = base;
            }
            startActivity(intent) {
                let activity = new intent.cls();
                if (activity instanceof Activity) {
                    activity[_attach](intent);
                }
            }
            getBaseContext() {
                return this[_context];
            }
        }
        Application.Context = Context;
        class Activity extends Context {
            _onCreate(icicle) {
            }
            _onStart() {
            }
            _onStop() {
            }
            _onDestroy() {
            }
            getWindow() {
                return this[_window];
            }
            getIntent() {
                return this[_intent];
            }
            setContentView(view) {
                this[_window].setContentView(view);
                AFC.gui.onRestoreViewState(this, this[_window].getElement(), this.getSupportFragmentManager());
            }
            getSupportFragmentManager() {
                return this[_fragmentManager] || (this[_fragmentManager] = new Application.FragmentManager(this, { onGetLayoutInflater: () => this.getLayoutInflater() }));
            }
            getLayoutInflater() {
                return this[_layoutInflater] || (this[_layoutInflater] = new Application.Inflater());
            }
            /** @internal */
            [_attach](intent, icicle) {
                this[_intent] = intent;
                this[_context] = intent.packageContext;
                this[_window] = new AFC.Controls.Window(this);
                this._onCreate(icicle);
                this._onStart();
            }
            finish() {
                if (this[_intent]) {
                    this._onStop();
                    this._onDestroy();
                    this[_window].destroy();
                    delete this[_window];
                    delete this[_context];
                    delete this[_intent];
                }
            }
        }
        Application.Activity = Activity;
    })(Application = AFC.Application || (AFC.Application = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 18/09/2020.
 */
///<reference path="Activity.ts" /> 
var AFC;
(function (AFC) {
    var Application;
    (function (Application_1) {
        class Application extends Application_1.Context {
            constructor() {
                super(null);
                this.onCreate();
            }
            onCreate() {
            }
        }
        Application_1.Application = Application;
    })(Application = AFC.Application || (AFC.Application = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 18/09/2020.
 */
///<reference path="Activity.ts" />
///<reference path="../adapters/globals/WaitAdapter.ts" />
var AFC;
(function (AFC) {
    var Application;
    (function (Application) {
        const _identity = Symbol(), _restModel = Symbol();
        const _waitAdapter = new AFC.Globals.WaitAdapter({});
        function ShowWaitBar(restModel, tid) {
            _waitAdapter.push(restModel, tid);
        }
        Application.ShowWaitBar = ShowWaitBar;
        function HideWaitBar(restModel, tid) {
            _waitAdapter.pop(restModel, tid);
        }
        Application.HideWaitBar = HideWaitBar;
        class RestActivity extends Application.Activity {
            _onCreate(icicle) {
                let intent = this.getIntent(), identity, serviceUrl, restModel;
                if (intent) {
                    serviceUrl = intent.getValue('serviceUrl');
                    identity = intent.getValue('identity');
                }
                if (identity && !identity.isAuthenticated) {
                    identity.authorizationPolicy.restart(true);
                }
                restModel = this[_restModel] = new AFC.Rest.RestModel(this[_identity] = identity, serviceUrl);
                restModel.on(2 /* AFC.Tools.EventType.NetworkBegin */, (event) => event.data.forEach(request => ShowWaitBar(restModel, request.progressId)));
                restModel.on(3 /* AFC.Tools.EventType.NetworkComplete */, (event) => event.data.forEach(eventData => HideWaitBar(restModel, eventData.request.progressId)));
            }
            getRestModel() {
                return this[_restModel];
            }
            getAuthorizationPolicy() {
                return this.getIdentity()?.authorizationPolicy;
            }
            getIdentity() {
                return this[_identity];
            }
        }
        Application.RestActivity = RestActivity;
    })(Application = AFC.Application || (AFC.Application = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 13/02/2017.
 */
///<reference path="../../helpers/Tools.ts" />
var AFC;
(function (AFC) {
    var Data;
    (function (Data) {
        const _storeSource = Symbol(), _store = Symbol(), _items = Symbol(), _creations = Symbol(), _modifications = Symbol(), _deletions = Symbol();
        class EventInfo {
            constructor(eventType, storeSource, values, oldValues) {
                this.eventType = eventType;
                this.values = values;
                this.oldValues = oldValues;
                this[_storeSource] = storeSource;
            }
            get store() {
                return this[_store] || (this[_store] = this[_storeSource].getStoreFromRow(this.values));
            }
            get key() {
                return this.store.key;
            }
            getInitialData(column) {
                const oldRow = this.oldValues;
                return oldRow && oldRow[this[_storeSource].columnIndex[column]];
            }
        }
        function _build(storeSource, variations) {
            let infos = [];
            variations && variations.row.forEach((values, i) => {
                let old = variations.old[i], eventType = old ? 2 /* DataEventType.modify */ : 1 /* DataEventType.create */;
                if (!values) {
                    values = old;
                    eventType = 4 /* DataEventType.delete_ */;
                }
                values && infos.push(new EventInfo(eventType, storeSource, values, old));
            });
            return infos;
        }
        function _translate(columns, row) {
            let values = {};
            columns.forEach((item, indice) => values[item.name] = row[indice]);
            return values;
        }
        function _getModification(columns, row, old) {
            let oldValues;
            let values = {};
            columns.forEach((item, indice) => {
                ((values[item.name] = row[indice]) !== old[indice]) && ((oldValues || (oldValues = {}))[item.name] = old[indice]);
            });
            return oldValues ? { values: values, oldValues: oldValues } : void 0;
        }
        class Scenario extends AFC.Tools.EventSink {
            constructor(storeSource, model) {
                super();
                this.model = model;
                this[_items] = _build(storeSource, model.getVariations());
                (this.source = storeSource).on(6 /* Tools.EventType.Dirty */, this._onDirty, this);
            }
            _onDirty(event) {
                this[_items] = _build(this.source, this.model.getVariations());
                delete this[_creations];
                delete this[_modifications];
                delete this[_deletions];
                this.fireEvent(6 /* Tools.EventType.Dirty */, new Data.DataEventData(void 0, true));
            }
            get creations() {
                return this[_creations] || (this[_creations] = this._filter(1 /* DataEventType.create */, _translate));
            }
            get modifications() {
                return this[_modifications] || (this[_modifications] = this._filter(2 /* DataEventType.modify */, _getModification));
            }
            get deletions() {
                return this[_deletions] || (this[_deletions] = this._filter(4 /* DataEventType.delete_ */, _translate));
            }
            _filter(type, converter) {
                const columns = this.columns;
                return this[_items].filter(info => info.eventType === type).map(info => converter(columns, info.values, info.oldValues));
            }
            /* IRowCollection */
            get length() {
                return this[_items].length;
            }
            indexOf(row) {
                return this[_items].findIndex(info => !Data.compareKey(info.values, row));
            }
            getRow(index) {
                const info = this[_items][index];
                return info && info.values;
            }
            /* IKeyProvider */
            get columns() {
                return this.model.columns;
            }
            get primaryKey() {
                return this.model.primaryKey;
            }
            getKeyFromRow(row) {
                return this.model.getKeyFromRow(row);
            }
            compareKey(row, key) {
                return this.model.compareKey(row, key);
            }
            compareRow(row0, row1) {
                return this.model.compareRow(row0, row1);
            }
            /* IDataSource */
            item(index) {
                const info = this[_items][index];
                return info && {
                    dataItem: info,
                    dataItemIndex: index
                };
            }
            dropEvents(key) {
                this.model.dropEvents(key);
            }
        }
        Data.Scenario = Scenario;
    })(Data = AFC.Data || (AFC.Data = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 22/06/2018.
 */
///<reference path="../../helpers/EventSink.ts" /> 
///<reference path="../rest/RestModel.ts" />
var AFC;
(function (AFC) {
    var Data;
    (function (Data) {
        class TableResource extends AFC.Tools.EventSink {
            constructor(sessionProvider) {
                super();
                this._session = sessionProvider;
            }
            get dbName() {
                return this._content ? this._content.descriptor.database.name : this._dbName;
            }
            get name() {
                return this._content ? this._content.descriptor.name : this._name;
            }
            get session() {
                return this._session?.getSession();
            }
            refreshStamps() {
                let content = this._content;
                if (content) {
                    content.history = null;
                    delete this._sequence;
                }
            }
            reset(rest, dbName, name) {
                delete this._sequence;
                delete this._content;
                this._schema = rest.schema;
                this._dbName = dbName;
                this._name = name;
                return this;
            }
            _updateHistory(content) {
                let descriptor = content.descriptor;
                return descriptor.isHistoricized && new Promise(resolve => {
                    this._sequence = descriptor.requestStamps((stamp, refreshStamp /*, sequence: number*/) => {
                        let restModel = descriptor.database.schema.restModel, resource = this._resource || (this._resource = restModel.pushModifier(new AFC.Rest.ResourceSubstitute(restModel, content.descriptor.fullName)));
                        resource.create(new Data.HistoryView(descriptor.fullName, content.history = {
                            stamp: stamp,
                            refreshStamp: refreshStamp,
                            session: this.session
                        }));
                        content.resource = resource.replacement;
                        resolve();
                    });
                });
            }
            async load() {
                let content = this._content || (this._content = {});
                return content.descriptor && (content.history || !content.descriptor.isHistoricized) ?
                    content :
                    new Promise(async (resolve, reject) => {
                        this.notify(65536 /* Tools.EventType.UserEvent */, () => content ? resolve(content) : reject());
                        if (!this._sequence) {
                            let promises = [], descriptor;
                            if (!content.definition) {
                                this._sequence = -1;
                                descriptor = await Data.getTable(this._schema, this._dbName, this._name);
                                content.descriptor = descriptor;
                                content.resource = descriptor.fullName;
                                promises[1] = descriptor.getDefinition().then(definition => {
                                    content.definition = definition;
                                });
                            }
                            promises[0] = this._updateHistory(content);
                            await Promise.all(promises);
                            this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                        }
                    });
            }
            release() {
                let resource = this._resource;
                if (resource) {
                    resource.release();
                    delete this._resource;
                }
                delete this._content;
                delete this._sequence;
            }
        }
        Data.tableResource = (sessionProvider) => new TableResource(sessionProvider);
        const _resource = Symbol();
        class ResourceLoader extends AFC.Tools.EventSink {
            constructor(resource) {
                super();
                this[_resource] = resource;
            }
            async getMetadata() {
                let content = await this[_resource].load(), ref, history, refresh = true;
                if (!content)
                    throw '';
                if (ref) {
                    history = content.history;
                    refresh = history && (history.stamp !== ref.history.stamp || history.refreshStamp !== ref.history.refreshStamp || history.session !== ref.history.session);
                }
                else {
                    this._content = ref = {};
                }
                refresh && $.extend(ref, content);
                return ref;
            }
            get tableResource() {
                return this[_resource];
            }
            clone() {
                let clone = Reflect.construct(ResourceLoader, [this[_resource]], this.constructor);
                clone._content = this._content;
                return clone;
            }
        }
        Data.ResourceLoader = ResourceLoader;
    })(Data = AFC.Data || (AFC.Data = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 22/04/2016.
 */
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="../data/data.ts" />
var AFC;
(function (AFC) {
    var TradeArea;
    (function (TradeArea) {
        const _path = '/tradearea/dynamic';
        class DMAConfigsDescriptor extends AFC.Tools.EventSink {
            constructor(restModel) {
                super();
                this.restModel = restModel;
            }
            _onAlways(sequence, jqXHR, textStatus) {
                if (this._sequence === sequence) {
                    this._dma = (jqXHR.responseJSON || []);
                    this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                }
            }
            getConfigurations() {
                return this._dma ? Promise.resolve(this._dma) : new Promise(resolve => {
                    this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this._dma));
                    if (!this._sequence) {
                        let request = this.restModel.createAjaxRequest(`${_path}/info`);
                        request.options.always = this._onAlways.bind(this);
                        this._sequence = request.call();
                    }
                });
            }
        }
        TradeArea.DMAConfigsDescriptor = DMAConfigsDescriptor;
        class DMASimulation {
            constructor(config, invalidate) {
                this._config = config;
                this._invalidate = invalidate;
            }
            initFrom(dma) {
                let dataTable;
                (dataTable = AFC.Data.updateTableData(dma.area)) && (this._area = new AFC.Data.DataModelBase(dataTable.columns, dataTable.primaryKey, dataTable.values));
                (dataTable = AFC.Data.updateTableData(dma.income)) && (this._income = new AFC.Data.DataModelBase(dataTable.columns, dataTable.primaryKey, dataTable.values));
                (dataTable = AFC.Data.updateTableData(dma.neighbors)) && (this._neighbors = new AFC.Data.DataModelBase(dataTable.columns, dataTable.primaryKey, dataTable.values));
            }
            set sites(value) {
                this._sites = value;
                this._invalidate.call(this._config);
            }
            get sites() {
                return this._sites;
            }
            get area() {
                return this._area;
            }
            get income() {
                return this._income;
            }
            get neighbors() {
                return this._neighbors;
            }
        }
        class DMAConfigModel extends AFC.Tools.EventSink {
            constructor(configs) {
                super();
                this._restricted = true;
                this._configs = configs;
                this._source = new DMASimulation(this, this._invalidate);
                this._target = new DMASimulation(this, this._invalidate);
            }
            _invalidate() {
                delete this._storeCode;
                delete this._sequence;
            }
            set id(value) {
                if (this._id !== value) {
                    delete this._config;
                    this._id = value;
                    this._invalidate();
                }
            }
            set area(value) {
                if (this._area !== value) {
                    this._area = value;
                    this._invalidate();
                }
            }
            get area() {
                return this._area;
            }
            set income(value) {
                if (this._income !== value) {
                    this._income = value;
                    this._invalidate();
                }
            }
            get income() {
                return this._income;
            }
            set neighbors(value) {
                if (this._neighbors !== value) {
                    this._neighbors = value;
                    this._invalidate();
                }
            }
            get neighbors() {
                return this._neighbors;
            }
            set impact(value) {
                if (this._impact !== value) {
                    this._impact = value;
                    this._invalidate();
                }
            }
            get impact() {
                return this._impact;
            }
            set restricted(value) {
                let v0 = this._restricted, v1 = !value;
                if (v0 !== v1) {
                    this._restricted = !v1;
                    this._invalidate();
                }
            }
            get restricted() {
                return this._restricted;
            }
            set sites(value) {
                if (this._sites !== value) {
                    this._sites = value;
                    this._invalidate();
                }
            }
            get sites() {
                return this._sites;
            }
            set threshold(value) {
                if (this._threshold !== value) {
                    this._threshold = value;
                    this._sites || this._invalidate();
                }
            }
            get storeTable() {
                return this._storeTable;
            }
            get storeCode() {
                return this._storeCode;
            }
            get areaCode() {
                return this._areaCode;
            }
            get influence() {
                return this._influence;
            }
            get time() {
                return this._time;
            }
            get partition() {
                return this._partition;
            }
            get source() {
                return this._source;
            }
            get target() {
                return this._target;
            }
            get impactTable() {
                return this._impactTable;
            }
            _onAlways(sequence, jqXHR, textStatus) {
                if (sequence === this._sequence) {
                    let data = jqXHR.responseJSON;
                    if (data) {
                        let dataTable = AFC.Data.updateTableData(data.impact);
                        this._storeTable = data.storeTable;
                        this._storeCode = data.storeCode;
                        this._areaCode = data.areaCode;
                        this._influence = data.influence;
                        this._time = data.time;
                        this._partition = data.partition;
                        data.source && this._source.initFrom(data.source);
                        data.target && this._target.initFrom(data.target);
                        dataTable && (this._impactTable = new AFC.Data.DataModelBase(dataTable.columns, dataTable.primaryKey, dataTable.values));
                    }
                    this.fireEvent(6 /* Tools.EventType.Dirty */);
                }
            }
            _run() {
                let request = this._configs.restModel.createAjaxRequest(_path, false, { useProgressInfo: true, modifierOptions: { noReplacements: true } });
                let data = request.options.data;
                request.options.always = this._onAlways.bind(this);
                data.model = this._config.id;
                if (this._source.sites || this._target.sites) {
                    data.context || (data.context = {});
                    this._source.sites && (data.context.source = this._source.sites);
                    this._target.sites && (data.context.target = this._target.sites);
                }
                this._area && (data.area = true);
                this._income && (data.income = true);
                this._neighbors && (data.neighbors = true);
                this._impact && (data.impact = true);
                !this._restricted && (data.restricted = false);
                this._sites ? data.sites = this._sites : this._threshold && (data.threshold = this._threshold);
                this._sequence = request.call();
            }
            simulate() {
                return this._storeCode ?
                    Promise.resolve() :
                    new Promise(async (resolve) => {
                        this.notify(6 /* Tools.EventType.Dirty */, resolve);
                        if (!this._sequence) {
                            this._sequence = -1;
                            if (this._config || (this._config = AFC.Tools.findByIdOrName(this._id, await this._configs.getConfigurations()))) {
                                this._run();
                            }
                        }
                    });
            }
        }
        TradeArea.DMAConfigModel = DMAConfigModel;
    })(TradeArea = AFC.TradeArea || (AFC.TradeArea = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 22/06/2018.
 */
///<reference path="Global.ts" />
///<reference path="DataSource.ts" />
///<reference path="Data.ts" />
///<reference path="Scenario.ts" />
///<reference path="TableResource.ts" />
///<reference path="../tradearea/DMAConfig.ts" />
var AFC;
(function (AFC) {
    var Data;
    (function (Data) {
        function findQualifier(content, qualifier, mute) {
            if (!content.qualifiers) {
                content.qualifiers = {};
                content.definition.columns.forEach((column, i) => {
                    column.qualifiers && column.qualifiers.forEach(qualifier => content.qualifiers[qualifier] = i);
                });
            }
            if (content.qualifiers[qualifier] !== void 0) {
                return content.qualifiers[qualifier];
            }
            mute || console.log(`Missing store qualifier '${Data.qualifier(qualifier)}'`);
            return -1;
        }
        Data.findQualifier = findQualifier;
        ;
        function _convert(content, columnIndex, row) {
            let values = [];
            content.definition.columns.forEach((column, indice) => {
                let i = columnIndex[column.name];
                values[indice] = i === void 0 ? null : row[i];
            });
            return values;
        }
        ;
        const _key = Symbol();
        class StoreBase {
            constructor(content) {
                this.content = content;
            }
            _getGeometry() {
                if (this.content.geometryIndice !== void 0) {
                    return this.content.geometryIndice;
                }
                console.log('Missing store geometry');
            }
            _getColumn(column) {
                let content = this.content;
                if (content.columnIndex && (content.columnIndex[column] !== void 0)) {
                    return content.columnIndex[column];
                }
                console.log('Missing store columns');
            }
            _getQualifier(qualifier, mute) {
                return findQualifier(this.content, qualifier);
            }
            static extend(constructor, getProperty) {
                let value;
                for (let i = 1 /* Qualifier.identifier */; value = Data.qualifier(i); ++i) {
                    Object.defineProperty(constructor.prototype, value, getProperty(i));
                }
            }
            get tableDefinition() {
                return this.content.definition;
            }
            get key() {
                return this[_key] || (this[_key] = this.content.definition.primaryKey.map((column) => this._getData(this._getColumn(column))));
            }
            getData(column, stringify) {
                return this._getData(this._getColumn(column));
            }
            hasQualifier(qualifier) {
                return this._getQualifier(qualifier, true) !== -1;
            }
            getQualifiedColumn(qualifier) {
                return this.content.definition.columns[this._getQualifier(qualifier)];
            }
            getColumn(name) {
                return this.content.definition.columns[this._getColumn(name)];
            }
        }
        Data.StoreBase = StoreBase;
        class ReadonlyStore extends StoreBase {
            constructor(content, values) {
                super(content);
                this._values = values;
            }
            _getData(indice) {
                return this._values[indice];
            }
            static propertyDefinition(qualifier) {
                return {
                    get: function () {
                        return this._getData(this._getQualifier(qualifier));
                    },
                    enumerable: true,
                    configurable: true
                };
            }
            get geometry() {
                return this._values[this._getGeometry()];
            }
        }
        Data.ReadonlyStore = ReadonlyStore;
        StoreBase.extend(ReadonlyStore, ReadonlyStore.propertyDefinition);
        class Store extends AFC.Tools.EventSinkMixin(StoreBase) {
            constructor(content, parameters, values) {
                super(content);
                this._parameters = parameters;
                this._values = values;
                this._override = new Data.RecordOverrides(this.content.definition.columns, values);
            }
            _reset(values) {
                this._override.reset(this._values = values);
            }
            _toPositions(columns) {
                return columns ? columns.map(column => this._getColumn(column)) : this.content.definition.columns.map((column, indice) => indice);
            }
            _getData(indice) {
                return this._override.get(indice);
            }
            _set(indice, value) {
                let dataRecordEventData = this._override.set(indice, value);
                if (dataRecordEventData) {
                    delete this._valid;
                    this.fireEvent(6 /* Tools.EventType.Dirty */, dataRecordEventData);
                    return true;
                }
            }
            _check(parameters, callback) {
                if (this._valid !== void 0) {
                    callback(this._valid, this._messages, this._events);
                }
                else {
                    delete this._messages;
                    delete this._events;
                    Promise.all(this.content.definition.columns.map((column, indice) => this._override.check(this, parameters, column, indice))).then(results => {
                        let messages, events, valid = results.every(([column, dirty, value, valid, message, indice]) => {
                            message && (messages || (messages = [])).push(message);
                            dirty && !AFC.Tools.Data.equalValue(column.type, value, this._values[indice]) && ((events || (events = {}))[column.name] = value);
                            return valid;
                        });
                        callback(this._valid = valid, messages && (this._messages = messages), events && (this._events = events));
                    });
                }
            }
            static propertyDefinition(qualifier) {
                return {
                    get: function () {
                        return this._override.get(this._getQualifier(qualifier));
                    },
                    set: function (value) {
                        this._set(this._getQualifier(qualifier), value);
                    },
                    enumerable: true,
                    configurable: true
                };
            }
            static commit(store, key, parameters, callback) {
                let final = (valid, messages) => callback && callback(valid, messages);
                let branch = parameters.data;
                if (store._closed) {
                    return final(false);
                }
                let h = (valid, messages, events) => {
                    if (valid) {
                        let compare = (item) => {
                            return item.committed && !branch.compareKey(item.row, key);
                        };
                        let h2 = (event) => {
                            if (event.data.reset || event.data.items.some(compare)) {
                                let row = branch.getRow(branch.indexOf(store._values));
                                row && store._reset(_convert(store.content, branch.columnIndex, row));
                                final(true);
                            }
                            else {
                                branch.notify(6 /* Tools.EventType.Dirty */, h2);
                            }
                        };
                        if (events) {
                            branch.notify(6 /* Tools.EventType.Dirty */, h2);
                            store._created ? branch.create(key, events) : branch.modify(key, events);
                        }
                        else
                            final(true);
                    }
                    else {
                        final(false, messages);
                    }
                };
                store._check(parameters, h);
            }
            get tableDescriptor() {
                return this.content.descriptor;
            }
            get exist() {
                return !(this._created || this._closed);
            }
            get geometry() {
                return this._override.get(this._getGeometry());
            }
            set geometry(value) {
                this._set(this._getGeometry(), value);
            }
            getOldData(column) {
                return this._values[this._getColumn(column)];
            }
            setData(column, value) {
                return this._set(this._getColumn(column), value);
            }
            checkColumn(column, callback) {
                let indice = this._getColumn(column);
                (indice !== void 0) && this._override.check(this, this._parameters, this.content.definition.columns[indice], indice).then(result => callback(...result));
            }
            check(callback) {
                this._check(this._parameters, callback);
            }
            commit(callback) {
                Store.commit(this, this.key, this._parameters, callback);
            }
            close() {
                if (!this._closed) {
                    this._closed = true;
                    this._parameters.data.delete_(this.key);
                }
            }
            getState() {
                return new ReadonlyStore(this.content, this.content.definition.columns.map((column, indice) => this._override.get(indice)));
            }
            invalidate(columns) {
                this._override.invalidate(this._toPositions(columns));
            }
            isDirty(columns) {
                return this._toPositions(columns).some(indice => this._override.isDirty(indice));
            }
        }
        Data.Store = Store;
        StoreBase.extend(Store, Store.propertyDefinition);
        class ExistingStore extends Store {
            constructor(content, parameters, row) {
                super(content, parameters, _convert(content, parameters.data.columnIndex, row));
            }
        }
        class NewStore extends Store {
            constructor(content, parameters, key) {
                let i = 0;
                let values = [];
                content.definition.columns.map((column, indice) => {
                    let value = column.index === -1 ? null : key && key[i++];
                    values[indice] = value === void 0 ? AFC.Tools.Data.generateRndValue(column) : value;
                });
                super(content, parameters, values);
                this._created = true;
            }
            commit(callback) {
                let h = (valid, messages) => {
                    valid && (delete this._created);
                    callback && callback(valid, messages);
                };
                Store.commit(this, this.key, this._parameters, h);
            }
            close() {
                this._created ? this._closed = true : super.close();
            }
        }
        function _updateContent(content) {
            let columnIndex = {};
            content.definition.columns.forEach((item, indice) => {
                columnIndex[item.name] = indice;
                columnIndex[item.alias] = indice;
                if (AFC.Tools.Data.checkGeometryType(item, 1048576 /* DataKind.point */) && (content.geometryIndice === void 0)) {
                    content.geometryIndice = indice;
                }
            });
            content.columnIndex = columnIndex;
        }
        function _updateColumns(dataTable, content) {
            dataTable.columns.forEach((column) => {
                let i = content.columnIndex[column.name];
                if ((i === void 0) || content.definition.columns[i].readOnly) {
                    column.readOnly = true;
                }
            });
        }
        async function _createBranch(content, options) {
            return content.descriptor.isHistoricized ?
                content.descriptor.insertBranch(options) : {
                id: AFC.Tools.Data.generateRndString(10),
                author: content.descriptor.database.schema.restModel.identity.name,
                creationDate: new Date(),
                properties: (options || (options = {})).properties,
                rating: options.rating,
                description: options.description,
                status: options.status
            };
        }
        const _getDMASites = Symbol();
        class StoreSource extends Data.ResourceLoader {
            constructor(resource, remote) {
                super(resource);
                this._parameters = {
                    data: this,
                    check: this._check.bind(this)
                };
                this._historizedModel = new Data.HistorizedModel(remote);
            }
            /** @internal */
            [_getDMASites](branch) {
                if (this._content) {
                    let events;
                    let dmaSites = {
                        reference: this._content.resource
                    };
                    (events = this._historizedModel.generateEvents(branch)) && (dmaSites.events = events);
                    return dmaSites;
                }
            }
            _check(store, column, dirty, value, callback) {
                return this.check ? this.check(this, store, column, dirty, value, callback) : callback(true);
            }
            _onDirty(event) {
                delete this._cache;
                this.fireEvent(6 /* Tools.EventType.Dirty */, event.data);
            }
            _release() {
                if (this._dataModel) {
                    this._dataModel.off(6 /* Tools.EventType.Dirty */, this._onDirty, this);
                    this._historizedModel.releaseBranch(this._dataModel.branch);
                    delete this._dataModel;
                    delete this._cache;
                }
            }
            async getMetadata() {
                let history = this._content?.history, content = await super.getMetadata();
                history && history !== content.history && this._release();
                _updateContent(content);
                return content;
            }
            get parameters() {
                return this._parameters;
            }
            get fullName() {
                return this._content?.descriptor.fullName;
            }
            get isHistoricized() {
                return this._content?.descriptor.isHistoricized;
            }
            get branchInfo() {
                return this._dataModel?.branchInfo;
            }
            get geometry() {
                return this._content?.definition.columns[this._content.geometryIndice];
            }
            release() {
                this._release();
            }
            get session() {
                return this._historizedModel.session;
            }
            get columns() {
                return this._historizedModel.columns;
            }
            get primaryKey() {
                return this._historizedModel.primaryKey;
            }
            get values() {
                return this._dataModel?.values;
            }
            get columnIndex() {
                return this._historizedModel.columnIndex;
            }
            getKeyFromRow(row) {
                return this._historizedModel.getKeyFromRow(row);
            }
            compareKey(row, key) {
                return this._historizedModel.compareKey(row, key);
            }
            compareRow(row0, row1) {
                return this._historizedModel.compareRow(row0, row1);
            }
            create(key, values) {
                this._dataModel.create(key, values);
            }
            modify(key, values) {
                this._dataModel.modify(key, values);
            }
            delete_(key) {
                this._dataModel.delete_(key);
            }
            indexOf(row) {
                return this._dataModel.indexOf(row);
            }
            find(key) {
                return this._dataModel.find(key);
            }
            getRow(index) {
                return this._dataModel.values[index];
            }
            dropEvents(key) {
                let reference = (this._dataModel === this._historizedModel);
                this._dataModel.dropEvents(key, reference ? { session: this.session } : void 0);
            }
            generateContext() {
                return this._cache || (this._cache = new StoreSource.DMAContext(this));
            }
            get scenario() {
                return this._scenario || (this._scenario = new Data.Scenario(this, this._dataModel));
            }
            async _setBranch(project, commit) {
                let dataModel = this._historizedModel, session = this.session;
                if (project) {
                    project.events && this._historizedModel.appendEvents(project.events, !!commit, project.id, session);
                    dataModel = await this._historizedModel.getBranch(project.id);
                    dataModel.session = session;
                    dataModel.branchInfo = project.info;
                    if (commit && project.events) {
                        await new Promise(resolve => dataModel.once(6 /* Tools.EventType.Dirty */, resolve, this._onDirty, this)); // wait for update
                    }
                }
                else {
                    await this._historizedModel.ready();
                }
                this._release();
                (this._dataModel = dataModel).on(6 /* Tools.EventType.Dirty */, this._onDirty, this);
                return this._content;
            }
            _onDataTable(content, dataTable, project) {
                if (!this._content)
                    this._content = content;
                _updateColumns(dataTable, content);
                this._historizedModel.initFrom(dataTable.columns, dataTable.primaryKey, dataTable.values, content);
                this._historizedModel.session = this.tableResource.session;
                return this._setBranch(project);
            }
            get branch() {
                return this._dataModel && this._dataModel.branch;
            }
            async init(project) {
                this._ready = false;
                this._release();
                let content = await this.getMetadata(), dataTable = await this._load(content);
                await this._onDataTable(content, dataTable, project);
                this.fireEvent(65536 /* Tools.EventType.UserEvent */ + 1);
                this.fireEvent(6 /* Tools.EventType.Dirty */, new Data.DataEventData(void 0, true));
                this._ready = true;
                return !!content;
            }
            ready() {
                return this._ready ? Promise.resolve(!!this._content) : new Promise((resolve) => this.notify(65536 /* Tools.EventType.UserEvent */ + 1, ( /*event: Tools.IEvent*/) => resolve(!!this._content)));
            }
            createStore(code) {
                let stores = this._content;
                return stores && new NewStore(stores, this._parameters, (code === void 0) || (code instanceof Array) ? code : [code]);
            }
            getStore(code) {
                let index = this._dataModel.find(code instanceof Array ? code : [code]);
                return (index !== -1) && this.getStoreFromRow(this.values[index]);
            }
            getStoreFromRow(row) {
                const content = row && this._content;
                return content && new ExistingStore(content, this._parameters, row);
            }
            hasQualifier(qualifier) {
                return this._content && (findQualifier(this._content, qualifier, true) !== -1);
            }
            getQualifiedColumn(qualifier) {
                return this._content && this._content.definition.columns[findQualifier(this._content, qualifier, true)];
            }
            get length() {
                return this.values ? this.values.length : 0;
            }
            item(index) {
                return {
                    dataItem: {
                        get key() {
                            return this.store.key;
                        },
                        store: this.getStoreFromRow(this.values[index])
                    },
                    dataItemIndex: index
                };
            }
            generateEvents() {
                return this._dataModel && this._historizedModel.generateEvents(this._dataModel.branch);
            }
            async createBranch(options, events) {
                let content = await this.getMetadata(), branch;
                if (!this._historizedModel.values) {
                    let table = {
                        columns: content.definition.columns,
                        primaryKey: content.definition.primaryKey,
                        values: []
                    };
                    await this._onDataTable(content, table);
                }
                branch = await _createBranch(content, options);
                await this._setBranch({
                    id: branch.id,
                    info: {
                        description: branch.description,
                        properties: branch.properties,
                        rating: branch.rating
                    },
                    events: events
                }, true);
                return branch;
            }
            clone() {
                let clone = super.clone();
                clone._historizedModel = this._historizedModel;
                clone._parameters = {
                    data: clone,
                    check: clone._check.bind(clone)
                };
                clone.check = this.check;
                return clone;
            }
            copy(project) {
                let clone = this.clone();
                this.ready().then(success => {
                    if (clone._ready = success) {
                        clone._setBranch(project);
                    }
                });
                return clone;
            }
        }
        StoreSource.DMAContext = class {
            constructor(storeSource) {
                this.storeSource = storeSource;
            }
            get source() {
                return this._source || (this._source = this.storeSource[_getDMASites]());
            }
            get target() {
                return this.storeSource._dataModel ? this._target || (this._target = this.storeSource[_getDMASites](this.storeSource._dataModel.branch)) : this.source;
            }
        };
        Data.StoreSource = StoreSource;
        function readOnlyStoreSourceMixin(Base) {
            const Derived = class extends Base {
                constructor(args) {
                    super(args);
                    this.content = args.content;
                }
                get geometry() {
                    return this.content.definition.columns[this.content.geometryIndice];
                }
                get fullName() {
                    return this.content.descriptor.fullName;
                }
                hasQualifier(qualifier) {
                    return findQualifier(this.content, qualifier, true) !== -1;
                }
                getQualifiedColumn(qualifier) {
                    return this.content.definition.columns[findQualifier(this.content, qualifier, true)];
                }
                getStoreFromRow(row) {
                    return row && new ReadonlyStore(this.content, row);
                }
                item(index) {
                    const store = this.getStoreFromRow(this.getRow(index));
                    return store && {
                        dataItem: {
                            get key() {
                                return this.store.key;
                            },
                            store
                        },
                        dataItemIndex: index
                    };
                }
            };
            return Derived;
        }
        Data.readOnlyStoreSourceMixin = readOnlyStoreSourceMixin;
        function _check(store, column, dirty, value, callback) {
            return this.check ? this.check(this, store, column, dirty, value, callback) : callback(true);
        }
        function storeSourceMixin(Base) {
            const Derived = class extends Base {
                constructor(args) {
                    super(args);
                    this.content = args.content;
                    this.parameters = {
                        data: this,
                        check: _check.bind(this)
                    };
                }
                get geometry() {
                    return this.content.definition.columns[this.content.geometryIndice];
                }
                get fullName() {
                    return this.content.descriptor.fullName;
                }
                hasQualifier(qualifier) {
                    return findQualifier(this.content, qualifier, true) !== -1;
                }
                getQualifiedColumn(qualifier) {
                    return this.content.definition.columns[findQualifier(this.content, qualifier, true)];
                }
                createStore(code) {
                    const content = this.content;
                    return content && new NewStore(content, this.parameters, (code === void 0) || (code instanceof Array) ? code : [code]);
                }
                getStoreFromRow(row) {
                    return row && new ExistingStore(this.content, this.parameters, row);
                }
                item(index) {
                    const store = this.getStoreFromRow(this.getRow(index));
                    return store && {
                        dataItem: {
                            get key() {
                                return this.store.key;
                            },
                            store
                        },
                        dataItemIndex: index
                    };
                }
            };
            return Derived;
        }
        Data.storeSourceMixin = storeSourceMixin;
    })(Data = AFC.Data || (AFC.Data = {}));
})(AFC || (AFC = {}));
var AFC;
(function (AFC) {
    var Tools;
    (function (Tools) {
        const _pendings = Symbol();
        let MutexState;
        (function (MutexState) {
            MutexState[MutexState["acquired"] = 0] = "acquired";
            MutexState[MutexState["e_cancelled"] = 1] = "e_cancelled";
        })(MutexState = Tools.MutexState || (Tools.MutexState = {}));
        class Mutex {
            /* lock */
            acquire() {
                return new Promise(resolve => {
                    let pendings = this[_pendings];
                    if (pendings) {
                        pendings.push(resolve);
                    }
                    else {
                        this[_pendings] = [];
                        resolve(0 /* MutexState.acquired */);
                    }
                });
            }
            /* Unlock */
            release() {
                let pendings = this[_pendings];
                if (pendings && pendings.length) {
                    pendings.shift()(0 /* MutexState.acquired */);
                }
                else {
                    delete this[_pendings];
                }
            }
            /* Cancel pending locks */
            cancel() {
                let pendings = this[_pendings];
                if (pendings) {
                    pendings.forEach(pending => pending(1 /* MutexState.e_cancelled */));
                    this[_pendings] = [];
                }
            }
            /* Check if lock is acquired */
            isLocked() {
                return !!this[_pendings];
            }
        }
        Tools.Mutex = Mutex;
    })(Tools = AFC.Tools || (AFC.Tools = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 15/05/2019.
 */
///<reference path="../models/data/StoreSource.ts" />
///<reference path="../helpers/Mutex.ts" />
var AFC;
(function (AFC) {
    var Application;
    (function (Application) {
        const _updater = Symbol(), _code = Symbol(), _project = Symbol(), _selector = Symbol();
        function _getData(dashboard, viewName) {
            let view = AFC.Tools.findByIdOrName(viewName, dashboard.views);
            view.invalidate();
            return view.getLayer(0).then(layer => layer.dataModel);
        }
        class DashboardParcUpdater {
            constructor(historizedModel, dashboard, view) {
                this.historizedModel = historizedModel;
                this.dashboard = dashboard;
                this.view = view;
                this.dirty = new Set;
                this.lock = new AFC.Tools.Mutex;
            }
            init(content) {
                let requestBuilder = this.dashboard.requestBuilder;
                this._content = content;
                return this._updater = requestBuilder.pushModifier(new AFC.Rest.ResourceSubstitute(requestBuilder, content.descriptor.fullName));
            }
            async _update(columns, project) {
                let result = await this.lock.acquire() === 0 /* Tools.MutexState.acquired */;
                if (result) {
                    try {
                        let historizedModel = this.historizedModel, info, events, branch;
                        if (project) {
                            branch = project.id;
                            if (this._content.descriptor.isHistoricized) {
                                info = project.info;
                            }
                        }
                        if (result = this.dirty.has(branch)) {
                            events = historizedModel.generateEvents(branch);
                            this._updater.create(new AFC.Data.ModificationCreation(this._content.resource, events, info));
                            historizedModel.applyValuesSilent(await _getData(this.dashboard, this.view), columns, branch);
                            this.dirty.delete(branch);
                        }
                    }
                    finally {
                        this.lock.release();
                    }
                }
                return result;
            }
            async ready(wait, project) {
                let columns = this.columns, branch = project?.id;
                if (columns && this.isDirty(branch)) {
                    const updates = [this._update(columns, project), project && this.dirty.has(void 0) && this._update(columns)];
                    if (wait)
                        await Promise.all(updates);
                }
                return true;
            }
            move(point) {
                this.columns && this.historizedModel.clearColumns(this.columns);
                this.dashboard.mainCluster.setSite(point);
            }
            invalidate(branch) {
                this.dirty.add(branch);
            }
            isDirty(branch) {
                return this.dirty.has(void 0) || this.dirty.has(branch);
            }
            release() {
                let updater = this._updater;
                updater.release();
                this.dashboard.requestBuilder.popModifier(updater);
            }
        }
        function _checkEventField(item, column, branch) {
            return (item.type === 1 /* Data.DataEventType.create */ || (item.type === 2 /* Data.DataEventType.modify */ && item.values.hasOwnProperty(column))) && (!branch === !item.branch);
        }
        class DashboardParc extends AFC.Data.StoreSource {
            get dirty() {
                const updater = this[_updater];
                return updater?.isDirty(this.branch);
            }
            _load(content) {
                let updater = this[_updater], replacement = updater.init(content);
                replacement.replacement = content.resource;
                return _getData(updater.dashboard, updater.view);
            }
            _onDirty(event) {
                const updater = this[_updater], data = updater.columns && event && event.data, name = this.geometry.name, branch = this.branch;
                if (data) {
                    if (data.reset) {
                        updater.invalidate();
                        updater.invalidate(branch);
                    }
                    else if (data.items) {
                        data.items.forEach(item => {
                            if (_checkEventField(item, name)) {
                                updater.invalidate();
                            }
                            else if (_checkEventField(item, name, branch)) {
                                updater.invalidate(branch);
                            }
                        });
                    }
                }
                super._onDirty(event);
            }
            _setBranch(project, commit) {
                const updater = this[_updater];
                this[_project] = project;
                if (project && updater) {
                    updater.invalidate(project.id);
                }
                return super._setBranch(project, commit);
            }
            async ready(dashboardData) {
                const ready = await super.ready(), updater = this[_updater];
                return ready && updater ? await updater.ready(dashboardData, this[_project]) : ready;
            }
            async init(project) {
                const ready = await super.init(project), columns = ready && project && this.columns.filter(column => column.readOnly);
                if (columns && columns.length) {
                    this[_updater].columns = columns;
                    this._historizedModel.clearBranchesColumnsSilent(columns);
                }
                return ready;
            }
            clone() {
                let clone = super.clone();
                clone[_updater] = this[_updater];
                clone[_project] = this[_project];
                return clone;
            }
            release() {
                let updater = this[_updater];
                super._release();
                if (updater) {
                    updater.release();
                    delete this[_updater];
                }
            }
            move(point) {
                const updater = this[_updater];
                return updater && updater.move(point);
            }
            setParameters(dashboard, point, view) {
                (this[_updater] = new DashboardParcUpdater(this._historizedModel, dashboard, view)).move(point);
            }
            modify(key, values) {
                const updater = this[_updater], columns = updater && updater.columns;
                if (columns && values[this.geometry.name]) {
                    values = $.extend(columns.reduce((acc, column) => (acc[column.name] = null, acc), {}), values);
                }
                super.modify(key, values);
            }
        }
        Application.DashboardParc = DashboardParc;
        class AdminParc extends AFC.Data.StoreSource {
            setCode(selector, code) {
                this.release();
                this[_selector] = selector;
                this[_code] = code;
            }
            _load(content) {
                let restModel = content.descriptor.database.schema.restModel, parameter = AFC.Tools.Data.QueryTemplateParameters[AFC.Tools.Data.isValid(2 /* Data.DataKind.real */, this[_code]) ? 2 /* Data.DataKind.real */ : 1 /* Data.DataKind.character */], command = {
                    commandText: `SELECT * FROM ${content.resource} WHERE ${this[_selector]}=:param0(${parameter})`,
                    parameters: { param0: this[_code] },
                    maximumRows: 1000000
                };
                return new AFC.Data.Queries(restModel).getDataTable([command]).then(tables => tables[0]);
            }
            ;
        }
        Application.AdminParc = AdminParc;
    })(Application = AFC.Application || (AFC.Application = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 29/07/2020.
 */
///<reference path="Global.ts" />
///<reference path="Symbol.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="../data/Data.ts" />
///<reference path="../../views/Global.ts" />
///<reference path="../../helpers/Geometry.ts" />
///<reference path="../../helpers/Data.ts" />
///<reference path="../../helpers/Cartographer.ts" />
var AFC;
(function (AFC) {
    var Globals;
    (function (Globals) {
        class TileLayerProvider extends AFC.Rest.RequestBuilder {
            constructor(mapLayerDescriptor, base) {
                super(base || mapLayerDescriptor.mapView.globals.restModel);
                this.descriptor = mapLayerDescriptor;
            }
            requestTiles(layer, tiles, callback) {
                this.load().then(() => {
                    let request = this.descriptor.createRequest('/tiles', false, { builder: this }), data = request.options.data;
                    data.keys = tiles;
                    request.options.always = (sequence, jqXHR, textStatus) => {
                        let data = jqXHR.responseJSON;
                        callback(tiles, data && AFC.Data.updateDataRows(layer.tiledModel.data.columns, data.values));
                    };
                    request.call();
                });
            }
        }
        Globals.TileLayerProvider = TileLayerProvider;
        function _makeSingle(column) {
            return (row) => row[column];
        }
        function _makeMultiple(columns) {
            return (row) => columns.map(indice => row[indice]);
        }
        class EventSink extends AFC.Tools.EventSinkMixin(AFC.Data.RowComparator) {
            constructor(primaryKey, columnIndex) {
                const keys = primaryKey.map((item) => columnIndex[item]);
                super(keys);
                this._timeout = null;
                if (keys.length === 1) {
                    this.getCodeForContext = _makeSingle(keys[0]);
                    this.getKeyFromContext = (code) => [code];
                }
                else {
                    this.getCodeForContext = _makeMultiple(keys);
                    this.getKeyFromContext = (code) => code;
                }
            }
            _register() {
                this.dispatchChange || (this.dispatchChange = () => {
                    (this._timeout !== null) && clearTimeout(this._timeout);
                    this._timeout = setTimeout(() => {
                        this.fireEvent(1073741824 /* Tools.EventType.Attach */, new AFC.Data.DataEventData(void 0, true));
                        this._timeout = null;
                    }, 300);
                });
            }
            once(type, callback, callbackref, context) {
                this._register();
                super.once(type, callback, callbackref, context);
            }
            on(type, callback, context) {
                this._register();
                super.on(type, callback, context);
            }
        }
        class TileVectorModel extends EventSink {
            constructor({ provider, name, geometryIndice, columns, primaryKey }) {
                const columnIndex = AFC.Data.getColumnIndex(columns);
                super(primaryKey, columnIndex);
                this.provider = provider;
                this.name = name;
                this.geometryIndice = geometryIndice;
                this.columns = columns;
                this.primaryKey = primaryKey;
                this.columnIndex = columnIndex;
                this.empty();
            }
            _lowerBound(container, row) {
                return AFC.Tools.lower_bound(container, row, (feature, row) => this.compareRow(feature.properties.data, row));
            }
            _match(container, i, row) {
                return (i < container.length) && !this.compareRow(container[i].properties.data, row) ? container[i] : null;
            }
            _insert(container, indice, entity) {
                container.splice(indice, 0, entity);
            }
            _remove(container, indice) {
                container.splice(indice, 1);
            }
            _getRowContainer(row) {
                return this._filter && !this._filter(row, this) ? this._hidden : this.entities;
            }
            _onDirty(event) {
                this.notify(1073741824 /* Tools.EventType.Attach */ + 1, () => {
                    let data = event.data, items;
                    if (data.filter || (items = data.data && data.data.items)) {
                        this.fireEvent(6 /* Tools.EventType.Dirty */, data.filter ? new AFC.Data.DataEventData(items, true) : data.data);
                    }
                });
                this.fireEvent(1073741824 /* Tools.EventType.Attach */ + 1); // wait a little for the layer attach event to reach the MapModel ...
            }
            attach(mapLayerTiledModel) {
                this.detach();
                //(this._mapLayerTiledModel = mapLayerTiledModel).on(Tools.EventType.Attach, this._onDirty, this);
                this._mapLayerTiledModel = mapLayerTiledModel;
            }
            detach() {
                if (this._mapLayerTiledModel) {
                    //this._mapLayerTiledModel.off(Tools.EventType.Attach, this._onDirty, this);
                    delete this._mapLayerTiledModel;
                }
            }
            /*public fireLayerEvent(item?: Data.IDataEventItem, reset?: boolean): ReturnType<EventSink['fireEvent']> {
                let dataEventData = item && new Data.DataEventData([item]);
                return this._mapLayerTiledModel.fireEvent(Tools.EventType.Attach, mapLayerModelEventData(false, false, dataEventData, reset));
            }*/
            fireLayerEvent(items, reset) {
                let dataEventData = items && new AFC.Data.DataEventData(items);
                if (reset || items) {
                    this.notify(1073741824 /* Tools.EventType.Attach */ + 1, () => {
                        this.fireEvent(6 /* Tools.EventType.Dirty */, reset ? new AFC.Data.DataEventData(items, true) : dataEventData);
                    });
                    this.fireEvent(1073741824 /* Tools.EventType.Attach */ + 1); // wait a little for the layer attach event to reach the MapModel ...
                }
                return this._mapLayerTiledModel.fireEvent(1073741824 /* Tools.EventType.Attach */, Globals.mapLayerModelEventData(false, false, dataEventData, reset));
            }
            lowerBound(geometry, row) {
                return new TileVectorModel._Bookmark(this, geometry, row);
            }
            remove(feature) {
                if (--feature.properties.count === 0) {
                    let row = feature.properties.data, container = this._getRowContainer(row), i = this._lowerBound(container, row);
                    if (this._match(container, i, row)) {
                        this._remove(container, i);
                    }
                    return true;
                }
            }
            empty() {
                this._hidden = [];
                this.entities = [];
            }
            get length() {
                return this.entities.length;
            }
            getRow(index) {
                let feature = this.entities[index];
                return feature && feature.properties.data;
            }
            indexOf(row) {
                let i = this._lowerBound(this.entities, row);
                return this._match(this.entities, i, row) ? i : -1;
            }
            find(key) {
                let i = AFC.Tools.lower_bound(this.entities, key, (feature, key) => this.compareKey(feature.properties.data, key)), entity = this.entities[i];
                return entity && !this.compareKey(entity.properties.data, key) ? i : -1;
            }
            set filter(value) {
                if (this._filter !== value) {
                    let hidden = this._hidden;
                    this._hidden = [];
                    this._filter = value;
                    if (value) {
                        let entities = this.entities;
                        this.entities = [];
                        entities.forEach(entity => this._getRowContainer(entity.properties.data).push(entity));
                    }
                    hidden.forEach(entity => {
                        let row = entity.properties.data, container = this._getRowContainer(row);
                        this._insert(container, this._lowerBound(container, row), entity);
                    });
                    this.fireLayerEvent(void 0, true);
                }
            }
            get filter() {
                return this._filter;
            }
        }
        TileVectorModel._Bookmark = class {
            constructor(model, geometry, row) {
                let container = model._getRowContainer(row), visible = model.entities === container, position = model._lowerBound(container, row), insert = () => (++this.feature.properties.count, false);
                this.insert = (this.feature = model._match(container, position, row)) ?
                    insert :
                    () => {
                        let feature = AFC.Tools.Cartographer.feature(geometry, { data: row, count: 1 });
                        model._insert(container, position, this.feature = feature);
                        this.insert = insert;
                        return visible;
                    };
            }
        };
        Globals.TileVectorModel = TileVectorModel;
        function tileVectorModel(provider, columns, primaryKey, name, geometryIndice) {
            return new TileVectorModel({
                provider,
                name,
                geometryIndice,
                columns: columns,
                primaryKey: primaryKey
            });
        }
        Globals.tileVectorModel = tileVectorModel;
        class Event {
            constructor(eventType, committed, row, rectangle) {
                this.type = eventType;
                this.committed = committed;
                this.row = row;
                this.rectangle = rectangle;
            }
        }
        class CreateEvent extends Event {
            constructor(committed, row, rectangle, eventType) {
                super(eventType || 1 /* Data.DataEventType.create */, committed, row, rectangle);
                this.oldRow = null;
            }
            apply(model, layer, tiles, rows) {
                layer.intersect(tiles, this.rectangle) && rows.push(this.row);
            }
            getValues(columns) {
                let values = {};
                columns.forEach((column, indice) => {
                    if (column.index === -1) {
                        values[column.name] = this.row[indice];
                    }
                });
                return values;
            }
            append(columns, event) {
                if (event.type !== 4 /* Data.DataEventType.delete_ */) {
                    // creation + modification = creation
                    this.committed = event.committed;
                    this.row = event.row;
                    this.rectangle = event.rectangle;
                    return this;
                }
            }
            commit(model, values) {
                let modifiedRow = !this.committed && values && AFC.Data.modifyRowWithValues(model, this.row, values);
                this.committed = true;
                return modifiedRow && (this.row = modifiedRow);
            }
            revert(model) {
                return {
                    type: 4 /* Data.DataEventType.delete_ */,
                    row: this.row,
                    committed: true
                };
            }
        }
        class DeleteEvent extends Event {
            constructor(committed, row, rectangle) {
                super(4 /* Data.DataEventType.delete_ */, committed, row, rectangle);
                this.oldRow = row;
            }
            apply(model, layer, tiles, rows) {
                if (layer.intersect(tiles, this.rectangle)) {
                    for (let i = 0; i < rows.length; ++i) {
                        if (!model.compareRow(this.row, rows[i])) {
                            rows.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            append(columns, event) {
                // should never happen
                return this;
            }
            commit(model, values) {
                this.committed = true;
                return;
            }
            revert(model) {
                return {
                    type: 1 /* Data.DataEventType.create */,
                    row: this.row,
                    committed: true
                };
            }
        }
        class ModifyEvent extends CreateEvent {
            constructor(committed, row, oldRow, rectangle, geometryIndice) {
                let oldRectange = AFC.Tools.Geometry.getBoundRect(oldRow[geometryIndice]);
                super(committed, row, rectangle, 2 /* Data.DataEventType.modify */);
                this.oldRow = oldRow;
                this.rectangle.some((item, indice) => item !== oldRectange[indice]) && (this._delete = new DeleteEvent(void 0, oldRow, oldRectange));
                this._geometryIndice = geometryIndice;
            }
            apply(model, layer, tiles, rows) {
                if (this._delete) {
                    this._delete.apply(model, layer, tiles, rows);
                    super.apply(model, layer, tiles, rows);
                }
                else if (layer.intersect(tiles, this.rectangle)) {
                    for (let i = 0; i < rows.length; ++i) {
                        if (!model.compareRow(this.row, rows[i])) {
                            rows[i] = this.row;
                            break;
                        }
                    }
                }
            }
            getValues(columns) {
                let values;
                columns.forEach((column, indice) => {
                    if ((column.index === -1) && !AFC.Tools.Data.equalValue(column.type, this.row[indice], this.oldRow[indice])) {
                        (values || (values = {}))[column.name] = this.row[indice];
                    }
                });
                return values;
            }
            append(columns, event) {
                let oldRect = this._delete && this._delete.rectangle;
                if (event.type === 4 /* Data.DataEventType.delete_ */)
                    return new DeleteEvent(event.committed, this.oldRow, oldRect || this.rectangle); // modification + deletion = deletion
                // modification + modification = modification
                let row = event.row, oldRow = this.oldRow, modification, geometryIndice = this._geometryIndice;
                columns.some((column, indice) => {
                    if (column.index === -1) {
                        let geometry = (indice === geometryIndice), equal;
                        if (geometry || !modification) {
                            equal = AFC.Tools.Data.equalValue(column.type, row[indice], oldRow[indice]);
                            equal || (modification = true);
                            geometry && equal && (delete this._delete);
                        }
                        return modification && (indice >= geometryIndice);
                    }
                });
                if (modification) {
                    this.committed = event.committed;
                    this.rectangle = event.rectangle;
                    this.oldRow = oldRow;
                    return this;
                }
            }
            revert(model) {
                return {
                    type: 2 /* Data.DataEventType.modify */,
                    row: this.oldRow,
                    committed: true
                };
            }
        }
        class CommitableEntry {
            constructor(event) {
                this._pending = event;
                this.oldRow = event.oldRow;
                this.row = event.row;
            }
            get type() {
                return (this._pending && this._pending.type) || (this._sent && this._sent.type) || (this._committed && this._committed.type) || 0 /* Data.DataEventType.none */;
            }
            pending() {
                if (!this._sent)
                    return this._pending;
            }
            get skip() {
                return !(this._sent || this._pending);
            }
            startTransaction(sequence) {
                this._sequence = sequence;
                this._sent = this._pending;
                delete this._pending;
            }
            endTransaction(sequence, model, values) {
                let sent, modifiedRow;
                if ((sequence === this._sequence) && (sent = this._sent)) {
                    delete this._sent;
                    (modifiedRow = sent && sent.commit(model, values)) && (this.row = modifiedRow);
                    this._committed = this._committed ? this._committed.append(model.columns, sent) : sent;
                    if (!this._pending) {
                        return {
                            type: modifiedRow ? 2 /* Data.DataEventType.modify */ : 0 /* Data.DataEventType.none */,
                            row: modifiedRow || this.row,
                            committed: true
                        };
                    }
                }
            }
            apply(model, layer, tiles, rows) {
                this._sent && this._sent.apply(model, layer, tiles, rows);
                this._pending && this._pending.apply(model, layer, tiles, rows);
            }
            append(columns, event) {
                this._pending = this._pending ? this._pending.append(columns, event) : event;
                this.row = event.row;
                return this;
            }
            revert(model) {
                let row = this.row = this.oldRow || this.row, dataEventType = 0 /* Data.DataEventType.none */;
                this.rollback = true;
                switch (this.type) {
                    case 1 /* Data.DataEventType.create */:
                        dataEventType = 4 /* Data.DataEventType.delete_ */;
                        break;
                    case 2 /* Data.DataEventType.modify */:
                        dataEventType = 2 /* Data.DataEventType.modify */;
                        break;
                    case 4 /* Data.DataEventType.delete_ */:
                        dataEventType = 1 /* Data.DataEventType.create */;
                        break;
                }
                delete this._committed;
                delete this._sent;
                delete this._pending;
                return {
                    type: dataEventType,
                    row: row,
                    committed: true
                };
            }
        }
        class EventStack extends AFC.Tools.EventSink {
            constructor(tileVectorModel, descriptor, target, updates, session) {
                super();
                this.model = tileVectorModel;
                this.provider = tileVectorModel.provider;
                this.target = target;
                this.updates = updates;
                this.session = session;
                this.events = [];
                descriptor.isHistoricized && (this.descriptor = descriptor);
            }
            _onUpdateRow(sequence, eventType, code, values) {
                let model = this.model, key = model.getKeyFromContext(code), i = AFC.Tools.lower_bound(this.events, key, (event, row) => model.compareKey(event.row, key)), event = this.events[i];
                if (event && !model.compareKey(event.row, key)) {
                    let item = event.endTransaction(sequence, model, values);
                    (event.type === 0 /* Data.DataEventType.none */) && this.events.splice(i, 1);
                    item && this.model.fireLayerEvent([item]);
                    return item;
                }
            }
            _onUpdate(sequence, results) {
                let events;
                delete this._sequence;
                if (results && results[0] && (events = results[0].events)) {
                    events.creations && events.creations.forEach(creation => this._onUpdateRow(sequence, 1 /* Data.DataEventType.create */, creation.code, creation.values));
                    events.modifications && events.modifications.forEach(modification => this._onUpdateRow(sequence, 2 /* Data.DataEventType.modify */, modification.code, modification.values));
                    events.deletions && events.deletions.forEach(deletion => this._onUpdateRow(sequence, 4 /* Data.DataEventType.delete_ */, deletion));
                }
                this._commit();
            }
            _onRollback(rollbacks, events) {
                let model = this.model;
                delete this._sequence;
                rollbacks.forEach(entry => {
                    entry.rollback = false;
                    if (entry.type === 0 /* Data.DataEventType.none */) {
                        let row = entry.row, i = AFC.Tools.lower_bound(this.events, row, (event, row) => model.compareRow(event.row, row)), event0 = this.events[i];
                        event0 && !model.compareRow(row, event0.row) && this.events.splice(i, 1);
                    }
                });
            }
            _commit() {
                if (this._dirty) {
                    let model = this.model, events = {}, filtered, rollbacks;
                    delete this._dirty;
                    delete this._timeout;
                    filtered = this.events.filter((entry) => {
                        if (entry.rollback) {
                            (rollbacks || (rollbacks = [])).push(entry);
                        }
                        else if (!entry.rollback) {
                            let event = entry.pending(); // dirty cast to lure typescript transpiler
                            if (event) {
                                let code = model.getCodeForContext(event.row);
                                switch (event.type) {
                                    case 1 /* Data.DataEventType.create */:
                                        (events.creations || (events.creations = [])).push({ code: code, values: event.getValues(model.columns) });
                                        break;
                                    case 2 /* Data.DataEventType.modify */:
                                        let values = event.getValues(model.columns);
                                        values && (events.modifications || (events.modifications = [])).push({ code: code, values: values });
                                        break;
                                    case 4 /* Data.DataEventType.delete_ */:
                                        (events.deletions || (events.deletions = [])).push(code);
                                        break;
                                }
                                return true;
                            }
                        }
                    });
                    let sequence;
                    if (rollbacks) {
                        let keys = rollbacks.map(entry => model.getKeyFromRow(entry.row)), session = this.session;
                        sequence = this.descriptor.rollbackEvents(keys, events => this._onRollback(rollbacks, events), session && { session: session, filter: { session: session } });
                    }
                    else if (filtered.length) {
                        sequence = this.updates.run([{
                                table: this.target,
                                events: events,
                                session: this.session
                            }], results => this._onUpdate(sequence, results));
                    }
                    this._sequence = sequence;
                    filtered.forEach(event => event.startTransaction(sequence));
                }
            }
            _prune() {
                this._dirty = true;
                if (!this._sequence) {
                    this._timeout && clearTimeout(this._timeout);
                    this._timeout = setTimeout(() => this._commit(), 200);
                }
            }
            _insert(event) {
                let model = this.model, i = AFC.Tools.lower_bound(this.events, event.row, (event, row) => model.compareRow(event.row, row)), event0 = this.events[i];
                if (!event0 || model.compareRow(event.row, event0.row)) {
                    let entry = this.updates ? new CommitableEntry(event) : event;
                    this.events.splice(i, 0, entry);
                }
                else {
                    let e = event0.append(model.columns, event);
                    e ? this.events[i] = e : this.events.splice(i, 1);
                }
                return event;
            }
            push(eventType, row, oldRow) {
                let geometryIndice = this.model.geometryIndice, rectangle = AFC.Tools.Geometry.getBoundRect(row[geometryIndice]), committed = !this.updates, event;
                switch (eventType) {
                    case 1 /* Data.DataEventType.create */:
                        event = new CreateEvent(committed, row, rectangle);
                        break;
                    case 2 /* Data.DataEventType.modify */:
                        event = new ModifyEvent(committed, row, oldRow, rectangle, geometryIndice);
                        break;
                    case 4 /* Data.DataEventType.delete_ */:
                        event = new DeleteEvent(committed, row, rectangle);
                        break;
                }
                committed || this._prune();
                return this._insert(event);
            }
            dropEvents(key) {
                if (!this.updates || this.descriptor) {
                    let model = this.model, i = AFC.Tools.lower_bound(this.events, key, (event, row) => model.compareKey(event.row, key)), event = this.events[i];
                    if (event && !model.compareKey(event.row, key)) {
                        let item = event.revert(model);
                        this.updates ? this._prune() : this.events.splice(i, 1);
                        item && this.model.fireLayerEvent([item]);
                        return item;
                    }
                }
            }
            requestTiles(layer, tiles, callback) {
                let model = this.model;
                this.provider.requestTiles(layer, tiles, (tiles, rows) => {
                    this.events.forEach(event => event.skip || event.apply(model, layer, tiles, rows));
                    callback(tiles, rows);
                });
            }
        }
        const _type = "{7C60520F-FC53-413D-97F9-BE0F18A44F5C}";
        class EventInfo {
            constructor(content, values) {
                this.content = content;
                this.store = new AFC.Data.ReadonlyStore(this.content, this._values = values);
            }
            get key() {
                return this.store.key;
            }
            get eventType() {
                return this.store.getData(_type);
            }
            getInitialData(column) {
                let eventStack = this.content.definition, event = eventStack.events[this._values.__pos], oldRow = event.oldRow;
                return oldRow && oldRow[eventStack.model.columnIndex[column]];
            }
        }
        class EventStackEx extends EventStack {
            constructor(tileVectorModel, descriptor, definition, target, updates, session) {
                let index = AFC.Data.getColumnIndex(definition.columns), columns = tileVectorModel.columns.map(column => definition.columns[index[column.name]] || column);
                super(tileVectorModel, descriptor, target, updates, session);
                columns.push(new AFC.Data.DBColumnDefinition(_type, 3 /* AFC.Data.DataKind.integer */, -1, 4, "type", true));
                this.columns = columns;
                this.primaryKey = tileVectorModel.primaryKey;
                this.columnIndex = AFC.Data.getColumnIndex(columns);
            }
            _fire(item) {
                if (item && (item.type !== 0 /* Data.DataEventType.none */)) {
                    delete this._values;
                    // should be more clever someday
                    this.fireEvent(6 /* Tools.EventType.Dirty */, new AFC.Data.DataEventData(void 0, true));
                    return item;
                }
            }
            _onUpdateRow(sequence, eventType, code, values) {
                return this._fire(super._onUpdateRow(sequence, eventType, code, values));
            }
            _insert(event) {
                return this._fire(super._insert(event));
            }
            dropEvents(key) {
                return this._fire(super.dropEvents(key));
            }
            // Data.IDataModelBase
            get values() {
                if (!this._values) {
                    let values = this._values = [];
                    this.events.forEach((event, indice) => {
                        if (event.type !== 0 /* Data.DataEventType.none */) {
                            let row = event.row.slice(0);
                            row.__pos = indice;
                            row.push(event.type);
                            values.push(row);
                        }
                    });
                }
                return this._values;
            }
            get length() {
                return this.values.length;
            }
            getRow(index) {
                return this.values[index];
            }
            item(index) {
                let row = this.values[index];
                if (row) {
                    return {
                        dataItem: new EventInfo(this._content || (this._content = {
                            definition: this,
                            columnIndex: this.columnIndex,
                            geometryIndice: this.model.geometryIndice
                        }), row),
                        dataItemIndex: index
                    };
                }
            }
            indexOf(row) {
                let values = this.values, i = AFC.Tools.lower_bound(values, row, (row0, row1) => this.model.compareRow(row0, row1));
                return this.model.compareRow(values[i], row) ? -1 : i;
            }
            getKeyFromRow(row) {
                return this.model.getKeyFromRow(row);
            }
            compareKey(row, key) {
                return this.model.compareKey(row, key);
            }
            compareRow(row0, row1) {
                return this.model.compareRow(row0, row1);
            }
        }
        class EditableTileVectorModel extends EventSink {
            constructor({ model, provider }) {
                super(model.primaryKey, model.columnIndex);
                (this.tileVectorModel = model).on(6 /* Tools.EventType.Dirty */, (e) => this.fireEvent(6 /* Tools.EventType.Dirty */, e.data && new AFC.Data.DataEventData(e.data.items, e.data.reset)));
                this.geometryIndice = model.geometryIndice;
                this.provider = provider;
            }
            attach(mapLayerTiledModel) {
                this.tileVectorModel.attach(mapLayerTiledModel);
            }
            detach() {
                this.tileVectorModel.detach();
            }
            _apply(eventType, row, oldRow) {
                let item = this.provider.push(eventType, row, oldRow);
                item && this.tileVectorModel.fireLayerEvent([item]);
            }
            get name() {
                return this.tileVectorModel.name;
            }
            get columns() {
                return this.tileVectorModel.columns;
            }
            get primaryKey() {
                return this.tileVectorModel.primaryKey;
            }
            get columnIndex() {
                return this.tileVectorModel.columnIndex;
            }
            get length() {
                return this.tileVectorModel.length;
            }
            getRow(index) {
                return this.tileVectorModel.getRow(index);
            }
            get entities() {
                return this.tileVectorModel.entities;
            }
            indexOf(row) {
                return this.tileVectorModel.indexOf(row);
            }
            find(key) {
                return this.tileVectorModel.find(key);
            }
            lowerBound(geometry, row) {
                return this.tileVectorModel.lowerBound(geometry, row);
            }
            remove(entity) {
                return this.tileVectorModel.remove(entity);
            }
            empty() {
                this.tileVectorModel.empty();
            }
            create(key, values) {
                this._apply(1 /* Data.DataEventType.create */, AFC.Data.createRowFromValues(this, key, values));
            }
            modify(key, values) {
                let i = AFC.Tools.lower_bound(this.entities, key, (feature, key) => this.compareKey(feature.properties.data, key)), row = this.getRow(i);
                if (row && !this.compareKey(row, key)) {
                    let modifiedRow = AFC.Data.modifyRowWithValues(this, row, values);
                    modifiedRow && this._apply(2 /* Data.DataEventType.modify */, modifiedRow, row);
                }
            }
            delete_(key) {
                let i = AFC.Tools.lower_bound(this.entities, key, (feature, key) => this.compareKey(feature.properties.data, key)), row = this.getRow(i);
                if (row && !this.compareKey(row, key)) {
                    this._apply(4 /* Data.DataEventType.delete_ */, row);
                }
            }
            dropEvents(key) {
                this.provider.dropEvents(key);
            }
            set filter(value) {
                this.tileVectorModel.filter = value;
            }
            get filter() {
                return this.tileVectorModel.filter;
            }
        }
        class MapLayerTiledModel extends Globals.MapLayerModel {
            constructor(template, thematics, data) {
                super(template, thematics);
                this.isTiled = true;
                this.data = data;
            }
            set data(value) {
                if (this._data !== value) {
                    if (this._data) {
                        this._data.detach();
                        delete this._data;
                    }
                    if (value) {
                        value.attach(this);
                        this._data = value;
                    }
                }
            }
            get data() {
                return this._data;
            }
        }
        function mapLayerTiledModel(mapLayerDescriptor, template, thematics, data) {
            const definition = template.table, columns = definition.columns;
            return new MapLayerTiledModel(template, thematics, data || tileVectorModel(new TileLayerProvider(mapLayerDescriptor), columns, definition.primaryKey, definition.name, AFC.Tools.Data.findFirstGeometry(columns)));
        }
        Globals.mapLayerTiledModel = mapLayerTiledModel;
        const _readOnlyStoreVectorModel = AFC.Data.readOnlyStoreSourceMixin((TileVectorModel));
        function readOnlyStoreVectorModel(content, provider, definition, name, geometryIndice) {
            const columns = content.definition.columns;
            return definition.primaryKey && new _readOnlyStoreVectorModel({
                content: $.extend({}, content, {
                    columnIndex: AFC.Data.getColumnIndex(columns),
                    geometryIndice: AFC.Tools.Data.findFirstGeometry(columns)
                }),
                provider,
                name,
                geometryIndice,
                columns: definition.columns,
                primaryKey: definition.primaryKey
            });
        }
        Globals.readOnlyStoreVectorModel = readOnlyStoreVectorModel;
        const _storeVectorModel = AFC.Data.storeSourceMixin((EditableTileVectorModel));
        function storeVectorModel(content, model, /* target table */ target, session) {
            const descriptor = content.descriptor, updates = target && new AFC.Data.Updates(descriptor.database.schema.restModel);
            return new _storeVectorModel({
                content,
                provider: new EventStackEx(model, descriptor, content.definition, target, updates, session),
                model
            });
        }
        Globals.storeVectorModel = storeVectorModel;
        const _vectorModel = Symbol();
        class CompoundTileLayerProvider extends TileLayerProvider {
            constructor(mapLayerDescriptor, reference, dataModel, name, template, base) {
                let additionalColumns = [], columns0 = reference.columns, columns1 = columns0.slice(0), metadata = Object.create(template);
                super(mapLayerDescriptor, base);
                dataModel.columns.forEach((column1, indice) => {
                    if (columns0.every(column0 => column0.alias !== column1.alias)) {
                        additionalColumns.push(indice);
                        columns1.push(column1);
                    }
                });
                this._additionalColumns = additionalColumns;
                metadata.name = name;
                metadata.table = {
                    name: name,
                    columns: columns1,
                    primaryKey: reference.primaryKey
                };
                this.template = metadata;
                (this.dataModel = dataModel).on(6 /* Tools.EventType.Dirty */, this._onDirty, this);
            }
            _onDirty(event) {
                let items, reset, data = event.data;
                if (data) {
                    reset = data.reset;
                    !reset && data.items && (data.items.some(item => {
                        if (item.type !== 0 /* Data.DataEventType.none */) {
                            let key = this.dataModel.getKeyFromRow(item.row), indice = this[_vectorModel].find(key);
                            if (indice !== -1) {
                                let row0 = this[_vectorModel].entities[indice].properties.data, row1 = row0.slice(0, row0.length - this._additionalColumns.length), value = item.type !== 4 /* Data.DataEventType.delete_ */;
                                this._additionalColumns.forEach(indice => row1.push(value ? item.row[indice] : null));
                                (items || (items = [])).push({
                                    type: 2 /* Data.DataEventType.modify */,
                                    row: row1,
                                    committed: true
                                });
                            }
                        }
                    }));
                }
                this[_vectorModel].fireLayerEvent(items, reset);
            }
            requestTiles(layer, tiles, callback) {
                super.requestTiles(layer, tiles, (tiles, rows) => {
                    let model;
                    rows && (model = layer.tiledModel.data) && rows.forEach(row => {
                        let key = model.getKeyFromRow(row), i = this.dataModel.find(key), compoundRow = this.dataModel.values[i];
                        this._additionalColumns.forEach(indice => row.push(compoundRow ? compoundRow[indice] : null));
                    });
                    callback(tiles, rows);
                });
            }
        }
        function compoundMapLayerTiledModel(mapLayerDescriptor, reference, thematics, dataModel, template, name, zooms) {
            let provider = new CompoundTileLayerProvider(mapLayerDescriptor, reference, dataModel, name, template), definition = provider.template.table, columns = definition.columns, data = tileVectorModel(provider, columns, definition.primaryKey, name, AFC.Tools.Data.findFirstGeometry(columns)), mapLayerTiledModel = new MapLayerTiledModel(provider.template, thematics, provider[_vectorModel] = data);
            zooms.minZ && (mapLayerTiledModel.minZ = zooms.minZ);
            zooms.maxZ && (mapLayerTiledModel.maxZ = zooms.maxZ);
            return mapLayerTiledModel;
        }
        Globals.compoundMapLayerTiledModel = compoundMapLayerTiledModel;
    })(Globals = AFC.Globals || (AFC.Globals = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 02/08/2016.
 */
///<reference path="../models/dashboards/Dashboard.ts" />
///<reference path="../models/data/StoreSource.ts" />
///<reference path="../models/globals/TileVectorModel.ts" />
///<reference path="data.ts" />
var AFC;
(function (AFC) {
    var Tools;
    (function (Tools) {
        var ParcEdition;
        (function (ParcEdition) {
            ;
            ;
            function _getRequiredColumns(definition, additionalColumns) {
                let all = definition.columns.every(column => !column.qualifiers);
                let geometry = false;
                return definition.columns.filter((column) => {
                    return all || (!column.readOnly && column.qualifiers) || (!geometry && (geometry = Tools.Data.checkGeometryType(column, 7340032 /* AFC.Data.DataKind.geometry */))) || definition.primaryKey.some(name => name === column.name) || (additionalColumns && additionalColumns.some(name => name === column.name));
                });
            }
            function _getListOptions(columns, history, filters) {
                let parameters = {
                    dataSelector: {
                        "columns": columns.map(column => column.name),
                        "fromProperties": "code"
                    }
                };
                history && (parameters.dataSelector.history = history);
                filters && (parameters.filter = filters);
                return parameters;
            }
            function _check(value) {
                return value === void 0 ? null : value;
            }
            function _cast(column, value) {
                if (value) {
                    return column.type === 5 /* AFC.Data.DataKind.date */ || column.type === 6 /* AFC.Data.DataKind.time */ || column.type === 7 /* AFC.Data.DataKind.timestamp */ ? new Date(value) : value;
                }
                return _check(value);
            }
            function _castAll(columns, data) {
                let values = data.values;
                columns.forEach(column => values.hasOwnProperty(column.name) && (values[column.name] = _cast(column, values[column.name])));
                return data;
            }
            function _loadBranch(descriptor, history, definition, id) {
                return descriptor.getBranchInfo(id, history).then(base => {
                    let events = {}, branch = { ...base };
                    branch.events = events;
                    base.events.forEach((e) => {
                        switch (e.type) {
                            case 2 /* AFC.Data.HistoryEventType.creation */:
                                (events.creations || (events.creations = [])).push(_castAll(definition.columns, e.data));
                                break;
                            case 3 /* AFC.Data.HistoryEventType.modification */:
                                (events.modifications || (events.modifications = [])).push(_castAll(definition.columns, e.data));
                                break;
                            case 4 /* AFC.Data.HistoryEventType.deletion */:
                                (events.deletions || (events.deletions = [])).push(e.data.code);
                                break;
                        }
                    });
                    return branch;
                });
            }
            class Project extends Tools.EventSink {
                constructor(branchBase, descriptor, store, events, info) {
                    let code = branchBase.properties.code;
                    super();
                    this.info = info || { properties: branchBase.properties };
                    this.descriptor = descriptor;
                    this.id = branchBase.id;
                    this.author = branchBase.author;
                    this.creationDate = branchBase.creationDate;
                    this.name = branchBase.name || '';
                    this.info.description = branchBase.description;
                    this.info.rating = branchBase.rating;
                    this._status = branchBase.status;
                    this.key = code instanceof Array ? code : [code];
                    this.store = store;
                    this.events = events;
                    this.on(65536 /* Tools.EventType.UserEvent */, this._onChange, this);
                }
                _onChange(event) {
                    let data = event.data, i = data?.length, description = this.description, rating = this.rating, status = this.status, change = {
                        description: description,
                        rating: rating,
                        status: status
                    }, values = {};
                    if (i) {
                        for (; i > 0; --i) {
                            $.extend(change, data[i - 1]);
                        }
                        if (description !== change.description) {
                            (values || (values = {})).description = description;
                        }
                        if (rating !== change.rating) {
                            (values || (values = {})).rating = rating;
                        }
                        if (status !== change.status) {
                            (values || (values = {})).status = status;
                        }
                        values && (this.descriptor.updateBranch(this.id, values), this.fireEvent(6 /* Tools.EventType.Dirty */));
                    }
                }
                get description() {
                    return this.info.description ?? null;
                }
                set description(value) {
                    this.fireEvent(65536 /* Tools.EventType.UserEvent */, [{
                            description: this.description
                        }]);
                    this.info.description = value;
                }
                get rating() {
                    return this.info.rating ?? null;
                }
                set rating(value) {
                    this.fireEvent(65536 /* Tools.EventType.UserEvent */, [{
                            rating: this.rating
                        }]);
                    this.info.rating = value;
                }
                get status() {
                    return this._status ?? null;
                }
                set status(value) {
                    this.fireEvent(65536 /* Tools.EventType.UserEvent */, [{
                            status: this.status
                        }]);
                    this._status = value;
                }
            }
            const _bookmark = "{6E79B3B3-123C-47B4-B82B-6FD4FB872362}", _name = "{E306FF9A-BD19-4614-8E4B-3DD3EF14DD68}", _author = "{0B253F86-2C75-4072-B690-A1791640D254}", _creationDate = "{FDE7E448-D4E7-4A92-8A1F-C582D8011903}", _rating = "{C411CF83-8FDE-46D5-BB38-C8D73904048E}", _description = "{EC9D92ED-41FE-49F3-81EC-1AFA24A0999B}", _status = "{154C0554-937C-4f8f-AC5B-0A1A289B644C}";
            var DBColumnDefinition = AFC.Data.DBColumnDefinition;
            function _getProjetTableParameters(storeColumns) {
                let columns = [
                    (new DBColumnDefinition(_bookmark, 1 /* AFC.Data.DataKind.character */, 0, 38, "id", true)),
                    (new DBColumnDefinition(_name, 1 /* AFC.Data.DataKind.character */, -1, 255, "name", true)),
                    (new DBColumnDefinition(_author, 1 /* AFC.Data.DataKind.character */, -1, 255, "author", true)),
                    (new DBColumnDefinition(_creationDate, 6 /* AFC.Data.DataKind.time */, -1, 38, "creation date", true)),
                    (new DBColumnDefinition(_rating, 2 /* AFC.Data.DataKind.real */, -1, 4, "rating")),
                    (new DBColumnDefinition(_description, 1 /* AFC.Data.DataKind.character */, -1, 255, "description")),
                    (new DBColumnDefinition(_status, 3 /* AFC.Data.DataKind.integer */, -1, 4, "status"))
                ];
                let key = [], offset = columns.length, geometry = -1;
                storeColumns.forEach(column => {
                    if (column.index !== -1) {
                        column = new AFC.Data.DBColumnDefinition(column.name, column.type, -1, column.size, column.alias, true, column.qualifiers, column.geographicalLevel, column.isSearchable);
                        key.push(columns.length);
                    }
                    else if ((geometry === -1) && Tools.Data.checkGeometryType(column, 1048576 /* AFC.Data.DataKind.point */)) {
                        geometry = columns.length;
                    }
                    columns.push(column);
                });
                return {
                    key: key,
                    offset: offset,
                    columns: columns,
                    primaryKey: [_bookmark],
                    geometry: geometry
                };
            }
            function _mapBranches(columns, offset, geometry, branches) {
                let values = [], geometryName = columns[geometry].name;
                branches.forEach(branch => {
                    if (branch.properties && branch.properties.code && branch.values.length) {
                        let data = branch.values[0], column;
                        if (data && Tools.Data.isValid(1048576 /* AFC.Data.DataKind.point */, data[geometryName])) {
                            let row = [branch.id, _check(branch.name), _check(branch.author), _check(branch.creationDate), _check(branch.rating), _check(branch.description), _check(branch.status)];
                            for (let i = offset; i < columns.length; ++i)
                                row.push(_cast(column = columns[i], data[column.name]));
                            values.push(row);
                        }
                    }
                });
                return values;
            }
            const _key = Symbol();
            class Store extends AFC.Data.ReadonlyStore {
                constructor(provider, values) {
                    super(provider.content, values);
                    this[_key] = provider.key;
                }
                get key() {
                    return this[_key].map((index) => this._values[index]);
                }
            }
            ;
            class ReadonlyProjectInfo {
                _getValue(column) {
                    return this._values[this._provider.content.columnIndex[column]];
                }
                constructor(provider, values) {
                    this._provider = provider;
                    this._values = values;
                }
                get id() {
                    return this._getValue(_bookmark);
                }
                get name() {
                    return this._getValue(_name);
                }
                get author() {
                    return this._getValue(_author);
                }
                get creationDate() {
                    return this._getValue(_creationDate);
                }
                get rating() {
                    return this._getValue(_rating);
                }
                get description() {
                    return this._getValue(_description);
                }
                get status() {
                    return this._getValue(_status);
                }
                get key() {
                    return [this.id];
                }
                get store() {
                    return this._store || (this._store = new Store(this._provider, this._values));
                }
                async load() {
                    let descriptor = this._provider.descriptor, history = this._provider.history, definition = this._provider.content.definition, branch = await _loadBranch(descriptor, history, definition, this.id);
                    return new Project(branch, descriptor, this.store, branch.events);
                }
            }
            class ProjectInfo extends ReadonlyProjectInfo {
                _setValue(column, value) {
                    let key = this._provider.getKeyFromRow(this._values), values = {
                        [column]: value
                    };
                    return this._provider.modify(key, values);
                }
                get status() {
                    return super.status;
                }
                set status(value) {
                    this._setValue(_status, value);
                    this._provider.descriptor.updateBranch(this.id, { status: value });
                }
            }
            class ProjectsList extends AFC.Data.DataModel {
                _check(store, column, dirty, value, callback) {
                    return this.check ? this.check(this, store, column, dirty, value, callback) : callback(true);
                }
                constructor(refContent, storeColumns, branches) {
                    let parameters = _getProjetTableParameters(storeColumns), values, firstGeometry;
                    if (parameters.geometry !== -1) {
                        firstGeometry = parameters.geometry;
                        values = _mapBranches(parameters.columns, parameters.offset, firstGeometry, branches);
                    }
                    super(parameters.columns, parameters.primaryKey, values || []);
                    this._offset = parameters.offset;
                    this.descriptor = refContent.descriptor;
                    this.history = refContent.history;
                    this.content = {
                        definition: this,
                        columnIndex: this.columnIndex,
                        geometryIndice: firstGeometry,
                        resource: refContent.resource,
                        descriptor: refContent.descriptor,
                        history: refContent.history
                    };
                    this.parameters = {
                        check: this._check.bind(this)
                    };
                    this.key = parameters.key;
                }
                get length() {
                    return this.values.length;
                }
                getRow(indice) {
                    return this.values[indice];
                }
                get geometry() {
                    return this.content && this.content.definition.columns[this.content.geometryIndice];
                }
                hasQualifier(qualifier) {
                    return this.content && (AFC.Data.findQualifier(this.content, qualifier, true) !== -1);
                }
                getQualifiedColumn(qualifier) {
                    return this.content && this.content.definition.columns[AFC.Data.findQualifier(this.content, qualifier, true)];
                }
                get fullName() {
                    return this.content && this.content.descriptor.fullName;
                }
                item(index) {
                    return {
                        dataItem: this.getProjectFromRow(this.values[index]),
                        dataItemIndex: index
                    };
                }
                getProjectFromRow(row) {
                    return row && new ProjectInfo(this, row);
                }
            }
            ParcEdition.ProjectsList = ProjectsList;
            ;
            ProjectsList.prototype.create = null; // Not implemented
            ProjectsList.prototype.delete_ = null; // Not implemented
            function _getMetadata(dataSource) {
                return dataSource.getMetadata().then(content => content.descriptor.isHistoricized ? content : Promise.reject());
            }
            function listProjects(dataSource, filters, additionalColumns) {
                return _getMetadata(dataSource).then(content => {
                    let columns = _getRequiredColumns(content.definition, additionalColumns);
                    return content.descriptor.selectBranches(_getListOptions(columns, content.history, filters)).then(branches => new ProjectsList(content, columns, branches));
                });
            }
            ParcEdition.listProjects = listProjects;
            async function createProject(dataSource, store) {
                const check = new Promise((resolve, reject) => store.check(valid => {
                    let key = store.key, info = {
                        properties: {
                            code: key.length === 1 ? key[0] : key
                        }
                    };
                    if (valid) {
                        dataSource.createBranch(info)
                            .then(branch => AFC.Data.Store.commit(store, key, dataSource.parameters, () => resolve(branch)))
                            .catch(reject);
                    }
                    else {
                        reject();
                    }
                })), [base, content] = await Promise.all([check, _getMetadata(dataSource)]), project = new Project(base, content.descriptor, store, dataSource.generateEvents(), dataSource.branchInfo);
                return project;
            }
            ParcEdition.createProject = createProject;
            async function loadProject(dataSource, id, store) {
                const content = await _getMetadata(dataSource), branch = await _loadBranch(content.descriptor, content.history, content.definition, id);
                return branch && new Project(branch, content.descriptor, store, branch.events);
            }
            ParcEdition.loadProject = loadProject;
            async function cloneProject(dataSource, project) {
                const [base, content] = await Promise.all([dataSource.createBranch(project.info, project.events), _getMetadata(dataSource)]);
                return new Project(base, content.descriptor, dataSource.getStore(project.store.key), dataSource.generateEvents(), dataSource.branchInfo);
            }
            ParcEdition.cloneProject = cloneProject;
            class QueryParc extends AFC.Data.StoreSource {
                _load(content) {
                    if (this._command) {
                        let restModel = content.descriptor.database.schema.restModel;
                        let brand;
                        let command = {
                            commandText: this._command.commandText.replace(new RegExp(`\\B${QueryParc.tableToken}\\B`, 'g'), content.resource).replace(new RegExp(`\\B${QueryParc.brandToken}\\B`, 'g'), (substring, ...args) => {
                                if (brand === void 0) {
                                    brand = this.getQualifiedColumn(10 /* AFC.Data.Qualifier.brand */).name;
                                }
                                return brand;
                            })
                        };
                        this._command.maximumRows && (command.maximumRows = this._command.maximumRows);
                        this._command.parameters && (command.parameters = this._command.parameters);
                        return new AFC.Data.Queries(restModel).getDataTable([command]).then((queries) => queries[0]);
                    }
                }
                loadData(command, project) {
                    this._command = command;
                    return this.init(project);
                }
            }
            QueryParc.tableToken = '{{table}}';
            QueryParc.brandToken = '{{brand}}';
            ParcEdition.QueryParc = QueryParc;
            class ProjectTileProvider {
                constructor(content, parameters, columns) {
                    let descriptor = content.descriptor;
                    if (descriptor.isHistoricized) {
                        let definition = {
                            columns: parameters.columns,
                            primaryKey: parameters.primaryKey
                        };
                        this._offset = parameters.offset;
                        this._options = _getListOptions(columns, content.history, this._filter = {});
                        this.content = {
                            resource: null,
                            descriptor: descriptor,
                            definition: definition,
                            geometryIndice: parameters.geometry,
                            columnIndex: AFC.Data.getColumnIndex(definition.columns)
                        };
                        this.key = parameters.key;
                    }
                }
                /*
                        public set filters(value: AFC.Data.IDBHistoryBranchesFilter & {proximity: never}) {
                            not implemented yet
                        }
                */
                requestTiles(layer, tiles, callback) {
                    let bounds = layer.getBoundsFromKeys(tiles), center = bounds.getCenter(), refPoint = center.lat > 0 ? bounds.getSouthWest() : bounds.getNorthEast(); // roughly !
                    this._filter.proximity = {
                        location: [center.lng, center.lat],
                        distance: Math.ceil(center.distanceTo(refPoint))
                    };
                    this.content.descriptor.selectBranches(this._options).then((branches) => callback(tiles, _mapBranches(this.content.definition.columns, this._offset, this.content.geometryIndice, branches)));
                }
            }
            class ProjectTileVectorModel extends AFC.Data.readOnlyStoreSourceMixin((AFC.Globals.TileVectorModel)) {
                constructor(content, additionalColumns) {
                    const columns = _getRequiredColumns(content.definition, additionalColumns), parameters = _getProjetTableParameters(columns), provider = new ProjectTileProvider(content, parameters, columns), name = `{${AFC.Tools.Data.generateRndString(20)}}`;
                    super({
                        provider,
                        name,
                        geometryIndice: parameters.geometry,
                        columns: parameters.columns,
                        primaryKey: parameters.primaryKey,
                        content: provider.content
                    });
                    this.descriptor = content.descriptor;
                    this.history = content.history;
                    this.key = provider.key;
                }
                item(index) {
                    const row = this.getRow(index);
                    return row && {
                        dataItem: this.getProjectFromRow(row),
                        dataItemIndex: index
                    };
                }
                getProjectFromRow(row) {
                    return row && new ReadonlyProjectInfo(this, row);
                }
            }
            ParcEdition.ProjectTileVectorModel = ProjectTileVectorModel;
        })(ParcEdition = Tools.ParcEdition || (Tools.ParcEdition = {}));
    })(Tools = AFC.Tools || (AFC.Tools = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 18/09/2020.
 */
///<reference path="RestActivity.ts" />
///<reference path="ParcParameters.ts" />
///<reference path="../helpers/ParcEdition.ts" />
var AFC;
(function (AFC) {
    var Application;
    (function (Application) {
        const _resources = Symbol(), _loading = Symbol(), _storage = Symbol(), _session = Symbol(), _replacements = Symbol();
        let EventType;
        (function (EventType) {
            EventType[EventType["ResourceReady"] = 65536] = "ResourceReady";
        })(EventType || (EventType = {}));
        ;
        let ParcType;
        (function (ParcType) {
            ParcType[ParcType["dashboard"] = 1] = "dashboard";
            ParcType[ParcType["administrative"] = 2] = "administrative";
            ParcType[ParcType["query"] = 3] = "query";
        })(ParcType = Application.ParcType || (Application.ParcType = {}));
        const ParcFactory = {
            [1 /* ParcType.dashboard */]: Application.DashboardParc,
            [2 /* ParcType.administrative */]: Application.AdminParc,
            [3 /* ParcType.query */]: AFC.Tools.ParcEdition.QueryParc
        };
        ;
        async function _getInjections(dashboardActivity, replacements) {
            if (!replacements.sequence) {
                let rest = dashboardActivity.getRestModel(), sequence = replacements.sequence = Symbol(), replacementTable = await AFC.Tools.Data.normalizeSQLName(rest.schema, 'CATALOG_APP_INJECTION');
                if (replacementTable) {
                    let [dataTable] = await (new AFC.Data.Queries(rest, null)).getDataTable([{
                            commandText: `SELECT * FROM ${replacementTable}`
                        }]) || [];
                    if (dataTable && replacements.sequence === sequence) {
                        let modifiers = replacements.modifiers, values = dataTable.values, target, table;
                        if (values &&
                            values[0] &&
                            ((target = dataTable.columns.findIndex(column => column.name === 'TARGET')) !== -1) &&
                            ((table = dataTable.columns.findIndex(column => column.name === 'SQL_NAME')) !== -1)) {
                            let invalidate = false, dict0 = modifiers ? modifiers.reduce((acc, item) => (acc[item.reference] = item, acc), {}) : {}, dict1 = {};
                            replacements.modifiers = values.map(row => {
                                let reference = row[target], replacement = row[table], modifier = dict0[reference];
                                if (!modifier || modifier.replacement !== replacement) {
                                    (modifier || rest.pushModifier(modifier = new AFC.Rest.ContextSubstitute(reference))).replacement = replacement;
                                    invalidate = true;
                                }
                                dict1[modifier.reference] = modifier;
                                return modifier;
                            });
                            if (modifiers) {
                                modifiers.forEach(modifier => dict1[modifier.reference] || (invalidate = true, rest.popModifier(modifier)));
                                if (invalidate) {
                                    await dashboardActivity.invalidateStaticLayers();
                                }
                            }
                        }
                    }
                }
            }
            return replacements;
        }
        class HistorizedModelRemote {
            constructor(activity, remote) {
                this.activity = activity;
                this.remote = remote;
            }
            async confirmUpdate(result) {
                return this.remote?.confirmUpdate ? this.remote.confirmUpdate(result) : true;
            }
            onUpdate(results, force) {
                let modifiers = results && this.activity[_replacements]?.modifiers, invalidates = modifiers && results.reduce((acc, result) => {
                    let items = result?.invalidate;
                    return items ? items.reduce((acc, item) => (acc[item.reference] = item.replacement, acc), acc) : acc;
                }, {}), updates = invalidates && Object.entries(invalidates).reduce((acc, [key, value]) => {
                    let item = modifiers.find(item => item.reference === key);
                    if (item && item.replacement !== value) {
                        item.replacement = value;
                        acc.push(item);
                    }
                    return acc;
                }, []);
                updates?.length && this.activity.invalidateStaticLayers();
                this.remote?.onUpdate(results, force, updates);
            }
        }
        class DashboardActivity extends Application.RestActivity {
            constructor() {
                super(...arguments);
                this._sink = new AFC.Tools.EventSink(this);
            }
            async refreshStamps() {
                delete this[_session];
                this[_resources] && this[_resources].forEach(resource => resource.refreshStamps());
                let databases = await this.getRestModel().schema.getDatabases();
                databases && databases.forEach(database => database.noCache && database.refresh());
                let replacements = this[_replacements];
                if (replacements) {
                    delete replacements.sequence;
                }
            }
            getSession() {
                return this[_session] || (this[_session] = AFC.Tools.Data.generateRndString(32));
            }
            getHistorizedTableResources() {
                return this[_resources] ? Promise.resolve(this[_resources]) : new Promise(resolve => {
                    this._sink.notify(65536 /* EventType.ResourceReady */, ( /*event: Tools.IEvent*/) => resolve(this[_resources]));
                    if (!this[_loading]) {
                        let restModel = this.getRestModel(), resources = [];
                        this[_loading] = true;
                        restModel.schema.getDatabases()
                            .then(databases => Promise.all(databases.map(database => database.getTables().then(tables => tables.forEach(table => {
                            if (table.isHistoricized && (table.type !== 8 /* AFC.Data.TableType.seamless */)) {
                                let resource = AFC.Data.tableResource(this);
                                resource.reset(restModel, database.name, table.name);
                                resources.push(resource);
                                resources[table.fullName.toLowerCase()] = resource;
                            }
                        })))))
                            .then(() => {
                            this[_resources] = resources;
                            this._sink.fireEvent(65536 /* EventType.ResourceReady */);
                        });
                    }
                });
            }
            async loadHistory() {
                let resources = await this.getHistorizedTableResources();
                return Promise.all([...resources.map(resource => resource.load()), _getInjections(this, this[_replacements] || (this[_replacements] = {}))]);
            }
            async getStoreSource(dbName, name, parcType, remote) {
                let resources = await this.getHistorizedTableResources(), resource = resources[AFC.Tools.Data.makeSQLName(dbName, name).toLowerCase()], source, rest = this.getRestModel();
                if (!resource) {
                    resource = AFC.Data.tableResource(this);
                    resource.reset(rest, dbName, name);
                }
                source = new (ParcFactory[parcType])(resource, new HistorizedModelRemote(this, remote));
                await Promise.all([source.getMetadata(), this.loadHistory()]);
                return source;
            }
            async invalidateStaticLayers() {
                let mapViews = await this.getRestModel().globals.getMapViews();
                return Promise.all(mapViews.map(mapView => mapView.getMetadata().then(mapView => mapView.layers.forEach(layer => layer.invalidate()))));
            }
            async _pushContextModifiers(dashboard, storeSource, context) {
                new AFC.Tools.Dashboards.StoreSourceLoader(dashboard, storeSource);
            }
            async getDashboards(descriptors, storeSource, store, project, context) {
                let dashboards = await Promise.all(descriptors.map(descriptor => descriptor && AFC.Dashboards.dashboard(descriptor, project?.id))), name = storeSource.fullName, filtered = dashboards.filter(dashboard => {
                    let sitesTable;
                    return dashboard.zones.some(zone => (dashboard.mainCluster === zone.cluster) && (sitesTable = zone.reference.sitesTable) && !name.localeCompare(sitesTable.table, undefined, { sensitivity: 'accent' })) && (AFC.Tools.Dashboards.setClusterSite(dashboard.mainCluster, store), true);
                });
                return filtered.length ? Promise.all(filtered.map(dashboard => this._pushContextModifiers(dashboard, storeSource, context))).then(() => dashboards) : dashboards;
            }
            getDataStorage() {
                return this[_storage] || (this[_storage] = new AFC.Application.Storage(this.getRestModel().baseUrl));
            }
        }
        Application.DashboardActivity = DashboardActivity;
    })(Application = AFC.Application || (AFC.Application = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 17/05/2019.
 */
///<reference path="../gui/Globals.ts" /> 
var AFC;
(function (AFC) {
    var Application;
    (function (Application) {
        class DataGrabber extends AFC.Tools.EventSink {
            constructor(method = 'GET', async = true, dataType = 'json') {
                super();
                this.method = method;
                this.async = async;
                this.dataType = dataType;
            }
            _onAlways(key, jqXHR, textStatus) {
                let dataTable = AFC.Data.updateTableData(jqXHR.responseJSON);
                this._cache[key] = dataTable?.columns && dataTable.values ? new AFC.Data.DataModel(dataTable.columns, dataTable.primaryKey, dataTable.values) : null;
                Application.HideWaitBar();
                this.fireEvent(65536 /* Tools.EventType.UserEvent */);
            }
            getData(url, body) {
                let key = CryptoJS.SHA1(url + JSON.stringify(body)).toString(CryptoJS.enc.Base64), cache = this._cache || (this._cache = {});
                return cache[key] !== void 0 ? Promise.resolve(cache[key]) : new Promise((resolve) => {
                    this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this._cache[key]));
                    if (!cache.hasOwnProperty(key)) {
                        let options = {
                            data: body,
                            method: this.method,
                            dataType: this.dataType,
                            complete: this._onAlways.bind(this, key)
                        };
                        Application.ShowWaitBar();
                        this._cache[key] = void 0;
                        jQuery.ajax(url, options);
                    }
                });
            }
        }
        Application.DataGrabber = DataGrabber;
    })(Application = AFC.Application || (AFC.Application = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 21/02/2020.
 */
///<reference path="Fragment.ts" /> 
var AFC;
(function (AFC) {
    var Application;
    (function (Application) {
        var _a;
        const _showsDialog = Symbol(), _dialog = Symbol();
        class DialogFragment extends Application.Fragment {
            constructor() {
                super(...arguments);
                /** @internal */
                this[_a] = true;
                //void onCancel (DialogInterface dialog)
            }
            onCreate(savedInstanceState) {
                super.onCreate(savedInstanceState);
                this[_showsDialog] = !this.containerId;
            }
            getLayoutInflater(savedInstanceState) {
                if (this[_showsDialog]) {
                    this[_dialog] = this.onCreateDialog(savedInstanceState);
                    return this.getActivity().getLayoutInflater();
                }
                return super.getLayoutInflater(savedInstanceState);
            }
            onCreateDialog(savedInstanceState) {
                return new AFC.Controls.Dialog(this.getActivity());
            }
            onSaveInstanceState(outState) {
                let dialog, dialogState;
                super.onSaveInstanceState(outState);
                if ((dialog = this[_dialog]) !== null) {
                    dialogState = dialog.onSaveInstanceState();
                    if (dialogState != null) {
                        outState.putBundle('SAVED_DIALOG_STATE_TAG', dialogState);
                    }
                }
            }
            onActivityCreated(savedInstanceState) {
                super.onActivityCreated(savedInstanceState);
                if (!this[_showsDialog]) {
                    return;
                }
                let view = this.getView(), dialog = this[_dialog];
                dialog.setOnDismissListener(this);
                if (view != null) {
                    dialog.setContentView(view);
                }
                dialog.setOwnerActivity(this.getActivity());
                /*dialog.setCancelable(mCancelable);
                dialog.setOnCancelListener(this);
                dialog.setOnDismissListener(this);*/
                if (savedInstanceState != null) {
                    let dialogState = savedInstanceState.getBundle('SAVED_DIALOG_STATE_TAG');
                    if (dialogState != null) {
                        dialog.onRestoreInstanceState(dialogState);
                    }
                }
            }
            onDestroyView() {
                if (this[_dialog] != null) {
                    this[_dialog].dismiss();
                    this[_dialog] = null;
                }
                super.onDestroyView();
            }
            show(fragmentManager, tag) {
                fragmentManager.attachView(null, this, tag);
                this[_dialog] && this[_dialog].show();
            }
            dismiss() {
                if (this[_dialog] != null) {
                    this[_dialog].dismiss();
                    this[_dialog] = null;
                }
                Application.FragmentManager.detachView(this);
            }
            onViewStateRestored(savedInstanceState) {
                super.onViewStateRestored(savedInstanceState);
                if (this[_dialog] != null) {
                    this[_dialog].show();
                }
            }
            onDismiss(dialog) {
                // dialog has been dismissed
                this[_dialog] = null;
                this.dismiss();
            }
        }
        _a = _showsDialog;
        Application.DialogFragment = DialogFragment;
    })(Application = AFC.Application || (AFC.Application = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 18/09/2020.
 */
var AFC;
(function (AFC) {
    var Application;
    (function (Application) {
        class Inflater {
            inflate(resource, root) {
                let div = new AFC.gui.AfcGuiDiv();
                div.innerHTML = resource;
                div.className = 'InflatedFragment';
                return div;
            }
        }
        Application.Inflater = Inflater;
    })(Application = AFC.Application || (AFC.Application = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 18/09/2020.
 */
///<reference path="../gui/Globals.ts" /> 
var AFC;
(function (AFC) {
    var Application;
    (function (Application) {
        class Storage {
            constructor(key) {
                this.key = key;
            }
            setItem(key, value) {
                AFC.Tools.Storage.setItem(this.key + '.' + key, value);
            }
            getItem(key) {
                return AFC.Tools.Storage.getItem(this.key + '.' + key);
            }
        }
        Application.Storage = Storage;
    })(Application = AFC.Application || (AFC.Application = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 14/05/2019.
 */
///<reference path="../gui/Globals.ts" /> 
var AFC;
(function (AFC) {
    var Application;
    (function (Application) {
        let _mru;
        const _id = 'E8F463C8-5ECE-494A-8F18';
        function _checkLength() {
            let maxElement = BrandSelectorConfiguration.mruMaxElement;
            (_mru.length > maxElement) && (_mru.length = maxElement);
        }
        function _getOrder(ref) {
            let order = ref ? Object.create(ref) : {};
            _mru.forEach((brand, indice) => {
                order[brand] = indice - 0x7FFFFFFF;
            });
            return order;
        }
        class BrandSelectorConfiguration {
            _getOrder() {
                return this._order || (this._order = _getOrder(this._ref));
            }
            constructor(order) {
                this.filterEnabled = true;
                this.template = '<span style="background-color: {{color}};"><input id="brands_{{value}}" type="radio" name="brands" value="{{value}}"><label for="brands_{{value}}" style="background-image: url(\'{{image}}\');" name="{{label}}"></label></span>';
                (_mru || (_mru = AFC.Tools.Storage.getItem(_id) || []));
                this.filterEnabled = true;
                this._ref = order;
                _checkLength();
                return this;
            }
            compare(brand0, brand1) {
                let order = this._getOrder();
                return (order[brand0] || 0xFFFFFFFF) - (order[brand1] || 0xFFFFFFFF);
            }
            map(symbolFactory, brand, businessCode, indice) {
                return {
                    value: indice,
                    label: brand,
                    image: _getSymbol(symbolFactory, brand, businessCode),
                    color: this._getOrder().hasOwnProperty(brand) ? '#FAFADE' : 'transparent'
                };
            }
            filter(regExps, brand) {
                return !regExps || regExps.every(regex => brand.match(regex));
            }
            onClick(brand, image) {
                let i;
                if ((i = _mru.indexOf(brand)) !== 0) {
                    if (i !== -1) {
                        _mru.splice(i, 1);
                    }
                    _mru.unshift(brand);
                    _checkLength();
                    AFC.Tools.Storage.setItem(_id, _mru);
                    delete this._order;
                }
            }
        }
        BrandSelectorConfiguration.mruMaxElement = 5;
        Application.BrandSelectorConfiguration = BrandSelectorConfiguration;
        function _getSymbolBase(symbolFactory, symbol) {
            let img;
            return (symbolFactory && symbol && (img = symbolFactory.symbol(symbol)) && img.url) || AFC.Tools.Style.transparent1Pixel;
        }
        function _getBusinessCode(symbols, businessCode) {
            let key = businessCode;
            if (symbols && !symbols[key]) {
                for (key in symbols) {
                    break;
                }
            }
            return key;
        }
        function _getSymbol(symbolFactory, brand, businessCode) {
            let symbols = symbolFactory && symbolFactory.symbols(brand), symbol = symbols && symbols[_getBusinessCode(symbols, businessCode)];
            return _getSymbolBase(symbolFactory, symbol);
        }
        function _equalValue(value0, value1) {
            return (value0 === value1) || (value0 && value1 && (value0.brand === value1.brand) && (value0.symbol === value1.symbol));
        }
        function _updateBrandsControl(control, brands, symbolFactory, selected, configuration, maxItem, pattern) {
            let localCompare = function (reference0, value1) {
                return (configuration.compare && configuration.compare(reference0.brand, value1.brand)) || (reference0.value - value1.value) || (reference0.indice - value1.indice);
            };
            let regExps = pattern && (pattern.split(' ').map(function (word) {
                return new RegExp(`\\b${word}`, 'i');
            }));
            let references = [];
            let found, input;
            maxItem = Math.min(maxItem, brands.length);
            brands.forEach((brand, value) => {
                if (brand && configuration.filter(regExps, brand)) {
                    let symbols = symbolFactory.symbols(brand), businessCode, image, dict = {}, reference, i, indice = 0;
                    for (businessCode in symbols) {
                        reference = {
                            value: value,
                            indice: indice,
                            brand: brand,
                            businessCode: businessCode
                        };
                        if (i === void 0) {
                            i = AFC.Tools.lower_bound(references, reference, localCompare);
                        }
                        if (i >= maxItem) {
                            break;
                        }
                        image = symbols[businessCode];
                        if (!dict[image]) {
                            dict[image] = true;
                            reference.symbol = image;
                            if (i < references.length) {
                                if (i < maxItem) {
                                    references.splice(i, 0, reference);
                                }
                                (references.length > maxItem) && references.pop();
                            }
                            else {
                                references.push(reference);
                            }
                            ++i;
                            ++indice;
                        }
                    }
                }
            });
            references.forEach((reference, i) => {
                control.addItem(configuration.map(symbolFactory, reference.brand, reference.businessCode, i));
                _equalValue(reference, selected) && (found = i);
            });
            (found !== void 0) && (input = control.node.querySelector(`#brands_${found}`)) && (input.checked = true);
            return references;
        }
        function _setImage(control, symbol, symbolFactory) {
            control.style.backgroundImage = `url('${_getSymbolBase(symbolFactory, symbol)}')`;
        }
        const _value = Symbol();
        class AfcBrand extends HTMLElement {
            get value() {
                return this[_value];
            }
            set value(value) {
                if (this[_value] !== value) {
                    this[_value] = value;
                    this.connectedCallback();
                }
            }
            connectedCallback() {
                let value = this[_value];
                $(this).empty();
                (value !== void 0) && (value !== null) && this.appendChild(document.createTextNode(value));
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                this.value = newVal;
            }
        }
        AfcBrand.observedAttributes = ['value'];
        Application.AfcBrand = AfcBrand;
        const _symbols = Symbol();
        class AfcSymbol extends AFC.gui.AfcGuiElement {
            get symbols() {
                return this[_symbols];
            }
            set symbols(value) {
                _setImage(this, this[_value], this[_symbols] = value);
            }
            get value() {
                return this[_value];
            }
            set value(value) {
                (this[_value] !== value) && _setImage(this, this[_value] = value, this[_symbols]);
            }
            connectedCallback() {
                let form = $(this).closest('afc-gui-store-form');
                form.length && _setImage(this, this[_value], this[_symbols]);
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                (attrName === 'value') ? this.value = newVal : super.attributeChangedCallback(attrName, oldVal, newVal);
            }
        }
        AfcSymbol.observedAttributes = AFC.gui.AfcGuiElement.observedAttributes.concat(['value']);
        Application.AfcSymbol = AfcSymbol;
        function _setContent(selector, value) {
            let text = value == null ? '' : value;
            $(selector).empty().append(document.createTextNode(text));
        }
        const _onClick = Symbol(), _change = Symbol(), _onKeyDown = Symbol(), _onMouseLeave = Symbol(), _onChange = Symbol(), _dispatch = Symbol();
        class AfcBusinessCodeSelector extends AFC.gui.AfcGuiElement {
            /** @internal */
            [_onClick]( /*event: MouseEvent*/) {
                let options = this.options, value;
                if (options && options.length) {
                    value = this.options[(options.indexOf(this.value) + 1) % options.length];
                    (this.value !== value) && AFC.gui._dispatchEvent(this, 'change', { detail: this.value = value });
                }
            }
            ;
            constructor() {
                super();
                this.addEventListener('click', this[_onClick].bind(this), true);
            }
            get value() {
                return this[_value];
            }
            set value(value) {
                (this[_value] !== value) && _setContent(this, this[_value] = value);
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                (attrName === 'value') ? this.value = newVal : super.attributeChangedCallback(attrName, oldVal, newVal);
            }
        }
        AfcBusinessCodeSelector.observedAttributes = AFC.gui.AfcGuiElement.observedAttributes.concat(['value']);
        Application.AfcBusinessCodeSelector = AfcBusinessCodeSelector;
        const _configuration = Symbol(), _timeout = Symbol(), _control = Symbol(), _connected = Symbol(), _container = Symbol(), _filter = Symbol(), _setFilter = Symbol(), _items = Symbol(), _selected = Symbol(), _form = Symbol(), _onFormClickHandler = Symbol(), _refresh = Symbol(), _generateFilter = Symbol(), _onFormClick = Symbol(), _refreshBrands = Symbol(), _visible = Symbol();
        function _getItem(selector, input) {
            return input.value && selector[_items] && selector[_items][parseInt(input.value)];
        }
        class AfcBrandSelector extends AFC.gui.AfcGuiElement {
            /** @internal */
            [_onChange](event) {
                let label = event.target, input, hover;
                if (label.htmlFor && (input = this.querySelector(`input#${label.htmlFor}`)) && (hover = _getItem(this, input))) {
                    AFC.gui._dispatchEvent(this, 'hover-change', { detail: hover });
                }
            }
            /** @internal */
            [_onMouseLeave]( /*event: MouseEvent*/) {
                AFC.gui._dispatchEvent(this, 'hover-change');
            }
            /** @internal */
            [_onClick](event) {
                let input = event.target, clicked, toggle;
                if (input.getAttribute && (input.getAttribute('name') === 'brands') && (clicked = _getItem(this, input))) {
                    if ((toggle = this.getAttribute('toggle')) && (document.getElementById(toggle))) {
                        $(this).hide();
                    }
                    if (!_equalValue(clicked, this[_selected])) {
                        this.getConfiguration().onClick(clicked.brand, clicked.symbol);
                        AFC.gui._dispatchEvent(this, 'change', { detail: this.selected = clicked });
                    }
                }
            }
            /** @internal */
            [_refreshBrands]() {
                let control = this[_control], symbolFactory = this[_symbols], pattern = this[_generateFilter](), brands, configuration;
                if (control && symbolFactory && (brands = symbolFactory.brands) && (configuration = this.getConfiguration())) {
                    control.setTemplate(configuration.template);
                    (this[_setFilter] = (pattern) => {
                        let labels, mouseenter;
                        control.empty();
                        this[_items] = _updateBrandsControl(control, brands, symbolFactory, this[_selected], configuration, this.maxItem, pattern);
                        labels = control.node.querySelectorAll('LABEL');
                        for (let i = 0; i < labels.length; ++i) {
                            labels[i].onmouseenter = mouseenter || (mouseenter = this[_onChange].bind(this));
                        }
                    })(pattern);
                }
            }
            /** @internal */
            [_onKeyDown](event) {
                let target = event.target;
                if (target.getAttribute && target.getAttribute('name') === 'filter') {
                    let setFilter = this[_setFilter];
                    (this[_timeout] !== void 0) && clearTimeout(this[_timeout]);
                    setFilter && (this[_timeout] = setTimeout(() => {
                        delete this[_timeout];
                        setFilter(target.value);
                    }, 500));
                }
            }
            /** @internal */
            [_refresh]() {
                if (this.disabled) {
                    $(this).hide();
                }
                else if (this[_connected]) {
                    this[_refreshBrands]();
                }
            }
            /** @internal */
            [_generateFilter]() {
                let str, filter = this[_filter], input;
                if (this[_container]) {
                    if (this.getConfiguration().filterEnabled) {
                        if (filter) {
                            input = filter.querySelector('input');
                        }
                        else {
                            (input = (this[_filter] = this[_container].appendChild(document.createElement('div'))).appendChild(document.createElement('input'))).type = "text";
                            input.placeholder = "Filtrer les enseignes ...";
                            input.setAttribute('name', 'filter');
                        }
                        str = input.value;
                    }
                    else if (filter) {
                        this[_container].removeChild(filter);
                        delete this[_filter];
                    }
                }
                return str;
            }
            /** @internal */
            [_onFormClick](event) {
                let target = event.target;
                if (!this.disabled && target.id === this.getAttribute('toggle')) {
                    let query = $(this);
                    (this[_visible] = !query.is(':visible')) ? query.show() : query.hide();
                }
            }
            constructor() {
                super();
                this.addEventListener('click', this[_onClick].bind(this), true);
                this.addEventListener('keydown', this[_onKeyDown].bind(this));
                this.addEventListener('mouseleave', this[_onMouseLeave].bind(this));
                this.addEventListener('change', this[_onChange].bind(this));
                this.maxItem = 10;
            }
            getConfiguration() {
                return this[_configuration] || (this[_configuration] = new BrandSelectorConfiguration());
            }
            setConfiguration(value) {
                this[_configuration] = value;
                this[_refresh]();
            }
            get symbols() {
                return this[_symbols];
            }
            set symbols(value) {
                this[_symbols] = value;
                this[_refresh]();
            }
            get selected() {
                return this[_selected];
            }
            set selected(value) {
                if (!_equalValue(value, this[_selected])) {
                    this[_selected] = value;
                    this[_refresh]();
                }
            }
            connectedCallback() {
                let form = $(this).closest('afc-gui-store-form');
                this[_connected] = true;
                if (!this[_container]) {
                    this[_container] = this.appendChild(document.createElement('div'));
                    this[_control] = new AFC.Controls.Repeater(this[_container].appendChild(document.createElement('span')));
                }
                if (form.length && (this[_form] = form[0])) {
                    this[_refresh]();
                    this[_form].addEventListener('click', this[_onFormClickHandler] = this[_onFormClick].bind(this));
                }
            }
            disconnectedCallback() {
                this[_onFormClickHandler] && this[_form].removeEventListener('click', this[_onFormClickHandler]);
                delete this[_onFormClickHandler];
                this[_connected] = false;
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                switch (attrName) {
                    case 'disabled':
                        this.disabled = newVal !== null;
                        this[_refresh]();
                        break;
                    case 'max-item':
                        isNaN(this.maxItem = parseInt(newVal)) && (this.maxItem = 10);
                        this[_refresh]();
                        break;
                    default:
                        super.attributeChangedCallback(attrName, oldVal, newVal);
                        break;
                }
            }
            setVisibility(show) {
                (this[_visible] = show) ? $(this).show() : $(this).hide();
            }
        }
        AfcBrandSelector.observedAttributes = AFC.gui.AfcGuiElement.observedAttributes.concat(['max-item', 'disabled']);
        Application.AfcBrandSelector = AfcBrandSelector;
        function _getSafeName(template) {
            let s = template.getAttribute('name');
            return s === null ? "" : s;
        }
        const _casts = {
            [2 /* Data.DataKind.real */]: AFC.Tools.Data.toFloat,
            [3 /* Data.DataKind.integer */]: AFC.Tools.Data.toInteger,
            [4 /* Data.DataKind.bool */]: AFC.Tools.Data.toBoolean,
            [5 /* Data.DataKind.date */]: (value) => new Date(value + "T00:00")
        };
        function _getInputForQualifier(form, store, qualifier) {
            let name = AFC.Data.qualifier(qualifier), id = form.getAttribute(name), column;
            return id !== null ?
                document.getElementById(id) :
                form.querySelector(`[bind="qualifier"][name="${name}"]`) || (store && (column = store.getQualifiedColumn(qualifier)) && form.querySelector(`[bind="column"][name="${column.name}"]`));
        }
        function _updateInputValue(form, update, store, qualifier, value, input = _getInputForQualifier(form, store, qualifier)) {
            if (input) {
                let ret = value !== input.value;
                if (ret) {
                    input.value = value;
                }
                update && form[_change](input);
                return ret;
            }
        }
        function _updateBrandSelector(form, brand, symbol_) {
            let selector = form.querySelector('afc-gui-brand-selector');
            selector && (selector.selected = {
                brand: brand,
                symbol: symbol_
            });
        }
        function _updateBusinessCodeControl(businessCodeControl, symbols) {
            let options = [];
            for (let option in symbols) {
                options.push(option);
            }
            businessCodeControl.options = options;
            options.length > 1 ? $(businessCodeControl).show() : $(businessCodeControl).hide();
        }
        function _tryCast(column, value) {
            let cast, ret;
            return value === '' || value === null ?
                ret = null : (cast = _casts[column.type],
                ret = cast && cast(value),
                ret === void 0 ? value : ret);
        }
        function _setData(store, input, column, rootForm) {
            if (input.tagName !== 'LABEL') {
                let value, ret;
                if (store.setData) {
                    switch (input.type) {
                        case 'radio':
                            let name = input.getAttribute('name'), selector = `input[type='radio'][name='${name}']:checked`, val = rootForm ? $(rootForm).find(selector).val() : $(selector).val();
                            value = val === void 0 ? null : val;
                            break;
                        case 'checkbox':
                            value = input.checked;
                            break;
                        default:
                            value = input.value;
                            break;
                    }
                    ret = store.setData(column.name, _tryCast(column, value));
                }
                return ret;
            }
        }
        function _getData(store, input, column, rootForm) {
            let value = store.getData(column.name);
            if (input.tagName === 'LABEL') {
                let str = value === null ? ' - ' : (AFC.Tools.Data.isNumber(value) ? new Intl.NumberFormat().format(value) : value), query = $(input);
                query.empty().append(document.createTextNode(str));
            }
            else {
                switch (input.type) {
                    case 'radio':
                        let name = input.getAttribute('name'), selector = `input[type='radio'][name='${name}']`, radios = rootForm ? $(rootForm).find(selector) : $(selector);
                        radios.prop('checked', function () { return _tryCast(column, this.value) === value; });
                        break;
                    case 'checkbox':
                        input.checked = !!value;
                        break;
                    case 'date':
                        {
                            if (!value)
                                input.value = value;
                            else {
                                if (column.type === 5 /* Data.DataKind.date */) {
                                    input.value = `${value.getFullYear()}-${('0' + (value.getMonth() + 1)).slice(-2)}-${('0' + (value.getDate() + 1)).slice(-2)}`;
                                }
                                else {
                                    let offset = value.getTimezoneOffset(), date = new Date(value.getTime() + (offset * 60000));
                                    input.value = date.toISOString().split('T')[0];
                                }
                            }
                        }
                        break;
                    default:
                        input.value = value;
                        break;
                }
            }
        }
        const _forEach = Symbol(), _on = Symbol(), _off = Symbol(), _store = Symbol(), _onDirty = Symbol(), _template = Symbol(), _oldTemplate = Symbol(), _templates = Symbol(), _dataChange = Symbol(), _detail = Symbol(), _onHover = Symbol(), _updateControls = Symbol();
        class AfcStoreForm extends AFC.gui.AfcGuiElement {
            _onRestoreViewState(activity, fragmentManager, savedInstanceState) {
                if (activity.getRestModel) {
                    let rest = activity.getRestModel();
                    rest && rest.globals.getSymbolFactory().then(symbolFactory => {
                        let store;
                        (this[_symbols] = symbolFactory) && (store = this[_store]) && this[_refresh](store);
                    });
                }
                super._onRestoreViewState(activity, fragmentManager, savedInstanceState);
            }
            /** @internal */
            [_refresh](store) {
                if (this[_timeout] === void 0) {
                    this[_timeout] = setTimeout(() => {
                        let symbolFactory = this[_symbols], symbols, brand = store.brand, symbol_, selector, id, key, templates, businessCodeControl;
                        delete this[_timeout];
                        if (this[_oldTemplate] !== void 0) {
                            let nodes = this.querySelectorAll(`[data-template="${this[_oldTemplate]}"]`), node;
                            for (let i = 0; i < nodes.length; ++i) {
                                (node = nodes[i]).parentNode.removeChild(node);
                            }
                            delete this[_oldTemplate];
                        }
                        if (store) {
                            key = this[_template] || '';
                            if (this[_templates] && (templates = this[_templates][key])) {
                                templates.forEach(template => {
                                    let fragment = document.createDocumentFragment();
                                    AFC.Controls.Repeater.generateContent(fragment, key, template, store);
                                    $(fragment).children().attr('data-template', key);
                                    template.parentNode.insertBefore(fragment, template.refNode);
                                });
                                this[_oldTemplate] = key;
                            }
                            if (symbolFactory) {
                                (businessCodeControl = _getInputForQualifier(this, store, 11 /* AFC.Data.Qualifier.businessCode */)) && (symbols = symbolFactory.symbols(brand)) && _updateBusinessCodeControl(businessCodeControl, symbols);
                                _updateBrandSelector(this, brand, store.symbol);
                                (symbol_ = this.querySelector('afc-gui-symbol')) && (symbol_.symbols = symbolFactory);
                            }
                            this[_forEach](store, _getData);
                            if (symbolFactory)
                                (selector = this.querySelector('afc-gui-brand-selector')) && (selector.symbols = symbolFactory);
                            selector && (selector[_visible] === void 0) && (id = selector.getAttribute('toggle')) && document.getElementById(id) && selector.setVisibility(!store.brand);
                            this.dispatchEvent(new CustomEvent('draw', { bubbles: false, detail: store }));
                        }
                    }, 0);
                }
            }
            /** @internal */
            [_forEach](store, onColumn) {
                let inputs = this.querySelectorAll('*[bind]');
                let i, column;
                for (i = 0; i < inputs.length; ++i) {
                    (column = this._getColumnForInput(store, inputs[i])) && onColumn(store, inputs[i], column, this);
                }
            }
            /** @internal */
            [_on]() {
                this[_store] && this[_store].on && this[_store].on(6 /* AFC.Tools.EventType.Dirty */, this[_onDirty], this);
            }
            /** @internal */
            [_off]() {
                this[_store] && this[_store].off && this[_store].off(6 /* AFC.Tools.EventType.Dirty */, this[_onDirty], this);
            }
            /** @internal */
            [_onDirty](event) {
                let index = {}, store = this[_store];
                let _this = this;
                this[_forEach](store, (store, input, column) => {
                    index[column.name] = input;
                });
                event.data.columns.forEach(function (column) {
                    let input = index[column.name];
                    input && _getData(store, index[column.name], column, _this);
                });
            }
            /** @internal */
            [_onClick](event) {
                let target = event.target;
                if (target.getAttribute && (target.getAttribute('name') === 'submit')) {
                    event.stopPropagation();
                    this.submit();
                }
            }
            /** @internal */
            [_dispatch](column) {
                let detail = this[_detail];
                if (!detail) {
                    this[_detail] = detail = [];
                    setTimeout(() => {
                        delete this[_detail];
                        this.dispatchEvent(new CustomEvent("dataChange", { bubbles: false, cancelable: false, detail: detail }));
                    }, 0);
                }
                detail.push(column);
                return true;
            }
            /** @internal */
            [_change](input) {
                let column = this._getColumnForInput(this.store, input);
                return column && _setData(this.store, input, column, this) && this[_dispatch](column);
            }
            _getColumnForInput(store, input) {
                let name, bind, qualifier, column;
                if ((name = input.getAttribute('name')) && (bind = input.getAttribute('bind'))) {
                    switch (bind.toLowerCase()) {
                        case 'column':
                            column = store.getColumn(name);
                            break;
                        case 'qualifier':
                            ((qualifier = AFC.Data.qualifier(name)) !== void 0) && (column = store.getQualifiedColumn(qualifier));
                            break;
                    }
                }
                return column;
            }
            getColumnForInput(input) {
                return this._getColumnForInput(this.store, input);
            }
            setStoreValue(column, value, fireEvent) {
                let store = this.store, cast;
                if (store && store.setData && (cast = _casts[column.type])) {
                    return store.setData(column.name, value ? cast(value) : null) && (!fireEvent || this[_dispatch](column));
                }
            }
            /** @internal */
            [_updateControls](update, brand, symbol_, businessCode, businessCodeControl) {
                let store, symbols, brandControl;
                if (brand === void 0) {
                    brand = (brandControl = _getInputForQualifier(this, store, 10 /* AFC.Data.Qualifier.brand */)) && brandControl.value;
                }
                if (brand && (store = this.store) && (symbols = this[_symbols].symbols(brand))) {
                    businessCodeControl || (businessCodeControl = _getInputForQualifier(this, store, 11 /* AFC.Data.Qualifier.businessCode */));
                    businessCode || (businessCode = businessCodeControl && businessCodeControl.value);
                    _updateInputValue(this, update, store, 10 /* AFC.Data.Qualifier.brand */, brand, brandControl) && businessCodeControl && _updateBusinessCodeControl(businessCodeControl, symbols);
                    if (symbol_) {
                        let eligible, key;
                        for (key in symbols) {
                            if (symbols[key] === symbol_) {
                                if (eligible === void 0) {
                                    eligible = key;
                                }
                                if (key === businessCode) {
                                    eligible = key;
                                    break;
                                }
                            }
                        }
                        businessCode = eligible;
                    }
                    else {
                        symbol_ = symbols[businessCode];
                    }
                    _updateInputValue(this, update, store, 11 /* AFC.Data.Qualifier.businessCode */, businessCode, businessCodeControl);
                    _updateInputValue(this, update, store, 9 /* AFC.Data.Qualifier.symbol */, symbol_);
                }
                update && _updateBrandSelector(this, brand, symbol_);
            }
            /** @internal */
            [_onChange](event) {
                let store = this.store;
                if (store) {
                    let target = event.target, selected;
                    if (target.tagName === 'AFC-GUI-BRAND-SELECTOR') {
                        (selected = target.selected) && this[_updateControls](true, selected.brand, selected.symbol);
                    }
                    else if (target.getAttribute && this[_change](target)) {
                        let businessCodeControl = _getInputForQualifier(this, store, 11 /* AFC.Data.Qualifier.businessCode */);
                        (businessCodeControl === target) && this[_updateControls](true, void 0, void 0, void 0, businessCodeControl);
                    }
                }
            }
            /** @internal */
            [_onHover](event) {
                let selector, detail = event.detail || ((selector = this.querySelector('afc-gui-brand-selector')) && selector.selected);
                this[_updateControls](false, detail && detail.brand, detail && detail.symbol);
            }
            constructor() {
                super();
                this.addEventListener('click', this[_onClick].bind(this), true);
                this.addEventListener('change', this[_onChange].bind(this), true);
                this.addEventListener('hover-change', this[_onHover].bind(this), true);
            }
            get store() {
                return this[_store];
            }
            set store(value) {
                if (this[_store] !== value) {
                    this[_off]();
                    this[_refresh](this[_store] = value);
                    this[_on]();
                }
            }
            get template() {
                return this[_template];
            }
            set template(value) {
                if (this[_template] !== value) {
                    this[_template] = value;
                    this[_refresh](this[_store]);
                }
            }
            get ondatachange() {
                return this[_dataChange];
            }
            set ondatachange(value) {
                if (this[_dataChange] !== value) {
                    this[_dataChange] && this.removeEventListener('dataChange', this[_dataChange]);
                    (this[_dataChange] = value) && this.addEventListener('dataChange', value);
                }
            }
            connectedCallback() {
                let templateNodes = this.getElementsByTagName('template');
                let templateNode, key, templates;
                if (templateNodes) {
                    for (let i = templateNodes.length; i > 0; --i) {
                        key = _getSafeName(templateNode = templateNodes[i - 1]);
                        templates = (this[_templates] || (this[_templates] = {}))[key] || (this[_templates][key] = []);
                        templates.push({
                            parentNode: templateNode.parentNode,
                            refNode: templateNode.nextSibling,
                            content: templateNode.innerHTML
                        });
                        templateNode.parentNode.removeChild(templateNode);
                    }
                }
                let e = new CustomEvent("connected", { bubbles: false, cancelable: false });
                let onConnected = this.getAttribute('onconnected');
                this.dispatchEvent(e);
                try {
                    onConnected && eval("(function(event) { " + onConnected + "})")(e);
                }
                catch (e) {
                }
                this[_on]();
            }
            disconnectedCallback() {
                this[_off]();
            }
            submit() {
                this[_store] && this[_forEach](this[_store], _setData);
                this.dispatchEvent(new Event("submit", { bubbles: true, cancelable: true }));
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                attrName === 'template' ? this.template = newVal : super.attributeChangedCallback(attrName, oldVal, newVal);
            }
        }
        AfcStoreForm.observedAttributes = AFC.gui.AfcGuiElement.observedAttributes.concat(['template', 'datachange']);
        Application.AfcStoreForm = AfcStoreForm;
        AFC.gui.registerElement("afc-gui-brand", AfcBrand);
        AFC.gui.registerElement("afc-gui-symbol", AfcSymbol);
        AFC.gui.registerElement("afc-gui-businesscode-selector", AfcBusinessCodeSelector);
        AFC.gui.registerElement("afc-gui-brand-selector", AfcBrandSelector);
        AFC.gui.registerElement("afc-gui-store-form", AfcStoreForm);
    })(Application = AFC.Application || (AFC.Application = {}));
})(AFC || (AFC = {}));
/* global AFC */
/* global customElements */
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        const _timeout = Symbol();
        function _generate(control) {
            (control[_timeout] !== void 0) || (control[_timeout] = setTimeout(function () {
                let query = $(control), div = document.createElement('div'), newFocus = null;
                if (control.editionMode) {
                    let input = document.createElement('input');
                    input.type = 'text';
                    input.style.width = '100%';
                    input.style.height = control.style.height;
                    input.value = control.value;
                    newFocus = input;
                    $(input).change(function () {
                        AFC.gui._dispatchEvent(control, 'change', { detail: control.value = this.value });
                    });
                    div.appendChild(input);
                }
                else {
                    let span = document.createElement('span'), divButton = document.createElement('div'), style = div.style;
                    divButton.className = 'editButton';
                    span.innerHTML = control.value;
                    style.display = 'flex';
                    style.flexDirection = 'row';
                    style.alignItems = 'flex-end';
                    div.appendChild(divButton);
                    div.appendChild(span);
                }
                div.style.cursor = 'pointer';
                query.empty();
                control.appendChild(div);
                if (newFocus)
                    newFocus.focus();
                delete control[_timeout];
            }, 0));
        }
        class AfcAutoEditLabelControl extends gui.AfcGuiElement {
            constructor() {
                super();
                this._editionMode = false;
                this._value = '';
                this.addEventListener('click', function (event) {
                    if (!this.editionMode) {
                        this.editionMode = true;
                    }
                }, true);
                _generate(this);
            }
            get value() {
                return this._value;
            }
            set value(value) {
                this._value = value;
                _generate(this);
            }
            get editionMode() {
                return this._editionMode;
            }
            set editionMode(value) {
                let showEdition = !!value;
                if (showEdition !== this._editionMode) {
                    this._editionMode = showEdition;
                    _generate(this);
                }
            }
        }
        AfcAutoEditLabelControl.observedAttributes = gui.AfcGuiElement.observedAttributes.concat(['editionMode']);
        gui.AfcAutoEditLabelControl = AfcAutoEditLabelControl;
        gui.registerElement("afc-gui-auto-edit-label-control", AfcAutoEditLabelControl);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/* global AFC */
/* global customElements */
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        function _convert(s) {
            let ret;
            try {
                ret = eval('[' + s + ']')[0];
            }
            catch (e) {
            }
            return ret;
        }
        function _indexOf(parent, element) {
            let ret = -1;
            for (var i = 0; i < parent.childNodes.length; ++i) {
                if (parent.childNodes[i] === element) {
                    ret = i;
                    break;
                }
            }
            return ret;
        }
        ;
        const _name = Symbol(), _type = Symbol(), _selection = Symbol(), _columns = Symbol(), _rows = Symbol(), _timeout = Symbol(), _filterText = Symbol(), _highlighted = Symbol(), _textFilterChangeTimer = Symbol(), _onChange = Symbol();
        class AfcFilterControl extends gui.AfcGuiElement {
            constructor() {
                super();
                this._resetHighlighted();
                this.addEventListener('mouseover', this._onMouseEnter.bind(this));
                this.addEventListener('click', this._onClick.bind(this));
                this.addEventListener('mouseout', this._onMouseOut.bind(this));
            }
            _getContextParamName(param) {
                var value = this.id || '';
                value += this[_name] || '';
                value += param;
                return value;
            }
            _onSaveInstanceState(context, savedInstanceState) {
                super._onSaveInstanceState(context, savedInstanceState);
                this.id && savedInstanceState.putValue(this._getContextParamName("selection"), this[_selection]);
            }
            _onRestoreViewState(context, fragmentManager, savedInstanceState) {
                super._onRestoreViewState(context, fragmentManager, savedInstanceState);
                savedInstanceState && this.id && (this[_selection] = savedInstanceState.getValue(this._getContextParamName("selection")));
            }
            get columns() {
                return this[_columns];
            }
            set columns(value) {
                if (value) {
                    this[_columns] = value;
                    this.resetSelection(true);
                    this._refresh();
                }
            }
            get rows() {
                return this[_rows];
            }
            set rows(value) {
                if (value) {
                    this[_rows] = value;
                    this.resetSelection(true);
                    this._refresh();
                }
            }
            get value() {
                return { selection: this[_selection], filterText: this[_filterText] };
            }
            set value(value) {
                let v = value, v2 = value;
                if (!value || (v2.length === 2 && v2[0] === -1 && v2[1] === -1)) {
                    this.resetSelection(true);
                }
                else {
                    if (value.selection) {
                        this.setSelection(value.selection);
                        this.setFilterText(value.filterText || '');
                    }
                    else {
                        this.setSelection(v);
                        this.setFilterText('');
                    }
                }
            }
            get type() {
                return this[_type];
            }
            set type(value) {
                this[_type] = value;
                this._refresh();
            }
            _hasCustomFilter() {
                return $(this).find("[custom-filter]").length > 0;
            }
            setSelection(value) {
                this[_selection] = value;
                this._draw();
                let values = value?.[this[_rows] ? this[_rows].length : 0], indice = 0;
                values && $(this).find("[custom-filter]").each(function () {
                    if (indice < values.length && this.getAttribute("type") === "checkbox") {
                        this.checked = values[indice++];
                    }
                });
            }
            setFilterText(value) {
                this[_filterText] = value;
                this._draw();
            }
            _refresh() {
                this[_timeout] || (this[_timeout] = setTimeout(() => {
                    this._draw();
                    delete this[_timeout];
                }, 1));
            }
            _refreshHighlighted() {
                var table = $(this).find("table");
                var _this = this;
                if (this[_columns] && this[_rows]) {
                    table.find("tr").each(function (i, tr) {
                        i--;
                        $(tr).find("td, th").each(function (j, td) {
                            j--;
                            if (((_this[_highlighted].row === i) && (_this[_highlighted].col === -1))
                                || ((_this[_highlighted].row === -1) && (_this[_highlighted].col === j))
                                || ((_this[_highlighted].row === i) && (_this[_highlighted].col === j))
                                || ((_this[_highlighted].row === -1) && (_this[_highlighted].col === -1)))
                                $(td).addClass('filterControlHighlighted');
                            else
                                $(td).removeClass('filterControlHighlighted');
                        });
                    });
                }
            }
            _draw() {
                if (!this[_selection] && this[_rows] && this[_columns])
                    this.resetSelection();
                var container = $(this).find("#mainFilter");
                var query;
                if (container && container.length > 0)
                    query = container.empty();
                else
                    query = $(this).empty();
                var table, row, cell;
                if (this[_columns] && this[_rows]) {
                    var tdWidth, thWidth, tdClass;
                    var _this = this;
                    {
                        var textLabel, textInput, div1, div2, div3;
                        query.append(div1 = document.createElement('div'));
                        div1.setAttribute('class', 'filterControl');
                        div1.append(div2 = document.createElement('div'));
                        //div2.innerHTML = "Filtre:";
                        div1.appendChild(div2 = document.createElement('div'));
                        div2.setAttribute('class', 'filterControlText');
                        div2.appendChild(textInput = document.createElement('input'));
                        textInput.setAttribute('class', 'filterControlTextInput');
                        textInput.setAttribute('placeholder', 'Filtre ...');
                        textInput.type = "text";
                        textInput.value = this[_filterText] || '';
                        //textInput.addEventListener('input', _this._onTextFilterChange.bind(_this));
                        textInput.addEventListener('keyup', _this._onTextFilterChange.bind(_this));
                        div2.appendChild(div3 = document.createElement('div'));
                        div3.setAttribute("class", "btn_close_filter");
                        div3.addEventListener('click', _this._onClickCloseFilterText.bind(_this));
                    }
                    if (this[_rows].length > 0) {
                        thWidth = Math.floor(100 / (this[_columns].length + 1));
                        tdWidth = 100 - (thWidth * this[_columns].length);
                        query.append(table = document.createElement('table'));
                        table.setAttribute('class', 'filterTable');
                        table.appendChild(row = document.createElement('tr'));
                        row.appendChild(cell = document.createElement('td')).appendChild(document.createTextNode(String.fromCharCode(0xA0)));
                        cell.setAttribute('style', 'width:' + tdWidth.toString() + '%');
                        this[_columns].forEach(function (item, i) {
                            row.appendChild(cell = document.createElement('th')).innerHTML = item;
                            cell.setAttribute('style', 'width:' + thWidth.toString() + '%');
                            if ((_this[_highlighted].row === -1) && (_this[_highlighted].col === i))
                                $(cell).addClass('filterControlHighlighted');
                        });
                    }
                    for (var i = 0; i < this[_rows].length; i++) {
                        table.appendChild(row = document.createElement('tr'));
                        row.appendChild(cell = document.createElement('th')).innerHTML = this[_rows][i];
                        if ((this[_highlighted].row === i) && (this[_highlighted].col === -1))
                            $(cell).addClass('filterControlHighlighted');
                        for (var j = 0; j < this[_columns].length; j++) {
                            row.appendChild(cell = document.createElement('td')).appendChild(document.createTextNode(String.fromCharCode(0xA0)));
                            cell.setAttribute('class', this[_selection][i][j] ? 'visible' : 'hidden');
                            if (((this[_highlighted].row === i) && (this[_highlighted].col === -1))
                                || ((this[_highlighted].row === -1) && (this[_highlighted].col === j))
                                || ((this[_highlighted].row === i) && (this[_highlighted].col === j))
                                || ((this[_highlighted].row === -1) && (this[_highlighted].col === -1)))
                                $(cell).addClass('filterControlHighlighted');
                        }
                    }
                }
                $(this).off('change').on('change', this[_onChange].bind(this));
                this.updateCloseFilterButton();
            }
            ;
            /** @internal */
            [_onChange](event) {
                let elem = $(event.target);
                if (elem.attr("custom-filter") != undefined) {
                    if ((!this[_rows].length && this[_selection].length == 0) || (this[_rows].length && this[_selection].length == this[_rows].length))
                        this[_selection].push([]);
                    let values = [];
                    $(this).find("[custom-filter]").each(function (idx) {
                        let elem = $(this);
                        if (elem.attr("type") == "checkbox")
                            values.push(elem.is(':checked'));
                    });
                    this[_selection][this[_selection].length - 1] = values;
                    this._onTextFilterChangeNoDelay();
                    //this._draw();
                }
            }
            resetSelection(selectAll) {
                var i, j;
                var newSelection;
                if (this[_rows] && this[_columns]) {
                    newSelection = [];
                    for (i = 0; i < this[_rows].length; i++) {
                        let row = [];
                        for (j = 0; j < this[_columns].length; j++)
                            row.push(selectAll);
                        newSelection.push(row);
                    }
                }
                this.setSelection(newSelection);
            }
            selectColumn(col) {
                var iRow, iCol;
                var currentValue = this[_selection][0][col];
                var stop = false;
                var isCheckBox = this[_type] === 'checkbox';
                for (iRow = 0; !stop && (iRow < this[_selection].length); iRow++) {
                    if (currentValue !== this[_selection][iRow][col]) {
                        currentValue = false;
                        stop = true;
                    }
                }
                if (!isCheckBox && currentValue) {
                    currentValue = !this[_selection][0][col > 0 ? col - 1 : col + 1];
                }
                for (iRow = 0; iRow < this[_selection].length; iRow++) {
                    for (iCol = 0; iCol < this[_selection][iRow].length; iCol++) {
                        if (iCol === col)
                            this[_selection][iRow][iCol] = isCheckBox ? !currentValue : true;
                        else if (!isCheckBox)
                            this[_selection][iRow][iCol] = currentValue;
                    }
                }
            }
            selectRow(row) {
                var iRow, iCol;
                var currentValue = this[_selection][row][0];
                var stop = false;
                var isCheckBox = this[_type] === 'checkbox';
                for (iCol = 0; !stop && (iCol < this[_selection][row].length); iCol++) {
                    if (currentValue !== this[_selection][row][iCol]) {
                        currentValue = false;
                        stop = true;
                    }
                }
                if (!isCheckBox && currentValue) {
                    currentValue = !this[_selection][row > 0 ? row - 1 : row + 1][0];
                }
                for (iRow = 0; iRow < this[_selection].length; iRow++) {
                    for (iCol = 0; iCol < this[_selection][iRow].length; iCol++) {
                        if (iRow === row)
                            this[_selection][iRow][iCol] = isCheckBox ? !currentValue : true;
                        else if (!isCheckBox)
                            this[_selection][iRow][iCol] = currentValue;
                    }
                }
            }
            selectCell(col, row) {
                var isCheckBox = this[_type] === 'checkbox';
                if (isCheckBox)
                    this[_selection][row][col] = !this[_selection][row][col];
                else {
                    var iRow, iCol;
                    var allOtherSameValues = true;
                    var otherValues = -1;
                    if (!this[_selection][row][col]) {
                        allOtherSameValues = false;
                    }
                    else {
                        for (iRow = 0; allOtherSameValues && (iRow < this[_selection].length); iRow++) {
                            for (iCol = 0; allOtherSameValues && (iCol < this[_selection][iRow].length); iCol++) {
                                if ((iRow !== row) && (iCol !== col)) {
                                    if (otherValues === -1)
                                        otherValues = this[_selection][iRow][iCol];
                                    else if (otherValues !== this[_selection][iRow][iCol])
                                        allOtherSameValues = false;
                                }
                            }
                        }
                    }
                    this.resetSelection(allOtherSameValues ? !otherValues : false);
                    this[_selection][row][col] = true;
                }
            }
            _getXYFromEvent(e) {
                let target = e.target, result = {
                    x: -2,
                    y: -2
                };
                if ((target.tagName === 'TD') || (target.tagName === 'TH')) {
                    let parent = target.parentNode, x = _indexOf(parent, target), y = _indexOf(parent.parentNode, parent);
                    result.x = --x;
                    result.y = --y;
                }
                return result;
            }
            _resetHighlighted() {
                this[_highlighted] = { col: -2, row: -2 };
            }
            ;
            _onMouseEnter(e) {
                var coords = this._getXYFromEvent(e);
                this[_highlighted].col = coords.x;
                this[_highlighted].row = coords.y;
                this._refreshHighlighted();
            }
            _onMouseOut(e) {
                this._resetHighlighted();
                this._refreshHighlighted();
            }
            _onClickCloseFilterText() {
                let textInput = this.querySelector('.filterControlTextInput');
                textInput.value = '';
                this[_filterText] = '';
                this._onTextFilterChangeNoDelay();
                this.updateCloseFilterButton();
            }
            updateCloseFilterButton() {
                if (this[_filterText] && (this[_filterText] !== ''))
                    $(this).find('.btn_close_filter').show();
                else
                    $(this).find('.btn_close_filter').hide();
            }
            _onTextFilterChange(e) {
                let textInput = e.target;
                if (this[_filterText] !== textInput.value) {
                    this[_filterText] = textInput.value;
                    this.updateCloseFilterButton();
                    (this[_textFilterChangeTimer] !== void 0) && clearTimeout(this[_textFilterChangeTimer]);
                    this[_textFilterChangeTimer] = setTimeout(() => {
                        delete this[_textFilterChangeTimer];
                        this._onTextFilterChangeNoDelay();
                    }, 500);
                }
            }
            onFilterChanged() {
            }
            _onTextFilterChangeNoDelay() {
                this.onFilterChanged();
            }
            _onClick(e) {
                var coords = this._getXYFromEvent(e);
                if ((coords.x >= -1) && (coords.y >= -1)) {
                    var x = coords.x, y = coords.y;
                    if ((x !== -1) || (y !== -1)) {
                        if (x === -1)
                            this.selectRow(y);
                        else if (y === -1)
                            this.selectColumn(x);
                        else
                            this.selectCell(x, y);
                    }
                    else {
                        if (this[_type] === 'checkbox') {
                            var allSelected = this[_selection][0][0];
                            var stop = false;
                            var iCol, iRow;
                            for (iRow = 0; !stop && (iRow < this[_selection].length); iRow++) {
                                for (iCol = 0; iCol < this[_selection][iRow].length; iCol++) {
                                    if (allSelected !== this[_selection][iRow][iCol]) {
                                        allSelected = false;
                                        stop = true;
                                    }
                                }
                            }
                            this.resetSelection(!allSelected);
                        }
                        else
                            this.resetSelection(true);
                    }
                    this._onTextFilterChangeNoDelay();
                    this._draw();
                }
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                switch (attrName) {
                    case 'name':
                        this[_name] = newVal;
                        break;
                    case 'columns':
                        if (newVal == "")
                            this.columns = [];
                        else
                            this.columns = _convert(newVal);
                        break;
                    case 'rows':
                        if (newVal == "")
                            this.rows = [];
                        else
                            this.rows = _convert(newVal);
                        break;
                    case 'value':
                        this.value = _convert(newVal);
                        break;
                    case 'type':
                        this.type = newVal;
                        break;
                }
            }
        }
        AfcFilterControl.observedAttributes = gui.AfcGuiElement.observedAttributes.concat(['type', 'columns', 'rows', 'value', 'name']);
        gui.AfcFilterControl = AfcFilterControl;
        gui.registerElement("afc-gui-filter-control", AfcFilterControl);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 18/01/2017.
 */
///<reference path="../Globals.ts" /> 
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        function _recurse(element, method) {
            let children = element.children;
            if (children) {
                for (let i = 0; i < children.length; ++i) {
                    method(children[i]);
                    (children[i] instanceof AfcGuiDiv) || _recurse(children[i], method);
                }
            }
        }
        class AfcGuiDiv extends gui.AfcGuiElement {
            _setMute(mute) {
                if (mute !== this._muted) {
                    this._muted = mute;
                    _recurse(this, gui.AfcGuiElement._setMute.bind(null, mute));
                }
            }
            _resize(screenRect) {
                super._resize(screenRect);
                this.hidden || _recurse(this, gui.AfcGuiElement._resize.bind(null, screenRect));
            }
        }
        AfcGuiDiv.observedAttributes = gui.AfcGuiElement.observedAttributes;
        gui.AfcGuiDiv = AfcGuiDiv;
        class AfcGuiRoot extends AfcGuiDiv {
            resize(screenRect) {
                this.init(screenRect);
                super._resize(screenRect);
            }
        }
        AfcGuiRoot.observedAttributes = gui.AfcGuiElement.observedAttributes;
        gui.AfcGuiRoot = AfcGuiRoot;
        gui.registerElement("afc-gui-div", AfcGuiDiv);
        gui.registerElement("afc-gui-root", AfcGuiRoot);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 28/01/2020.
 */
///<reference path="../Globals.ts" /> 
///<reference path="./Root.ts" /> 
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        const _fragment = Symbol(), _fragmentManager = Symbol(), _tag = Symbol();
        class AfcGuiFragmentHolder extends gui.AfcGuiElement {
            set content(className) {
                let fragmentManager = this[_fragmentManager];
                if (fragmentManager) {
                    let fragment;
                    try {
                        if (className) {
                            let ctor = className.split('.').reduce((acc, key) => {
                                return acc[key];
                            }, window);
                            fragment = new ctor();
                        }
                    }
                    finally {
                        this.setContent(fragment, this.getAttribute('tag'));
                    }
                }
            }
            setContent(value, tag) {
                if (this[_fragment] !== value) {
                    let fragmentManager = this[_fragmentManager], fragment;
                    if (fragment = this[_fragment]) {
                        AFC.Application.FragmentManager.detachView(fragment);
                    }
                    this[_fragment] = value;
                    this[_tag] = tag;
                    fragmentManager && value && fragmentManager.attachView(this, value, tag);
                }
            }
            _onSaveInstanceState(context, savedInstanceState) {
                let tag, fragment;
                if (this.id && (fragment = this[_fragment]) && (tag = fragment.getTag())) {
                    savedInstanceState.putValue(this.id, tag);
                }
            }
            _onRestoreViewState(context, fragmentManager, savedInstanceState) {
                let fragment = this[_fragment], tag = this[_tag];
                this[_fragment] = null;
                this[_fragmentManager] = fragmentManager;
                if (!fragment && savedInstanceState && this.id && (tag = savedInstanceState.getValue(this.id))) {
                    fragment = fragmentManager.findFragmentByTag(tag);
                }
                fragment ?
                    this.setContent(fragment, tag) :
                    this.content = this.getAttribute('content');
            }
            disconnectedCallback() {
                let fragment = this[_fragment];
                fragment && AFC.Application.FragmentManager.detachView(fragment);
                delete this[_fragment];
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                attrName === 'content' ?
                    this.content = newVal :
                    super.attributeChangedCallback(attrName, oldVal, newVal);
            }
        }
        AfcGuiFragmentHolder.observedAttributes = gui.AfcGuiDiv.observedAttributes.concat(['content']);
        gui.AfcGuiFragmentHolder = AfcGuiFragmentHolder;
        gui.registerElement("afc-gui-fragmentholder", AfcGuiFragmentHolder);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 14/05/2019.
 */
///<reference path="../Globals.ts" /> 
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        function _computeValue(control, value) {
            let ratio = control.allowHalf ? 2 : 1;
            return Math.ceil(ratio * value) / ratio;
        }
        function _setWidth(control, child, value) {
            child.style.width = value ? `${Math.min(value, control.maxValue) * 100 / control.maxValue}%` : '0';
        }
        function _setValue(control, value, highlight) {
            let child0 = control.children[0];
            if (child0) {
                let child1 = child0.children[0], child2 = child0.children[1], child3 = child0.children[2], value1 = 0, value2 = 0, value3 = 0;
                if (highlight !== void 0) {
                    if (highlight > value) {
                        value3 = value;
                        value1 = highlight;
                    }
                    else if (highlight < value) {
                        value3 = highlight;
                        value2 = value;
                    }
                    else {
                        value2 = value;
                    }
                }
                else {
                    value3 = value;
                }
                _setWidth(control, child1, value1);
                _setWidth(control, child2, value2);
                _setWidth(control, child3, value3);
            }
        }
        function _getValue(control, event) {
            let query = $(control), width = query.children('div').width();
            return (event.pageX - query.offset().left) * control.maxValue / width;
        }
        const _value = Symbol(), _maxValue = Symbol(), _allowHalf = Symbol(), _timeout = Symbol(), _disabled = Symbol(), _generate = Symbol();
        class AfcRatingControl extends gui.AfcGuiElement {
            /** @internal */
            [_generate]() {
                (this[_timeout] !== void 0) || (this[_timeout] = setTimeout(() => {
                    let query = $(this), maxValue = this.maxValue, control0 = document.createElement('div'), control1 = document.createElement('div');
                    query.empty();
                    control0.appendChild(document.createTextNode(String.fromCharCode(0x2606).repeat(maxValue)));
                    control1.appendChild(document.createTextNode(String.fromCharCode(0x2605).repeat(maxValue)));
                    this.appendChild(control0);
                    control0.appendChild(control0.cloneNode(true));
                    control0.appendChild(control1);
                    control0.appendChild(control1.cloneNode(true));
                    _setValue(this, this.value);
                    delete this[_timeout];
                }, 0));
            }
            constructor() {
                super();
                this[_value] = 0;
                this[_maxValue] = 3;
                this[_allowHalf] = false;
                this.addEventListener('pointerup', (event) => {
                    if (!this[_disabled]) {
                        let value = _computeValue(this, _getValue(this, event));
                        this.value = value === this.value ? 0 : value;
                        _setValue(this, this.value, value);
                        gui._dispatchEvent(this, 'change', { detail: this.value });
                    }
                }, true);
                this.addEventListener('pointermove', (event) => this[_disabled] || _setValue(this, this.value, _computeValue(this, _getValue(this, event))));
                this.addEventListener('pointerleave', ( /*event: PointerEvent*/) => this[_disabled] || _setValue(this, this.value));
                this[_generate]();
            }
            _onRestoreViewState(activity, fragmentManager, savedInstanceState) {
                const id = savedInstanceState && this.id;
                if (id) {
                    this.value = savedInstanceState.getValue(id);
                }
            }
            _onSaveInstanceState(context, savedInstanceState) {
                const id = this.id;
                id && savedInstanceState.putValue(id, this.value);
                super._onSaveInstanceState(context, savedInstanceState);
            }
            get value() {
                return this[_value];
            }
            set value(value) {
                if ((value = _computeValue(this, value)) !== this[_value]) {
                    _setValue(this, this[_value] = value);
                }
            }
            get maxValue() {
                return this[_maxValue];
            }
            set maxValue(value) {
                if ((this[_maxValue] !== value)) {
                    this[_maxValue] = Math.max(1, value);
                    this[_generate]();
                }
            }
            get allowHalf() {
                return this[_allowHalf];
            }
            set allowHalf(value) {
                let v = !value;
                (this[_allowHalf] === v) && !(this[_allowHalf] = !v) && (this.value = this[_value]);
            }
            get disabled() {
                return this[_disabled];
            }
            set disabled(value) {
                (this[_disabled] = !!value) && _setValue(this, this[_value]);
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                let value;
                switch (attrName) {
                    case 'value':
                        isFinite(value = parseFloat(newVal)) && (this.value = value);
                        break;
                    case 'max-value':
                        isFinite(value = parseFloat(newVal)) && (this.maxValue = value);
                        break;
                    case 'allow-half':
                        this.allowHalf = newVal !== null;
                        break;
                    case 'disabled':
                        this.disabled = newVal !== null;
                        break;
                    default:
                        super.attributeChangedCallback(attrName, oldVal, newVal);
                        break;
                }
            }
        }
        AfcRatingControl.observedAttributes = gui.AfcGuiElement.observedAttributes.concat(['value', 'max-value', 'allow-half', 'disabled']);
        gui.AfcRatingControl = AfcRatingControl;
        gui.registerElement("afc-gui-rating-control", AfcRatingControl);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 03/02/2020.
 */
///<reference path="../Globals.ts" /> 
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        const _selected = Symbol(), _onSelected = Symbol(), _onClick = Symbol();
        function select(tab, value) {
            (tab[_selected] = value = !!value) ? $(tab).addClass('selected') : $(tab).removeClass('selected');
            return value;
        }
        class AfcGuiTab extends HTMLElement {
            get selected() {
                return this[_selected];
            }
            set selected(value) {
                let tabBar = this.parentElement;
                select(this, value) && tabBar[_onSelected] && tabBar[_onSelected](this);
            }
        }
        gui.AfcGuiTab = AfcGuiTab;
        class AfcGuiTabBar extends gui.AfcGuiElement {
            constructor() {
                super();
                this.addEventListener('click', this[_onClick].bind(this));
            }
            /** @internal */
            [_onSelected](tab) {
                let tabs = this.getElementsByTagName('afc-gui-tab');
                for (let i = 0, item; i < tabs.length; ++i) {
                    if ((item = tabs[i]) !== tab) {
                        select(item);
                    }
                }
            }
            /** @internal */
            [_onClick](event) {
                let target = event.target;
                if (target.tagName === 'AFC-GUI-TAB') {
                    target.selected = true;
                    setTimeout(() => {
                        gui._dispatchEvent(this, 'change');
                    }, 0);
                }
            }
            _onSaveInstanceState(context, savedInstanceState) {
                this.id && savedInstanceState.putValue(this.id, this.value);
            }
            _onRestoreViewState(context, fragmentManager, savedInstanceState) {
                if (savedInstanceState && this.id) {
                    this.value = savedInstanceState.getValue(this.id);
                }
                else {
                    let tab = this.querySelector('afc-gui-tab[selected]'), value;
                    tab && (value = tab.getAttribute('value')) && (this.value = value);
                }
            }
            get value() {
                let tabs = this.getElementsByTagName('afc-gui-tab');
                for (let i = 0; i < tabs.length; ++i) {
                    if (tabs[i].selected) {
                        return tabs[i].getAttribute('value');
                    }
                }
            }
            set value(value) {
                let tabs = this.getElementsByTagName('afc-gui-tab'), found;
                for (let i = 0; i < tabs.length; ++i) {
                    select(tabs[i], !found && (found = tabs[i].getAttribute('value') === value));
                }
            }
        }
        AfcGuiTabBar.observedAttributes = gui.AfcGuiElement.observedAttributes;
        gui.AfcGuiTabBar = AfcGuiTabBar;
        gui.registerElement("afc-gui-tab", AfcGuiTab);
        gui.registerElement("afc-gui-tabbar", AfcGuiTabBar);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 25/07/2018.
 */
///<reference path="Root.ts" /> 
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        const _attribute = 'content', _context = Symbol(), _state = Symbol(), _content = Symbol(), _fragmentManager = Symbol();
        class AfcGuiTemplate extends gui.AfcGuiDiv {
            _onSaveInstanceState(context, savedInstanceState) {
                super._onSaveInstanceState(context, savedInstanceState);
                this.id && savedInstanceState.putValue(this.id, this.getAttribute(_attribute));
            }
            _onRestoreViewState(context, fragmentManager, savedInstanceState) {
                super._onRestoreViewState(context, fragmentManager, savedInstanceState);
                savedInstanceState && this.id && (this.content = savedInstanceState.getValue(this.id));
                this[_context] = context;
                this[_fragmentManager] = fragmentManager;
                this[_state] = savedInstanceState;
            }
            set content(value) {
                if (value !== this[_content]) {
                    delete this[_content];
                    $(this).empty();
                    if (value) {
                        let template = AFC.Tools.Data.isString(value) ? document.querySelector(`template#${value}`) : value;
                        this[_content] = value;
                        template && this.appendChild(document.importNode(template.content, true));
                        this[_context] && gui.onRestoreViewState(this[_context], this, this[_fragmentManager], this[_state]);
                    }
                }
            }
            get content() {
                return this[_content];
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                if (attrName === _attribute) {
                    this.content = newVal;
                }
                else {
                    super.attributeChangedCallback(attrName, oldVal, newVal);
                }
            }
        }
        AfcGuiTemplate.observedAttributes = gui.AfcGuiDiv.observedAttributes.concat([_attribute]);
        gui.AfcGuiTemplate = AfcGuiTemplate;
        gui.registerElement("afc-gui-template", AfcGuiTemplate);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 20/05/2020.
 */
///<reference path="../Globals.ts" /> 
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        const _viewPager = Symbol(), _adapter = Symbol(), _options = Symbol(), _item = Symbol(), _draggable = Symbol();
        class AfcGuiViewPager extends gui.AfcGuiElement {
            _onSaveInstanceState(context, savedInstanceState) {
                if (this.id && this[_adapter]) {
                    savedInstanceState.putValue(`${this.id}|adapter`, this[_adapter]);
                    savedInstanceState.putValue(`${this.id}|item`, this[_item]);
                    this[_options] && savedInstanceState.putValue(`${this.id}|options`, this[_options]);
                }
            }
            _onRestoreViewState(context, fragmentManager, savedInstanceState) {
                let adapter, item, options;
                this[_viewPager] = new AFC.Controls.ViewPager(this);
                if (savedInstanceState && (adapter = savedInstanceState.getValue(`${this.id}|adapter`))) {
                    item = savedInstanceState.getValue(`${this.id}|item`);
                    options = savedInstanceState.getValue(`${this.id}|options`);
                }
                this[_viewPager].onPageScrollStateChanged = state => this.dispatchEvent(new CustomEvent('change', { detail: state }));
                (options = options ? $.extend(this[_options], options) : this[_options]) && this.setOptions(options);
                this.setAdapter(this[_adapter] || adapter);
                this.setCurrentItem(this[_item] === void 0 ? item : this[_item]);
            }
            _resize(screenRect) {
                super._resize(screenRect);
                this.init(screenRect);
                this[_viewPager]?.invalidateSize();
            }
            setAdapter(adapter) {
                this[_adapter] = adapter;
                this[_viewPager]?.setAdapter(adapter);
            }
            setOptions(options) {
                let viewPager = this[_viewPager];
                options = (this[_options] ? $.extend(this[_options], options) : this[_options] = options) || {};
                if (viewPager) {
                    this[_viewPager].setPageTransformer(options.pageTransformer);
                    this[_viewPager].ease = options.timingFunction;
                    options.duration !== void 0 && (this[_viewPager].duration = options.duration);
                }
            }
            setCurrentItem(item) {
                this[_item] = item;
                return this[_viewPager]?.setCurrentItem(item);
            }
            getCurrentItem() {
                return this[_item];
            }
            refresh() {
                this._resize({});
            }
            connectedCallback() {
                if (this.hasAttribute("draggable")) {
                    let draggable = new AFC.Controls.Draggable(this), swipeLeft = (event) => {
                        this.setCurrentItem(this[_item] + 1);
                    }, swipeRight = (event) => {
                        this.setCurrentItem(this[_item] - 1);
                    }, dragMove = (event) => {
                    }, dragEnd = (event) => {
                    };
                    this.addEventListener('swipe:left', swipeLeft);
                    this.addEventListener('swipe:right', swipeRight);
                    this.addEventListener('drag:move', dragMove);
                    this.addEventListener('drag:end', dragEnd);
                    this[_draggable] = {
                        draggable: draggable,
                        swipeLeft: swipeLeft,
                        swipeRight: swipeRight,
                        dragMove: dragMove,
                        dragEnd: dragEnd
                    };
                }
            }
            disconnectedCallback() {
                let draggable = this[_draggable];
                if (draggable) {
                    this.removeEventListener('swipe:left', draggable.swipeLeft);
                    this.removeEventListener('swipe:right', draggable.swipeRight);
                    this.removeEventListener('drag:move', draggable.dragMove);
                    this.removeEventListener('drag:end', draggable.dragEnd);
                    AFC.Controls.Draggable.destroy(draggable.draggable);
                }
            }
        }
        gui.AfcGuiViewPager = AfcGuiViewPager;
        gui.registerElement("afc-gui-view-pager", AfcGuiViewPager);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        const _control = Symbol();
        function parseOptions(value, defaultOptions) {
            let matches = value?.matchAll(/([^:;]+):([^:;]+)(?:;|$)/g), options;
            if (matches) {
                options = {};
                for (let [, key, value] of matches) {
                    try {
                        if (defaultOptions.hasOwnProperty(key = key.trim())) {
                            options[key] = AFC.Tools.Data.isString(defaultOptions[key]) ? value.trim() : JSON.parse(value);
                        }
                    }
                    catch (e) {
                    }
                }
                return options;
            }
        }
        gui.parseOptions = parseOptions;
        class AfcGuiWaitBar extends gui.AfcGuiElement {
            constructor() {
                super();
                this.adapter = new AFC.Globals.WaitAdapter({
                    waitBar: this[_control] = new AFC.Controls.WaitBar(this)
                });
            }
            _onSaveInstanceState(context, savedInstanceState) {
                let options = this.id && this[_control].options;
                if (options) {
                    savedInstanceState.putValue(`${this.id}|options`, options);
                }
            }
            _onRestoreViewState(context, fragmentManager, savedInstanceState) {
                let options = (this.id && savedInstanceState?.getValue(`${this.id}|options`)) || parseOptions(this.getAttribute('options'), AFC.Controls.WaitBar.defaultOptions);
                options && this.setOptions(options);
                this.adapter.register();
            }
            setOptions(options) {
                this[_control].options = options;
            }
            disconnectedCallback() {
                this.adapter.unregister();
            }
        }
        gui.AfcGuiWaitBar = AfcGuiWaitBar;
        class AfcGuiProgressBar extends gui.AfcGuiElement {
            constructor() {
                super();
                this.adapter = new AFC.Globals.WaitAdapter({
                    progressBar: this[_control] = new AFC.Controls.ProgressBar(this)
                });
            }
            connectedCallback() {
                this.adapter.dummyEnabled = this.getAttribute("enable-dummy") !== null;
                this.adapter.register();
            }
            disconnectedCallback() {
                this.adapter.unregister();
            }
        }
        gui.AfcGuiProgressBar = AfcGuiProgressBar;
        gui.registerElement("afc-gui-wait-bar", AfcGuiWaitBar);
        gui.registerElement("afc-gui-progress-bar", AfcGuiProgressBar);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 19/09/2017.
 */
///<reference path="../Globals.ts" />
///<reference path="../../models/data/Data.ts" />
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        function _getFunction(s) {
            return gui.StringToFunction(`function($scope) {return ${s}}`);
        }
        function _compare(value0, value1) {
            let comp = this.compare ? this.compare(value0, value1) : 0;
            if (!comp) {
                if (this.orderBy) {
                    if (typeof (value0.dataItem[this.orderBy]) === "string")
                        comp = value0.dataItem[this.orderBy].localeCompare(value1.dataItem[this.orderBy]);
                    else
                        comp = value0.dataItem[this.orderBy] - value1.dataItem[this.orderBy];
                }
            }
            if (this.orderByDirection == "desc")
                comp = -comp;
            return comp;
        }
        gui._compare = _compare;
        const _context = Symbol(), _state = Symbol(), _onClear = Symbol(), _fragmentManager = Symbol();
        class AfcGuiRepeater extends gui.AfcBindableElement {
            constructor() {
                super();
                this._adapter = new AFC.Data.RepeaterAdapter(this._control = new AFC.Controls.Repeater(this));
                this._adapter.maxItem = 10;
                this._adapter.compare = _compare.bind(this);
            }
            _onRestoreViewState(context, fragmentManager, savedInstanceState) {
                super._onRestoreViewState(context, fragmentManager, savedInstanceState);
                this[_context] = context;
                this[_fragmentManager] = fragmentManager;
                this[_state] = savedInstanceState;
            }
            [_onClear]() {
                this[_context] && gui.onSaveInstanceState(this[_context], this, this[_state] || (this[_state] = new AFC.Application.Bundle()));
            }
            _onGenerate() {
                this[_context] && gui.onRestoreViewState(this[_context], this, this[_fragmentManager], this[_state]);
                this._control.loadingEnd();
                gui._dispatchEvent(this, 'dataChange');
            }
            set maxItem(value) {
                this._adapter.maxItem = value;
            }
            get maxItem() {
                return this._adapter.maxItem;
            }
            get adapter() {
                return this._adapter;
            }
            set template(value) {
                this._adapter.template = value;
            }
            get template() {
                return this._adapter.template;
            }
            set dataBinder(value) {
                this._control.dataBinder = value;
            }
            get dataBinder() {
                return this._control.dataBinder;
            }
            set filter(value) {
                this._adapter.filter = value;
            }
            get filter() {
                return this._adapter.filter;
            }
            connectedCallback() {
                let templates = this.getElementsByTagName("template");
                let template;
                if (templates) {
                    for (let i = 0; i < templates.length; ++i) {
                        let parentNode = templates[i].parentNode;
                        let validTemplate = true;
                        while (validTemplate && parentNode && parentNode != this) {
                            if (parentNode.nodeName.toLocaleLowerCase() == "template")
                                validTemplate = false;
                            parentNode = parentNode.parentNode;
                        }
                        //if (templates[i].parentNode === this) {
                        if (validTemplate) {
                            let name = (template = templates[i]).getAttribute('name');
                            this._control.setTemplate(template.innerHTML, name === null ? void 0 : name);
                        }
                    }
                }
                $(this).empty();
                this._control.loadingStart();
                this._adapter.onClear = this[_onClear].bind(this);
                this._adapter.onGenerate = this._onGenerate.bind(this);
                super.connectedCallback();
            }
            disconnectedCallback() {
                delete this._adapter.onGenerate;
                super.disconnectedCallback();
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                let f;
                switch (attrName) {
                    case 'template':
                        (f = _getFunction(newVal)) && (this.template = f);
                        break;
                    case 'order-by':
                        this.orderBy = newVal;
                        break;
                    case 'order-by-direction':
                        this.orderByDirection = newVal.toLowerCase();
                        break;
                    case 'compare':
                        (f = gui.StringToFunction(newVal)) && (this.compare = f);
                        break;
                    case 'filter':
                        (f = gui.StringToFunction(newVal)) && (this.filter = f);
                        break;
                    case 'data-binder':
                        (f = gui.StringToFunction(newVal)) && (this.dataBinder = f);
                        break;
                    case 'max-item':
                        isNaN(this.maxItem = parseInt(newVal)) && (this.maxItem = 10);
                        break;
                    case 'format-numbers':
                        this._control.setFormatNumbers(newVal !== null);
                        break;
                    default:
                        super.attributeChangedCallback(attrName, oldVal, newVal);
                        break;
                }
            }
            refresh() {
                this._adapter.refresh();
            }
        }
        AfcGuiRepeater.observedAttributes = gui.AfcBindableElement.observedAttributes.concat(['template', 'order-by', 'order-by-direction', 'compare', 'data-binder', 'max-item', 'format-numbers', 'filter']);
        gui.AfcGuiRepeater = AfcGuiRepeater;
        gui.registerElement("afc-gui-repeater", AfcGuiRepeater);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 19/09/2017.
 */
///<reference path="../Globals.ts" />
///<reference path="../../models/data/Data.ts" />
///<reference path="../../gui/data/Repeater.ts" />
///<reference path="../../adapters/dashboards/ConfigGroupAdapter.ts" />
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        class ConfigGroupControlRepeater extends AFC.Controls.Repeater {
            constructor() {
                super(...arguments);
                this._childrenElem = [];
            }
            storeChildElem(elem) {
                this._childrenElem.push(elem);
            }
            getChildrenElem() {
                return this._childrenElem;
            }
            insertItem(container, elem) {
                let index = (void 0 !== elem.dataset.index) ? parseInt(elem.dataset.index, 10) : void 0;
                if (void 0 !== index && index < container.childNodes.length) {
                    container.insertBefore(elem, Array.from(container.childNodes)[index]);
                }
                else {
                    container.appendChild(elem);
                }
            }
        }
        /**
         * Config group repeater
         *
         * defaultcursel = "VALUE" select dom item with data-value = defaultcursel (use it for item out of model !!!)
         * defaultcursel = null: default item (in mdoel) selection
         *
         * Usage example:
         *          <afc-gui-config-group
         *                  handlers="app.screen.getConfigListHandlers"
         *                  defaultcursel="0"
         *                  mru-id="mruConfigList"
         *                  mru-active="true"
         *                  mru-handlers="app.screen.getDataStorageHandlers">
         *              ...
         *              <template>...</template>
         *              ...
         *              <div data-index="4" onclick="myFn();">
         *                  Custom button to be added outside reapeater logic
         *              </div>
         *          </afc-gui-config-group>
         */
        class AfcGuiConfigGroup extends gui.AfcGuiRepeater {
            constructor() {
                super();
                this._adapter = new AFC.Dashboards.ConfigGroupAdapter(this._control = new ConfigGroupControlRepeater(this));
                this._adapter.compare = gui._compare.bind(this);
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                let f;
                switch (attrName) {
                    case 'defaultcursel':
                        this._adapter.defaultSelection = newVal === "null" ? null : newVal;
                        break;
                    case 'handlers':
                        (f = gui.StringToFunction(newVal)) && (this._adapter.handlers = f());
                        if (this._adapter.handlers && this._adapter.handlers.fnCompare) {
                            this._adapter.compare = (value0, value1) => this._adapter.handlers.fnCompare(value0.dataItem, value1.dataItem);
                        }
                        break;
                    case 'mru-active':
                        this._adapter.storageHelper.storageActive = (newVal === 'true');
                        break;
                    case 'mru-id':
                        this._adapter.storageHelper.mruId = newVal;
                        break;
                    case 'mru-handlers':
                        (f = gui.StringToFunction(newVal)) && (this._adapter.storageHandlers = f());
                        break;
                    default:
                        super.attributeChangedCallback(attrName, oldVal, newVal);
                        break;
                }
            }
            connectedCallback() {
                [...this.children].filter(e => e.tagName.toLowerCase() !== "template")
                    .sort((a, b) => {
                    let indexA = parseInt(a.dataset.index, 10), indexB = parseInt(b.dataset.index, 10), res;
                    if (isNaN(indexA) && isNaN(indexB)) {
                        res = 0;
                    }
                    else if (isNaN(indexA)) {
                        res = 1;
                    }
                    else if (isNaN(indexB)) {
                        res = -1;
                    }
                    else {
                        res = indexA - indexB;
                    }
                    return res;
                })
                    .forEach(elem => this._control.storeChildElem(elem));
                super.connectedCallback();
            }
            _onGenerate() {
                super._onGenerate();
                let control = this._control;
                let node = this._control.node;
                // Add fixed items
                control.getChildrenElem().forEach(element => {
                    control.insertItem(node, element);
                });
                node.removeEventListener("click", this.onListClick);
                node.addEventListener("click", this.onListClick);
                this._manualContainerElem = node.querySelector(".list__item__manual");
                if (this._manualContainerElem) {
                    // For each input, set data-value default, to be reset when click on Cancel btn
                    this._manualContainerElem
                        .querySelectorAll("input, select")
                        .forEach(e => e.dataset.resetvalue = e.value);
                    // Attach onClick event on btns manual inputs ("Annuler" / "Valider" popin)
                    this._manualContainerElem
                        .querySelectorAll(".list__item__manual__footer .btn")
                        .forEach(elem => elem.addEventListener("click", this.onListBtnClick.bind(this)));
                    // Attach onKeypress event on inputs manual
                    this._manualContainerElem.querySelectorAll("input[type='text']")
                        .forEach(elem => elem.addEventListener("keypress", (event) => {
                        let allowed = /[0-9,.]/.test(event.key);
                        if (!allowed) {
                            event.preventDefault();
                        }
                        return allowed;
                    }));
                }
                // Auto select item that is in template but not in model
                try {
                    if (this._adapter.model && this._adapter.defaultSelection !== null) {
                        node.querySelector(`[data-value="${this._adapter.defaultSelection}"]`)
                            .classList.toggle("selected", this._adapter.model.selection === null);
                    }
                }
                catch (e) {
                    // No dom item found, ignore
                }
            }
            onListClick(event) {
                const currConfigGroup = this;
                let itemElem, parentNode = event.target, list = event.currentTarget;
                if (event.target.closest(".list__item__manual")) {
                    event.stopImmediatePropagation();
                    return false;
                }
                while (parentNode && (parentNode !== list)) {
                    parentNode = (itemElem = parentNode).parentNode;
                }
                this._adapter.onListItemClick.call(this._adapter, event, itemElem)
                    .then((result) => { result && currConfigGroup.toggleManualEdition(event, itemElem, true); })
                    .catch(() => { }); // Prevent browser from displaying err when rejected
            }
            onListBtnClick(event) {
                const btnDOM = event.currentTarget;
                const inputsDOM = btnDOM.closest(".list__item__manual")
                    .querySelectorAll("input[type='text'], select");
                let params;
                if (btnDOM.classList.contains("btn_ok")) {
                    params = [...inputsDOM].map(e => e.value);
                }
                else {
                    this._manualContainerElem
                        .querySelectorAll("input, select")
                        .forEach(e => e.value = e.dataset.resetvalue);
                }
                this._adapter.onListBtnClick.call(this._adapter, event, params)
                    .then(() => { this.toggleManualEdition(event, btnDOM.closest(".list__item"), false); }, null)
                    .catch(() => { });
                event && event.stopPropagation();
            }
            toggleCollapse(forceCollapse) {
                this._control.node.classList.toggle("collapsed", forceCollapse);
                this._adapter.toggleCollapse.call(this._adapter, this._control.node.classList.contains("collapsed"));
            }
            toggleManualEdition(event, itemElem, forceShow) {
                const manualElem = this._control.node.querySelector(".list__item__manual");
                const isDisplayed = manualElem.style.display !== "none";
                this._adapter
                    .toggleManualEdition
                    .call(this._adapter, event, itemElem, forceShow)
                    .then(() => {
                    this._control.node.classList.toggle("show_manual", forceShow || !isDisplayed);
                    manualElem.style.display = forceShow ? "block" : (forceShow === false || isDisplayed ? "none" : "block");
                });
            }
        }
        AfcGuiConfigGroup.observedAttributes = gui.AfcGuiRepeater.observedAttributes
            .concat(['defaultcursel', 'mru-active', 'mru-handlers', 'mru-id', 'handlers']);
        gui.AfcGuiConfigGroup = AfcGuiConfigGroup;
        gui.registerElement("afc-gui-config-group", AfcGuiConfigGroup);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 28/05/2019.
 */
///<reference path="../Globals.ts" />
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        const _connected = Symbol(), _model = Symbol(), _for = Symbol(), _setProvider = Symbol();
        class BindableElement extends gui.AfcGuiElement {
            /*protected _serialize(context: IContext): void {
                this.id && (context[this.id] = this[_model]);
            }
            
            
            protected _deserialize(context: IContext): void {
                this.id && (this[_model] = context[this.id]) && this._bind();
            }*/
            _setMute(bMute) {
                AFC.Tools.AdapterBase.disable(this._adapter, bMute);
                super._setMute(bMute);
            }
            _onDirty(event) {
                this[_model] && gui._dispatchEvent(this, 'dataChange', { detail: event });
            }
            _bind() {
                let provider = this[_model];
                this.dispatchEvent(new CustomEvent('bind', { detail: provider }));
                if (provider) {
                    this._adapter.bindTo(provider);
                    provider.on(6 /* Tools.EventType.Dirty */, this._onDirty, this);
                }
                return provider;
            }
            _unbind() {
                let provider = this[_model];
                if (provider) {
                    provider.off(6 /* Tools.EventType.Dirty */, this._onDirty, this);
                    this._adapter.unbind();
                }
                this.dispatchEvent(new CustomEvent('unbind', { detail: provider }));
            }
            set model(value) {
                if (this[_model] !== value) {
                    this._unbind();
                    this[_model] = value;
                    this[_connected] && this._bind();
                }
            }
            get model() {
                return this[_model];
            }
            get adapter() {
                return this._adapter;
            }
            connectedCallback() {
                this[_connected] = true;
                this._bind();
            }
            disconnectedCallback() {
                this._unbind();
                this[_connected] = false;
            }
        }
        BindableElement.observedAttributes = gui.AfcGuiElement.observedAttributes;
        gui.BindableElement = BindableElement;
        class ForElement extends BindableElement {
            constructor(setProvider) {
                super();
                this[_setProvider] = setProvider;
            }
            set for(value) {
                if (this[_for] !== value) {
                    this[_for] = value;
                    this[_connected] && this[_setProvider](this, value);
                }
            }
            get for() {
                return this[_for];
            }
            connectedCallback() {
                super.connectedCallback();
                this[_for] && this[_setProvider](this, this[_for]);
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                if (attrName === 'for') {
                    this.for = newVal;
                }
                else {
                    super.attributeChangedCallback(attrName, oldVal, newVal);
                }
            }
        }
        ForElement.observedAttributes = BindableElement.observedAttributes.concat(['for']);
        gui.ForElement = ForElement;
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 04/10/2016.
 */
///<reference path="../../views/controls/Image.ts" />
///<reference path="../../adapters/dashboards/ChartAdapter.ts" />
///<reference path="../../models/data/Global.ts" />
///<reference path="../globals/ForElement.ts" />
///<reference path="../application/root.ts" />
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        const _source = Symbol(), _ctor = Symbol();
        function parentLookup(element, tagName) {
            let parentElement = element.parentElement;
            while (parentElement) {
                if (parentElement.tagName === tagName) {
                    return parentElement;
                }
                parentElement = parentElement.parentElement;
            }
        }
        gui.parentLookup = parentLookup;
        class DashboardView extends gui.ForElement {
            constructor(setProvider, ctor) {
                super(setProvider);
                this.label = new gui.LabelProvider();
                this[_ctor] = ctor;
                this.model = new this[_ctor]();
            }
            set source(value) {
                if (value !== this[_source]) {
                    let guiDashboard = parentLookup(this, 'AFC-GUI-DASHBOARD');
                    value === null ? delete this[_source] : this[_source] = value;
                    if (guiDashboard) {
                        this.model.dashboardModel = guiDashboard.model;
                        this.model.setId(value);
                    }
                    else {
                        this.model = null;
                    }
                }
            }
            get source() {
                return this[_source];
            }
            _bind() {
                let model = super._bind();
                this.label.model = model;
                return model;
            }
            _unbind() {
                this.label.model = null;
                super._unbind();
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                (attrName === 'source') ?
                    setTimeout(() => this.source = newVal, 0) : // set timeout to avoid a bug when connecting
                    super.attributeChangedCallback(attrName, oldVal, newVal);
            }
        }
        DashboardView.observedAttributes = gui.ForElement.observedAttributes.concat(['source']);
        gui.DashboardView = DashboardView;
        function _setChart(chart, forVal) {
            let holder = forVal && document.getElementById(forVal);
            chart.model = holder && holder.chart;
            return holder;
        }
        class AfcGuiChart extends DashboardView {
            constructor() {
                super(_setChart, AFC.Dashboards.ChartModel);
                this._adapter = new AFC.Dashboards.ChartAdapter(new AFC.Controls.ReportPage(this), this.hasAttribute('dataMode'));
            }
            get options() {
                return this._adapter.options;
            }
            set options(value) {
                this._adapter.options = value;
            }
            _resize(screenRect) {
                super._resize(screenRect);
                this._adapter.isData ? this._adapter.control.invalidateSize() : this._adapter.refresh();
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                (attrName === 'options') ? this.options = newVal && JSON.parse(newVal) : super.attributeChangedCallback(attrName, oldVal, newVal);
            }
        }
        AfcGuiChart.observedAttributes = DashboardView.observedAttributes.concat(['options']);
        gui.AfcGuiChart = AfcGuiChart;
        function _setGrid(name, forVal) {
            let holder = forVal && document.getElementById(forVal);
            name.model = holder && holder.grid;
            return holder;
        }
        function _getFunction(s) {
            return gui.StringToFunction(`function($cell) {return ${s}}`);
        }
        class SelectionHandler {
            constructor(element, view) {
                this.element = element;
                this.view = view;
                this.view.selectItem = (key, fire) => {
                    let model = this.model, line;
                    if (model) {
                        line = key ? model.find(key) : -1;
                        this.element.selectLine(line === -1 ? void 0 : line);
                        if (fire && this.view.onItemClick) {
                            this.view.onItemClick && this.view.onItemClick(key, model, model.getRow(line));
                        }
                    }
                };
                this.view.createRemote = () => this;
                this.view.getSelection = () => {
                    let model = this.model, line, row;
                    return model && (line = this.view.selection) !== void 0 && (row = model.getRow(this.adapter.convertLine(line))) && { pk: model.getKeyFromRow(row) };
                };
            }
            get model() {
                return this.element.model?.getForeignDataModel();
            }
            get enabled() {
                return this.view.isItemRowClickEnabled ? this.view.isItemRowClickEnabled() : !!this.model;
            }
            onCellClick(column, line) {
                let model, row, key, detail = {
                    column: column,
                    line: line
                };
                if (line !== -1 && (model = detail.model = this.model) && (row = model.getRow(detail.originalLine = this.adapter.convertLine(line)))) {
                    key = detail.key = model.getKeyFromRow(row);
                    this.view.onItemClick && this.view.onItemClick(key, model, row);
                }
                return detail;
            }
            onGenerate() {
                this.view._builded?.();
            }
            move(offset) {
                let line = this.element.moveFromCurrentLine(offset);
                return line !== void 0 && this.model?.getRow(line);
            }
        }
        /* end handle deprecation */
        const _handler = Symbol(), _selection = Symbol();
        class AfcGuiGrid extends DashboardView {
            constructor() {
                let gridView;
                super(_setGrid, AFC.Dashboards.GridModel);
                gridView = new AFC.Controls.GridView(this);
                this[_handler] = new SelectionHandler(this, gridView);
                this._adapter = this[_handler].adapter = new AFC.Dashboards.GridAdapter(gridView),
                    this._adapter.onCellClick = (column, line) => this.dispatchEvent(new CustomEvent('cellclick', { detail: this[_handler].onCellClick(column, line) }));
                this._adapter.onGenerate = () => {
                    let selection = this[_selection], header = this.querySelector('th');
                    this.style.scrollPaddingTop = header ? `${header.offsetHeight}px` : '';
                    gui._dispatchEvent(this, 'dataReady');
                    this[_handler].onGenerate();
                    selection && this.model.id === selection.id ?
                        this.selectLine(selection.line) :
                        delete this[_selection];
                };
            }
            _onDirty(event) {
                super._onDirty(event);
                this._adapter.enableSelection = this[_handler].enabled;
            }
            _resize(screenRect) {
                super._resize(screenRect);
                this._adapter.control.invalidateSize();
            }
            set template(value) {
                this._adapter.control.template = value;
            }
            get template() {
                return this._adapter.control.template;
            }
            set dataBinder(value) {
                this._adapter.control.dataBinder = value;
            }
            get dataBinder() {
                return this._adapter.control.dataBinder;
            }
            set originalSize(value) {
                this._adapter.control.autoSize = !value;
            }
            get originalSize() {
                return !this._adapter.control.autoSize;
            }
            get selection() {
                let adapter = this._adapter;
                return adapter.convertLine(adapter.control.selection);
            }
            moveFromCurrentLine(offset) {
                let adapter = this._adapter, gridApp = adapter.control.gridApp, rowCount = gridApp ? gridApp.getRowCount() : 0, selection = this.selection;
                if (rowCount && selection !== void 0) {
                    let line = (((adapter.control.selection + offset) % rowCount) + rowCount) % rowCount;
                    adapter.control.highlight(line);
                    line = adapter.convertLine(line /*, Dashboards.ConversionDirection.positionToNative*/);
                    this[_selection] = { id: this.model.id, line };
                    return line;
                }
            }
            selectLine(nativeLine) {
                let line;
                delete this[_selection];
                if (Number.isInteger(nativeLine)) {
                    this[_selection] = { id: this.model.id, line: nativeLine };
                    line = this._adapter.convertLine(nativeLine, 1 /* Dashboards.ConversionDirection.nativeToPosition */);
                }
                this._adapter.control.highlight(line);
            }
            connectedCallback() {
                let templates = this.getElementsByTagName("template");
                let template;
                if (templates) {
                    for (let i = 0; i < templates.length; ++i) {
                        if (templates[i].parentNode === this) {
                            let name = (template = templates[i]).getAttribute('name');
                            this._adapter.control.setTemplate(template.innerHTML, name === null ? void 0 : name);
                        }
                    }
                }
                $(this).empty();
                super.connectedCallback();
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                let f;
                switch (attrName) {
                    case 'template':
                        (f = _getFunction(newVal)) && (this.template = f);
                        break;
                    case 'data-binder':
                        (f = gui.StringToFunction(newVal)) && (this.dataBinder = f);
                        break;
                    case 'original-size':
                        this.originalSize = (newVal !== null);
                        break;
                    default:
                        super.attributeChangedCallback(attrName, oldVal, newVal);
                        break;
                }
            }
        }
        AfcGuiGrid.observedAttributes = DashboardView.observedAttributes.concat(['template', 'data-binder', 'original-size']);
        gui.AfcGuiGrid = AfcGuiGrid;
        let SelectorModeLookup;
        (function (SelectorModeLookup) {
            SelectorModeLookup[SelectorModeLookup["none"] = 0 /* Dashboards.SelectorMode.none */] = "none";
            SelectorModeLookup[SelectorModeLookup["type"] = 1] = "type";
            SelectorModeLookup[SelectorModeLookup["link"] = 2] = "link";
        })(SelectorModeLookup || (SelectorModeLookup = {}));
        function _updateSelectorMode(selector, value) {
            let mode = SelectorModeLookup[value] || 1 /* Dashboards.SelectorMode.type */;
            selector.mode = mode;
        }
        class AfcGuiSelector extends gui.BindableElement {
            constructor() {
                let list = document.createElement('div'), radio = document.createElement('div');
                super();
                radio.addEventListener('change', e => e.stopPropagation());
                this._adapter = new AFC.Dashboards.SelectorAdapter(new AFC.Controls.Selector(list, radio));
                this._adapter.onChange = (eventData) => gui._dispatchEvent(this, 'change', { detail: eventData });
                this.appendChild(radio);
                this.appendChild(list);
            }
            set mode(value) {
                this._adapter.mode = value;
            }
            get mode() {
                return this._adapter.mode;
            }
            get map() {
                return this._adapter.map;
            }
            get grid() {
                return this._adapter.grid;
            }
            get chart() {
                return this._adapter.chart;
            }
            get filter() {
                return this._adapter.filter;
            }
            set filter(value) {
                this._adapter.filter = value;
            }
            connectedCallback() {
                let guiDashboard;
                super.connectedCallback();
                (guiDashboard = parentLookup(this, 'AFC-GUI-DASHBOARD')) && (this.model = guiDashboard.model);
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                switch (attrName) {
                    case 'mode':
                        _updateSelectorMode(this, newVal);
                        break;
                    case 'filter':
                        this.filter = gui.StringToFunction(newVal);
                        break;
                    default:
                        super.attributeChangedCallback(attrName, oldVal, newVal);
                        break;
                }
            }
            selectPrevious() {
                return this._adapter.previous();
            }
            selectNext() {
                return this._adapter.next();
            }
            selectItem(value) {
                return this._adapter.selectItem(value);
            }
            getDashboardFilter(mode) {
                return this._adapter.getDashboardFilter(mode);
            }
        }
        AfcGuiSelector.observedAttributes = gui.BindableElement.observedAttributes.concat(['mode', 'filter']);
        gui.AfcGuiSelector = AfcGuiSelector;
        const _dashboard = Symbol(), _rest = Symbol(), _setInstance = Symbol();
        class AfcGuiDashboard extends gui.AfcGuiDiv {
            constructor() {
                super();
                this.model = new AFC.Dashboards.DashboardModel();
            }
            /** @internal */
            [_setInstance]() {
                let name = this[_dashboard], restModel = this[_rest];
                name && restModel && AFC.Dashboards.getDashboard(restModel, name).then(dashboard => this.model.dashboard = dashboard);
            }
            _onSaveInstanceState(context, savedInstanceState) {
                super._onSaveInstanceState(context, savedInstanceState);
                this.id && savedInstanceState.putValue(this.id, {
                    dashboard: this[_dashboard],
                    instance: this.model.dashboard
                });
            }
            _onRestoreViewState(activity, fragmentManager, savedInstanceState) {
                let data, instance;
                super._onRestoreViewState(activity, fragmentManager, savedInstanceState);
                this[_rest] = activity.getRestModel();
                if (savedInstanceState && this.id && (data = savedInstanceState.getValue(this.id))) {
                    instance = data.instance;
                    this[_dashboard] = data.dashboard;
                }
                instance ? this.model.dashboard = instance : this[_setInstance]();
            }
            get dashboard() {
                return this[_dashboard];
            }
            set dashboard(value) {
                this[_dashboard] = value;
                this[_setInstance]();
            }
            get instance() {
                return this.model.dashboard;
            }
            set instance(value) {
                delete this[_dashboard];
                this.model.dashboard = value;
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                attrName === 'dashboard' ? this.dashboard = newVal : super.attributeChangedCallback(attrName, oldVal, newVal);
            }
            disconnectedCallback() {
                this.model.release();
            }
        }
        AfcGuiDashboard.observedAttributes = gui.AfcGuiDiv.observedAttributes.concat(['dashboard']);
        gui.AfcGuiDashboard = AfcGuiDashboard;
        function _applyToChildren(element, f) {
            $(element).find('afc-gui-chart,afc-gui-grid').each(function (indice) {
                let parent = this;
                while (parent.parentNode !== element) {
                    parent = parent.parentNode;
                }
                f(this, parent, indice);
            });
        }
        class AfcGuiSplitter extends gui.AfcGuiElement {
            constructor() {
                super();
                this.addEventListener('dataChange', this._onDataChange);
            }
            _onSaveInstanceState(context, savedInstanceState) {
                let hidden = [];
                super._onSaveInstanceState(context, savedInstanceState);
                _applyToChildren(this, (view, parent) => hidden.push(parent.hidden));
                this.id && savedInstanceState.putValue(this.id, hidden);
            }
            _onRestoreViewState(context, fragmentManager, savedInstanceState) {
                super._onRestoreViewState(context, fragmentManager, savedInstanceState);
                if (savedInstanceState && this.id) {
                    let hidden = savedInstanceState.getValue(this.id);
                    if (hidden) {
                        _applyToChildren(this, (view, parent, indice) => parent.hidden = hidden[indice]);
                    }
                }
            }
            _onDataChange(e) {
                let target = e.target;
                target.model && target.model.getType().then(viewType => {
                    let globalWide = false;
                    let bFound = false;
                    let children = [];
                    let ref = (viewType !== void 0) && target;
                    _applyToChildren(this, (view, parent) => {
                        let viewModel = view.model, properties, grow = 0;
                        if (viewModel && (properties = viewModel.properties)) {
                            let index = viewModel.dashboard.viewsProperties, wide = index.iswide && properties[index.iswide][2];
                            grow = index.width ? properties[index.width][2] : 1;
                            globalWide = wide || globalWide;
                            ref || (ref = view);
                        }
                        children.push({ gui: view, parent: parent, target: (ref === view), grow: grow });
                        bFound = bFound || (target === view);
                    });
                    bFound && children.reduce((acc, item, indice) => {
                        item.parent.hidden = globalWide && !item.target;
                        item.parent.style.flexGrow = globalWide ? null : item.grow;
                        return acc;
                    }, 100);
                });
            }
        }
        AfcGuiSplitter.observedAttributes = gui.AfcGuiElement.observedAttributes;
        gui.AfcGuiSplitter = AfcGuiSplitter;
        function _attachRedistrict(redistrict, id) {
            redistrict.setRedistrictable(id && document.getElementById(id));
        }
        let RedistrictColumnType;
        (function (RedistrictColumnType) {
            RedistrictColumnType[RedistrictColumnType["integer"] = 1] = "integer";
            RedistrictColumnType[RedistrictColumnType["real"] = 2] = "real";
            RedistrictColumnType[RedistrictColumnType["string"] = 3] = "string";
            RedistrictColumnType[RedistrictColumnType["sum"] = 4] = "sum";
        })(RedistrictColumnType || (RedistrictColumnType = {}));
        ;
        let RedistrictColumnTypeLookup;
        (function (RedistrictColumnTypeLookup) {
            RedistrictColumnTypeLookup[RedistrictColumnTypeLookup["integer"] = 1] = "integer";
            RedistrictColumnTypeLookup[RedistrictColumnTypeLookup["real"] = 2] = "real";
            RedistrictColumnTypeLookup[RedistrictColumnTypeLookup["string"] = 3] = "string";
            RedistrictColumnTypeLookup[RedistrictColumnTypeLookup["sum"] = 4] = "sum";
        })(RedistrictColumnTypeLookup || (RedistrictColumnTypeLookup = {}));
        ;
        const DataKindLookup = {
            [1 /* RedistrictColumnType.integer */]: 3 /* Data.DataKind.integer */,
            [2 /* RedistrictColumnType.real */]: 2 /* Data.DataKind.real */,
            [3 /* RedistrictColumnType.string */]: 1 /* Data.DataKind.character */,
            [4 /* RedistrictColumnType.sum */]: 2 /* Data.DataKind.real */
        };
        function _mapType(type_) {
            return DataKindLookup[type_];
        }
        class CustomColumn {
            constructor(operator, name, size, value) {
                this.type = operator;
                this.definition = new AFC.Data.DBColumn(name, _mapType(operator), -1, size);
                this.value = value;
            }
        }
        let ZoneType;
        (function (ZoneType) {
            ZoneType[ZoneType["subset"] = 1] = "subset";
            ZoneType[ZoneType["outOfZone"] = 2] = "outOfZone";
            ZoneType[ZoneType["total"] = 3] = "total";
        })(ZoneType = gui.ZoneType || (gui.ZoneType = {}));
        const _lastColumn = 4;
        class AggregateModel extends AFC.Data.DataModelBase {
            constructor() {
                super([
                    new AFC.Data.DBColumn('order', 3 /* Data.DataKind.integer */, -1, 4),
                    new AFC.Data.DBColumn('id', 1 /* Data.DataKind.character */, 0, 255),
                    new AFC.Data.DBColumn('name', 1 /* Data.DataKind.character */, -1, 255),
                    new AFC.Data.DBColumn('type', 3 /* Data.DataKind.integer */, -1, 4)
                ], ['order'], []);
                this.on(1073741824 /* Tools.EventType.Attach */, this._on, this);
            }
            _getScope(columns, row) {
                let $scope = {};
                columns.forEach((column, indice) => {
                    $scope[column.name] = row[indice];
                });
                return $scope;
            }
            _on( /*event: Tools.IEvent*/) {
                let dataNode;
                if (this._appended && this.values.length && this.dataModel && (dataNode = this._descriptor.dataNodes.find(dataNode => dataNode.qualifier === 4 /* Dashboards.DataQualifier.partition */))) {
                    let partition = this.dataModel.columns.findIndex(column => column.alias === dataNode.name), items, changes = {}, index = {}, scopes = this.values.map(row => {
                        let scope = {}, value = row[2];
                        index[value] || (index[value] = scope);
                        return scope;
                    }), last = scopes[scopes.length - 1], update = (i, j, value) => {
                        let row = this.values[i];
                        if (!AFC.Tools.Data.isValid(this.columns[j].type, value))
                            value = null;
                        if (value !== row[j]) {
                            row[j] = value;
                            changes[i] || (items || (items = [])).push(changes[i] = {
                                row: row,
                                type: 2 /* Data.DataEventType.modify */,
                                committed: true
                            });
                        }
                        return value;
                    };
                    this.columns.forEach((column, j) => {
                        let redistrictColumn, columnName = column.name;
                        if ((j < _lastColumn) || ((redistrictColumn = this._appended[j - _lastColumn]).type !== 4 /* RedistrictColumnType.sum */)) {
                            scopes.forEach((scope, i) => scope[columnName] = j < _lastColumn ?
                                this.values[i][j] :
                                update(i, j, redistrictColumn.value(scope, scopes)));
                        }
                        else {
                            scopes.forEach(scope => scope[columnName] = 0);
                            for (let l = 0, lCount = this.dataModel.length; l < lCount; ++l) {
                                let row = this.dataModel.getRow(l), scope = index[row[partition]];
                                if (scope !== last) {
                                    let value = redistrictColumn.value(scope, scopes, AFC.Tools.Data.mapRow(this.dataModel.columns, row));
                                    scope[columnName] += value;
                                    last[columnName] += value;
                                }
                                ;
                            }
                            scopes.forEach((scope, i) => scope[columnName] = update(i, j, scope[columnName]));
                        }
                    });
                    items && this.fireEvent(6 /* Tools.EventType.Dirty */, new AFC.Data.DataEventData(items));
                }
            }
            _onDirty( /*event: Data.IDataEvent*/) {
                this.fireEvent(1073741824 /* Tools.EventType.Attach */);
            }
            setParameters(parameters) {
                let values = this.values, dataModel = this.dataModel, zone, descriptor, partition;
                values.length = 0;
                if (dataModel) {
                    dataModel.off(6 /* Tools.EventType.Dirty */, this._onDirty, this);
                    delete this.dataModel;
                }
                if (parameters && (dataModel = parameters.dataModel) && (zone = parameters.zone) && (descriptor = parameters.descriptor) && (partition = descriptor.partition)) {
                    let property = parameters.colorProperty, classes = property?.thematic?.classes;
                    this.dataModel = dataModel;
                    this._descriptor = descriptor;
                    classes && this.attachColumn(new CustomColumn(3 /* RedistrictColumnType.string */, 'color', 7, ($scope) => classes[$scope.order] ? AFC.Tools.Style.convertColor(classes[$scope.order].value) : null));
                    this.attachColumn(new CustomColumn(3 /* RedistrictColumnType.string */, 'label', 255, ($scope) => classes?.[$scope.order]?.pattern ?? $scope.name));
                    partition.subsets.forEach((subset, indice) => (subset.type !== 11 /* Dashboards.ZoneType.subsetUnion */) && values.push([
                        values.length,
                        subset.id,
                        subset.value,
                        subset.type !== 12 /* Dashboards.ZoneType.outOfZone */ ? 1 /* ZoneType.subset */ : 2 /* ZoneType.outOfZone */
                    ]));
                    values.push([values.length, zone.id, zone.name, 3 /* ZoneType.total */]);
                    dataModel.on(6 /* Tools.EventType.Dirty */, this._onDirty, this);
                    this.fireEvent(1073741824 /* Tools.EventType.Attach */);
                }
            }
            attachColumn(column) {
                let definition = column.definition;
                let index = this.columnIndex[definition.name];
                if (index === void 0) {
                    this.columnIndex[definition.name] = index = this.columns.length;
                }
                else if (index < _lastColumn) {
                    return;
                }
                this.columns[index] = definition;
                (this._appended || (this._appended = []))[index - _lastColumn] = column;
                if (this.values.length) {
                    this.values.forEach((row) => row[index] = null);
                    this.fireEvent(1073741824 /* Tools.EventType.Attach */);
                }
            }
            detachColumn(name) {
                let index = this.columnIndex[name];
                if ((index !== void 0) && (index >= _lastColumn)) {
                    delete this.columnIndex[name];
                    for (let i = index + 1; i < this.columns.length; ++i) {
                        --this.columnIndex[this.columns[i].name];
                    }
                    this.columns.splice(index, 1);
                    this._appended.length == 1 ? delete this._appended : this._appended.splice(index - _lastColumn, 1);
                    if (this.values.length) {
                        this.values.forEach((row) => row.splice(index, 1));
                        this.fireEvent(1073741824 /* Tools.EventType.Attach */);
                    }
                }
            }
            refresh() {
                this.fireEvent(1073741824 /* Tools.EventType.Attach */);
            }
        }
        function _getFunction2(value, type_) {
            return gui.StringToFunction(type_ !== 4 /* RedistrictColumnType.sum */ ? `function($scope,$scopes) { return ${value}; }` : `function($scope,$scopes,$row) { return ${value}; }`);
        }
        const _for = Symbol(), _redistrictable = Symbol(), _connected = Symbol(), _name = Symbol(), _definition = Symbol(), _type = Symbol(), _value = Symbol();
        class AfcGuiColumn extends HTMLElement {
            constructor() {
                super();
                this[_type] = 3 /* RedistrictColumnType.string */;
            }
            set name(value) {
                delete this[_definition];
                this[_name] = value;
            }
            get name() {
                return this[_name];
            }
            set type(value) {
                if (this[_type] !== value) {
                    delete this[_value];
                    this[_type] = value;
                }
            }
            get type() {
                return this[_type];
            }
            set value(value) {
                this[_value] = value;
            }
            get value() {
                return this[_value] || (this[_value] = _getFunction2(this.getAttribute('value'), this.type));
            }
            get definition() {
                return this[_definition] || (this[_definition] = new AFC.Data.DBColumn(this[_name], _mapType(this[_type]), -1, 0));
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                switch (attrName) {
                    case 'name':
                        this.name = newVal;
                        break;
                    case 'type':
                        let type = RedistrictColumnTypeLookup[newVal];
                        type && (this.type = type);
                        break;
                    case 'value':
                        delete this[_value];
                        break;
                }
            }
            connectedCallback() {
                let parent = this.parentNode;
                if (parent && parent.tagName === 'AFC-GUI-REDISTRICT') {
                    parent.model.attachColumn(this);
                }
            }
            disconnectedCallback() {
                let parent = this.parentNode;
                if (parent && parent.tagName === 'AFC-GUI-REDISTRICT') {
                    parent.model.detachColumn(this.name);
                }
            }
        }
        AfcGuiColumn.observedAttributes = ['name', 'type', 'value'];
        gui.AfcGuiColumn = AfcGuiColumn;
        class AfcGuiRedistrict extends gui.AfcGuiElement {
            constructor() {
                super();
                this.model = new AggregateModel();
                this.addEventListener('dataChange', AfcGuiRedistrict._onDataChange);
            }
            static _onDataChange(e) {
                let self = e.currentTarget, query = $(self).find('input[name=__redistrict]');
                query.filter(':checked').length || query.val([self.model.length - 1]);
            }
            set for(value) {
                if (this[_for] !== value) {
                    _attachRedistrict(this, value);
                    this[_for] = value;
                }
            }
            get for() {
                return this[_for];
            }
            get selected() {
                let s = $(this).find('input[name=__redistrict]:checked').val(), selected, row;
                if (s && !isNaN(selected = parseInt(s)) && (selected < this.model.length)) {
                    row = this.model.values[selected];
                    if (row && row[3] !== 3 /* ZoneType.total */) {
                        return row[1];
                    }
                }
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                attrName === 'for' ? this.for = newVal : super.attributeChangedCallback(attrName, oldVal, newVal);
            }
            connectedCallback() {
                _attachRedistrict(this, this[_for]);
            }
            disconnectedCallback() {
                _attachRedistrict(this);
            }
            setRedistrictable(element) {
                let old = this[_redistrictable];
                if (old !== element) {
                    old?.detachRedistrict?.(this);
                    this.model.setParameters();
                    (this[_redistrictable] = element)?.attachRedistrict?.(this);
                }
            }
            _dataBind(repeater, name, key, value) {
                let aKeys, isCumul, isCumulPct, isPct, items, sResult = this.redistrictDataBinder(name, key, value);
                if (sResult === void 0) {
                    aKeys = AFC.Controls.Repeater.splitKey(key);
                    if (aKeys.length == 2) {
                        if (aKeys[0] == 'cumul') {
                            isCumul = true;
                        }
                        else if (aKeys[0] == 'cumulPct') {
                            isCumulPct = true;
                        }
                        else if (aKeys[0] == 'pct') {
                            isPct = true;
                        }
                    }
                    if (isCumul || isCumulPct || isPct) {
                        items = [];
                        if (value && value.dataItem) {
                            if (isPct)
                                items.push(value);
                            else if (value.dataItem.type == 1 /* ZoneType.subset */) {
                                for (let i = 0; i < this.model.length; i++) {
                                    let item = this.model.item(i);
                                    if (item.dataItem.type === 1 /* ZoneType.subset */)
                                        items.push(item);
                                }
                                repeater.compare && items.sort(repeater.compare);
                            }
                            else if (value.dataItem.type == 3 /* ZoneType.total */)
                                items.push(value);
                        }
                        if (items.length > 0) {
                            let cumul = 0;
                            for (let i = 0; i < items.length; i++) {
                                cumul += items[i].dataItem[aKeys[1]];
                                if (items[i].dataItemIndex === value.dataItemIndex) {
                                    break;
                                }
                            }
                            if (isCumulPct || isPct) {
                                let typeColIndex = this.model.columnIndex.type, totalZoneValuesIndex = this.model.values.findIndex(row => row[typeColIndex] === 3 /* ZoneType.total */), totalValue;
                                if (totalZoneValuesIndex >= 0 && (totalValue = this.model.item(totalZoneValuesIndex).dataItem[aKeys[1]])) {
                                    cumul /= totalValue;
                                    cumul = Math.round(cumul * 1000) / 10;
                                }
                                else {
                                    return '-';
                                }
                            }
                            sResult = cumul.toString();
                        }
                    }
                }
                return sResult;
            }
            redistrictDataBinder(name, key, value) {
            }
            setParameters(parameters) {
                let repeaters = this.getElementsByTagName('afc-gui-repeater'), repeater = repeaters && repeaters[0];
                if (repeater) {
                    this.model.setParameters(parameters);
                    repeater.dataBinder = this._dataBind.bind(this, repeater);
                    repeater.bindTo(this.model);
                }
            }
            refresh() {
                this.model.refresh();
            }
        }
        AfcGuiRedistrict.observedAttributes = gui.AfcGuiElement.observedAttributes.concat(['for']);
        gui.AfcGuiRedistrict = AfcGuiRedistrict;
        gui.registerElement("afc-gui-chart", AfcGuiChart);
        gui.registerElement("afc-gui-grid", AfcGuiGrid);
        gui.registerElement("afc-gui-selector", AfcGuiSelector);
        gui.registerElement("afc-gui-dashboard", AfcGuiDashboard);
        gui.registerElement("afc-gui-splitter", AfcGuiSplitter);
        gui.registerElement("afc-gui-redistrict", AfcGuiRedistrict);
        gui.registerElement("afc-gui-redistrict-column", AfcGuiColumn);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 18/01/2017.
 */
///<reference path="Dashboards.ts" />
///<reference path="../../adapters/dashboards/MapAdapter.ts" />
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        function _setMap(guiMap, forVal) {
            let holder = forVal && document.getElementById(forVal);
            guiMap.model = holder && holder.map;
            return holder;
        }
        const _district = Symbol(), _districtProvider = Symbol(), _districtLayer = Symbol();
        class AfcGuiMap extends gui.DashboardView {
            constructor() {
                super(_setMap, AFC.Dashboards.MapModel);
                this._adapter = new AFC.Dashboards.MapAdapter();
                this._adapter.onUpdate = (districtProvider) => {
                    this[_districtProvider] = districtProvider;
                    delete this[_districtLayer];
                    this[_district] && districtProvider && Promise.all([districtProvider.getLayer(), districtProvider.getDistrictParameters()]).then(results => {
                        if (results[0] && this[_district]) {
                            this[_districtLayer] = results[0].layerModel;
                            this[_district].setParameters(results[1]);
                        }
                    });
                    gui._dispatchEvent(this, 'layersChange');
                };
            }
            getCount() {
                return this._adapter.getCount();
            }
            getLayerProvider(indice) {
                return this._adapter.getLayerProvider(indice);
            }
            getBbox() {
                return this.model.getBbox();
            }
            getInfo() {
                return this._adapter.getInfo();
            }
            canDistrict() {
                return this._adapter.canDistrict();
            }
            enableDistricting(enable, indicators) {
                this._adapter.enableDistricting(enable, indicators);
            }
            isRedistricted() {
                return this._adapter.isRedistricted();
            }
            resetDistrict() {
                this._adapter.resetDistrict();
            }
            get handlers() {
                return this.canDistrict() && {
                    click: (latlng, info, event) => {
                        let feature, data, model;
                        if (this[_district] && info && ((model = info.model) === this[_districtLayer]) && (feature = info.feature?.feature) && (data = feature.properties?.data)) {
                            this[_districtProvider].affectRow(model.data, data, this[_district].selected);
                        }
                        return true;
                    }
                };
            }
            getDistrictProvider() {
                return this[_districtProvider];
            }
            refresh() {
                this._adapter.refresh();
            }
            attachRedistrict(redistrict) {
                this[_district] = redistrict;
            }
            detachRedistrict(redistrict) {
                delete this[_district];
            }
            getRedistrict() {
                return this[_district];
            }
            disconnectedCallback() {
                delete this[_district];
            }
        }
        gui.AfcGuiMap = AfcGuiMap;
        gui.registerElement("afc-gui-map", AfcGuiMap);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 19/09/2017.
 */
///<reference path="../Globals.ts" />
///<reference path="../../models/data/Data.ts" />
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        class AfcGuiComboBox extends gui.AfcBindableElement {
            constructor() {
                super();
                this._adapter = new AFC.Data.ComboBoxAdapter(this._control = new AFC.Controls.ComboBox(this));
                this._adapter.onControlChange = this.onchange;
            }
            _onGenerate() {
                this._control.loadingEnd();
                gui._dispatchEvent(this, 'dataChange');
            }
            connectedCallback() {
                $(this).empty();
                this._control.loadingStart();
                this._adapter.onGenerate = this._onGenerate.bind(this);
                super.connectedCallback();
            }
            disconnectedCallback() {
                delete this._adapter.onGenerate;
                super.disconnectedCallback();
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                switch (attrName) {
                    case 'value':
                        this.value = newVal;
                        break;
                    case 'disabled':
                        this._control.disabled = (newVal != "" ? true : false);
                        break;
                    default:
                        super.attributeChangedCallback(attrName, oldVal, newVal);
                        break;
                }
            }
            set disabled(newVal) {
                if (newVal)
                    this.setAttribute("disabled", "");
                else
                    this.removeAttribute("disabled");
                this._control.disabled = newVal;
            }
            get disabled() {
                return this._control.disabled;
            }
            set value(newVal) {
                this._adapter.value = newVal;
            }
            get value() {
                return this._adapter.value;
            }
            refresh() {
                this._adapter.refresh();
            }
        }
        AfcGuiComboBox.observedAttributes = gui.AfcBindableElement.observedAttributes.concat(['value', 'disabled']);
        gui.AfcGuiComboBox = AfcGuiComboBox;
        gui.registerElement("afc-gui-combobox", AfcGuiComboBox);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 08/12/2020.
 */
///<reference path="../Globals.ts" /> 
var AFC;
(function (AFC) {
    var Application;
    (function (Application) {
        function _getSafeName(template) {
            let s = template.getAttribute('name');
            return s === null ? "" : s;
        }
        function _setData(dataRecord, input, column, rootForm) {
            if (input.tagName !== 'LABEL') {
                let value, ret;
                if (dataRecord.setData) {
                    switch (input.type) {
                        case 'radio':
                            let name = input.getAttribute('name'), selector = `input[type='radio'][name='${name}']:checked`, val = rootForm ? $(rootForm).find(selector).val() : $(selector).val();
                            value = val === void 0 ? null : val;
                            break;
                        case 'checkbox':
                            value = input.checked;
                            break;
                        default:
                            value = input.value;
                            break;
                    }
                    ret = dataRecord.setData(column.name, AFC.Tools.Data.castInputValue(column, value));
                }
                return ret;
            }
        }
        function _getData(dataRecord, input, column, rootForm) {
            let value = dataRecord.getData(column.name);
            if (input.tagName === 'LABEL') {
                let str = value === null ? ' - ' : (AFC.Tools.Data.isNumber(value) ? new Intl.NumberFormat().format(value) : value), query = $(input);
                query.empty().append(document.createTextNode(str));
            }
            else {
                switch (input.type) {
                    case 'radio':
                        let name = input.getAttribute('name'), selector = `input[type='radio'][name='${name}']`, radios = rootForm ? $(rootForm).find(selector) : $(selector);
                        radios.prop('checked', function () { return AFC.Tools.Data.castInputValue(column, this.value) === value; });
                        break;
                    case 'checkbox':
                        input.checked = !!value;
                        break;
                    case 'date':
                        {
                            let offset = value.getTimezoneOffset(), date = new Date(value.getTime() + (offset * 60000));
                            input.value = date.toISOString().split('T')[0];
                        }
                        break;
                    default:
                        input.value = value;
                        break;
                }
            }
        }
        const _timeout = Symbol(), _forEach = Symbol(), _on = Symbol(), _off = Symbol(), _record = Symbol(), _onDirty = Symbol(), _template = Symbol(), _oldTemplate = Symbol(), _templates = Symbol(), _dataChange = Symbol(), _detail = Symbol(), _refresh = Symbol(), _onChange = Symbol(), _onKeyUp = Symbol(), _onClick = Symbol(), _dispatch = Symbol();
        class AfcForm extends AFC.gui.AfcGuiElement {
            /** @internal */
            [_refresh](dataRecord) {
                if (this[_timeout] === void 0) {
                    this[_timeout] = setTimeout(() => {
                        delete this[_timeout];
                        if (this[_oldTemplate] !== void 0) {
                            let nodes = this.querySelectorAll(`[data-template="${this[_oldTemplate]}"]`), node;
                            for (let i = 0; i < nodes.length; ++i) {
                                (node = nodes[i]).parentNode.removeChild(node);
                            }
                            delete this[_oldTemplate];
                        }
                        if (dataRecord) {
                            let key = this[_template] || '', templates;
                            if (this[_templates] && (templates = this[_templates][key])) {
                                templates.forEach(template => {
                                    let fragment = document.createDocumentFragment();
                                    AFC.Controls.Repeater.generateContent(fragment, key, template, dataRecord);
                                    $(fragment).children().attr('data-template', key);
                                    template.parentNode.insertBefore(fragment, template.refNode);
                                });
                                this[_oldTemplate] = key;
                            }
                            this[_forEach](dataRecord, _getData);
                            this.dispatchEvent(new CustomEvent('draw', { bubbles: false, detail: dataRecord }));
                        }
                    }, 0);
                }
            }
            /** @internal */
            [_forEach](dataRecord, onColumn) {
                let inputs = this.querySelectorAll('*[bind]');
                let i, column;
                for (i = 0; i < inputs.length; ++i) {
                    (column = this._getColumnForInput(dataRecord, inputs[i])) && onColumn(dataRecord, inputs[i], column, this);
                }
            }
            /** @internal */
            [_on]() {
                this[_record] && this[_record].on && this[_record].on(6 /* AFC.Tools.EventType.Dirty */, this[_onDirty], this);
            }
            /** @internal */
            [_off]() {
                this[_record] && this[_record].off && this[_record].off(6 /* AFC.Tools.EventType.Dirty */, this[_onDirty], this);
            }
            /** @internal */
            [_onDirty](event) {
                let index = {}, dataRecord = this[_record];
                let _this = this;
                this[_forEach](dataRecord, (dataRecord, input, column) => {
                    index[column.name] = input;
                });
                event.data.columns.forEach(function (column) {
                    let input = index[column.name];
                    input && _getData(dataRecord, index[column.name], column, _this);
                });
            }
            /** @internal */
            [_onClick](event) {
                let target = event.target;
                if (target.getAttribute && (target.getAttribute('name') === 'submit')) {
                    event.stopPropagation();
                    this.submit();
                }
            }
            /** @internal */
            [_dispatch](column) {
                let detail = this[_detail];
                if (!detail) {
                    this[_detail] = detail = [];
                    setTimeout(() => {
                        delete this[_detail];
                        this.dispatchEvent(new CustomEvent("dataChange", { bubbles: false, cancelable: false, detail: detail }));
                    }, 0);
                }
                detail.push(column);
                return true;
            }
            /** @internal */
            [_onChange](event) {
                let dataRecord = this[_record], input = event.target, column;
                dataRecord && (column = this._getColumnForInput(this[_record], input)) && _setData(this[_record], input, column, this) && this[_dispatch](column);
            }
            /** @internal */
            [_onKeyUp](event) {
                if (event.key === 'Enter') {
                    this.submit();
                }
            }
            _getColumnForInput(dataRecord, input) {
                let name, bind, qualifier, column;
                if ((name = input.getAttribute('name')) && (bind = input.getAttribute('bind'))) {
                    switch (bind.toLowerCase()) {
                        case 'column':
                            column = dataRecord.getColumn(name);
                            break;
                        case 'qualifier':
                            ((qualifier = AFC.Data.qualifier(name)) !== void 0) && dataRecord.getQualifiedColumn && (column = dataRecord.getQualifiedColumn(qualifier));
                            break;
                    }
                }
                return column;
            }
            getColumnForInput(input) {
                return this._getColumnForInput(this[_record], input);
            }
            setValue(column, value, fireEvent) {
                let dataRecord = this[_record];
                if (dataRecord && dataRecord.setData) {
                    return dataRecord.setData(column.name, AFC.Tools.Data.castInputValue(column, value)) && (!fireEvent || this[_dispatch](column));
                }
            }
            constructor() {
                super();
                this.addEventListener('click', this[_onClick].bind(this), true);
                this.addEventListener('change', this[_onChange].bind(this), true);
                this.addEventListener('keyup', this[_onKeyUp].bind(this), true);
            }
            get dataRecord() {
                return this[_record];
            }
            set dataRecord(value) {
                if (this[_record] !== value) {
                    this[_off]();
                    this[_refresh](this[_record] = value);
                    this[_on]();
                }
            }
            get template() {
                return this[_template];
            }
            set template(value) {
                if (this[_template] !== value) {
                    this[_template] = value;
                    this[_refresh](this[_record]);
                }
            }
            get ondatachange() {
                return this[_dataChange];
            }
            set ondatachange(value) {
                if (this[_dataChange] !== value) {
                    this[_dataChange] && this.removeEventListener('dataChange', this[_dataChange]);
                    (this[_dataChange] = value) && this.addEventListener('dataChange', value);
                }
            }
            connectedCallback() {
                let templateNodes = this.getElementsByTagName('template');
                let templateNode, key, templates;
                if (templateNodes) {
                    for (let i = templateNodes.length; i > 0; --i) {
                        key = _getSafeName(templateNode = templateNodes[i - 1]);
                        templates = (this[_templates] || (this[_templates] = {}))[key] || (this[_templates][key] = []);
                        templates.push({
                            parentNode: templateNode.parentNode,
                            refNode: templateNode.nextSibling,
                            content: templateNode.innerHTML
                        });
                        templateNode.parentNode.removeChild(templateNode);
                    }
                }
                let e = new CustomEvent("connected", { bubbles: false, cancelable: false });
                let onConnected = this.getAttribute('onconnected');
                this.dispatchEvent(e);
                try {
                    onConnected && eval("(function(event) { " + onConnected + "})")(e);
                }
                catch (e) {
                }
                this[_on]();
            }
            disconnectedCallback() {
                this[_off]();
            }
            submit() {
                this[_record] && this[_forEach](this[_record], _setData);
                this.dispatchEvent(new Event("submit", { bubbles: true, cancelable: true }));
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                attrName === 'template' ? this.template = newVal : super.attributeChangedCallback(attrName, oldVal, newVal);
            }
        }
        AfcForm.observedAttributes = AFC.gui.AfcGuiElement.observedAttributes.concat(['template', 'datachange']);
        Application.AfcForm = AfcForm;
        AFC.gui.registerElement("afc-gui-form", AfcForm);
    })(Application = AFC.Application || (AFC.Application = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 03/04/2017.
 */
///<reference path="../Globals.ts" />
///<reference path="../../adapters/data/PanelAdapter.ts" />
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        const _getParent = (element) => gui.parentLookup(element, 'AFC-GUI-PANEL-HOLDER');
        const _id = Symbol(), _name = Symbol(), _source = Symbol(), _dashboardModel = Symbol();
        class AfcGuiPanel extends HTMLElement {
            set name(value) {
                if (this[_name] != value) {
                    this[_name] = value;
                    this[_id] && this[_source].adapter.refresh(this[_id]);
                }
            }
            get name() {
                return this[_name];
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                attrName === 'name' && (this.name = newVal);
            }
            connectedCallback() {
                let parent = _getParent(this);
                parent && (this[_id] = (this[_source] = parent).adapter.add(new AFC.Data.LabelPanel(this, new AFC.Controls.Label(this))));
            }
            disconnectedCallback() {
                let id = this[_id];
                if (id) {
                    this[_source].adapter.remove(id);
                    delete this[_id];
                }
            }
        }
        AfcGuiPanel.observedAttributes = ['name'];
        gui.AfcGuiPanel = AfcGuiPanel;
        class AfcGuiPanelHolder extends gui.BindableElement {
            constructor() {
                super();
                this._adapter = new AFC.Data.PanelAdapter();
            }
            set source(value) {
                if (this[_source] !== value) {
                    let model = new AFC.Dashboards.GridModel();
                    model.setId(this[_source] = value);
                    this.model = model;
                }
            }
            get source() {
                return this[_source];
            }
            _bind() {
                let model = super._bind(), guiDashboard;
                if (model instanceof AFC.Dashboards.GridModel && (guiDashboard = gui.parentLookup(this, 'AFC-GUI-DASHBOARD'))) {
                    model.dashboardModel = guiDashboard.model;
                }
                return model;
            }
            _unbind() {
                let model = this.model;
                if (model instanceof AFC.Dashboards.GridModel) {
                    model.dashboardModel = null;
                }
                super._unbind();
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                (attrName === 'source') ? this.source = newVal : super.attributeChangedCallback(attrName, oldVal, newVal);
            }
        }
        AfcGuiPanelHolder.observedAttributes = gui.BindableElement.observedAttributes.concat(['source']);
        gui.AfcGuiPanelHolder = AfcGuiPanelHolder;
        gui.registerElement("afc-gui-panel-holder", AfcGuiPanelHolder);
        gui.registerElement("afc-gui-panel", AfcGuiPanel);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 28/05/2019.
 */
///<reference path="ForElement.ts" />
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        class LabelProvider extends AFC.Tools.EventSink {
            _onAttach( /*event: Tools.IEvent*/) {
                this.fireEvent(6 /* Tools.EventType.Dirty */);
            }
            _onDirty( /*event: Tools.IEvent*/) {
                this.fireEvent(1073741824 /* Tools.EventType.Attach */);
            }
            constructor() {
                super();
                this.on(1073741824 /* Tools.EventType.Attach */, this._onAttach, this);
            }
            get label() {
                return this._model && this._model.label;
            }
            set model(value) {
                if (value !== this._model) {
                    this._model && this._model.off(6 /* Tools.EventType.Dirty */, this._onDirty, this);
                    value ? (this._model = value).on(6 /* Tools.EventType.Dirty */, this._onDirty, this) : delete this._model;
                    this.fireEvent(1073741824 /* Tools.EventType.Attach */);
                }
            }
            get model() {
                return this._model;
            }
        }
        gui.LabelProvider = LabelProvider;
        function _setProvider(name, forVal) {
            let holder = forVal && document.getElementById(forVal);
            name.model = holder && holder.label;
            return holder;
        }
        class AfcGuiLabel extends gui.ForElement {
            constructor() {
                super(_setProvider);
                this._adapter = new AFC.Globals.LabelAdapter(new AFC.Controls.Label(this));
            }
        }
        AfcGuiLabel.observedAttributes = gui.ForElement.observedAttributes;
        gui.AfcGuiLabel = AfcGuiLabel;
        gui.registerElement("afc-gui-label", AfcGuiLabel);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 28/05/2019.
 */
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        class AfcGuiPhotoControl extends AFC.Controls.Control {
            constructor(element) {
                super(element);
                this._ro = false;
                this.empty();
            }
            setROMode(ro) {
                this._ro = ro;
            }
            empty() {
                $(this.node).empty();
            }
            refresh(storePictures) {
                let mainNode = $(this.node);
                this.empty();
                let _this = this;
                let bind = mainNode.attr("bind") || "";
                let name = mainNode.attr("name") || "";
                let pictureId = mainNode.attr("pictureId") || "";
                let id = mainNode.attr("id");
                let title = mainNode.attr("title");
                let pictureFormat = mainNode.attr("pictureFormat");
                let input = $("<input/>");
                let div = $("<div/>");
                let divprogress = $("<div/>");
                let divimg = $("<div/>");
                let divCamera = $("<div/>");
                let divDate = $("<span class='pictureDate'/>");
                let table = $("<table/>");
                let img = $("<img/>");
                let divContainer = $("<div/>");
                let spanPicturesCount = $("<span/>");
                let waitControl = new AFC.Controls.ControlLoadingState(divprogress[0], true);
                img.click(function () {
                    $("#picture_fullscreen").css("background-image", `url("${$(this).attr("src")}")`);
                    $("#picture_fullscreen").show();
                });
                let refreshPicturesCount = function () {
                    if (name != "") {
                        storePictures && storePictures.getPictures([{ name: bind, value: name }]).then(pictures => {
                            if (pictures && pictures.length > 1) {
                                spanPicturesCount.html(`&nbsp;(${pictures.length})`);
                                spanPicturesCount.show();
                            }
                            else
                                spanPicturesCount.hide();
                        });
                    }
                };
                let refreshPicture = function () {
                    divOKCancel.hide();
                    setHasPictureStyle(true);
                    if (name != "") {
                        storePictures && storePictures.getFirstPicture([{ name: bind, value: name }]).then(pic => {
                            if (pic) {
                                waitControl.show();
                                img.data("picture", pic);
                                pic.getData(pictureFormat).then(data => {
                                    waitControl.hide();
                                    setPictureSource(data, pic);
                                    if (!_this._ro)
                                        divOKCancel.show();
                                });
                            }
                            else {
                                img.data("picture", null);
                                setPictureSource("");
                            }
                        });
                    }
                    else {
                        storePictures && storePictures.getPicture(pictureId).then(pic => {
                            if (pic) {
                                waitControl.show();
                                img.data("picture", pic);
                                pic.getData().then(data => {
                                    waitControl.hide();
                                    setPictureSource(data, pic);
                                    if (!_this._ro)
                                        divOKCancel.show();
                                });
                            }
                            else {
                                img.data("picture", null);
                                setPictureSource("");
                            }
                        });
                    }
                };
                let setHasPictureStyle = function (hasPicture, picture) {
                    let date;
                    if (hasPicture) {
                        divContainer.addClass("cameraPhoto");
                        divContainer.removeClass("cameraNoPhoto");
                        divCamera.hide();
                        divDate.show();
                        if (picture)
                            date = new Date(picture.creationDate);
                        else
                            date = new Date(Date.now());
                        divDate.html(date.toLocaleString(undefined, {
                            weekday: "long",
                            year: "numeric",
                            month: "long",
                            day: "numeric"
                        }).replace(/ /g, "&nbsp;"));
                        if (!_this._ro)
                            divOKCancel.show();
                    }
                    else {
                        divContainer.addClass("cameraNoPhoto");
                        divContainer.removeClass("cameraPhoto");
                        divCamera.show();
                        divDate.hide();
                    }
                };
                let setPictureSource = function (picSrc, picture) {
                    if (picSrc != "") {
                        img.attr("src", picSrc);
                        setHasPictureStyle(true, picture);
                    }
                    else {
                        img.attr("src", "#");
                        setHasPictureStyle(false);
                    }
                    refreshPicturesCount();
                };
                input.change(function () {
                    const [file] = this.files;
                    let parent = img.parent();
                    if (file && parent) {
                        let tags = [
                            {
                                name: $(this).attr("bind"),
                                value: $(this).attr("name")
                            }
                        ];
                        let toReplace = img.data("picture");
                        waitControl.show();
                        setHasPictureStyle(true);
                        divOKCancel.hide();
                        img.hide();
                        storePictures && storePictures.addPicture(file, tags, toReplace).then(newPicture => {
                            setPictureSource(URL.createObjectURL(file));
                            img.data("picture", newPicture);
                            img.show();
                            waitControl.hide();
                            if (!_this._ro)
                                divOKCancel.show();
                            refreshPicturesCount();
                        });
                    }
                    else {
                        storePictures && storePictures.getFirstPicture([{ name: bind, value: name }]).then(pic => {
                            storePictures.deletePicture(pic).then(success => {
                                img.data("picture", null);
                                refreshPicture();
                            });
                        });
                    }
                });
                img.attr("name", name);
                img.attr("bind", bind);
                input.attr("id", id);
                input.attr("name", name);
                input.attr("bind", bind);
                input.attr("type", "file");
                input.attr("accept", "image/*");
                //input.attr("capture", "environment");
                input.hide();
                divCamera.addClass("cameraButton");
                divCamera.append(input);
                divCamera.click(function () {
                    if (input && input[0])
                        input[0].click();
                });
                let tr = $("<tr class='pictureTitle'/>");
                let td = $("<td/>");
                td.css("width", "90%");
                td.text(title);
                td.append(spanPicturesCount);
                tr.append(td);
                td = $("<td/>");
                td.append(divDate);
                if (!this._ro)
                    td.append(divCamera);
                tr.append(td);
                table.append(tr);
                tr = $("<tr/>");
                td = $("<td/>");
                td.attr("colspan", 2);
                let divOKCancel = $("<div id='' style='display: flex; flex: none;' />");
                let divDeletePicture = $("<div class='btn_deletePicture'/>");
                let divUpdatePicture = $("<div class='btn_updatePicture' style='right: 0;'/>");
                if (!this._ro) {
                    divOKCancel.append(divDeletePicture);
                    divOKCancel.append(divUpdatePicture);
                }
                img.addClass("photomanager-photo");
                refreshPicture();
                divimg.append(img);
                divContainer.append(divprogress);
                divContainer.append(divimg);
                divContainer.append(divOKCancel);
                divDeletePicture.click(function () {
                    _this.node.deletePictureCheck(_this.node).then(process => {
                        if (process)
                            input.val('').trigger('change');
                    });
                });
                divUpdatePicture.click(function () {
                    if (input && input[0])
                        input[0].click();
                });
                divOKCancel.hide();
                td.append(divContainer);
                tr.append(td);
                table.append(tr);
                mainNode.append(table);
            }
        }
        ;
        class AfcGuiPhoto extends gui.AfcGuiElement {
            constructor() {
                super();
                this._control = new AfcGuiPhotoControl(this);
            }
            set picturesSource(pictureSource) {
                this._pictureSource = pictureSource;
            }
            _onGenerate() {
                //_dispatchEvent(this, 'dataChange');
            }
            connectedCallback() {
                this.refresh();
            }
            refresh() {
                $(this).empty();
                this._control.refresh(this._pictureSource);
            }
            deletePictureCheck(picture) {
                return Promise.resolve(true);
            }
            setROMode(ro) {
                this._control.setROMode(ro);
            }
        }
        AfcGuiPhoto.observedAttributes = gui.ForElement.observedAttributes;
        gui.AfcGuiPhoto = AfcGuiPhoto;
        gui.registerElement("afc-gui-photo", AfcGuiPhoto);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
///<reference path="../Globals.ts" />
///<reference path="../../models/data/Data.ts" />
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        const _control = Symbol(), _context = Symbol(), _state = Symbol(), _fragmentManager = Symbol(), _onGenerate = Symbol();
        class AfcGuiTemplateElem extends gui.AfcBindableElement {
            constructor(adapter) {
                super();
                this._adapter = adapter ?? new AFC.Globals.TemplateElemAdapter(this[_control] = new AFC.Controls.TemplateElem(this));
                this._adapter.onGenerate = this[_onGenerate].bind(this);
            }
            _onRestoreViewState(context, fragmentManager, savedInstanceState) {
                super._onRestoreViewState(context, fragmentManager, savedInstanceState);
                this[_context] = context;
                this[_state] = savedInstanceState;
            }
            /** @internal */
            [_onGenerate]() {
                this[_context] && gui.onRestoreViewState(this[_context], this, this[_fragmentManager], this[_state]);
                gui._dispatchEvent(this, 'dataChange');
            }
            set dataBinder(value) {
                this[_control].dataBinder = value;
            }
            get dataBinder() {
                return this[_control].dataBinder;
            }
            set adapter(adapter) {
                this._adapter = adapter;
            }
            get adapter() {
                return this._adapter;
            }
            /**
             * Store initial content <afc-gui-template-elem> as template
             */
            connectedCallback() {
                let templates = this.getElementsByTagName("template");
                let template;
                if (templates.length) {
                    for (let i = 0; i < templates.length; ++i) {
                        if (templates[i].parentNode === this) {
                            let name = (template = templates[i]).getAttribute('name');
                            this[_control].setTemplate(template.innerHTML, name === null ? void 0 : name);
                        }
                    }
                }
                else {
                    this[_control].setTemplate(this.innerHTML);
                }
                // Clean content
                while (this.firstChild) {
                    this.removeChild(this.firstChild);
                }
                super.connectedCallback();
            }
            disconnectedCallback() {
                delete this._adapter.onGenerate;
                super.disconnectedCallback();
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                let f;
                switch (attrName) {
                    case 'data-binder':
                        (f = gui.StringToFunction(newVal)) && (this.dataBinder = f);
                        break;
                    case 'format-numbers':
                        this[_control].setFormatNumbers(newVal !== null);
                        break;
                    default:
                        super.attributeChangedCallback(attrName, oldVal, newVal);
                        break;
                }
            }
            refresh() {
                this._adapter.refresh();
            }
        }
        AfcGuiTemplateElem.observedAttributes = gui.AfcBindableElement.observedAttributes.concat([
            'data-binder', 'format-numbers'
        ]);
        gui.AfcGuiTemplateElem = AfcGuiTemplateElem;
        gui.registerElement("afc-gui-template-elem", AfcGuiTemplateElem);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 03/10/2018.
 */
///<reference path="Globals/ForElement.ts" />
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        function _internalBind(legend, forVal) {
            let holder = forVal && document.getElementById(forVal);
            legend.model = holder && holder.legends;
            return holder;
        }
        class AfcGuiLegend extends gui.ForElement {
            _onDirty( /*event: Tools.IEvent*/) {
                this._adapter.control && this._adapter.control.loadingStart();
                if (this.model && this.enableFiltering) {
                    gui._dispatchEvent(this, 'dataChange', { detail: !this._adapter.isEmpty() });
                }
            }
            constructor() {
                super(_internalBind);
                this._adapter = new AFC.Globals.LegendsAdapter(new AFC.Controls.Legends(this));
            }
            set enableFiltering(value) {
                this._adapter.enableFiltering = !!value;
            }
            get enableFiltering() {
                return !this._adapter.enableFiltering;
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                (attrName === 'enable-filtering') ? this.enableFiltering = newVal !== null : super.attributeChangedCallback(attrName, oldVal, newVal);
            }
            isEmpty() {
                return this._adapter.isEmpty();
            }
        }
        AfcGuiLegend.observedAttributes = gui.ForElement.observedAttributes.concat(['enable-filtering']);
        gui.AfcGuiLegend = AfcGuiLegend;
        gui.registerElement("afc-gui-legend", AfcGuiLegend);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 11/10/2017.
 */
/**
 * Created by jean.rennes on 19/02/2019.
 */
///<reference path="../../models/globals/Global.ts" />
var AFC;
(function (AFC) {
    var gui;
    (function (gui) {
        const _rest = Symbol(), _name = Symbol(), _layers = Symbol(), _mapView = Symbol(), _onDirty = Symbol(), _getMetadata = Symbol(), _bindTo = Symbol(), _noClustering = Symbol(), _clusteringMaxZoom = Symbol();
        class AfcGuiLibraryMap extends gui.AfcGuiElement {
            /** @internal */
            [_onDirty]( /*e: Tools.IEvent*/) {
                gui._dispatchEvent(this, 'layersChange');
            }
            /** @internal */
            [_getMetadata](rest, name) {
                return this[_mapView] ?
                    Promise.resolve(this[_mapView]) :
                    new Promise(async (resolve) => {
                        if (rest && name) {
                            let mapViews = await rest.globals.getMapViews(), mapView = AFC.Tools.findByIdOrName(name, mapViews);
                            this[_mapView] = mapView && await mapView.getMetadata();
                        }
                        resolve(this[_mapView]);
                    });
            }
            /** @internal */
            [_bindTo](name, states) {
                let rest = this[_rest];
                if (rest) {
                    let config;
                    if (!states) {
                        config = {
                            hidden: this.hidden
                        };
                        isNaN(this[_clusteringMaxZoom]) || (config.clusteringMaxZoom = this[_clusteringMaxZoom]);
                        this[_noClustering] && (config.clustering = false);
                    }
                    delete this[_layers];
                    this[_getMetadata](rest, name).then((metadata) => {
                        this[_layers] = metadata && metadata.layers.map((layer, indice) => new gui.TileLayerProvider(layer, config || states[indice]));
                        this[_onDirty]();
                    });
                }
            }
            _setHide(bHide) {
                this._setMute(bHide);
                this[_layers]?.forEach(layer => layer.hidden = bHide);
                this[_onDirty]();
            }
            _onRestoreViewState(activity, fragmentManager, savedInstanceState) {
                if (activity.getRestModel) {
                    let state = savedInstanceState && this.id && savedInstanceState.getValue(this.id), name = this.name, states;
                    this[_rest] = activity.getRestModel();
                    if (state) {
                        name = this[_name] = state.name;
                        states = state.layers;
                    }
                    name && this[_bindTo](name, states);
                }
            }
            _onSaveInstanceState(context, savedInstanceState) {
                let layers = this.id && this[_layers], name = this.name;
                super._onSaveInstanceState(context, savedInstanceState);
                layers && savedInstanceState.putValue(this.id, {
                    name: name,
                    layers: name && layers.map(layer => ({
                        hidden: layer.hidden,
                        filter: layer.filter,
                        options: layer.options,
                        clustering: layer.clustering,
                        clusteringMaxZoom: layer.clusteringMaxZoom
                    }))
                });
            }
            set name(value) {
                if (this.name !== value) {
                    delete this[_mapView];
                    this[_name] = value;
                    this[_bindTo](value);
                }
            }
            get name() {
                return this[_name];
            }
            getCount() {
                let layers = this[_layers];
                return layers ? layers.length : 0;
            }
            getLayerProvider(indice) {
                return this[_layers]?.[indice];
            }
            getInfo() {
                return this[_getMetadata](this[_rest], this.name).then(gui.getProviderInfoFromMapMetadata);
            }
            attributeChangedCallback(attrName, oldVal, newVal) {
                switch (attrName) {
                    case 'name':
                        this.name = newVal;
                        break;
                    case 'no-clustering':
                        this[_noClustering] = newVal !== null;
                        break;
                    case 'clustering-max-zoom':
                        let value = parseInt(newVal);
                        this[_clusteringMaxZoom] = isNaN(value) ? void 0 : value;
                        break;
                    default:
                        super.attributeChangedCallback(attrName, oldVal, newVal);
                }
            }
            refresh() {
                this[_layers]?.forEach(layer => layer.refresh());
            }
        }
        AfcGuiLibraryMap.observedAttributes = gui.AfcGuiElement.observedAttributes.concat(['name', 'no-clustering', 'clustering-max-zoom']);
        gui.AfcGuiLibraryMap = AfcGuiLibraryMap;
        gui.registerElement("afc-gui-library-map", AfcGuiLibraryMap);
    })(gui = AFC.gui || (AFC.gui = {}));
})(AFC || (AFC = {}));
///<reference path="../AFC.ts" />
var AFC;
(function (AFC) {
    var Tools;
    (function (Tools) {
        /**
         * Helper for command history, stack list of actions, enable to undo or redo stacked commands.
         */
        class CommandHistoryHelper {
            constructor(execCommand) {
                this._currentCommitDone = false;
                this._currentRollbackDone = false;
                this._cursor = 0;
                this._stackCommands = [];
                this.undo = this.undoCommand; // aliases
                this.redo = this.redoCommand;
                this._execCommand = execCommand;
            }
            /**
             * Get command at given index
             * @param index The command index, if null, index = cursor
             * @returns
             */
            getCommand(index) {
                return this._stackCommands[index ?? this._cursor];
            }
            /**
             * Allow update of last command, in case of action wasnt finished yet, and one command is a succession of multiple actions (eg. mousedown while painting)
             * @param command The updated command
             * @param index The command index, if null, index = cursor
             */
            updateLastCommand(command, index) {
                this._stackCommands[index ?? this._cursor] = command;
            }
            /**
             * Add a command item to history stack at cursor index, then reset all next actions (clean redos after undo > new action).
             * @param commandItem The command to be added to the stack, must contain rollback and commit callbacks.
             */
            addCommand(commandItem) {
                let atCursor;
                if (this._currentRollbackDone) {
                    atCursor = this._cursor === 0 ? 0 : this._cursor;
                }
                else {
                    atCursor = this._cursor + 1;
                }
                this._stackCommands.splice(atCursor, this._stackCommands.length, commandItem); // Resets all redos !
                this._cursor = this._stackCommands.length - 1;
                this._currentRollbackDone = false;
                this._currentCommitDone = true;
            }
            /**
             * Can redo if stack is not empty and current box' commit callback not already done
             * @returns true if can redo action (not already comitted), false otherwise
             */
            canRedo() {
                return !(this._cursor === this._stackCommands.length - 1 && this._currentCommitDone);
            }
            /**
             * Can redo if stack is not empty and current box' commit callback not already done
             * @returns true if can undo action (not already rollbacked), false otherwise
             */
            canUndo() {
                return !(this._cursor === 0 && this._currentRollbackDone);
            }
            /**
             * Undo command if exists, call previous item's cmdRollback function. If only one item, call self rollback.
             */
            undoCommand() {
                if (this.canUndo()) {
                    if (this._currentRollbackDone && this._cursor - 1 >= 0) {
                        this._cursor--;
                    }
                    this.execCommand(this._stackCommands[this._cursor].cmdRollback);
                    this._currentRollbackDone = true;
                    this._currentCommitDone = false;
                }
            }
            /**
             * Redo command if exists, call next item's cmdCommit function. If only one item, call self commit.
             */
            redoCommand() {
                if (this.canRedo()) {
                    if (this._currentCommitDone && this._cursor + 1 < this._stackCommands.length) {
                        this._cursor++;
                    }
                    this.execCommand(this._stackCommands[this._cursor].cmdCommit);
                    this._currentCommitDone = true;
                    this._currentRollbackDone = false;
                }
            }
            /**
             * Execute callback function.
             * @param command The callback function that will apply state according to triggered action (redo or undo).
             */
            execCommand(command) {
                this._execCommand(command);
            }
        }
        Tools.CommandHistoryHelper = CommandHistoryHelper;
    })(Tools = AFC.Tools || (AFC.Tools = {}));
})(AFC || (AFC = {}));
;
/**
 * Created by jean.rennes on 22/03/2021.
 */
///<reference path="../../AFC.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        function _getCell(gridData, item) {
            let cell = Object.create((item.className && gridData.classes[item.className]) || null), image = item.image;
            cell.renderer = item.renderer;
            if (image) {
                image.charAt(0) === '<' ?
                    cell.symbol = image :
                    cell.symbol = image;
            }
            return cell;
        }
        function _getHeaderCell(gridData, item) {
            let cell = _getCell(gridData, item);
            cell.value = item.name;
            cell.text = item.text || item.name;
            return cell;
        }
        class GridApp {
            constructor(gridData, allowOrdering = false, sortedColumns) {
                this.gridData = gridData;
                this.hasRowHeader = gridData.rowHeaders?.visibility;
                this.hasColumnHeader = gridData.columnHeaders?.visibility;
                if (allowOrdering) {
                    let index = this._index = {};
                    gridData.columnHeaders.items.forEach((item, indice) => index[item.name] = indice);
                    this.sortedColumns = sortedColumns || [];
                }
            }
            get allowOrdering() {
                return !!this._index;
            }
            getRowCount() {
                return this.gridData.items.length;
            }
            getRowHeader(line) {
                return _getHeaderCell(this.gridData, this.gridData.rowHeaders.items[line]);
            }
            getRowHeaderWidth() {
                return this.gridData.rowHeaders.width;
            }
            getRowHeight(line) {
                return this.gridData.rowHeaders.items[line].height;
            }
            getColumnInfo(column) {
                return this.gridData.columnHeaders.items[column];
            }
            getColumnCount() {
                return this.gridData.columnHeaders.items.length;
            }
            getColumnHeader(column) {
                return _getHeaderCell(this.gridData, this.gridData.columnHeaders.items[column]);
            }
            getColumnHeaderHeight() {
                return this.gridData.columnHeaders.height;
            }
            getColumnWidth(column) {
                return this.gridData.columnHeaders.items[column].width;
            }
            getCell(column, line) {
                let item = this.gridData.items[line][column], cell = _getCell(this.gridData, item);
                cell.value = cell.value;
                cell.text = item.text;
                return cell;
            }
            getValue(column, line) {
                let cell = this.gridData.items[line][this._index[column]];
                return cell?.value ?? null;
            }
            getSymbol(key) {
                return this.gridData.images[key];
            }
        }
        Dashboards.GridApp = GridApp;
        function _castArray(value, fn) {
            if (value instanceof Array) {
                let str = '';
                for (let i = 0; i < value.length; ++i) {
                    i && (str += ' ');
                    str += fn ? fn(value[i]) : value[i];
                }
                return str;
            }
            return fn ? fn(value) : value;
        }
        class GridAppCell {
            constructor(item, template, value, text, backgroundColor) {
                this.value = value;
                this.text = text;
                this.symbol = item.image;
                /*this.image: string;*/
                this.color = AFC.Tools.Style.convertRGBAColor(template.color || 0);
                this.backgroundColor = backgroundColor || AFC.Tools.Style.convertRGBAColor(template.backgroundColor || 0);
                this.renderer = item.renderer;
                this.padding = _castArray(template.padding, (value) => `${value}pt`);
                this.fontSize = `${template.fontSize}pt`;
                this.textAlign = template.align;
                this.verticalAlign = template.verticalAlign;
                this.fontWeight = template.fontWeight;
                this.fontFamily = template.fontFamily;
                this.borderStyle = _castArray(template.borderStyle);
                this.borderWidth = _castArray(template.borderWidth);
                this.borderColor = _castArray(template.borderColor, AFC.Tools.Style.convertRGBAColor);
                this.textDecoration = template.textDecoration;
                this.fontStyle = template.fontStyle;
                this.whiteSpace = template.whiteSpace;
            }
        }
        class MetaGridApp {
            constructor(template, allowOrdering, sortedColumns) {
                this.template = template;
                this.hasRowHeader = template.rowHeaders?.visibility;
                this.hasColumnHeader = template.columnHeaders?.visibility;
                if (this.allowOrdering = allowOrdering) {
                    this.sortedColumns = sortedColumns || [];
                }
            }
            _getCellEx(item, value, text, backgroundColor, format) {
                if (!text) {
                    if (!format) {
                        let kind = AFC.Tools.Data.isNumber(item.value) ? 2 /* Data.DataKind.real */ : 1 /* Data.DataKind.character */;
                        if (item.format || kind === 2 /* Data.DataKind.real */) {
                            format = new AFC.Tools.StringTools.FormatString(item.format, kind);
                        }
                    }
                    text = format ? format.getFormated(value) : value;
                }
                return new GridAppCell(item, (item.className && this.template.classes[item.className]) || {}, value, text, backgroundColor);
            }
            getColumnCount() {
                return this.template.items[0].length;
            }
            getColumnHeaderHeight() {
                return this.template.columnHeaders.height;
            }
            getColumnWidth(column) {
                return this.template.columnHeaders.items[column].width;
            }
            getSymbol(key) {
                return this.template.images[key];
            }
        }
        Dashboards.MetaGridApp = MetaGridApp;
        class DetailedGridApp extends MetaGridApp {
            constructor(template, data, sortedColumns) {
                let thematic = template.thematic, columns = thematic && thematic.columns, solver, formats = [];
                super(template, true);
                this.dataModel = data.dataModel;
                this.index = template.columnHeaders.items.map((header, indice) => {
                    let item = template.items[0][indice], pos = data.dataModel.columnIndex[header.column] ?? -1;
                    pos !== -1 && item.format && (formats[indice] = new AFC.Tools.StringTools.FormatString(item.format, data.dataModel.columns[pos].type));
                    return pos;
                });
                this.sortedColumns = sortedColumns;
                if (columns && columns.length === 1) {
                    solver = AFC.Globals.getMonoThematicSolver(columns[0], thematic.classes, data, data.dataModel.columnIndex);
                    solver && (this._thematic = (row) => {
                        let value = solver(row), _class = this.template.thematic.classes[value];
                        return _class && AFC.Tools.Style.convertColor(_class.value);
                    });
                }
                this._formats = formats;
            }
            getRowCount() {
                return this.dataModel.length;
            }
            getRowHeader(line) {
                return;
            }
            getRowHeaderWidth() {
                return;
            }
            getRowHeight(line) {
                return this.template.rowHeaders.items[0].height;
            }
            getColumnInfo(column) {
                let info = Object.create(this.dataModel.columns[this.index[column]] || null);
                info.supportOrdering = true;
                return info;
            }
            getColumnHeader(column) {
                let item = this.template.columnHeaders.items[column];
                return this._getCellEx(item, item.value, item.text);
            }
            getCell(column, line) {
                let row = this.dataModel.values[line], value, backgroundColor;
                if (row) {
                    value = row[this.index[column]];
                    backgroundColor = this._thematic && this._thematic(row);
                }
                return this._getCellEx(this.template.items[0][column], value, null, backgroundColor, this._formats[column]);
            }
            getValue(column, line) {
                let row = this.dataModel.values[line];
                return (row && row[this.dataModel.columnIndex[column]]) ?? null;
            }
        }
        Dashboards.DetailedGridApp = DetailedGridApp;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 22/04/2016.
 */
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="../data/data.ts" />
var AFC;
(function (AFC) {
    var Traffic;
    (function (Traffic) {
        "use strict";
        var _path = '/traffic';
        let EventType;
        (function (EventType) {
            EventType[EventType["statistics"] = 65537] = "statistics";
            EventType[EventType["packages"] = 65538] = "packages";
        })(EventType = Traffic.EventType || (Traffic.EventType = {}));
        let TrafficStatus;
        (function (TrafficStatus) {
            TrafficStatus[TrafficStatus["none"] = 0] = "none";
            TrafficStatus[TrafficStatus["pending"] = 1] = "pending";
            TrafficStatus[TrafficStatus["ready"] = 2] = "ready";
        })(TrafficStatus = Traffic.TrafficStatus || (Traffic.TrafficStatus = {}));
        class TrafficPackages {
            constructor(invalidate, response) {
                this._invalidate = invalidate;
                this._packages = response.packages;
                this._newVersionCost = response.newVersionCost;
                this._credits = response.credits;
            }
            get packages() {
                return this._packages;
            }
            get newVersionCost() {
                return this._newVersionCost;
            }
            get credits() {
                return this._credits;
            }
        }
        class TrafficStatistics {
            constructor(model, invalidate, response, infoTableResource) {
                this._invalidate = invalidate;
                this._model = model;
                this._id = response.section.id;
                this._provider = response.provider;
                this._package = response.package;
                this._newVersionAvailable = response.newVersionAvailable;
                this._onError = true;
                this._errorMsg = response.error;
                if (this._errorMsg == "") {
                    this._onError = false;
                    this._livingArea = this._getLivingAreaTable(response.livingArea);
                    this._workingArea = this._getWorkingAreaTable(response.workingArea);
                    this._infoTable = this._getInfoTable(response.data, infoTableResource);
                }
            }
            _getLivingAreaTable(units) {
                if (units) {
                    var values = [];
                    var columns = {
                        columns: [
                            { name: "TOKEN_ID", type: "asteropDataKindCharacter" },
                            { name: "CODE", type: "asteropDataKindCharacter" },
                            { name: "PCT", type: "asteropDataKindReal" },
                            { name: "COUNT", type: "asteropDataKindReal" },
                        ]
                    };
                    var currentCode = this.id; //this._model.currentCodeValue;
                    for (var i = 0; i < units.length; i++) {
                        var value = [currentCode, units[i].code, units[i].pct, units[i].count];
                        values.push(value);
                    }
                    return new AFC.Data.DataModelBase(AFC.Data.mapDataColumns(columns), ["TOKEN_ID", "CODE"], values);
                }
                return null;
            }
            _getWorkingAreaTable(units) {
                if (units) {
                    var values = [];
                    var columns = {
                        columns: [
                            { name: "TOKEN_ID", type: "asteropDataKindCharacter" },
                            { name: "CODE", type: "asteropDataKindCharacter" },
                            { name: "PCT", type: "asteropDataKindReal" },
                            { name: "COUNT", type: "asteropDataKindReal" },
                        ]
                    };
                    var currentCode = this.id; //this._model.currentCodeValue;
                    for (var i = 0; i < units.length; i++) {
                        var value = [currentCode, units[i].code, units[i].pct, units[i].count];
                        values.push(value);
                    }
                    return new AFC.Data.DataModelBase(AFC.Data.mapDataColumns(columns), ["TOKEN_ID", "CODE"], values);
                }
                return null;
            }
            _getInfoTable(info, infoTableResource) {
                var columns = {
                    columns: [
                        { name: "TOKEN_ID", type: "asteropDataKindCharacter" },
                        { name: "PROVIDER", type: "asteropDataKindCharacter" },
                        { name: "PACKAGE", type: "asteropDataKindCharacter" },
                        { name: "GEOMETRY", type: "asteropDataKindPoint" }
                    ]
                };
                var values = [
                    [
                        this.id,
                        this.provider,
                        this.package,
                        {
                            type: "Point",
                            coordinates: [this._model.x, this._model.y],
                        }
                    ]
                ];
                /*
                let fullColumns = new Set();
                infoTableResource.definition.columns.forEach(column => {
                    if (column.type == AFC.Data.DataKind.integer) {
                        fullColumns.add(column.name);
                    }
                });
                */
                info.forEach(data => {
                    //fullColumns.delete(data.name);
                    columns.columns.push({ name: data.name, type: "asteropDataKindInteger" });
                    values[0].push(data.value);
                });
                /*
                /fullColumns.forEach(columnName => {
                    columns.columns.push({name: columnName, type: "asteropDataKindInteger"});
                    values[0].push(0);
                });
                */
                return new AFC.Data.DataModelBase(AFC.Data.mapDataColumns(columns), ["TOKEN_ID"], values);
            }
            initFrom( /*dma: ITrafficStatisticsResponse*/) {
                /*
                let table: {columns: any[]; primaryKey: string[]; values: any[][]};
                (table = dma.area) && (this._area = new Data.DataModelBase(Data.mapDataColumns(table), table.primaryKey, table.values));
                (table = dma.income) && (this._income = new Data.DataModelBase(Data.mapDataColumns(table), table.primaryKey, table.values));
                (table = dma.neighbors) && (this._neighbors = new Data.DataModelBase(Data.mapDataColumns(table), table.primaryKey, table.values));
                */
            }
            get isOnError() {
                return this._onError;
            }
            get errorMsg() {
                return this._errorMsg;
            }
            get id() {
                return this._id;
                //return this._model.currentCodeValue;
            }
            get provider() {
                return this._provider;
            }
            get package() {
                return this._package;
            }
            get newVersionAvailable() {
                return this._newVersionAvailable;
            }
            get workingArea() {
                return this._workingArea;
            }
            get livingArea() {
                return this._livingArea;
            }
            get infoTable() {
                return this._infoTable;
            }
            get status() {
                return this._status;
            }
            get newerAvailable() {
                return this._newerAvailable;
            }
            get needBuy() {
                return this._needBuy;
            }
        }
        class TrafficModel extends AFC.Tools.EventSink {
            constructor(restModel) {
                super();
                this._serverKind = "";
                this._packageToBuy = "";
                this.restModel = restModel;
            }
            _invalidate() {
                delete this._statistics;
                delete this._sequence;
                delete this._sequencePackages;
            }
            set geographicSource(value) {
                if (this._geographicSource != value) {
                    this._geographicSource = value;
                    this._invalidate();
                }
            }
            get geographicSource() {
                return this._geographicSource;
            }
            set serverKind(value) {
                if (this._serverKind !== value) {
                    this._serverKind = value;
                    this._invalidate();
                }
            }
            get serverKind() {
                return this._serverKind;
            }
            set x(value) {
                if (this._x !== value) {
                    //delete this._config;
                    this._x = value;
                    this._invalidate();
                }
            }
            set y(value) {
                if (this._y !== value) {
                    //delete this._config;
                    this._y = value;
                    this._invalidate();
                }
            }
            get x() {
                return this._x;
            }
            get y() {
                return this._y;
            }
            get isOnError() {
                if (this._statistics)
                    return this._statistics.isOnError;
                return true;
            }
            get errorMsg() {
                if (this._statistics)
                    return this._statistics.errorMsg;
                return "";
            }
            set currentCodeValue(value) {
                if (this._currentCodeValue !== value) {
                    this._currentCodeValue = value;
                    this._invalidate();
                }
            }
            get currentCodeValue() {
                return this._currentCodeValue;
            }
            setUseCredit(value, pack) {
                if (value)
                    this._packageToBuy = pack;
                else
                    this._packageToBuy = "";
                if (this._useCredit !== value) {
                    this._useCredit = value;
                    if (this._useCredit)
                        this._invalidate();
                }
            }
            set infoTableTemplate(table) {
                this._infoTableName = table;
            }
            _onAlwaysPackages(sequence, jqXHR, textStatus) {
                if (sequence === this._sequencePackages) {
                    let data = jqXHR.responseJSON;
                    if (data)
                        this._packages = new TrafficPackages(this._invalidate, data);
                    this.fireEvent(65538 /* EventType.packages */);
                }
            }
            _onAlways(sequence, jqXHR, textStatus) {
                if (sequence === this._sequence) {
                    let data = jqXHR.responseJSON;
                    let _this = this;
                    let hOnLoad = function (infoTableResournce) {
                        if (_this._useCredit) {
                            delete _this._packages;
                        }
                        _this._statistics = new TrafficStatistics(_this, _this._invalidate, data, infoTableResournce);
                        _this.fireEvent(65537 /* EventType.statistics */);
                    };
                    if (data) {
                        hOnLoad(null);
                    }
                    else
                        this.fireEvent(65537 /* EventType.statistics */);
                }
            }
            request() {
                let statistics = this._statistics;
                return statistics ? Promise.resolve(statistics) : new Promise(async (resolve) => {
                    this.notify(65537 /* EventType.statistics */, ( /*event: Tools.IEvent*/) => resolve(this._statistics));
                    if (!this._sequence) {
                        this._sequence = 1;
                        let request = this.restModel.createAjaxRequest(_path + "/statistics", true, { useProgressInfo: false });
                        let data = request.options.data;
                        request.options.always = this._onAlways.bind(this);
                        data.lon = this._x;
                        data.lat = this._y;
                        data.useCredit = this._useCredit;
                        data.package = this._packageToBuy;
                        data.geographicSource = this._geographicSource;
                        if (this._serverKind && this._serverKind !== "")
                            data.serverKind = this._serverKind;
                        this._sequence = request.call();
                    }
                });
            }
            requestPackages() {
                let packages = this._packages;
                return packages ? Promise.resolve(packages) : new Promise(async (resolve) => {
                    this.notify(65538 /* EventType.packages */, ( /*event: Tools.IEvent*/) => resolve(this._packages));
                    if (!this._sequencePackages) {
                        let request = this.restModel.createAjaxRequest(_path + "/packages", true, { useProgressInfo: false });
                        let data = request.options.data;
                        request.options.always = this._onAlwaysPackages.bind(this);
                        data.lon = this._x;
                        data.lat = this._y;
                        if (this._serverKind && this._serverKind !== "")
                            data.serverKind = this._serverKind;
                        this._sequencePackages = request.call();
                    }
                });
            }
        }
        Traffic.TrafficModel = TrafficModel;
    })(Traffic = AFC.Traffic || (AFC.Traffic = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 26/04/2016.
 */
///<reference path="../models/dashboards/Dashboard.ts" />
///<reference path="../models/dashboards/GridApp.ts" />
///<reference path="../models/tradearea/DMAConfig.ts" />
///<reference path="../models/rest/RequestBuilder.ts" />
///<reference path="../models/traffic/Traffic.ts" />
///<reference path="../models/data/Global.ts" />
///<reference path="../models/data/Data.ts" />
///<reference path="Data.ts" />
var AFC;
(function (AFC) {
    var Tools;
    (function (Tools) {
        var Dashboards;
        (function (Dashboards_1) {
            var Dashboards = AFC.Dashboards;
            const ResourceSubstitute = AFC.Rest.ResourceSubstitute;
            const _init = Symbol();
            class StoreSourceListener {
                constructor(dashboard, storeSource) {
                    this.dashboard = dashboard;
                    this.storeSource = storeSource;
                    this[_init] = true;
                    dashboard.requestBuilder.pushModifier(this);
                }
                _create() { }
                async load( /* options?: Dashboards.IDashboardContextModifierOptions*/) {
                    if (this[_init]) {
                        this[_init] = false;
                        let success = await this.storeSource.ready();
                        if (success) {
                            this._create();
                            this.storeSource.on(6 /* EventType.Dirty */, this._update, this);
                        }
                        return success;
                    }
                    return this.storeSource.ready();
                }
                release() {
                    this.dashboard.requestBuilder.popModifier(this);
                    this.storeSource.off(6 /* EventType.Dirty */, this._update, this);
                }
            }
            class StoreSourceLoader extends StoreSourceListener {
                constructor(dashboard, storeSource) {
                    super(dashboard, storeSource);
                    this.creator = new ResourceSubstitute(dashboard.requestBuilder, storeSource.fullName);
                }
                _create() {
                    let storeSource = this.storeSource, context = storeSource.generateContext(), sites = context.target, branchInfo;
                    if (storeSource.isHistoricized) {
                        branchInfo = storeSource.branchInfo;
                    }
                    branchInfo || sites.events ?
                        this.creator.create(new AFC.Data.ModificationCreation(sites.reference, sites.events, branchInfo)) :
                        this.creator.replacement = sites.reference;
                }
                _update(event) {
                    let data = event.data;
                    if (data && (data.reset || data.items.every(item => item.committed))) {
                        let tableName = this.creator.reference.toUpperCase();
                        this[_init] = true;
                        this.storeSource.off(6 /* EventType.Dirty */, this._update, this);
                        this.dashboard.invalidateViews();
                        this.dashboard.clusters.forEach(cluster => {
                            cluster.zones.forEach((zone) => {
                                switch (zone.type) {
                                    case 1 /* Dashboards.ZoneType.radius */:
                                    case 2 /* Dashboards.ZoneType.isodistance */:
                                    case 3 /* Dashboards.ZoneType.isochrone */:
                                        let sitesTable = zone.reference.sitesTable;
                                        if (sitesTable && sitesTable.table.toUpperCase() === tableName && (event.data.reset || event.data.items.some(item => {
                                            let column = this.storeSource.columnIndex[sitesTable.codecolumn];
                                            if (item.row[column] === cluster.current) {
                                                return true; //item.values.hasOwnProperties(zone.perSiteConfiguration) || geometry;
                                            }
                                        }))) {
                                            zone.invalidate(true); // should be false when geometry
                                        }
                                        break;
                                }
                            });
                        });
                    }
                }
                updateBody(body /*, options?: Dashboards.IDashboardContextModifierOptions*/) {
                    this.creator.updateBody(body);
                }
                release() {
                    this.creator.release();
                    super.release();
                }
            }
            Dashboards_1.StoreSourceLoader = StoreSourceLoader;
            let SimulationStatus;
            (function (SimulationStatus) {
                SimulationStatus[SimulationStatus["none"] = 0] = "none";
                SimulationStatus[SimulationStatus["pending"] = 1] = "pending";
                SimulationStatus[SimulationStatus["ready"] = 2] = "ready";
                SimulationStatus[SimulationStatus["dirty"] = 3] = "dirty";
            })(SimulationStatus || (SimulationStatus = {}));
            function _checkValues(item, columns) {
                return item.type !== 0 /* AFC.Data.DataEventType.none */ &&
                    (item.type !== 2 /* AFC.Data.DataEventType.modify */ || !columns || !item.values || columns.some(column => item.values.hasOwnProperty(column)));
            }
            class DMALoader extends Tools.EventSinkMixin(StoreSourceListener) {
                constructor(dashboard, storeSource, dmaModel, options) {
                    let requestBuilder = dashboard.requestBuilder;
                    super(dashboard, storeSource);
                    this.dmaModel = dmaModel;
                    if (options) {
                        options.confirm && (this.confirm = options.confirm);
                        options.zone && (this.zone = new DMALoader._Zone(this, requestBuilder, options.zone));
                        options.income && (this.income = new ResourceSubstitute(requestBuilder, options.income.reference.sitesTable.table));
                        options.impact && (this.impact = new ResourceSubstitute(requestBuilder, options.impact));
                        options.neighbors && (this.neighbors = new ResourceSubstitute(requestBuilder, options.neighbors));
                        options.descriptor?.dataInput?.some(dataInput => {
                            if (!storeSource.fullName.localeCompare(dataInput.table, undefined, { sensitivity: 'accent' })) {
                                this._columns = dataInput.columns;
                                return true;
                            }
                        });
                    }
                }
                _off() {
                    this._reaffectStorage?.off(6 /* Tools.EventType.Dirty */, this._onReset, this);
                }
                _onReset(event) {
                    event.data.some(operation => operation.type === 1 /* Dashboards.OperationType.reset */) && (this._status = 0 /* SimulationStatus.none */);
                }
                async _update(event) {
                    // check for columns match ...
                    let data = event.data;
                    if (data) {
                        if (data.reset || (data.items.reduce((acc, item) => {
                            this._pending = this._pending || _checkValues(item, this._columns);
                            return acc && item.committed;
                        }, true) && this._pending)) {
                            delete this._pending;
                            this._status = 3 /* SimulationStatus.dirty */;
                        }
                    }
                }
                updateBody(body, options) {
                    this.zone && this.zone.updateBody(body);
                    this.income && this.income.updateBody(body);
                    this.impact && this.impact.updateBody(body);
                    this.neighbors && this.neighbors.updateBody(body);
                }
                async load(options) {
                    if (this._status !== 2 /* SimulationStatus.ready */) {
                        await super.load();
                        if (!options || options.districtType !== 0 /* Dashboards.DistrictType.base */) {
                            return new Promise(async (resolve) => {
                                const reset = this._status === 3 /* SimulationStatus.dirty */, zone = this.zone;
                                this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve());
                                if (reset) {
                                    this._status = 0 /* SimulationStatus.none */;
                                }
                                if (!this._status) {
                                    this._status = 1 /* SimulationStatus.pending */;
                                    if (!reset || !this.confirm || await this.confirm()) {
                                        if (zone) {
                                            this._off();
                                            await zone.load(reset);
                                            // bug work around: as ReaffectEditableStorage is not fully implemented, reload zone when reset occur
                                            zone.zone.getReaffectStorage().then(reaffectStorage => reaffectStorage && (this._reaffectStorage = reaffectStorage).on(6 /* Tools.EventType.Dirty */, this._onReset, this));
                                        }
                                        else {
                                            await this._simulate();
                                        }
                                    }
                                    this._status = 2 /* SimulationStatus.ready */;
                                    this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                                }
                            });
                        }
                    }
                }
                async _simulate() {
                    let dmaModel = this.dmaModel, context = this.storeSource.generateContext(), simulation;
                    dmaModel.source.sites = context.source;
                    dmaModel.target.sites = context.target;
                    await dmaModel.simulate();
                    simulation = dmaModel.target;
                    this.income && this.income.create(simulation.income);
                    this.impact && dmaModel.impactTable.columns && this.impact.create(dmaModel.impactTable);
                    this.neighbors && this.neighbors.create(simulation.neighbors);
                    return simulation;
                }
                release() {
                    this._off();
                    this.impact && this.impact.release();
                    this.neighbors && this.neighbors.release();
                    this.income && this.income.release();
                    this.zone && this.zone.release();
                    super.release();
                }
            }
            // <editor-fold defaultstate="collapsed" desc="DMALoader._Zone">
            DMALoader._Zone = class extends ResourceSubstitute {
                constructor(loader, dataCreator, zone) {
                    super(dataCreator, zone.reference.areaTable);
                    this.loader = loader;
                    this.zone = zone;
                }
                async load(reset) {
                    const zone = this.zone, [simulation] = await Promise.all([this.loader._simulate(), reset && await zone.district.reset()]);
                    this.create(simulation.area);
                    zone.invalidate(true);
                }
            };
            Dashboards_1.DMALoader = DMALoader;
            class TrafficLoader extends Tools.EventSinkMixin(StoreSourceLoader) {
                constructor(dashboard, storeSource, restModel, options) {
                    super(dashboard, storeSource);
                    this._trafficModel = new AFC.Traffic.TrafficModel(restModel);
                    this._status = 0 /* Traffic.TrafficStatus.none */;
                    let clusterId = "";
                    if (options) {
                        options.confirm && (this._confirm = options.confirm);
                        if (options.workingZone) {
                            this._workingArea = new ResourceSubstitute(dashboard.requestBuilder, options.workingZone.reference.areaTable);
                            this._trafficStatistics = new ResourceSubstitute(dashboard.requestBuilder, options.workingZone.reference.sitesTable.table);
                            clusterId = options.workingZone.cluster.id;
                            this._trafficModel.infoTableTemplate = options.workingZone.reference.sitesTable.table;
                        }
                        if (options.livingZone) {
                            this._livingArea = new ResourceSubstitute(dashboard.requestBuilder, options.livingZone.reference.areaTable);
                            this._trafficStatistics = new ResourceSubstitute(dashboard.requestBuilder, options.livingZone.reference.sitesTable.table);
                            clusterId = options.livingZone.cluster.id;
                            this._trafficModel.infoTableTemplate = options.workingZone.reference.sitesTable.table;
                        }
                        //this._setDashboardCluster(dashboard, clusterId, options.currentCodeValue);
                        this._dashboard = dashboard;
                        this._cluster = clusterId;
                        this._trafficModel.serverKind = options.customServer;
                        this._trafficModel.x = options.x;
                        this._trafficModel.y = options.y;
                        this._trafficModel.currentCodeValue = options.currentCodeValue;
                        this._trafficModel.geographicSource = options.geographicSource;
                        this._trafficModel.setUseCredit(false, "");
                    }
                }
                _setDashboardCluster(dashboard, clusterId, value) {
                    for (var i = 0; i < dashboard.clusters.length; i++) {
                        if (dashboard.clusters[i].id === clusterId) {
                            if (dashboard.clusters[i].current != value)
                                dashboard.clusters[i].current = value;
                            break;
                        }
                    }
                }
                _getDashboardCluster(dashboard, clusterId) {
                    for (var i = 0; i < dashboard.clusters.length; i++) {
                        if (dashboard.clusters[i].id === clusterId) {
                            return dashboard.clusters[i].current;
                        }
                    }
                    return "";
                }
                updateBody(body) {
                    super.updateBody(body);
                    if (!this._trafficModel.isOnError && (this._status == 2 /* Traffic.TrafficStatus.ready */)) {
                        this._workingArea && this._workingArea.updateBody(body);
                        this._livingArea && this._livingArea.updateBody(body);
                        this._trafficStatistics && this._trafficStatistics.updateBody(body);
                    }
                }
                forceBuy(pack) {
                    this._trafficModel.setUseCredit(true, pack);
                }
                load() {
                    return (this._status === 2 /* Traffic.TrafficStatus.ready */) ? Promise.resolve() : new Promise(async (resolve) => {
                        await super.load();
                        this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve());
                        this._trafficModel.request().then((statistics) => {
                            if (!this._trafficModel.isOnError) {
                                this._workingArea && this._workingArea.create(statistics.workingArea);
                                this._livingArea && this._livingArea.create(statistics.livingArea);
                                this._trafficStatistics && this._trafficStatistics.create(statistics.infoTable);
                                this._setDashboardCluster(this._dashboard, this._cluster, statistics.id);
                            }
                            else {
                                /*
                                delete this._workingArea;
                                delete this._livingArea;
                                delete this._trafficStatistics;
                                */
                            }
                            this._trafficModel.setUseCredit(false, "");
                            this._status = 2 /* Traffic.TrafficStatus.ready */;
                            this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                        });
                    });
                }
                _update(event) {
                    let h = (update) => update && super._update(event);
                    this._confirm ? this._confirm(h) : h(true);
                }
                release() {
                    this._status = 0 /* Traffic.TrafficStatus.none */;
                    /*
                    this._workingArea && this._workingArea.release();
                    this._livingArea && this._livingArea.release();
                    this._trafficStatistics && this._trafficStatistics.release();
                    */
                    super.release();
                }
            }
            Dashboards_1.TrafficLoader = TrafficLoader;
            function setClusterSite(cluster, store) {
                let code;
                cluster.zones.some((zone) => {
                    let sitesTable = zone.reference.sitesTable;
                    return sitesTable && (code = store.getData(sitesTable.codecolumn));
                });
                return cluster.current = code;
            }
            Dashboards_1.setClusterSite = setClusterSite;
            function _getMaxValue(i0, i1) {
                return i0 === void 0 && i1 === void 0 ? void 0 : Math.max(i0 || 0, i1 || 0);
            }
            class RowIndex {
                constructor() {
                    this._index = {};
                    this._length = 0;
                }
                get(key) {
                    return this._index[key];
                }
                add(key) {
                    return this._index[key] = this._length++;
                }
            }
            class SheetColumns {
                constructor(metadataIn, rowIndex, cellTemplates, metadataOut, classCount) {
                    let columnHeadersIn = metadataIn.columnHeaders, rowHeadersIn = metadataIn.rowHeaders, imagesIn = metadataIn.images, classesIn = metadataIn.classes, columnHeadersOut = metadataOut.columnHeaders, rowHeadersOut = metadataOut.rowHeaders, imagesOut, classesOut, lines;
                    this.classCount = 0;
                    if (rowHeadersIn.items.length && columnHeadersIn.items.length) {
                        this.cells = metadataIn.items;
                        this.lines = lines = [];
                        if (imagesIn) {
                            imagesOut = metadataOut.images || (metadataOut.images = {});
                            for (let image in imagesIn) {
                                imagesOut[image] = imagesIn[image];
                            }
                        }
                        if (classesIn) {
                            classesOut = metadataOut.classes || (metadataOut.classes = {});
                            this.classes = {};
                            for (let item in classesIn) {
                                let name = `c${classCount + this.classCount++}`;
                                classesOut[this.classes[item] = name] = classesIn[item];
                            }
                        }
                        columnHeadersOut.visibility = columnHeadersOut.visibility || columnHeadersIn.visibility;
                        columnHeadersOut.height = _getMaxValue(columnHeadersOut.height, columnHeadersIn.height);
                        this.columnHeaders = columnHeadersIn.items.map(cell => this.getCell(cell));
                        rowHeadersOut.visibility = rowHeadersOut.visibility || rowHeadersIn.visibility;
                        rowHeadersOut.width = _getMaxValue(rowHeadersOut.width, rowHeadersIn.width);
                        rowHeadersIn.items.forEach((rowHeader, y) => {
                            let pos = rowIndex.get(rowHeader.value), cellTemplate;
                            if (pos === void 0) {
                                pos = rowIndex.add(rowHeader.value);
                                rowHeadersOut.items.push(this.getCell(rowHeader));
                                cellTemplate = this.getCell(metadataIn.items[y][0]);
                                cellTemplate.format = void 0;
                                cellTemplate.value = '-';
                                cellTemplates.push(cellTemplate);
                            }
                            lines[pos] = y;
                        });
                    }
                }
                get length() {
                    return (this.lines && this.lines.length) || 0;
                }
                // append rowheaders, images and classes, build column headers
                appendSheet(cellTemplates, views, sheet, positions, properties) {
                    let columnHeaders = properties.columnHeaders.items, nbRow = properties.rowHeaders.items.length, cells = properties.items;
                    for (let row = 0; row < nbRow; ++row) {
                        let y = this.lines[row];
                        this.columnHeaders.forEach((header, x) => {
                            let cell;
                            row || (positions.push({ columns: sheet, offset: x, lines: (this.lines.length = nbRow, this.lines) }), columnHeaders.push(header));
                            if (y !== void 0) {
                                cell = this.getCell(this.cells[y][x]);
                            }
                            (cells[row] || (cells[row] = [])).push(cell || cellTemplates[row]);
                        });
                    }
                }
                getCell(cell) {
                    if (cell.className) {
                        let clone = Object.create(cell);
                        clone.className = this.classes[cell.className];
                        return clone;
                    }
                    return cell;
                }
            }
            function _analyze(results, celltemplates, properties) {
                let index = {}, rowIndex = new RowIndex(), content, classCount = 0;
                results.map((result, indice) => {
                    let columns = index[result.id];
                    if (!columns) {
                        index[result.id] = columns = new SheetColumns(result.sheetProperties, rowIndex, celltemplates, properties, classCount);
                        classCount += columns.classCount;
                    }
                    columns.length && (content || (content = [])).push({ sheet: indice, columns: columns });
                });
                return content;
            }
            function _buildProperties(results, views, positions) {
                let celltemplates = [], properties = {
                    columnHeaders: {
                        visibility: false,
                        items: []
                    },
                    items: [],
                    rowHeaders: {
                        visibility: false,
                        items: []
                    }
                }, analysis = _analyze(results, celltemplates, properties);
                analysis.forEach(item => {
                    item.columns.appendSheet(celltemplates, views, item.sheet, positions, properties);
                });
                return properties;
            }
            class GridAppAggregate extends Dashboards.MetaGridApp {
                constructor(template, positions, data) {
                    super(template, false);
                    this.allowOrdering = false;
                    this.positions = positions;
                    this.data = data;
                }
                getRowCount() {
                    return this.template.items.length;
                }
                getRowHeader(line) {
                    let item = this.template.rowHeaders.items[line];
                    return this._getCellEx(item, item.value, item.text);
                }
                getRowHeaderWidth() {
                    return this.template.rowHeaders.width;
                }
                getRowHeight(line) {
                    return this.template.rowHeaders.items[line].height;
                }
                getColumnInfo(column) {
                    return;
                }
                getColumnHeader(column) {
                    let item = this.template.columnHeaders.items[column], value, position, data;
                    if (item.dynamic) {
                        position = this.positions[column];
                        value = (data = this.data[position.columns]) && data.columnHeaders.items[position.offset]?.value;
                    }
                    else {
                        value = item.value;
                    }
                    return this._getCellEx(item, value, item.text);
                }
                getColumnHeaderHeight() {
                    return this.template.columnHeaders.height;
                }
                getColumnWidth(column) {
                    return this.template.columnHeaders.items[column].width;
                }
                getCell(column, line) {
                    let item = this.template.items[line][column], value, position, indice, data;
                    if (item.dynamic) {
                        position = this.positions[column];
                        if ((data = this.data[position.columns]) && ((indice = position.lines[line]) !== void 0)) {
                            value = data.items[indice][position.offset]?.value;
                        }
                    }
                    else {
                        value = item.value;
                    }
                    return this._getCellEx(item, value, item.text);
                }
                getValue(column, line) {
                    return;
                }
            }
            class DashboardsAggregate extends Tools.EventSink {
                /* Obsolete : for compatibility only */
                getType() {
                    return Promise.resolve(3 /* AFC.Dashboards.ViewType.aggregatedSheet */);
                }
                getForeignDataModel() {
                    return;
                }
                getLegendImage(width, height, horizontal, quality) {
                    throw new Error('not implemented');
                }
                /* End Obsolete */
                _onAttach() {
                    this.fireEvent(6 /* EventType.Dirty */);
                }
                constructor() {
                    super();
                    this.on(1073741824 /* EventType.Attach */, this._onAttach, this);
                }
                _releaseView(view) {
                    view.dashboard.off(6 /* Tools.EventType.Dirty */, this._onDirty, this);
                }
                _loadViewData(sheet, indice) {
                    let data = this._data;
                    delete data[indice];
                    sheet.getData().then((d) => {
                        if (data === this._data) {
                            let columns = [], gridApp = this._gridApp;
                            data[indice] = d;
                            if (gridApp) {
                                gridApp.positions.forEach((position, column) => position.columns === indice && columns.push(column));
                                this.fireEvent(6 /* Tools.EventType.Dirty */, columns);
                            }
                        }
                    });
                }
                _onDirty(e) {
                    let dashboard = e.target;
                    this._sheets && this._sheets.forEach((sheet, indice) => {
                        if (sheet.dashboard === dashboard) {
                            this._loadViewData(sheet, indice);
                        }
                    });
                }
                _clear() {
                    if (this._gridApp) {
                        this._sheets.forEach(this._releaseView.bind(this));
                        delete this._gridApp;
                    }
                    delete this._sheets;
                    delete this._data;
                    this.fireEvent(1073741824 /* EventType.Attach */);
                }
                setId(value) {
                    if (value !== this._id) {
                        this._id = value;
                        this._clear();
                    }
                }
                get id() {
                    return this._id;
                }
                get label() {
                    return this._id;
                }
                set dashboards(value) {
                    if (value !== this._dashboards) {
                        this._dashboards = value;
                        this._clear();
                    }
                }
                get dashboards() {
                    return this._dashboards;
                }
                async getGridApp() {
                    let dashboards, id;
                    return this._gridApp || ((dashboards = this._dashboards) && dashboards.length && (id = this._id) && new Promise(resolve => {
                        this.notify(65536 /* Tools.EventType.UserEvent */, () => resolve(this._gridApp));
                        if (!this._sheets) {
                            let positions = [], data = [], sheets = [], promises = [];
                            this._sheets = sheets;
                            this._data = data;
                            dashboards.forEach((dashboard, indice) => {
                                let view = Tools.findByIdOrName(id, dashboard.views, view => (view.type === 3 /* AFC.Dashboards.ViewType.aggregatedSheet */) || (view.type === 5 /* AFC.Dashboards.ViewType.spreadSheet */));
                                if (view) {
                                    promises.push(view.getMetadata());
                                    view.dashboard.on(6 /* Tools.EventType.Dirty */, this._onDirty, this);
                                    sheets.push(view);
                                    this._loadViewData(view, indice);
                                }
                            });
                            Promise.all(promises).then(results => {
                                if (this._sheets === sheets) {
                                    this._gridApp = new GridAppAggregate(_buildProperties(results, sheets, positions), positions, data);
                                    this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                                }
                            });
                        }
                    }));
                }
            }
            Dashboards_1.DashboardsAggregate = DashboardsAggregate;
        })(Dashboards = Tools.Dashboards || (Tools.Dashboards = {}));
    })(Tools = AFC.Tools || (AFC.Tools = {}));
})(AFC || (AFC = {}));
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
///<reference path="../AFC.ts" />
var AFC;
(function (AFC) {
    var Tools;
    (function (Tools) {
        var Geocoding;
        (function (Geocoding) {
            let Provider;
            (function (Provider) {
                Provider[Provider["auto"] = 0] = "auto";
                Provider[Provider["nominatim"] = 1] = "nominatim";
                Provider[Provider["dataGouv"] = 2] = "dataGouv";
            })(Provider = Geocoding.Provider || (Geocoding.Provider = {}));
            const _nominatimUrl = 'https://nominatim.openstreetmap.org/';
            const _dataGouvUrl = 'https://api-adresse.data.gouv.fr/';
            ;
            ;
            function _processNominatim(item) {
                let x = item.lon, y = item.lat;
                let geocodeResult;
                if ((x !== void 0) && (y !== void 0)) {
                    geocodeResult = {
                        score: item.importance,
                        location: {
                            type: 'Point',
                            coordinates: [parseFloat(x), parseFloat(y)]
                        },
                        native_: item
                    };
                    let address = item.address;
                    if (address) {
                        if (address.pedestrian || address.road) {
                            let streetNumber = address.house_number ? `${address.house_number}, ` : '';
                            geocodeResult.address = `${streetNumber}${address.pedestrian || address.road}`;
                        }
                        geocodeResult.zipCode = address.postcode ? address.postcode.split(';')[0] : void 0;
                        geocodeResult.city = address.city || address.town || address.village || void 0;
                        geocodeResult.country = address.country || void 0;
                        geocodeResult.countryCode = address.country_code || void 0;
                    }
                }
                return geocodeResult;
            }
            function _processDataGouv(item) {
                let geocodeResult;
                if (item.geometry) {
                    geocodeResult = {
                        score: item.properties.score,
                        location: item.geometry,
                        native_: item
                    };
                    geocodeResult.address = item.properties.name;
                    geocodeResult.zipCode = item.properties.postcode;
                    geocodeResult.city = item.properties.city || item.properties.town || item.properties.village || void 0;
                    geocodeResult.country = 'France';
                    geocodeResult.countryCode = 'fr';
                }
                return geocodeResult;
            }
            function _map(ts, f) {
                let results = [];
                ts.forEach((t) => {
                    let result = f(t);
                    results && results.push(result);
                });
                return results;
            }
            const _searchConfigurations = [
                //auto
                (query, options) => {
                    return (options && options.countryCode && (options.countryCode.toLowerCase() === 'fr') ? _searchConfigurations[2 /* Provider.dataGouv */] : _searchConfigurations[1 /* Provider.nominatim */])(query, options);
                },
                //nominatim
                (query, options) => {
                    let data = `format=json&addressdetails=1&q=${query}`;
                    if (options) {
                        (options.countryCode) && (data += `&countrycodes=${options.countryCode}`);
                        (options.bbox && (options.bbox.length === 4)) && (data += `&bounded=1&viewboxlbrt=${options.bbox.join(',')}`);
                        (options.maxResults) && (data += `&limit=${options.maxResults}`);
                    }
                    let settings = {
                        url: `${_nominatimUrl}search`,
                        data: data
                    };
                    return { settings: settings, handle: (data) => _map(data, _processNominatim) };
                },
                //dataGouv
                (query, options) => {
                    let data = `q=${query}`;
                    if (options) {
                        (options.maxResults) && (data += `&limit=${options.maxResults}`);
                    }
                    let settings = {
                        url: `${_dataGouvUrl}search/`,
                        data: data
                    };
                    return { settings: settings, handle: (data) => _map(data.features, _processDataGouv) };
                }
            ];
            const _reverseConfigurations = [
                //auto
                (lat, lon, options) => {
                    return (options && options.countryCode && (options.countryCode.toLowerCase() === 'fr') ? _reverseConfigurations[2 /* Provider.dataGouv */] : _reverseConfigurations[1 /* Provider.nominatim */])(lat, lon, options);
                },
                //nominatim
                (lat, lon, options) => {
                    let data = `format=json&zoom=18&addressdetails=1&lat=${lat}&lon=${lon}`;
                    let settings = {
                        url: `${_nominatimUrl}reverse`,
                        data: data
                    };
                    return { settings: settings, handle: _processNominatim };
                },
                //dataGouv
                (lat, lon, options) => {
                    let data = `lon=${lon}&lat=${lat}`;
                    let settings = {
                        url: `${_dataGouvUrl}reverse/`,
                        data: data
                    };
                    return { settings: settings, handle: (data) => data.features && data.features.length && _processDataGouv(data.features[0]) };
                }
            ];
            class Geocoder {
                _onReverseComplete(handle, callback, jqXHR, textStatus) {
                    let geocodeResult;
                    let success = jqXHR.status === 200;
                    if (success) {
                        let data = jqXHR.responseText && JSON.parse(jqXHR.responseText);
                        data && (geocodeResult = handle(data));
                    }
                    callback(geocodeResult, success);
                }
                _onSearchComplete(handle, callback, jqXHR, textStatus) {
                    let geocodeResults;
                    let success = jqXHR.status === 200;
                    if (success) {
                        let data = jqXHR.responseText && JSON.parse(jqXHR.responseText);
                        data && (geocodeResults = handle(data));
                    }
                    callback(geocodeResults || [], success);
                }
                search(query, callback, options) {
                    let provider = (options && options.provider) || 0 /* Provider.auto */;
                    let handler = _searchConfigurations[provider];
                    let configuration;
                    if (handler && (configuration = handler(query, options))) {
                        let settings = jQuery.extend({
                            method: 'GET',
                            processData: false,
                            async: true,
                            complete: (jqXHR, textStatus) => this._onSearchComplete(configuration.handle, callback, jqXHR, textStatus)
                        }, configuration.settings);
                        jQuery.ajax(settings);
                    }
                }
                reverse(lat, lon, callback, options) {
                    let provider = (options && options.provider) || 0 /* Provider.auto */;
                    let handler = _reverseConfigurations[provider];
                    let configuration;
                    if (handler && (configuration = handler(lat, lon, options))) {
                        let settings = jQuery.extend({
                            method: 'GET',
                            processData: false,
                            async: true,
                            complete: (jqXHR, textStatus) => this._onReverseComplete(configuration.handle, callback, jqXHR, textStatus)
                        }, configuration.settings);
                        jQuery.ajax(settings);
                    }
                }
            }
            Geocoding.Geocoder = Geocoder;
        })(Geocoding = Tools.Geocoding || (Tools.Geocoding = {}));
    })(Tools = AFC.Tools || (AFC.Tools = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 14/03/2016.
 */
///<reference path="../models/globals/MapView.ts" />
///<reference path="../adapters/globals/MapAdapter.ts" />
///<reference types="leaflet" />
var AFC;
(function (AFC) {
    var Tools;
    (function (Tools) {
        var ParcEdition;
        (function (ParcEdition) {
            class MoveControl extends L.Control {
                constructor(info, cancel) {
                    let coordinates = info.store.geometry.coordinates;
                    super();
                    this._start = [coordinates[1], coordinates[0]];
                    this._cancel = cancel;
                    this.info = info;
                    this.options = {
                        position: 'topleft'
                    };
                    $(info.layer._icon).addClass('selectedMarker');
                }
                _onMove(e) {
                    let latlng = e.latlng;
                    let distance = Math.round(latlng.distanceTo(this._start));
                    this._text.text(distance + ' m');
                }
                onAdd(map) {
                    let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    let selection = d3.select(svg)
                        .attr("id", "moveCtrl")
                        .attr('height', 180)
                        .attr('width', 180);
                    selection.append('polygon')
                        .attr('points', '0,0 180,0 0,180');
                    this._text = selection.append('text')
                        .attr('x', 10)
                        .attr('y', 25)
                        .attr('font-size', 20)
                        .text('0');
                    map.on('mousemove', this._onMove, this);
                    selection.append('image')
                        .attr('xlink:href', 'img/Picto_Move_Large.png')
                        .attr('x', 10)
                        .attr('y', 35)
                        .attr('height', 64)
                        .attr('width', 64)
                        .on('click', (event /*, d*/) => {
                        this._cancel();
                        event.stopPropagation();
                    });
                    return svg;
                }
                onRemove(map) {
                    $(this.info.layer._icon).removeClass('selectedMarker');
                    map.off('mousemove', this._onMove, this);
                }
            }
            class LayerEditionHandlers {
                constructor(storeSource, holder, guiLayers, symbolFactory, options) {
                    this.options = options;
                    this.parc = storeSource;
                    this.holder = holder;
                    this.guiLayers = guiLayers;
                    this.symbolFactory = symbolFactory;
                }
                create(latlng) {
                    if (latlng) {
                        let code = this.options.createCode && this.options.createCode(this);
                        let store = this.parc.createStore(code);
                        store.geometry = { type: 'Point', coordinates: [latlng.lng, latlng.lat] };
                        return store;
                    }
                }
                startMove(info) {
                    this.endMove();
                    this.holder.control.closePopup();
                    this.holder.control.addControl(this._move = new MoveControl(info, this.endMove.bind(this)));
                }
                endMove() {
                    if (this._move) {
                        this.holder.control.removeControl(this._move);
                        delete this._move;
                    }
                }
                click(latlng, source, event) {
                    let info, gui;
                    if (this.disabled) {
                        return true;
                    }
                    if (this._move) {
                        let destination = { type: 'Point', coordinates: [latlng.lng, latlng.lat] };
                        let close = true;
                        info = this._move.info;
                        if (this.options.onMoveEnd) {
                            close = this.options.onMoveEnd(this, destination, info);
                        }
                        else {
                            info.store.geometry = destination;
                            info.store.commit();
                        }
                        close && this.endMove();
                    }
                    else {
                        gui = source && this.guiLayers.find(guiLayer => guiLayer === source.provider);
                        if (gui) {
                            const layer = source.feature, store = layer && this.parc.getStoreFromRow(layer.feature.properties.data);
                            info = store && { gui, layer, source, store };
                        }
                        if (!source === !info) {
                            this.options.click(this, latlng, info, event);
                        }
                        else {
                            return true;
                        }
                    }
                    event && L.DomEvent.stopPropagation(event);
                }
            }
            ParcEdition.LayerEditionHandlers = LayerEditionHandlers;
        })(ParcEdition = Tools.ParcEdition || (Tools.ParcEdition = {}));
    })(Tools = AFC.Tools || (AFC.Tools = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 05/10/2017.
 */
var AFC;
(function (AFC) {
    let Tools;
    (function (Tools) {
        function _dummy() {
            return null;
        }
        function _storage() {
            let storage;
            try {
                storage = localStorage;
            }
            catch (e) {
                storage = {
                    length: 0,
                    clear: _dummy,
                    getItem: _dummy,
                    key: _dummy,
                    removeItem: _dummy,
                    setItem: _dummy
                };
            }
            return storage;
        }
        let Storage;
        (function (Storage) {
            function setItem(key, value) {
                (value !== void 0) ? _storage().setItem(key, JSON.stringify(value)) : _storage().removeItem(key);
            }
            Storage.setItem = setItem;
            function getItem(key) {
                let value = _storage().getItem(key);
                if (value !== null) {
                    return JSON.parse(value);
                }
            }
            Storage.getItem = getItem;
            function getKeys() {
                let keys = [];
                let storage = _storage();
                for (let i = 0; i < storage.length; ++i) {
                    keys.push(storage.key(i));
                }
                return keys;
            }
            Storage.getKeys = getKeys;
        })(Storage = Tools.Storage || (Tools.Storage = {}));
    })(Tools = AFC.Tools || (AFC.Tools = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 22/05/2019.
 */
///<reference path="ParcEdition.ts" />
var AFC;
(function (AFC) {
    var Tools;
    (function (Tools) {
        var ParcEdition;
        (function (ParcEdition) {
            class StoreCartItemData {
                constructor(branch, store) {
                    this.id = branch;
                    this.store = store;
                }
            }
            class StoreCart extends Tools.EventSink {
                get length() {
                    return (this._data && this._data.length) || 0;
                }
                get label() {
                    return this.length.toString();
                }
                item(index) {
                    let item;
                    return this._data && (item = this._data[index]) && { dataItemIndex: index, dataItem: item };
                }
                indexOf(id, store) {
                    return this._data ? this._data.findIndex(item => (item.id === id) && (!AFC.Data.compareKey(store.key, item.store.key))) : -1;
                }
                add(id, store) {
                    let i = this.indexOf(id, store);
                    if (i === -1) {
                        (this._data || (this._data = [])).push(new StoreCartItemData(id, store));
                        this.fireEvent(6 /* Tools.EventType.Dirty */);
                        return true;
                    }
                }
                remove(id, store) {
                    let i = this.indexOf(id, store);
                    if (i !== -1) {
                        this._data.splice(i, 1);
                        this.fireEvent(6 /* Tools.EventType.Dirty */);
                    }
                }
                clear() {
                    delete this._data;
                    this.fireEvent(6 /* Tools.EventType.Dirty */);
                }
            }
            ParcEdition.StoreCart = StoreCart;
        })(ParcEdition = Tools.ParcEdition || (Tools.ParcEdition = {}));
    })(Tools = AFC.Tools || (AFC.Tools = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 26/04/2016.
 */
var AFC;
(function (AFC) {
    var Tools;
    (function (Tools) {
        function _callback(ref, arg) {
            if (ref.pending) {
                ref.h && ref.h.apply(this, arg);
                ref.dec() || ref.callback();
            }
        }
        class Synchronizer {
            constructor(callback, context) {
                var callees = [];
                var counter = 0;
                var __ = function (h, reference) {
                    h && (this.h = h);
                    this.pending = 1;
                    ++counter;
                    return this;
                };
                __.prototype.inc = function () {
                    ++this.pending;
                    return ++counter;
                };
                __.prototype.dec = function () {
                    --this.pending;
                    return --counter;
                };
                __.prototype.callback = () => { callback.call(context, this.result); };
                this.push = function (h, reference) {
                    let callee;
                    let ret;
                    for (let item of callees) {
                        if (item.h === h) {
                            callee = item;
                            break;
                        }
                    }
                    callee ? callee.inc() : callees.push(callee = new __(h, reference));
                    ret = (function (...args) {
                        _callback.call(this, callee, arguments);
                    });
                    return h ? Tools.AfcReferenceMixin(ret, reference || h) : ret;
                };
                this.start = this.push(void 0);
            }
        }
        Tools.Synchronizer = Synchronizer;
    })(Tools = AFC.Tools || (AFC.Tools = {}));
})(AFC || (AFC = {}));
;
var AFC;
(function (AFC) {
    let BulkMail;
    (function (BulkMail) {
        const ALL_STORES_COLOR = "#d4d0cf";
        const ALL_STORES_CODE = "ALL_STORES";
        class BMAnalysisDataValue {
            constructor(from, value) {
                this._from = from;
                this._value = value;
            }
            from() {
                return this._from;
            }
            value() {
                return this._value;
            }
        }
        BulkMail.BMAnalysisDataValue = BMAnalysisDataValue;
        class BMAnalysisDataValues {
            constructor(group, custom) {
                this._custom = custom;
                this._group = group;
                this._values = [];
            }
            get values() {
                return this._values;
            }
            get(dataId) {
                let values = [];
                if (this._custom)
                    values = this._custom(dataId, this);
                if (values.length == 0) {
                    this._values.forEach(vs => {
                        let value = vs.values[dataId];
                        if (value != undefined)
                            values.push(new BMAnalysisDataValue(vs.from, value));
                    });
                }
                return values;
            }
            dateRange() {
                return this._values.map(v => v.from);
            }
            pushValue(from, values) {
                this._values.push({
                    from: new Date(from),
                    values: values
                });
            }
            get group() {
                return this._group;
            }
        }
        BulkMail.BMAnalysisDataValues = BMAnalysisDataValues;
        class BMAnalysisData {
            constructor(id, name = "", description = "", suffix = "", canAggregate = true, precision = NaN, format = null, isCustom = false) {
                this._id = id;
                this._name = name;
                this._description = description;
                this._canAggregate = canAggregate;
                this._suffix = suffix;
                this._precision = precision;
                this._isCustom = isCustom;
                this._format = format;
            }
            get id() {
                return this._id;
            }
            get name() {
                return this._name;
            }
            get description() {
                return this._description;
            }
            get isCustom() {
                return this._isCustom;
            }
            canAggregate() {
                return this._canAggregate;
            }
            toString(x) {
                let _round = (v, precision) => {
                    if (isNaN(precision))
                        return v;
                    let f = Math.pow(10, precision);
                    return Math.round(v * f) / f;
                };
                return this._format ? this._format(x) : `${_round(x, this._precision).toLocaleString()}${this._suffix}`;
            }
        }
        BulkMail.BMAnalysisData = BMAnalysisData;
        class BMAnalysisGroupItemStyle {
            constructor(color) {
                this._color = color;
            }
            get color() {
                return this._color;
            }
        }
        class _StoreGroupItem {
            constructor(codeColumn, store) {
                this._store = store;
                this._codeColumn = codeColumn;
            }
            get key() {
                return { id: this._codeColumn, value: this._store.code };
            }
            get id() {
                return this._store.code;
            }
            get name() {
                return this._store.name;
            }
            get description() {
                return "";
            }
            get isStore() {
                return true;
            }
            get style() {
                return null;
            }
            get count() {
                return 1;
            }
        }
        class _GroupGroupItem {
            constructor(groupKey, groupValue, items, color) {
                this._key = groupKey;
                this._value = groupValue;
                this._stores = items;
                this._color = color;
            }
            get key() {
                return { id: this._key, value: this._value };
            }
            get id() {
                return `${this._key}-${this._value}`;
            }
            get name() {
                return this._value;
            }
            get description() {
                return `${this._stores.length} magasin${this._stores.length > 1 ? 's' : ''}`;
            }
            get isStore() {
                return false;
            }
            get style() {
                return new BMAnalysisGroupItemStyle(this._color);
            }
            get count() {
                return this._stores.length;
            }
        }
        class BMAnalysisGroupsSettings {
            constructor() {
                this._storesTable = null;
                this._groupColumns = [];
                this._groups = null;
                this._allStoresLabel = "";
                this._allowAllStores = false;
                this._isValid = false;
            }
            load() {
                const cachedData = BulkMail.BMEntityCacheData.getInstance();
                return new Promise((resolve, reject) => {
                    let request = cachedData.restModel.createAjaxRequest(`${BMAnalysis.uri}/groups`, true);
                    request.options.method = "GET";
                    request.options.always = ((sequence, jqXHR, textStatus) => {
                        if (jqXHR.status == 200) {
                            let items = jqXHR.responseJSON;
                            this.groupColumns = items;
                        }
                        resolve(true);
                    });
                    request.call();
                });
            }
            get description() {
                let res = [];
                if (this._allowAllStores) {
                    let allStoresGroup = this._getAllStoresGroup();
                    let label = this._allStoresLabel;
                    res.push({
                        get id() { return allStoresGroup.key.id; },
                        get name() { return label; },
                        get style() { return allStoresGroup.style; }
                    });
                }
                return res.concat(this._groupColumns.map(col => {
                    let color = col.color;
                    let colId = col.name;
                    let colName = col.alias;
                    return {
                        get id() { return colId; },
                        get name() { return colName; },
                        get style() { return new BMAnalysisGroupItemStyle(color); }
                    };
                }));
            }
            set storesTable(storesTable) {
                if (this._storesTable != storesTable) {
                    this._storesTable = storesTable;
                    this._isValid = false;
                }
            }
            set nameColum(col) {
                if (this._nameColum != col) {
                    this._nameColum = col;
                    this._isValid = false;
                }
            }
            set codeColum(col) {
                if (this._codeColum != col) {
                    this._codeColum = col;
                    this._isValid = false;
                }
            }
            set groupColumns(cols) {
                let colors = ["#E77423", "#345995", "#3C896D", "#390040", "#FFE066"];
                this._allowAllStores = false;
                this._allStoresLabel = "";
                this._groupColumns = cols.filter(c => c.id != ALL_STORES_CODE).map((c, idx) => { return { name: c.id, alias: c.name, description: c.description, color: colors[idx % colors.length] }; });
                this._isValid = false;
                let allStores = cols.find(c => c.id == ALL_STORES_CODE);
                if (allStores != undefined) {
                    this._allowAllStores = true;
                    this._allStoresLabel = allStores.name;
                }
            }
            findFromKey(key) {
                this._init();
                if (key.id == this._codeColum) {
                    let store = this._allStores.find(store => store.code == key.value);
                    if (store != undefined)
                        return (new _StoreGroupItem(this._codeColum, store));
                }
                else if (key.id == "") {
                    return this._getAllStoresGroup();
                }
                else {
                    let groupIndex = this._groupColumns.findIndex(col => col.name == key.id);
                    if (groupIndex != -1 && groupIndex < this._groups.length) {
                        let group = this._groups[groupIndex].get(key.value);
                        return (new _GroupGroupItem(key.id, key.value, group.map(storeIdx => this._allStores[storeIdx]), this._groupColumns[groupIndex].color));
                    }
                }
                return null;
            }
            find(searchString, groupsOnly) {
                let res = [];
                let _this = this;
                let lcSearchString = searchString.toLowerCase();
                let isStoreOKForFilter = function (store) {
                    if (searchString == "")
                        return true;
                    return store.name.toLowerCase().includes(lcSearchString) || store.code.toLowerCase().includes(lcSearchString);
                };
                let isGroupOKForFilter = function (groupValue, storesIdx) {
                    if (searchString == "")
                        return true;
                    if (groupValue.toLowerCase().includes(lcSearchString))
                        return true;
                    return storesIdx.map(idx => _this._allStores[idx]).some(store => isStoreOKForFilter(store));
                };
                let addStores = true;
                let addGroups = true;
                if (groupsOnly != undefined) {
                    addStores = !groupsOnly;
                    addGroups = groupsOnly;
                }
                this._init();
                if (addStores) {
                    this._allStores.forEach(store => {
                        if (isStoreOKForFilter(store))
                            res.push(new _StoreGroupItem(this._codeColum, store));
                    });
                }
                if (addGroups) {
                    this._groups.forEach((groupMap, groupIdx) => {
                        let groupKey = this._groupColumns[groupIdx];
                        groupMap.forEach((stores, groupValue) => {
                            if (isGroupOKForFilter(groupValue, stores)) {
                                res.push(new _GroupGroupItem(groupKey.name, groupValue, stores.map(storeIdx => this._allStores[storeIdx]), groupKey.color));
                            }
                        });
                    });
                }
                if (this._allowAllStores && addGroups && res.length > 0)
                    res.unshift(this._getAllStoresGroup());
                return res;
            }
            _getAllStoresGroup() {
                return new _GroupGroupItem("", this._allStoresLabel, this._allStores, ALL_STORES_COLOR);
            }
            _init() {
                if (!this._isValid && this._storesTable) {
                    let columnsIndex = new Map();
                    let pkColumnIdx = "";
                    let pk = this._storesTable.primaryKey;
                    let values = this._storesTable.values;
                    this._storesTable.columns.forEach((col, idx) => {
                        columnsIndex.set(col.name.toLowerCase(), idx);
                        if (col.alias != "")
                            columnsIndex.set(col.alias.toLowerCase(), idx);
                    });
                    let groupColumnsIdx = this._groupColumns.map(col => columnsIndex.get(col.name.toLowerCase()));
                    let nameColumnIdx = columnsIndex.get(this._nameColum.toLowerCase());
                    let codeColumnIdx = columnsIndex.get(this._codeColum.toLowerCase());
                    if ([...groupColumnsIdx, nameColumnIdx, codeColumnIdx].every(idx => idx !== undefined)) {
                        this._allStores = [];
                        this._groups = [];
                        groupColumnsIdx.forEach(_ => this._groups.push(new Map()));
                        values.forEach((store) => {
                            this._allStores.push({ code: store[codeColumnIdx], name: store[nameColumnIdx] });
                            let storeIndex = this._allStores.length - 1;
                            groupColumnsIdx.forEach((colIdx, groupIdx) => {
                                let groupValue = store[colIdx];
                                let groupStores = this._groups[groupIdx].get(groupValue);
                                if (groupStores == undefined)
                                    this._groups[groupIdx].set(groupValue, [storeIndex]);
                                else {
                                    groupStores.push(storeIndex);
                                    this._groups[groupIdx].set(groupValue, groupStores);
                                }
                            });
                        });
                    }
                    this._isValid = true;
                }
            }
        }
        BulkMail.BMAnalysisGroupsSettings = BMAnalysisGroupsSettings;
        class BMAnalysis extends AFC.Tools.EventSink {
            static get uri() {
                return `${BulkMail.BMEntityCacheData.path}/analysis`;
            }
            constructor(groupsSettings) {
                super();
                this._data = undefined;
                this._customData = [];
                this._customValues = null;
                this._groupsSettings = groupsSettings;
                this._dataValuesCache = new Map();
                this._pendingRequests = new Set();
            }
            findGroupsFromKey(key) {
                return this._groupsSettings.findFromKey(key);
            }
            findGroups(searchString, groupsOnly) {
                return this._groupsSettings.find(searchString, groupsOnly);
            }
            get groupsDescription() {
                return this._groupsSettings.description;
            }
            get data() {
                if (this._data == undefined) {
                    const cachedData = BulkMail.BMEntityCacheData.getInstance();
                    this._data = [];
                    return new Promise((resolve, reject) => {
                        let request = cachedData.restModel.createAjaxRequest(`${BMAnalysis.uri}/indicators`, true);
                        request.options.method = "GET";
                        request.options.always = ((sequence, jqXHR, textStatus) => {
                            if (jqXHR.status == 200) {
                                let items = jqXHR.responseJSON;
                                this._data = items.map(item => new BMAnalysisData(item.id, item.name, item.description, item.suffix, item.canAggregate, item.precision));
                            }
                            this.data.then(d => resolve(d));
                            //resolve([...this._data, ...this._customData]);
                        });
                        request.call();
                    });
                }
                else
                    return Promise.resolve([...this._data, ...this._customData]);
            }
            requestDataValues(group) {
                let key = `${group.key.id}=${group.key.value}`;
                let isPending = this._pendingRequests.has(key);
                let values = this._dataValuesCache.get(key);
                if (values == undefined) {
                    const cachedData = BulkMail.BMEntityCacheData.getInstance();
                    return new Promise((resolve, reject) => {
                        let onNotify = () => {
                            let values = this._dataValuesCache.get(key);
                            if (values != undefined) {
                                resolve(values);
                                this.off(65536 /* Tools.EventType.UserEvent */, onNotify);
                            }
                        };
                        this.on(65536 /* Tools.EventType.UserEvent */, onNotify);
                        if (!isPending) {
                            let request = cachedData.restModel.createAjaxRequest(`${BMAnalysis.uri}/compute`, true);
                            this._pendingRequests.add(key);
                            request.options.method = "GET";
                            request.options.data = { filterColumn: group.key.id, filterValue: group.key.value };
                            request.options.always = ((sequence, jqXHR, textStatus) => {
                                if (jqXHR.status == 200) {
                                    let vs = jqXHR.responseJSON;
                                    values = new BMAnalysisDataValues(group, this._customValues);
                                    vs.forEach(value => {
                                        values.pushValue(new Date(value.date), value.values);
                                    });
                                }
                                this._dataValuesCache.set(key, values);
                                this._pendingRequests.delete(key);
                                this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                                //resolve(values);
                            });
                            request.call();
                        }
                    });
                }
                return Promise.resolve(values);
            }
            set customData(data) {
                this._customData = data;
            }
            set customValues(fn) {
                this._customValues = fn;
            }
            XLSExport(groups, dateRanges) {
                let cachedData = BulkMail.BMEntityCacheData.getInstance();
                let request = cachedData.restModel.createAjaxRequest(`${BMAnalysis.uri}/report`, true);
                this.data.then(async (d) => {
                    let [values0, values1] = await Promise.all([this.requestDataValues(groups.group0), this.requestDataValues(groups.group1)]);
                    let valuesToSend0 = [];
                    let valuesToSend1 = [];
                    let customValues = {};
                    d.forEach(data => {
                        if (data.isCustom) {
                            [values0, values1].forEach((vs, idx) => {
                                vs.get(data.id).forEach(customValue => {
                                    let key = `${customValue.from().getTime()}##${idx}`;
                                    let value = customValue.value();
                                    let knownValue = customValues[key];
                                    if (knownValue == undefined)
                                        customValues[key] = {};
                                    customValues[key][data.id] = value;
                                });
                            });
                        }
                    });
                    [values0.values, values1.values].forEach((vs, idx) => {
                        vs.forEach(v => {
                            let key = `${v.from.getTime()}##${idx}`;
                            let customValue = customValues[key];
                            let finalValue = { ...v };
                            for (let cv in customValue)
                                finalValue.values[cv] = customValue[cv];
                            if (idx == 0)
                                valuesToSend0.push(finalValue);
                            else
                                valuesToSend1.push(finalValue);
                        });
                    });
                    request.options.data = {
                        groups: {
                            group0: { filterColumn: groups.group0.key.id, filterValue: groups.group0.key.value, values: valuesToSend0 },
                            group1: { filterColumn: groups.group1.key.id, filterValue: groups.group1.key.value, values: valuesToSend1 },
                        },
                        dateRanges: dateRanges
                    };
                    request.options.method = "POST" /* Rest.RestMethod.POST */;
                    request.options.format = 15 /* Rest.RestFormat.xlsx */;
                    request.options.xhrFields = { responseType: "blob" };
                    request.options.done = (sequence, data, textStatus, jqXHR) => {
                        let blob = new Blob([data], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" /* Rest.MimeType.xlsx */ });
                        saveAs(blob, AFC.Tools.StringTools.normalizeString(`AnalysisReport.xlsx`));
                    };
                    cachedData.sequence = request.call();
                });
            }
        }
        BulkMail.BMAnalysis = BMAnalysis;
    })(BulkMail = AFC.BulkMail || (AFC.BulkMail = {}));
})(AFC || (AFC = {}));
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
var AFC;
(function (AFC) {
    let BulkMail;
    (function (BulkMail) {
        class BMEntity extends AFC.Tools.EventSink {
            get code() { return this._code; }
            constructor(item) {
                super();
            }
        }
        BulkMail.BMEntity = BMEntity;
    })(BulkMail = AFC.BulkMail || (AFC.BulkMail = {}));
})(AFC || (AFC = {}));
;
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="./BMCampaign.ts" />
var AFC;
(function (AFC) {
    let BulkMail;
    (function (BulkMail) {
        let BMStoreStatus;
        (function (BMStoreStatus) {
            BMStoreStatus["active"] = "active";
            BMStoreStatus["inactive"] = "inactive";
            BMStoreStatus["undefined"] = "undefined"; // parce que t'es obligé de gérer les erreurs data coté front
        })(BMStoreStatus = BulkMail.BMStoreStatus || (BulkMail.BMStoreStatus = {}));
        /**
         * Instance of store for a campaign
         */
        class BMStore extends BulkMail.BMEntity {
            constructor(campaign, item) {
                super();
                this._campaign = campaign;
                if (item) {
                    this._code = item.code;
                    this._status = item.status;
                    this._statusInitial = this._status;
                    if (item["values"]) {
                        this._valuesTargeted = item["values"];
                    }
                }
            }
            get code() { return this._code; }
            get status() { return this._status; }
            set status(status) { this._status = status; }
            get statusInitial() { return this._statusInitial; }
            get valuesInitial() { return this._valuesInitial; }
            get valuesTargeted() { return this._valuesTargeted; }
            set valuesTargeted(values) {
                if (this._valuesInitial === void 0 && !this._campaign.hasUpcoming()) {
                    this._valuesInitial = { ...values };
                }
                this._valuesTargeted = { ...values };
            }
            get valuesTargetedMax() { return this._valuesTargetedMax; }
            set valuesTargetedMax(values) { this._valuesTargetedMax = { ...values }; }
            get valuesUpcoming() { return this._valuesUpcoming; }
            set valuesUpcoming(values) {
                if (this._valuesInitial === void 0 && this._campaign.hasUpcoming()) {
                    this._valuesInitial = { ...values };
                }
                this._valuesUpcoming = { ...values };
            }
            get valuesUpcomingMax() { return this._valuesUpcomingMax; }
            set valuesUpcomingMax(values) { this._valuesUpcomingMax = { ...values }; }
            /**
             * Test if store is active (in campaign)
             *
             * @returns
             */
            isActive() {
                return this.status === "active" /* BMStoreStatus.active */;
            }
            /**
             * Toggle store status to active or inactive (no DB saving)
             *
             * @param active
             * @returns
             */
            toggleActive(active) {
                this.status = active === true || !this.isActive() ? "active" /* BMStoreStatus.active */ : "inactive" /* BMStoreStatus.inactive */;
                return this.status;
            }
            getQtyTargeted(options) {
                return this._getQty(this.valuesTargeted, options);
            }
            getQtyUpcoming(options) {
                return this._getQty(this.valuesUpcoming, options);
            }
            getQtyDiff() {
                return this.getQtyUpcoming() - this.getQtyTargeted();
            }
            /**
             * Return computed quantity according to given options (= segments), if no option, return sum of all
             * active segments in campaign
             *
             * @param options An array of segments code
             * @param optGetInitial If force true, retrieve intial values targeted or upcoming (valeus that hasnt changed following multiple computes by user), default is false
             * @returns sum of qty according to segments given or default active segments in campaign
             */
            getQty(options, optGetInitial = false) {
                const values = optGetInitial ? this.valuesInitial
                    : (this._campaign.hasUpcoming() ? this.valuesUpcoming : this.valuesTargeted);
                return this._getQty(values, options);
            }
            /**
             * Get max qty available
             * // TODO: refacto with previous getQty() fn
             *
             * @param options
             * @returns
             */
            getQtyMax(options) {
                const values = this._campaign.hasUpcoming() ? this.valuesUpcomingMax : this.valuesTargetedMax;
                return this._getQty(values, options);
            }
            _getQty(values, options) {
                if (values) {
                    if (values.cost)
                        return values.cost.volume;
                    return (options || this._campaign.getActiveSegments()).reduce((prev, curr) => prev + (values[curr] ?? 0), 0);
                }
                return 0;
            }
            /**
             * Return qty temp = input by user in store edition table
             *
             * @returns
             */
            getQtyTemp() {
                return this.qtyTemp !== void 0 ? this.qtyTemp : this.getQty();
            }
            getBudget() {
                return this.valuesTargeted?.cost?.budget || 0;
            }
            getBudgetMax() {
                return this.valuesTargetedMax?.cost?.budget;
            }
            getVolume() {
                return this.valuesTargeted?.cost?.volume;
            }
            getVolumeMax() {
                return this.valuesTargetedMax?.cost?.volume;
            }
            getZoneAggregates() {
                const cachedData = BulkMail.BMEntityCacheData.getInstance();
                const store = this;
                const valuesUpcoming = store.valuesUpcoming;
                const valuesTargeted = store.valuesTargeted;
                const campaign = store._campaign;
                const provider = cachedData.provider(null, campaign.codeVersionTargeted);
                const segments = campaign.getActiveSegments();
                const aggregateCodeList = [...segments];
                const aggregates = {};
                provider.aggregates.forEach((agg) => aggregateCodeList.push(agg.code)); // extract all aggregates code to be computed
                aggregateCodeList.forEach(aggCode => {
                    if (valuesUpcoming)
                        aggregates[aggCode] = valuesUpcoming[aggCode];
                    if (valuesTargeted) {
                        if (!valuesUpcoming)
                            aggregates[aggCode] = valuesTargeted[aggCode];
                        aggregates[`${aggCode}.targeted`] = valuesTargeted[aggCode] ?? 0;
                    }
                    aggregates[aggCode] || (aggregates[aggCode] = 0);
                });
                let cost = valuesUpcoming?.cost || valuesTargeted?.cost;
                if (cost) {
                    for (let prop in cost) {
                        aggregates[`cost.${prop}`] = cost[prop];
                    }
                }
                else {
                    aggregates['cost.volume'] = segments.reduce((acc, segment) => acc + (aggregates[segment] || 0), 0);
                }
                return aggregates;
            }
        }
        BulkMail.BMStore = BMStore;
    })(BulkMail = AFC.BulkMail || (AFC.BulkMail = {}));
})(AFC || (AFC = {}));
;
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="./BMEntity.ts" />
var AFC;
(function (AFC) {
    var BulkMail;
    (function (BulkMail) {
        ;
        let SegmentStatus;
        (function (SegmentStatus) {
            SegmentStatus["enabled"] = "enabled";
            SegmentStatus["disabled"] = "disabled";
        })(SegmentStatus = BulkMail.SegmentStatus || (BulkMail.SegmentStatus = {}));
        const _target = Symbol();
        function _normalize(campaign, data) {
            if (campaign.isChannelEddm()) {
                const segments = campaign.getActiveSegments();
                data.forEach(storeData => storeData?.units?.forEach(unit => (unit.values || (unit.values = {})).cost = { volume: segments.reduce((acc, segment) => acc + (unit.values[segment] || 0), 0) }));
            }
            return data;
        }
        class BMZone {
            constructor(campaign, zoneCode, featuresVersion, session) {
                this.campaign = campaign;
                this.code = zoneCode;
                this.featuresVersion = featuresVersion;
                this.session = session;
                this._unitsData = {};
            }
            createAjaxRequest(action) {
                let request = BulkMail.BMEntityCacheData.getInstance().restModel.createAjaxRequest(`${BulkMail.BMEntityCacheData.pathZones}/${this.code}`);
                request.options.data = {
                    action: $.extend(action || {}, {
                        session: this.session,
                        featuresVersion: this.featuresVersion
                    })
                };
                return request;
            }
            _getStoreZone(stores) {
                return new Promise((resolve, reject) => {
                    let request = this.createAjaxRequest({
                        type: 'units',
                        stores: stores,
                        ...(this.campaign.isChannelSMS() ? { target: this.campaign.getTarget() } : {})
                    });
                    request.options.always = (sequence, jqXHR, textStatus) => {
                        if (jqXHR.status === 200) {
                            let data = _normalize(this.campaign, jqXHR.responseJSON);
                            stores.forEach(code => this._unitsData[code] = null);
                            data.forEach(item => this._unitsData[item.storeCode] = item.units);
                            resolve();
                        }
                        else {
                            reject();
                        }
                    };
                    request.call();
                });
            }
            _compute(stores, criteria, segments, target, reset, update, hideUnits) {
                return new Promise((resolve, reject) => {
                    let request = this.createAjaxRequest({
                        type: update ? 'update' : 'compute',
                        stores: stores,
                        criteria: criteria,
                        reset: reset,
                        hideUnits: hideUnits ?? false,
                        ...(segments ? { segments: segments } : { target: target })
                    });
                    request.options.always = (sequence, jqXHR, textStatus) => {
                        jqXHR.status === 200 ?
                            resolve(_normalize(this.campaign, jqXHR.responseJSON)) :
                            reject();
                    };
                    request.call();
                });
            }
            async computeStoreZone(stores, criteria, segments, target, reset, hideUnits) {
                let data = await this._compute(stores, criteria, segments, target, reset, false, hideUnits);
                return data.map(items => items.units);
            }
            async updateStoreZone(stores, criteria, reset, hideUnits) {
                let data = await this._compute(stores, criteria, this.campaign.isChannelEddm() ? this.campaign.getSegments() : null, this.campaign.isChannelSMS() ? this.campaign.getTarget() : null, reset, true, hideUnits);
                stores.forEach(store => this._unitsData[store.storeCode] = null);
                return data.map(item => this._unitsData[item.storeCode] = item.units);
            }
            /**
             * Cancel session > call api, will trigger DB cleaning
             *
             * @returns
             */
            cancelComputeStoreZone() {
                return new Promise((resolve, reject) => {
                    let request = BulkMail.BMEntityCacheData.getInstance().restModel.createAjaxRequest(`${BulkMail.BMEntityCacheData.pathZones}`);
                    request.options.data = {
                        action: {
                            type: "cancelSession",
                            session: this.session
                        }
                    };
                    request.options.always = (sequence, jqXHR, textStatus) => {
                        jqXHR.status === 200 ? resolve(true) : reject(false);
                    };
                    request.call();
                });
            }
            replaceStoreZone(areas) {
                return new Promise((resolve, reject) => {
                    let request = this.createAjaxRequest({
                        type: 'replace',
                        areas: areas,
                        ...(this.campaign.isChannelSMS() ? this.campaign.getTarget() : {})
                    });
                    request.options.always = (sequence, jqXHR, textStatus) => {
                        if (jqXHR.status === 200) {
                            let data = jqXHR.responseJSON;
                            areas.forEach(area => this._unitsData[area.storeCode] = null);
                            resolve(data.map(item => this._unitsData[item.storeCode] = item.units));
                        }
                        else {
                            reject();
                        }
                    };
                    request.call();
                });
            }
            async getUnits(storeCodes) {
                let missing, index, results = storeCodes.map((code, indice) => (this._unitsData.hasOwnProperty(code) || ((missing || (index = {}, missing = [])).push(code), index[code] = indice), this._unitsData[code]));
                if (missing) {
                    await this._getStoreZone(missing);
                    missing.forEach(code => results[index[code]] = this._unitsData[code]);
                }
                return results;
            }
            async getInfo() {
                return this._info || new Promise((resolve, reject) => {
                    let request = this.createAjaxRequest({
                        type: 'info'
                    });
                    request.options.always = (sequence, jqXHR, textStatus) => {
                        if (jqXHR.status === 200) {
                            resolve(this._info = jqXHR.responseJSON);
                        }
                        else {
                            reject();
                        }
                    };
                    request.call();
                });
            }
            get unitsData() { return this._unitsData; }
        }
        BulkMail.BMZone = BMZone;
    })(BulkMail = AFC.BulkMail || (AFC.BulkMail = {}));
})(AFC || (AFC = {}));
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="./BMEntity.ts" />
///<reference path="./BMStore.ts" />
///<reference path="./BMZone.ts" />
var AFC;
(function (AFC) {
    let BulkMail;
    (function (BulkMail) {
        let BMCampaignChannel;
        (function (BMCampaignChannel) {
            BMCampaignChannel["sms"] = "sms";
            BMCampaignChannel["eddm"] = "eddm";
            BMCampaignChannel["social"] = "social";
        })(BMCampaignChannel = BulkMail.BMCampaignChannel || (BulkMail.BMCampaignChannel = {}));
        class BMCampaignExtraInfo {
            constructor(item) {
                this._messages = [];
                if (item.messages)
                    this._messages = item.messages.map(i => new BMCampaignMessage(i));
                if (item.providerMetaData)
                    this._providerMetaData = item.providerMetaData;
            }
            get messages() {
                return this._messages;
            }
            get providerMetaData() {
                return this._providerMetaData;
            }
        }
        BulkMail.BMCampaignExtraInfo = BMCampaignExtraInfo;
        class BMCampaignMessage {
            constructor(item) {
                this._code = item.code;
                this._name = item.name;
                this._preview = item.preview;
                this._description = item.description;
                this._color = item.color;
            }
            get code() {
                return this._code;
            }
            get name() {
                return this._name;
            }
            get description() {
                return this._description;
            }
            get preview() {
                return this._preview;
            }
            get color() {
                return this._color;
            }
            toHTMLText() {
                return `<div class='campaign-message-text-container'><div class='campaign-message-text-circle' style='--campaign-message-color:${this.color}'></div><div class=''>${this.name.replace(/ /g, '&nbsp;')}</div></div>`;
            }
        }
        BulkMail.BMCampaignMessage = BMCampaignMessage;
        class BMCampaign extends BulkMail.BMEntity {
            constructor(item, isNew) {
                let cachedData = BulkMail.BMEntityCacheData.getInstance();
                super();
                this._disableDirtyEvent = false;
                if (item) {
                    this._code = item.code;
                    this._codeVersionTargeted = item.targeted?.featuresVersion;
                    this._zoneCodeTargeted = item.targeted?.zoneCode;
                    this._name = item.name;
                    this._beginDate = item.dateStart instanceof Date ? item.dateStart : new Date(item.dateStart);
                    this._endDate = item.dateEnd instanceof Date ? item.dateEnd : new Date(item.dateEnd);
                    this._status = item.status;
                    this._storesCounter = item.stores ?? [];
                    this.segments = item.segments;
                    this.targetedAggregates = item.targeted?.aggregates;
                    this.channel = item.channel ?? "eddm" /* BMCampaignChannel.eddm */;
                    if (item.upcoming) {
                        this.upcomingAggregates = item.upcoming.aggregates;
                        this._codeVersionUpcoming = item.upcoming.featuresVersion;
                        this._zoneCodeUpcoming = item.upcoming.zoneCode;
                    }
                }
                if (isNew) {
                    this._timestampCreatedAt = Date.now();
                }
                this.on(65536 /* Tools.EventType.UserEvent */, () => cachedData.campaignList.fireEvent(65536 /* Tools.EventType.UserEvent */));
                this.on(6 /* Tools.EventType.Dirty */, () => {
                    cachedData.campaignList.fireEvent(6 /* Tools.EventType.Dirty */);
                });
            }
            get code() {
                return this._code;
            }
            get timestampCreatedAt() { return this._timestampCreatedAt; }
            get codeVersionTargeted() { return this._codeVersionTargeted; }
            set codeVersionTargeted(code) { this._codeVersionTargeted = code; }
            get codeVersionUpcoming() { return this._codeVersionUpcoming; }
            set codeVersionUpcoming(code) { this._codeVersionUpcoming = code; }
            get zoneCodeTargeted() { return this._zoneCodeTargeted; }
            set zoneCodeTargeted(zoneCode) { this._zoneCodeTargeted = zoneCode; }
            get zoneCodeUpcoming() { return this._zoneCodeUpcoming; }
            set zoneCodeUpcoming(zoneCode) { this._zoneCodeUpcoming = zoneCode; }
            get beginDate() { return this._beginDate; }
            get beginDateAsString() { return formatDate(this._beginDate, "", this.isChannelSMS()); }
            get beginDateAsStringInput() { return formatDate(this._beginDate, "input"); }
            set beginDate(date) {
                this._beginDate = date instanceof Date ? date : new Date(date);
                if (!this._disableDirtyEvent)
                    this.fireEvent(6 /* Tools.EventType.Dirty */);
            }
            get endDate() { return this._endDate; }
            get endDateAsString() { return formatDate(this._endDate); }
            get endDateAsStringInput() { return formatDate(this._endDate, "input"); }
            set endDate(date) {
                this._endDate = date instanceof Date ? date : new Date(date);
                if (!this._disableDirtyEvent)
                    this.fireEvent(6 /* Tools.EventType.Dirty */);
            }
            get name() { return this._name; }
            set name(name) { this._name = name; }
            get segments() { return this._segmentList; }
            set segments(segments) {
                if (segments instanceof Map) {
                    this._segmentList = new Map(segments);
                }
                else {
                    this._segmentList = new Map();
                    segments && Object.keys(segments).forEach(key => this._segmentList.set(key, segments[key]));
                }
            }
            get status() {
                return this._status;
            }
            set status(status) {
                if (status)
                    this._status = status;
            }
            get storesCounter() {
                return this._storesCounter;
            }
            set storesCounter(storesCounter) {
                if (Array.isArray(storesCounter)) {
                    this._storesCounter = storesCounter;
                }
            }
            set stores(stores) {
                this._storeEntityList = stores.map((_store) => new BulkMail.BMStore(this, _store));
            }
            get stores() {
                return this._storeEntityList;
            }
            get targetedAggregates() {
                return this._targetedAggregates;
            }
            set targetedAggregates(aggr) {
                if (aggr instanceof Map) {
                    this._targetedAggregates = new Map(aggr);
                }
                else {
                    this._targetedAggregates = new Map();
                    aggr && Object.keys(aggr).forEach(key => this._targetedAggregates.set(key, aggr[key]));
                }
            }
            get upcomingAggregates() {
                return this._upcomingAggregates;
            }
            set upcomingAggregates(aggr) {
                if (aggr instanceof Map) {
                    this._upcomingAggregates = new Map(aggr);
                }
                else {
                    this._upcomingAggregates = new Map();
                    aggr && Object.keys(aggr).forEach(key => this._upcomingAggregates.set(key, aggr[key]));
                }
            }
            cancelSession(session) {
                return Promise.all([this.getStoreZone(session, false).cancelComputeStoreZone(), this.manageStoresSession(session, true)]);
            }
            validateSession(session) {
                return Promise.all([this.updateCommitZone(session), this.manageStoresSession(session, false)]);
            }
            manageStoresSession(session, doCancel) {
                const campaign = this;
                const cachedData = BulkMail.BMEntityCacheData.getInstance();
                return new Promise((resolve, reject) => {
                    let request = cachedData.restModel.createAjaxRequest(`${BMCampaign.getUriCampaign(this)}/stores`, true, { data: { action: { type: doCancel ? "cancelSession" : "validateSession", session: session } } });
                    request.options.method = "GET";
                    request.options.always = ((sequence, jqXHR, textStatus) => {
                        if (jqXHR.status == 200)
                            resolve(true);
                        else
                            resolve(false);
                    });
                    request.call();
                });
            }
            /**
             * Return nb store active
             * !!! If campaign list dashboard => value comes from store counter (returned counter by api)
             * if details screen of a campaign, value comes from reducer on store list loaded by api
             */
            get nbStoresActive() {
                if (this._storeList) {
                    return this._storeList.reduce((prev, curr) => curr.status === "active" /* BMStoreStatus.active */ ? prev + 1 : prev, 0);
                }
                else {
                    let found;
                    return (found = this._storesCounter.find(elem => elem.status === "active" /* BMStoreStatus.active */) ?? []).count;
                }
            }
            get nbStoresActiveInitial() {
                if (this._storeEntityList)
                    return this._storeEntityList.reduce((prev, curr) => curr.statusInitial === "active" /* BMStoreStatus.active */ ? prev + 1 : prev, 0);
                return 0;
            }
            getNbStoresActive(customFilter) {
                if (this._storeList)
                    return this._storeList.reduce((prev, curr) => curr.status === "active" /* BMStoreStatus.active */ && (customFilter ? customFilter(curr) : true) ? prev + 1 : prev, 0);
                return 0;
            }
            /**
             * Return total of stores for the campaign (active and inactive), stores without zone are ignored,
             * if store list exists, get length of collection
             * otherwise, return store counter value provided by api (eg. in campaign screen)
             */
            get nbStoresTotal() {
                if (this._storeList)
                    return this._storeList.length;
                if (this._storesCounter)
                    return this._storesCounter.reduce((prev, curr) => prev + curr.count, 0);
                return 0;
            }
            getNbStoresTotal(customFilter) {
                let list = customFilter ? this._storeList.filter(customFilter) : this._storeList;
                if (list)
                    return list.length;
                return 0;
            }
            /**
             * Return sum of targeted segment, according to values from targeted version
             */
            get qty() {
                return this.isChannelSMS() ?
                    this._targetedAggregates.get('VOLUME')
                    : Array.from(this._segmentList.keys())
                        .filter(elem => this._segmentList.get(elem) === "enabled" /* BMSegmentStatus.enabled */)
                        .reduce((prev, curr) => prev + (this._targetedAggregates.get(curr) || 0), 0);
            }
            /**
             * Return sum of targeted segment, according to values from upcoming version
             */
            get qtyUpcoming() {
                return Array.from(this._segmentList.keys())
                    .filter(elem => this._segmentList.get(elem) === "enabled" /* BMSegmentStatus.enabled */)
                    .reduce((prev, curr) => prev + (this._upcomingAggregates.get(curr) || 0), 0);
            }
            /**
             * Return sum of targeted according to given segments if any
             *
             * @param segmentCodeList The code segment list
             * @returns The sum of targeted aggregates according to segments
             */
            getQty(segmentCodeList) {
                return segmentCodeList === void 0 ?
                    this.qty
                    : segmentCodeList
                        .reduce((prev, curr) => prev + (this._targetedAggregates.get(curr) || 0), 0);
            }
            /**
             * Return sum of each participating store's live qty (qty computed by user)
             */
            getStoresQty() {
                return this.stores.reduce((prev, store) => store.isActive() ? prev + store.getQty() : prev, 0);
            }
            /**
             * Return uri campaign API (eg. "/bm/campaigns/_CODE_CAMPAIGN_")
             *
             * @param campaign
             * @returns the uri for current campaign
             */
            static getUriCampaign(campaign) {
                return `${BulkMail.BMEntityCacheData.pathCampaign}/${(campaign instanceof BMCampaign ? campaign.code : campaign)}`;
            }
            /**
             * Download campaign's xlsx file, call api and save file as blob
             * eg. "http://localhost/asterop/rest/CiblageISA/bm/campaigns/e70aba3e6a8b49b787d9d054dd4f7f7d?f=xlsx&token=XXX...XXX"
             */
            downloadFile() {
                let cachedData = BulkMail.BMEntityCacheData.getInstance();
                let request = cachedData.restModel
                    .createAjaxRequest(BMCampaign.getUriCampaign(this));
                request.options.method = "GET" /* Rest.RestMethod.GET */;
                request.options.format = 15 /* Rest.RestFormat.xlsx */;
                request.options.xhrFields = { responseType: "blob" };
                const restModel = BulkMail.BMEntityCacheData.getInstance().restModel;
                request.options.done = (sequence, data, textStatus, jqXHR) => {
                    // use xhr.done instead of .always for data as blob (why????)
                    let blob = new Blob([data], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" /* Rest.MimeType.xlsx */ });
                    saveAs(blob, AFC.Tools.StringTools.normalizeString(`${this.name}.xlsx`));
                };
                cachedData.sequence = request.call();
            }
            /**
             * Check validity of campaign's inputs (eg. name, dates) and return an array of errors if any
             *
             * @returns string[]
             */
            hasError() {
                let errors = this.hasErrorEx();
                // Invalid dates or begin date and end dat not corresponding
                if (!this.isValidDates()) {
                    errors.push("Les dates de début et de fin de la campagne doivent être renseignées et doivent être valides. La date de fin de la campagne doit être supérieure à la date de début.");
                }
                // Empty name
                if (this.hasErrorTitle()) {
                    errors.push("Le nom de la campagne ne doit pas être vide.");
                }
                // Empty segment list
                if (this.hasErrorSegments()) {
                    errors.push("Au moins un segment doit être sélectionné.");
                }
                return errors;
            }
            hasErrorEx() {
                return [];
            }
            hasErrorSegments() {
                return 0 === Array.from(this.segments.keys()).filter(key => this.segments.get(key) === "enabled" /* BMSegmentStatus.enabled */).length;
            }
            hasErrorTitle() {
                return !this.name || !this.name.trim();
            }
            hasErrorDates() {
                return !this.isValidDates();
            }
            canPublish() {
                return this.isValid() && this.status === "pending" /* BMCampaignStatus.pending */;
            }
            canUnpublish() {
                return this.status === "published" /* BMCampaignStatus.published */;
            }
            isValid() {
                return this.isValidDates() && !this.hasErrorTitle() && !this.hasErrorSegments();
            }
            isChannelSMS() {
                return this.channel === "sms" /* BMCampaignChannel.sms */;
            }
            isChannelEddm() {
                return this.channel === "eddm" /* BMCampaignChannel.eddm */;
            }
            isChannelSocial() {
                return this.channel === "social" /* BMCampaignChannel.social */;
            }
            /**
             * Check if dates valid and check if begin date is before end date
             *
             * @returns boolean
             */
            isValidDates() {
                let timestampStart = this.beginDate ? this.beginDate.getTime() : void 0;
                let timestampEnd = this.endDate ? this.endDate.getTime() : void 0;
                return !isNaN(timestampStart)
                    && !isNaN(timestampEnd)
                    && timestampStart > 0 && timestampEnd > 0
                    && this.beginDate < this.endDate;
            }
            disableDirtyEvent(disable) {
                this._disableDirtyEvent = disable;
            }
            fillCampaignWithRestData(item) {
                let campaign = this;
                campaign._code = item.code;
                campaign.codeVersionTargeted = item.targeted.featuresVersion;
                campaign.zoneCodeTargeted = item.targeted.zoneCode;
                //!!! Si la liste des magasins participants change,
                // alors mise à jour des quantités à distribuer par segment
                // (cumul des BAL sur les zones pour les magasins participants)
                campaign.segments = item.segments;
                campaign.targetedAggregates = item.targeted.aggregates;
                campaign._storesCounter = item.stores;
                if (item.upcoming) {
                    campaign.upcomingAggregates = item.upcoming.aggregates;
                    campaign.codeVersionUpcoming = item.upcoming.featuresVersion; // eg. "ADREXO-2022-Q2"
                    campaign.zoneCodeUpcoming = item.upcoming.zoneCode;
                }
            }
            /**
             * Tag campaign as deleted in DB
             * @returns
             */
            delete() {
                let cachedData = BulkMail.BMEntityCacheData.getInstance();
                const campaign = this;
                return new Promise((resolve, reject) => {
                    cachedData.eventHandler.notify(65536 /* Tools.EventType.UserEvent */ + 1, ( /*event: Tools.IEvent*/) => resolve(true));
                    cachedData.eventHandler.notify(65536 /* Tools.EventType.UserEvent */ + 2, ( /*event: Tools.IEvent*/) => resolve(false));
                    let request = cachedData.restModel.createAjaxRequest(BMCampaign.getUriCampaign(campaign));
                    request.options.data = { action: { type: "delete" } };
                    request.options.byPassError = true;
                    request.options.always = ((sequence, jqXHR, textStatus) => {
                        if (cachedData.sequence === sequence) {
                            if (jqXHR.status == 200)
                                cachedData.eventHandler.fireEvent(65536 /* Tools.EventType.UserEvent */ + 1);
                            else
                                cachedData.eventHandler.fireEvent(65536 /* Tools.EventType.UserEvent */ + 2);
                        }
                    }).bind(this);
                    cachedData.sequence = request.call();
                    //cachedData.eventHandler.fireEvent(Tools.EventType.UserEvent + 1);
                });
            }
            getParamItemSave() {
                const campaign = this;
                return {
                    name: campaign.name,
                    dateStart: campaign.beginDate,
                    dateEnd: campaign.endDate,
                    segments: [...campaign.segments.keys()].map(key => { return { code: key, status: campaign.segments.get(key) }; })
                };
            }
            /**
             * (alias) Save new campaign in DB
             *
             * @param item
             * @returns
             */
            save(item = null, basedOnCodeCampaign) {
                const cachedData = BulkMail.BMEntityCacheData.getInstance();
                const campaign = this;
                let campaignValidity;
                if (item) {
                    if (item.name)
                        campaign.name = item.name;
                    if (item.dateStart)
                        campaign.beginDate = item.dateStart;
                    if (item.dateEnd)
                        campaign.endDate = item.dateEnd;
                    if (item.segments)
                        campaign.segments = item.segments;
                }
                // *************************************************
                // Check if campaign is valid before saving in DB
                // *************************************************
                if ((campaignValidity = this.hasError()).length > 0) {
                    campaign.fireEvent(6 /* Tools.EventType.Dirty */);
                    return Promise.reject(campaignValidity);
                }
                // *************************************************
                // Campaign is valid, continue
                // *************************************************
                campaign.status = "pending" /* BMCampaignStatus.pending */;
                campaign.fireEvent(6 /* Tools.EventType.Dirty */);
                return new Promise((resolve, reject) => {
                    let request = cachedData.restModel.createAjaxRequest(BMCampaign.getUriCampaign(basedOnCodeCampaign));
                    request.options.data = {
                        action: {
                            type: "create",
                            ...campaign.getParamItemSave()
                        }
                    };
                    request.options.always = ((sequence, jqXHR, textStatus) => {
                        const item = jqXHR.responseJSON;
                        campaign.fillCampaignWithRestData(item);
                        campaign.fireEvent(6 /* Tools.EventType.Dirty */);
                        if (cachedData.sequence === sequence) {
                            cachedData.eventHandler.fireEvent(65536 /* Tools.EventType.UserEvent */ + 32);
                        }
                        resolve(true);
                    }).bind(this);
                    cachedData.sequence = request.call();
                    cachedData.eventHandler.fireEvent(65536 /* Tools.EventType.UserEvent */ + 1);
                });
            }
            /**
             * Update campaign in DB if not new. If new, only update attributes.
             * Call api:
             *      /bm/campaigns/{codeCampaign}
             *      action={
                        "type":"update",
                        "name":"Le blanc 2018",
                        "dateStart":"2018-08-31",
                        "dateEnd":"2018-08-11",
                        "segments":[{"code":"NB_BALS_A", "status":"enabled"}, {"code":"NB_BALS_R", "status":"enabled"}]
                    }
             *
             * @param item eg.
             *      {
             *      dateEnd: "1999-08-11"
                    dateStart: "1999-08-31"
                    name: "Random 1"
                    segments:
                        {NB_BALS_A: "enabled"
                        NB_BALS_H: "disabled"
                        NB_BALS_R: "enabled"
                        NB_BALS_V: "enabled"}
                    }
             * @returns
             */
            update(item, forceSave = false, isSimulation = false, silent = false) {
                const cachedData = BulkMail.BMEntityCacheData.getInstance();
                const campaign = this;
                let campaignValidity;
                if (isSimulation === false) {
                    campaign.disableDirtyEvent(true);
                    if (item.name)
                        campaign.name = item.name;
                    if (item.dateStart)
                        campaign.beginDate = item.dateStart;
                    if (item.dateEnd)
                        campaign.endDate = item.dateEnd;
                    if (item.stores)
                        campaign.stores = item.stores;
                    if (item.segments)
                        campaign.segments = item.segments;
                    this.invalidateStats();
                    campaign.disableDirtyEvent(false);
                }
                if (campaign.isNew() && !forceSave) {
                    if (silent === false)
                        campaign.fireEvent(6 /* Tools.EventType.Dirty */);
                    return Promise.resolve(true); // No update for new campaign, use forceSave = true to create in DB through api
                }
                else
                    return new Promise((resolve, reject) => {
                        // *************************************************
                        // Check if campaign is valid before saving in DB
                        // *************************************************
                        /*
                        if ((campaignValidity = this.hasError()).length > 0) {
                            campaign.fireEvent(Tools.EventType.Dirty);
                            return reject(campaignValidity);
                        }
                        */
                        // *************************************************
                        // Campaign is valid, continue
                        // *************************************************
                        let request = cachedData.restModel.createAjaxRequest(BMCampaign.getUriCampaign(item.basedOnCodeCampaign ?? campaign));
                        // *************************************************
                        // Transform item.dateStart
                        // *************************************************
                        if (item.dateStart) {
                            item.dateStart = new Date(item.dateStart).toISOString();
                        }
                        request.options.data = {
                            action: {
                                type: campaign.status === "new" /* BMCampaignStatus.new */ ?
                                    "create"
                                    : (isSimulation ? "simulate" : "update"),
                                ...item,
                                ...(item.segments ?
                                    { segments: Object.keys(item.segments).map(key => { return { code: key, status: item.segments[key] }; }) }
                                    : {})
                            }
                        };
                        request.options.always = ((sequence, jqXHR, textStatus) => {
                            const item = jqXHR.responseJSON;
                            if (isSimulation === false) {
                                campaign.disableDirtyEvent(true);
                                campaign.fillCampaignWithRestData(item);
                                campaign.disableDirtyEvent(false);
                                if (silent === false)
                                    campaign.fireEvent(6 /* Tools.EventType.Dirty */);
                                if (cachedData.sequence === sequence) {
                                    cachedData.eventHandler.fireEvent(65536 /* Tools.EventType.UserEvent */ + 1);
                                }
                            }
                            resolve(isSimulation ? item : true);
                        }).bind(this);
                        cachedData.sequence = request.call();
                        if (isSimulation === false) {
                            cachedData.eventHandler.fireEvent(65536 /* Tools.EventType.UserEvent */ + 1);
                        }
                    });
            }
            /**
             *
             * @param item
             * @returns
             */
            simulate(item) {
                return this.update(item, false, true);
            }
            /**
             * Commit temp zone for current campaign
             *
             * Si un code de zone et un code de session sont passés, alors mise à jour de la table de zones
             * (les zones associées au code de session deviennent les zones courantes de la campagne)
             *
             * @param codeSession
             * @returns
             */
            updateCommitZone(codeSession) {
                const cachedData = BulkMail.BMEntityCacheData.getInstance();
                const campaign = this;
                return (!codeSession) ?
                    Promise.reject("Error, empty params")
                    : new Promise((resolve, reject) => {
                        this.invalidateStats();
                        let request = cachedData.restModel.createAjaxRequest(BMCampaign.getUriCampaign(campaign));
                        let dataAction = {
                            type: "update",
                            stores: campaign._storeList
                        };
                        if (campaign.hasUpcoming()) {
                            dataAction.upcoming = {
                                session: codeSession,
                                zoneCode: campaign.zoneCodeUpcoming,
                                featuresVersion: campaign.codeVersionUpcoming
                            };
                        }
                        else {
                            dataAction.targeted = {
                                session: codeSession,
                                zoneCode: campaign.zoneCodeTargeted,
                                featuresVersion: campaign.codeVersionTargeted
                            };
                        }
                        request.options.data = { action: dataAction };
                        request.options.always = ((sequence, jqXHR, textStatus) => {
                            const item = jqXHR.responseJSON;
                            campaign.zoneCodeTargeted = item.targeted.zoneCode;
                            campaign.targetedAggregates = item.targeted.aggregates;
                            campaign.codeVersionTargeted = item.targeted.featuresVersion;
                            campaign._storesCounter = item.stores;
                            // TODO: refacto this update
                            if (item.upcoming) {
                                campaign.zoneCodeUpcoming = item.upcoming.zoneCode;
                                campaign.upcomingAggregates = item.upcoming.aggregates;
                                campaign.codeVersionUpcoming = item.upcoming.featuresVersion;
                            }
                            campaign.fireEvent(6 /* Tools.EventType.Dirty */);
                            if (cachedData.sequence === sequence) {
                                cachedData.eventHandler.fireEvent(65536 /* Tools.EventType.UserEvent */ + 1);
                            }
                            resolve(true);
                        }).bind(this);
                        cachedData.sequence = request.call();
                    });
            }
            /**
             * Activate or deactivate a list of stores for the current campaign
             * !!! Don't wait for api return to trigger Event update on cachedData
             * !!! => but campaign segments and aggregates is updated w/ api call return
             *
             * @param stores An array of stores to be activated or deactivaed
             * @returns Promise true if call API ok
             */
            updateStores(stores) {
                const cachedData = BulkMail.BMEntityCacheData.getInstance();
                const campaign = this;
                // *************************************************
                // Update stores for current campaign obj stored in cached data
                // *************************************************
                // = dont wait api return
                stores.forEach((_store) => {
                    campaign._storeList.find((__s) => __s.code === _store.code).status = _store.status; // TODO: remove line when BMStore OK
                    campaign._storeEntityList.find((__s) => __s.code === _store.code).status = _store.status;
                });
                this.invalidateStats();
                cachedData.eventHandler.fireEvent(65536 /* Tools.EventType.UserEvent */ + 5);
                // *************************************************
                // Update stores in DB
                // *************************************************
                // + update segments campaign in cached data after resulted campaign in api
                return campaign.status === "new" /* BMCampaignStatus.new */ ?
                    Promise.resolve(true) // No update for new campaign, use forceSave = true to create in DB through api
                    : new Promise((resolve, reject) => {
                        let request = cachedData.restModel.createAjaxRequest(BMCampaign.getUriCampaign(campaign));
                        request.options.data = {
                            action: {
                                type: "update",
                                stores: stores
                            }
                        };
                        request.options.always = ((sequence, jqXHR, textStatus) => {
                            const item = jqXHR.responseJSON;
                            // !!! Si la liste des magasins participants change, alors mise à jour des quantités à distribuer par segment
                            // (cumul des BAL sur les zones pour les magasins participants)
                            campaign.segments = item.segments;
                            campaign.storesCounter = item.stores;
                            campaign.targetedAggregates = item.targeted.aggregates;
                            if (cachedData.sequence === sequence) {
                                cachedData.eventHandler.fireEvent(65536 /* Tools.EventType.UserEvent */ + 5);
                            }
                            resolve(true);
                        });
                        cachedData.sequence = request.call();
                    });
            }
            _updateFromPublish(item) {
            }
            /**
             * Publish campaign to provider (set status to "published")
             *
             * @param setIsPublish If true, set campaign to publish, if not, unpublish campaign (= set status pending). True by default.
             * @returns
             */
            publish(setIsPublish = true, immediate, publishDate, publishDate2) {
                const campaign = this;
                let cachedData = BulkMail.BMEntityCacheData.getInstance();
                return (campaign.canPublish() && setIsPublish) || (campaign.status === "published" /* BMCampaignStatus.published */ && setIsPublish === false)
                    ? new Promise((resolve, reject) => {
                        let request = cachedData.restModel.createAjaxRequest(BMCampaign.getUriCampaign(campaign));
                        request.options.byPassError = true;
                        request.options.data = { action: { type: setIsPublish ? "publish" : "unpublish" } };
                        if (immediate)
                            request.options.data.action.immediate = true;
                        if (publishDate)
                            request.options.data.action.dateStart = publishDate;
                        if (publishDate2)
                            request.options.data.action.dateEnd = publishDate2;
                        request.options.always = ((sequence, jqXHR, textStatus) => {
                            if (jqXHR.status === 200) {
                                //campaign.status = setIsPublish ? BMCampaignStatus.published : BMCampaignStatus.pending;
                                const item = jqXHR.responseJSON;
                                if (item && item.status) {
                                    campaign.status = item.status;
                                    campaign._updateFromPublish(item);
                                    if (item.dateStart)
                                        campaign.beginDate = new Date(item.dateStart);
                                    if (item.dateEnd)
                                        campaign.endDate = new Date(item.dateEnd);
                                }
                                campaign.fireEvent(6 /* Tools.EventType.Dirty */);
                                if (cachedData.sequence === sequence)
                                    resolve(campaign.status == "published" /* BMCampaignStatus.published */);
                            }
                            else if (cachedData.sequence === sequence)
                                resolve(false);
                        }).bind(this);
                        cachedData.sequence = request.call();
                    })
                    : Promise.resolve(true);
            }
            /**
             *
             * @param campaignCopyCode
             * @returns
             */
            postUpcomingApplyZone(campaignCopyCode) {
                const campaign = this;
                const campaignCopy = BulkMail.BMEntityCacheData.getInstance().campaign(campaignCopyCode);
                return campaign.isPostUpcoming() ?
                    campaign.update({
                        upcoming: {
                            zoneCode: campaignCopy.zoneCodeTargeted,
                            featuresVersion: campaignCopy.codeVersionTargeted
                        }
                    })
                    : Promise.resolve(true);
            }
            /**
             * Validate upcoming zone for the current campaign
             *
             * @returns
             */
            validateUpcoming() {
                const campaign = this;
                let cachedData = BulkMail.BMEntityCacheData.getInstance();
                return campaign.hasUpcoming()
                    ? new Promise((resolve, reject) => {
                        cachedData.eventHandler.notify(65536 /* Tools.EventType.UserEvent */ + 1, ( /*event: Tools.IEvent*/) => resolve(true));
                        this.invalidateStats();
                        let request = cachedData.restModel.createAjaxRequest(BMCampaign.getUriCampaign(campaign));
                        request.options.data = { action: { type: "upcomingValidation" } };
                        request.options.always = ((sequence, jqXHR, textStatus) => {
                            // TODO: refresh campaign !!!!!
                            const item = jqXHR.responseJSON; // TODO: extract update from item in fn helper?
                            campaign.upcomingAggregates = void 0;
                            campaign.codeVersionUpcoming = void 0;
                            campaign.zoneCodeUpcoming = void 0;
                            campaign.targetedAggregates = item.targeted.aggregates;
                            campaign.codeVersionTargeted = item.targeted.featuresVersion;
                            campaign.zoneCodeTargeted = item.targeted.zoneCode;
                            campaign.fireEvent(6 /* Tools.EventType.Dirty */);
                            if (cachedData.sequence === sequence) {
                                cachedData.eventHandler.fireEvent(65536 /* Tools.EventType.UserEvent */ + 1);
                            }
                        }).bind(this);
                        cachedData.sequence = request.call();
                        cachedData.eventHandler.fireEvent(65536 /* Tools.EventType.UserEvent */ + 1);
                    })
                    : Promise.resolve(true);
            }
            /**
             * Set zones and targetted aggregates from a given code campaign to the current campaign
             * (used in campaign creation)
             *
             * @param basedOnCodeCampaign The campaign code to be copied
             */
            copyZonesFromCampaign(basedOnCodeCampaign) {
                const basedOnCampaign = BulkMail.BMEntityCacheData.getInstance().campaign(basedOnCodeCampaign);
                this.codeVersionTargeted = basedOnCampaign.codeVersionTargeted;
                this.zoneCodeTargeted = basedOnCampaign.zoneCodeTargeted;
                this.targetedAggregates = basedOnCampaign.targetedAggregates;
                this.storesCounter = [...basedOnCampaign.storesCounter];
                this.segments = basedOnCampaign.segments;
                if (basedOnCampaign.hasUpcoming()) {
                    this.codeVersionUpcoming = basedOnCampaign.codeVersionUpcoming;
                    this.zoneCodeUpcoming = basedOnCampaign.zoneCodeUpcoming;
                    this.upcomingAggregates = basedOnCampaign.upcomingAggregates;
                }
                else {
                    this.codeVersionUpcoming = void 0;
                    this.zoneCodeUpcoming = void 0;
                    this.upcomingAggregates = void 0;
                }
            }
            copyZonesFromCampaignUpcoming(basedOnCodeCampaign, undoCopy = false) {
                const basedOnCampaign = BulkMail.BMEntityCacheData.getInstance().campaign(basedOnCodeCampaign);
                if (!undoCopy && basedOnCampaign.hasUpcoming()) {
                    this.codeVersionUpcoming = basedOnCampaign.codeVersionTargeted;
                    this.zoneCodeUpcoming = basedOnCampaign.zoneCodeTargeted;
                    this.upcomingAggregates = basedOnCampaign.targetedAggregates;
                }
                else if (undoCopy) {
                    this.codeVersionUpcoming = void 0;
                    this.zoneCodeUpcoming = void 0;
                    this.upcomingAggregates = void 0;
                }
            }
            /**
             * Return segment list as array
             *
             * @returns
             */
            getSegments() {
                return Array.from(this.segments).map((_item) => { return { code: _item[0], status: _item[1] }; });
            }
            /**
             * Return store entity corresponding to given store code
             *
             * @param storeCode The store code
             * @returns The BMStore entity found or undefined
             */
            getStore(storeCode) {
                return this._storeEntityList && this._storeEntityList.find(_store => _store.code === storeCode);
            }
            /**
             * Get all stores for a campaign: for each stores, indicates if it is active or not for the current campaign.
             *      url: /asterop/rest/bulkmail/bm/campaigns/{codeCampaign}/stores
             *      api response: [{code: "E001", status: "inactive"}, {code: "E002", status: "active"},…]
             *
             * Fills
             * - this._storeList // TODO: --remove this line when  BMStore entity OK
             * - this._storeEntityList
             *
             * @returns Promise result returning the list of active/inactive stores for the current campaign
             */
            getStoreList(forceUpdate = false) {
                const campaign = this;
                const cachedData = BulkMail.BMEntityCacheData.getInstance();
                // TODO: remove this._storeList whene BMStore entity OK
                return this._storeList && !forceUpdate ? Promise.resolve(this._storeList)
                    : new Promise((resolve, reject) => {
                        let request = cachedData.restModel.createAjaxRequest(`${BMCampaign.getUriCampaign(this)}/stores`);
                        request.options.method = "GET";
                        request.options.always = ((sequence, jqXHR, textStatus) => {
                            let storesResponse = jqXHR.responseJSON;
                            this._storeList = storesResponse;
                            campaign._storeEntityList = storesResponse.map((_store) => new BulkMail.BMStore(this, _store));
                            cachedData.eventHandler.fireEvent(65536 /* Tools.EventType.UserEvent */ + 1);
                            resolve(jqXHR);
                        });
                        request.call();
                    });
            }
            setStoreName(channel, storeCode, storeName) {
                return new Promise((resolve, refect) => {
                    this.getStoreList().then(_ => {
                        let store = this._storeList.find((s) => s.code === storeCode);
                        if (store) {
                            let request = BulkMail.BMEntityCacheData.getInstance().restModel.createAjaxRequest(`${BMCampaign.getUriCampaign(this)}/stores`);
                            let chanKey = channel == "sms" /* BMCampaignChannel.sms */ ? 'sms' : '';
                            if (chanKey != '') {
                                request.options.data = {
                                    action: {
                                        type: "update",
                                        values: {
                                            code: storeCode,
                                            name: storeName
                                        },
                                        channel: chanKey,
                                    }
                                };
                                request.options.byPassError = true;
                                request.options.method = "GET";
                                request.options.always = ((sequence, jqXHR, textStatus) => {
                                    //let response: IStoreDataInStoreList[] = jqXHR.responseJSON;
                                    if (jqXHR.status == 200)
                                        store.channels[chanKey].name = storeName;
                                    resolve(store);
                                });
                                request.call();
                            }
                            else
                                resolve(store);
                        }
                        else
                            resolve(null);
                    });
                });
            }
            /**
             * Call api to get kpis (per segmentations, aggregates, ...) for each store
             *          url: asterop/rest/{projet}/bm/zones/{code zone} + action type = "stats"
             *          api response:
             *          {"stores": [
             *              {"code":"E002","values":{"NB_BALS_H":2708,"NB_BALS_R":5107,"NB_BALS_V":25055,"NB_BALS_A":1869,"CA":0,"DATA1":0,"DATA2":0}},
             *              ...
             *          ]}
             *
             * @params codeSession - The session id generated by client on screen creation
             * @param storeCodes - A list of store codes to be refreshed
             * @params saveToCampaignStores - Force update for all campaign' stores obj, in both cases true or false, values are passed to promise result
             * @params saveToupdateQtyTmpComputed - If true, set value to temp computed qty of each store
             *
             * @returns
             */
            computeZoneData(codeSession, storeCodes = [], saveToCampaignStores = true) {
                const campaign = this;
                let pStoreListLoading = this._storeEntityList === void 0 ?
                    this.getStoreList().then(() => this._storeEntityList)
                    : Promise.resolve(this._storeEntityList);
                return !this._timestampStats ? new Promise((resolve, reject) => {
                    pStoreListLoading.then((storeList) => {
                        let request = campaign._generateApiStats(codeSession);
                        request.options.always = ((sequence, jqXHR) => {
                            let targetedRes = [];
                            let upcomingRes = [];
                            let toProcess = [];
                            let hasUpcoming = false;
                            if (jqXHR.responseJSON.targeted) {
                                targetedRes = jqXHR.responseJSON.targeted.stores;
                                toProcess = targetedRes;
                            }
                            if (jqXHR.responseJSON.upcoming) {
                                upcomingRes = jqXHR.responseJSON.upcoming.stores;
                                toProcess = upcomingRes;
                                hasUpcoming = true;
                            }
                            //if (saveToCampaignStores || updateQtyTmpComputed) {
                            targetedRes && targetedRes.forEach((_store) => {
                                if (storeCodes && (storeCodes.length > 0 && storeCodes.indexOf(_store.code) === -1)) {
                                    return;
                                }
                                try {
                                    let store = this.getStore(_store.code);
                                    saveToCampaignStores && ((store.valuesTargeted = _store.targeted) && (store.valuesTargetedMax = _store.whole));
                                    if (!hasUpcoming) {
                                        if (_store.targeted.cost)
                                            store.qtyTempComputed = this.isChannelSocial() ? _store.targeted.cost.budget : _store.targeted.cost.volume;
                                        else
                                            store.qtyTempComputed = campaign.getActiveSegments().reduce((__prev, __codeSegment) => __prev + (_store.targeted[__codeSegment] ?? 0), 0);
                                    }
                                }
                                catch (e) {
                                    // console.log(`Erreur pour le magasin ${ _store.code }`);
                                }
                            });
                            upcomingRes && upcomingRes.forEach((_store) => {
                                if (storeCodes && (storeCodes.length > 0 && storeCodes.indexOf(_store.code) === -1)) {
                                    return;
                                }
                                try {
                                    let store = this.getStore(_store.code);
                                    saveToCampaignStores && ((store.valuesUpcoming = _store.targeted) && (store.valuesUpcomingMax = _store.whole));
                                    if (hasUpcoming) {
                                        if (_store.targeted.cost)
                                            store.qtyTempComputed = this.isChannelSocial() ? _store.targeted.cost.budget : _store.targeted.cost.volume;
                                        else
                                            store.qtyTempComputed = campaign.getActiveSegments().reduce((__prev, __codeSegment) => __prev + (_store.targeted[__codeSegment] ?? 0), 0);
                                    }
                                }
                                catch (e) {
                                    // console.log(`Erreur pour le magasin ${ _store.code }`);
                                }
                            });
                            // Log loading stats, to prevent
                            saveToCampaignStores && (this._timestampStats = Date.now());
                            resolve();
                        });
                        request.call();
                    });
                }) : Promise.resolve();
            }
            _generateApiStats(codeSession) {
                const cachedData = BulkMail.BMEntityCacheData.getInstance();
                const campaign = this;
                //let action = campaign._generateApiStatsParam(codeSession, codeVersion);
                let request = cachedData.restModel.createAjaxRequest(`${BMCampaign.getUriCampaign(this)}/stores/stats`, // asterop/rest/{projet}/bm/campaigns/{code campaign}/stores/stats
                true, { data: { session: codeSession } });
                request.options.method = "GET";
                return request;
            }
            /**
             * Get campaign provider
             *
             * @returns
             */
            getProvider() {
                return BulkMail.BMEntityCacheData.getInstance().provider(null, this.codeVersionTargeted);
            }
            loadExtraInfo() {
                const cachedData = BulkMail.BMEntityCacheData.getInstance();
                return new Promise((resolve, reject) => {
                    let request = cachedData.restModel.createAjaxRequest(`${BMCampaign.getUriCampaign(this)}`, true);
                    request.options.method = "GET";
                    request.options.always = ((sequence, jqXHR, textStatus) => {
                        if (jqXHR.status == 200) {
                            resolve(new BMCampaignExtraInfo(jqXHR.responseJSON));
                        }
                        else
                            resolve(null);
                    });
                    request.call();
                });
            }
            /**
             * Compute aggregates for campaign/zones with kpis comming from @see BMCampaign::computeZoneData()
             * and stores definition (active/inactive)
             * // TODO: refacto totalStores, activeStores, selectedStores
             *
             * @param selectedStoreList Array of store codes wich will be used to computed aggreagation for store selection by user (if any given)
             * @param codeSession
             * @param filteredStoredList Array of store codes wich will be used to computed aggreagation on filtered stores only
             * @returns Promise with computed results
             */
            getZoneAggregates(selectedStoreList = [], codeSession, filteredStoredList) {
                const campaign = this;
                const cachedData = BulkMail.BMEntityCacheData.getInstance();
                const provider = cachedData.provider(null, this.codeVersionTargeted);
                const aggregateCodeList = provider.aggregates.map((agg) => agg.code); // extract all aggregates code to be computed
                const fnStorePassedFilter = (store) => filteredStoredList === void 0 || filteredStoredList.indexOf(store.code) !== -1;
                //MD : push getActiveSegments values to aggregates
                aggregateCodeList.push(...campaign.getActiveSegments());
                // TODO: do it once? store values?
                return Promise.all([
                    campaign.computeZoneData(codeSession, null, true),
                    campaign.getStoreList()
                ]).then((values) => {
                    const [_, storeList] = values;
                    let reduceValues = (stores) => {
                        let useUpcoming = false;
                        return stores.reduce((counter, store) => {
                            if (fnStorePassedFilter(store)) {
                                aggregateCodeList.forEach(aggCode => {
                                    let found = false;
                                    counter[aggCode] = counter[aggCode] ?? 0;
                                    if (store.valuesUpcoming) {
                                        useUpcoming = true;
                                        counter[aggCode] += store.valuesUpcoming[aggCode];
                                    }
                                    if (store.valuesTargeted) {
                                        if (!useUpcoming)
                                            counter[aggCode] += store.valuesTargeted[aggCode];
                                        counter[aggCode + ".targeted"] = counter[aggCode + ".targeted"] ?? 0;
                                        counter[aggCode + ".targeted"] += store.valuesTargeted[aggCode];
                                    }
                                });
                                let propsToCheck = ["cost", "insights"];
                                propsToCheck.forEach(prop => {
                                    let p = null;
                                    if (store.valuesUpcoming && store.valuesUpcoming[prop])
                                        p = store.valuesUpcoming[prop];
                                    else if (store.valuesTargeted && store.valuesTargeted[prop])
                                        p = store.valuesTargeted[prop];
                                    if (p) {
                                        for (let pp in p) {
                                            let key = `${prop}.${pp}`;
                                            counter[key] = counter[key] ?? 0;
                                            counter[key] += p[pp];
                                        }
                                    }
                                });
                            }
                            return counter;
                        }, {});
                    };
                    return Promise.resolve({
                        totalStores: reduceValues(campaign.stores),
                        activeStores: reduceValues(campaign.stores.filter((store) => {
                            let isActive = false;
                            try {
                                isActive = storeList.find((s) => s.code === store.code).status === "active" /* BMStoreStatus.active */;
                            }
                            catch (e) {
                                //console.error(`Store not found: ${ store.code }`);
                            }
                            return isActive;
                        })),
                        selectedStores: reduceValues(selectedStoreList.filter((storeCode) => campaign.stores.find((store) => store.code === storeCode))
                            .map((storeCode) => campaign.stores.find((store) => store.code === storeCode)))
                    });
                });
            }
            /**
             * Returns codes segments that are enabled for the current campaign
             *
             * @returns array[]
             */
            getActiveSegments() {
                return Array.from(this.segments.keys()).filter((key) => this.segments.get(key) === "enabled" /* BMSegmentStatus.enabled */);
            }
            /**
             * Returns zone model for handling zone sectors,
             * BEWARE ! in case of upcoming, return upcoming zone !!!!!!
             *
             * @returns BMZone
             */
            getStoreZone(session, forceGetTargeted) {
                return this.hasUpcoming() && forceGetTargeted === false ?
                    new BulkMail.BMZone(this, this.zoneCodeUpcoming, this.codeVersionUpcoming, session)
                    : new BulkMail.BMZone(this, this.zoneCodeTargeted, this.codeVersionTargeted, session);
            }
            /**
             * Return nb stores that have been modified by user
             * @returns
             */
            getKpiNbDiffStores(customFilter) {
                return this.stores ? this.stores.filter(_store => _store.qtyTemp !== void 0 && (customFilter ? customFilter(_store) : true)).length : 0;
            }
            getKpiNbActiveStores() {
                return this.stores ? this.stores.filter(_store => _store.isActive()).length : 0;
            }
            /**
             * Clean store list (eg. use when leaving campaign details screen)
             */
            flushStores() {
                this._storeList = void 0;
                this._storeEntityList = void 0;
                this.invalidateStats();
            }
            /**
             * Resset timestamp for stats to allow calling once again stats API (otherwise stats data are stores in each stores)
             */
            invalidateStats() {
                /*
                this._timestampStatsTargeted = void 0;
                this._timestampStatsUpcoming = void 0;
                */
                this._timestampStats = void 0;
            }
            /**
             * Check if campaign still has an upcoming version
             *
             * @returns If true, campaign has an upcoming version
             */
            hasUpcoming() {
                return !!this._zoneCodeUpcoming;
            }
            /**
             * Compares campaign begin date and next version delivery date
             *
             * @returns True if campaign starts after upcoming version is delivered to production
             */
            isPostUpcoming(withoutUpcomingZone = true) {
                const nextVersion = this.getProvider()?.getNextVersion();
                return nextVersion
                    && this._beginDate >= new Date(nextVersion.dateProduction)
                    && this.codeVersionTargeted !== nextVersion.code
                    && ((withoutUpcomingZone && !this.hasUpcoming())
                        || !withoutUpcomingZone)
                    && !this.isNew();
            }
            isPublished() {
                return this.status === "published" /* BMCampaignStatus.published */;
            }
            isNew() {
                return this.status === "new" /* BMCampaignStatus.new */;
            }
            storeToggleActive(storeOrCode, active) {
                let store = typeof storeOrCode === "string" ? this.getStore(storeOrCode) : storeOrCode;
                let finalStoreStatus = store.toggleActive(active);
                this._storeList.some((_store, _i) => {
                    if (_store.code === store.code) {
                        this._storeList[_i].status = finalStoreStatus;
                        return true;
                    }
                });
                this.fireEvent(6 /* Tools.EventType.Dirty */);
                return finalStoreStatus;
            }
        }
        BulkMail.BMCampaign = BMCampaign;
        const formatDate = (date, type = "", withTime = false) => {
            let dateString = "";
            if (!date || isNaN(date.getTime())) {
                return dateString;
            }
            if (type === "input") {
                let splittedDate = date
                    .toLocaleString("fr-FR", { year: "numeric", month: "numeric", day: "numeric" })
                    .split('/');
                dateString = `${splittedDate[2]}-${splittedDate[1]}-${splittedDate[0]}`;
            }
            else {
                dateString = date.toLocaleString("fr-FR", !withTime ?
                    { year: "numeric", month: "numeric", day: "numeric" }
                    : { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric" });
            }
            return dateString;
        };
        let BMCampaignStatus;
        (function (BMCampaignStatus) {
            BMCampaignStatus["new"] = "new";
            BMCampaignStatus["pending"] = "pending";
            BMCampaignStatus["published"] = "published";
            BMCampaignStatus["deleted"] = "deleted";
            BMCampaignStatus["template"] = "template";
            BMCampaignStatus["validated"] = "validated";
            BMCampaignStatus["checked"] = "checked";
        })(BMCampaignStatus = BulkMail.BMCampaignStatus || (BulkMail.BMCampaignStatus = {}));
        let BMCampaignRouteStatus;
        (function (BMCampaignRouteStatus) {
            BMCampaignRouteStatus["sleeping"] = "sleeping";
            BMCampaignRouteStatus["verification"] = "verification";
            BMCampaignRouteStatus["scheduled"] = "scheduled";
            BMCampaignRouteStatus["started"] = "started";
            BMCampaignRouteStatus["completed"] = "completed";
            BMCampaignRouteStatus["completedFinal"] = "completedFinal";
            BMCampaignRouteStatus["canceled"] = "canceled";
            BMCampaignRouteStatus["stopped"] = "stopped";
        })(BMCampaignRouteStatus = BulkMail.BMCampaignRouteStatus || (BulkMail.BMCampaignRouteStatus = {}));
        let BMSegmentStatus;
        (function (BMSegmentStatus) {
            BMSegmentStatus["enabled"] = "enabled";
            BMSegmentStatus["disabled"] = "disabled";
        })(BMSegmentStatus = BulkMail.BMSegmentStatus || (BulkMail.BMSegmentStatus = {}));
    })(BulkMail = AFC.BulkMail || (AFC.BulkMail = {}));
})(AFC || (AFC = {}));
;
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="./BMEntity.ts" />
///<reference path="./BMStore.ts" />
///<reference path="./BMZone.ts" />
var AFC;
(function (AFC) {
    let BulkMail;
    (function (BulkMail) {
        class BMCampaignEDDM extends BulkMail.BMCampaign {
        }
        BulkMail.BMCampaignEDDM = BMCampaignEDDM;
    })(BulkMail = AFC.BulkMail || (AFC.BulkMail = {}));
})(AFC || (AFC = {}));
;
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="./BMEntity.ts" />
///<reference path="./BMStore.ts" />
///<reference path="./BMZone.ts" />
var AFC;
(function (AFC) {
    let BulkMail;
    (function (BulkMail) {
        class BMCampaignFactory {
            static createCampaign(item, isNew) {
                if (item && item.channel === "sms" /* BMCampaignChannel.sms */) {
                    return new BulkMail.BMCampaignSMS(item, isNew);
                }
                if (item && item.channel === "social" /* BMCampaignChannel.social */) {
                    return new BulkMail.BMCampaignSocial(item, isNew);
                }
                return new BulkMail.BMCampaignEDDM(item, isNew);
            }
        }
        BulkMail.BMCampaignFactory = BMCampaignFactory;
    })(BulkMail = AFC.BulkMail || (AFC.BulkMail = {}));
})(AFC || (AFC = {}));
;
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="./BMEntity.ts" />
///<reference path="./BMStore.ts" />
///<reference path="./BMZone.ts" />
///<reference path="./BMCampaign.ts" />
var AFC;
(function (AFC) {
    let BulkMail;
    (function (BulkMail) {
        BulkMail.EventType_MessageDirty = 45679645;
        class BMCampaignSMS extends BulkMail.BMCampaign {
            constructor(item, isNew) {
                super(item, isNew);
                this._sender = "";
                this._message = "";
                this._shortenURL = false;
                this._personaOptions = [];
                this._segmentList = new Map();
                this._routeStatus = "sleeping" /* BMCampaignRouteStatus.sleeping */;
                if (item) {
                    this.volume = item.cost?.volume || 0;
                    this.budget = item.cost?.budget || 0;
                    this.personaOptions = item.target?.options;
                    this.segments = item.target?.segments;
                    this._routeStatus = item.routeStatus;
                    this._routeStatusDetail = item.routeStatusDetail;
                    this.sender = item.sender;
                    this.message = item.message?.text || "";
                    this.shortenURL = item.message?.shortenURL || false;
                }
            }
            get routeStatusDetail() { return this._routeStatusDetail; }
            get routeStatus() { return this._routeStatus; }
            set routeStatus(routeStatus) { this._routeStatus = routeStatus; }
            get segments() { return this._segmentList; }
            set segments(segments) {
                if (segments instanceof Map) {
                    this._segmentList = new Map(segments);
                }
                else {
                    this._segmentList = new Map();
                    segments && segments.forEach(persona => this._segmentList.set(persona.code, "enabled" /* BMSegmentStatus.enabled */));
                }
            }
            get personaId() {
                return [...this._segmentList]?.[0]?.[0];
            }
            get persona() {
                const personaId = this.personaId;
                if (personaId) {
                    return this.getProvider().segments.find(elem => elem.code == personaId)?.name;
                }
                return void 0;
            }
            get qty() {
                return this.volume;
            }
            get shortenURL() {
                return this._shortenURL;
            }
            set shortenURL(shorten) {
                this._shortenURL = shorten;
                if (!this._disableDirtyEvent)
                    this.fireEvent(6 /* Tools.EventType.Dirty */);
                this.fireEvent(BulkMail.EventType_MessageDirty);
            }
            get message() {
                return this._message;
            }
            set message(message) {
                this._message = message;
                if (!this._disableDirtyEvent)
                    this.fireEvent(6 /* Tools.EventType.Dirty */);
                this.fireEvent(BulkMail.EventType_MessageDirty);
            }
            get sender() {
                return this._sender;
            }
            set sender(sender) {
                this._sender = sender;
                if (!this._disableDirtyEvent)
                    this.fireEvent(6 /* Tools.EventType.Dirty */);
            }
            get personaOptions() {
                return this._personaOptions;
            }
            set personaOptions(options) {
                this._personaOptions = options;
            }
            getTarget() {
                return {
                    segments: [{ code: this.personaId }],
                    options: this.personaOptions
                };
            }
            _updateFromPublish(item) {
                let smsItem = item;
                this.routeStatus = smsItem.routeStatus;
            }
            isCompleted() {
                if (this.status == "published" /* BMCampaignStatus.published */)
                    return (this.routeStatus == "completed" /* BMCampaignRouteStatus.completed */) || (this.routeStatus == "completedFinal" /* BMCampaignRouteStatus.completedFinal */);
                return false;
            }
            canPublish() {
                return this.isValid() && this.status === "validated" /* BMCampaignStatus.validated */; // TODO: check BAT ?
            }
            canUnpublish() {
                return (this.status === "published" /* BMCampaignStatus.published */)
                    && ((this.routeStatus == "sleeping" /* BMCampaignRouteStatus.sleeping */)
                        || (this.routeStatus == "verification" /* BMCampaignRouteStatus.verification */)
                        || (this.routeStatus == "scheduled" /* BMCampaignRouteStatus.scheduled */));
            }
            isValidDates() {
                let timestampStart = this.beginDate.getTime();
                //TODO: test supp than now()
                return !isNaN(timestampStart);
                //&& timestampStart > Date.now() + 34; // TODO:
            }
            get beginDateTimeAsString() {
                let beginDate = this._beginDate;
                let hours = beginDate.getHours();
                let minutes = beginDate.getMinutes();
                if (!Number.isNaN(hours) && !Number.isNaN(minutes))
                    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                return '';
            }
            hasUpcoming() {
                return false;
            }
            hasOption(opt) {
                return this.personaOptions.indexOf(opt) !== -1;
            }
            fillCampaignWithRestData(item) {
                let campaign = this;
                super.fillCampaignWithRestData(item);
                campaign.volume = item.cost?.volume || 0;
                campaign.budget = item.cost?.budget || 0;
                campaign.personaOptions = item.target?.options;
                campaign.segments = item.target?.segments;
                campaign.targetedAggregates = item.targeted.aggregates;
                campaign._storesCounter = item.stores;
                campaign.routeStatus = item.routeStatus;
                campaign.sender = item.sender;
                campaign.shortenURL = item.message?.shortenURL;
                campaign.message = item.message?.text;
                if (item.status)
                    campaign.status = item.status;
            }
            getParamItemSave() {
                const campaign = this;
                return {
                    name: campaign.name,
                    dateStart: campaign.beginDate,
                    target: campaign.getTarget(),
                    sender: campaign.sender,
                    message: {
                        text: campaign.message,
                        shortenURL: campaign.shortenURL
                    }
                };
            }
            update(item, forceSave = false, isSimulation = false, silent = false) {
                let itemSms;
                if (item) {
                    let segments = { ...item.segments };
                    itemSms = {
                        name: item.name,
                        dateStart: item.dateStart,
                        target: {
                            options: item.target.options,
                            segments: Object.keys(segments)
                                .filter(key => segments[key] === "enabled" /* BMSegmentStatus.enabled */)
                                .map(key => { return { code: key }; })
                        }
                    };
                }
                else
                    itemSms = this.getParamItemSave();
                return super.update(itemSms, forceSave, isSimulation, silent);
            }
            hasErrorEx() {
                if (this._routeStatus == "stopped" /* BMCampaignRouteStatus.stopped */)
                    return [this.routeStatusDetail != "" ? this.routeStatusDetail : "Erreur lors du routage de la campagne"];
                if (this._message == "")
                    return ["Erreur: le texte du SMS est vide"];
                return [];
            }
            hasErrorSegments() {
                return 1 !== this.segments.size;
            }
            callSendSmsTest(phoneNumbers) {
                return this.code ? new Promise((resolve, reject) => {
                    const cachedData = BulkMail.BMEntityCacheData.getInstance();
                    let request = cachedData.restModel.createAjaxRequest(`${BulkMail.BMCampaign.getUriCampaign(this)}/sms/test`, true, {
                        data: {
                            phoneNumbers: phoneNumbers
                        },
                    });
                    request.options.byPassError = true;
                    request.options.method = "POST";
                    request.options.always = (sequence, jqXHR) => {
                        if (jqXHR.status === 200) {
                            this.status = jqXHR.responseJSON.status;
                            this.fireEvent(6 /* Tools.EventType.Dirty */);
                            resolve(this.status == "checked" /* BMCampaignStatus.checked */);
                        }
                        else
                            resolve(null);
                    };
                    request.call();
                }) : Promise.reject("Error: campaign must be saved in DB before sending test SMS.");
            }
            callPreviewMessage(refCode = "") {
                return new Promise((resolve, reject) => {
                    const cachedData = BulkMail.BMEntityCacheData.getInstance();
                    if (this.message && this.message != "") {
                        let request = cachedData.restModel.createAjaxRequest(`${BulkMail.BMEntityCacheData.path}/sms/preview`, // asterop/rest/{projet}/bm/sms/preview
                        true, {
                            data: {
                                sms: {
                                    message: { text: this.message, shortenURL: this.shortenURL }
                                },
                                codeCampaign: refCode != "" ? refCode : this.code
                            },
                        });
                        request.options.method = "GET";
                        request.options.always = (sequence, jqXHR) => {
                            resolve(jqXHR.responseJSON);
                        };
                        request.call();
                    }
                    else {
                        resolve({
                            preview: "",
                            smsCount: 0,
                            remainingChars: 0,
                            errors: ["Message du SMS vide"]
                        });
                    }
                });
            }
            validate() {
                const campaign = this;
                const cachedData = BulkMail.BMEntityCacheData.getInstance();
                return campaign.isValid() ? new Promise((resolve, reject) => {
                    let request = cachedData.restModel.createAjaxRequest(BulkMail.BMCampaign.getUriCampaign(campaign));
                    request.options.data = { action: { type: "validate" } };
                    request.options.byPassError = true;
                    request.options.always = ((sequence, jqXHR, textStatus) => {
                        if (jqXHR.status === 200) {
                            campaign.status = jqXHR.responseJSON.status;
                            campaign.fireEvent(6 /* Tools.EventType.Dirty */);
                            resolve(this.status == "validated" /* BMCampaignStatus.validated */);
                        }
                        else
                            resolve(false);
                    }).bind(this);
                    request.call();
                })
                    : Promise.resolve(false);
            }
            getNewVolumeBudget(campaignReference) {
                const campaign = this;
                const cachedData = BulkMail.BMEntityCacheData.getInstance();
                return new Promise((resolve, reject) => {
                    let request = cachedData.restModel.createAjaxRequest(`${BulkMail.BMCampaign.getUriCampaign(campaignReference ?? campaign)}/sms/cost`);
                    request.options.data = { target: { segments: [{ code: this.personaId }], options: this.personaOptions }, method: "estimate" };
                    request.options.always = ((sequence, jqXHR, textStatus) => {
                        campaign.volume = jqXHR.responseJSON.volume;
                        campaign.budget = jqXHR.responseJSON.budget;
                        campaign.fireEvent(6 /* Tools.EventType.Dirty */);
                        resolve(jqXHR.responseJSON);
                    }).bind(this);
                    cachedData.sequence = request.call();
                });
            }
        }
        BulkMail.BMCampaignSMS = BMCampaignSMS;
    })(BulkMail = AFC.BulkMail || (AFC.BulkMail = {}));
})(AFC || (AFC = {}));
;
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="./BMEntity.ts" />
///<reference path="./BMStore.ts" />
///<reference path="./BMZone.ts" />
///<reference path="./BMCampaign.ts" />
var AFC;
(function (AFC) {
    let BulkMail;
    (function (BulkMail) {
        class BMCampaignSocial extends BulkMail.BMCampaign {
            constructor(item, isNew) {
                super(item, isNew);
                this._routeStatus = "sleeping" /* BMCampaignRouteStatus.sleeping */;
                if (item) {
                    this._routeStatus = item.routeStatus;
                    this._routeStatusDetail = item.routeStatusDetail;
                    this.budget = item.cost?.budget || 0;
                }
            }
            get routeStatusDetail() { return this._routeStatusDetail; }
            get routeStatus() { return this._routeStatus; }
            set routeStatus(routeStatus) { this._routeStatus = routeStatus; }
            hasErrorSegments() {
                return false;
            }
            copyZonesFromCampaign(basedOnCodeCampaign) {
                const basedOnCampaign = (BulkMail.BMEntityCacheData.getInstance().campaign(basedOnCodeCampaign));
                super.copyZonesFromCampaign(basedOnCodeCampaign);
                if (basedOnCampaign)
                    this.budget = basedOnCampaign.budget;
            }
            _updateFromPublish(item) {
                let socialItem = item;
                this.routeStatus = socialItem.routeStatus;
            }
            setStoresInfo(values, session) {
                return new Promise((resolve, refect) => {
                    this.getStoreList().then(_ => {
                        let request = BulkMail.BMEntityCacheData.getInstance().restModel.createAjaxRequest(`${BulkMail.BMCampaign.getUriCampaign(this)}/stores`);
                        request.options.data = {
                            action: {
                                type: "update",
                                session: session,
                                values: values,
                                channel: 'social',
                            }
                        };
                        request.options.byPassError = true;
                        request.options.method = "POST";
                        request.options.always = ((sequence, jqXHR, textStatus) => {
                            if (jqXHR.status == 200)
                                resolve(true);
                            else
                                resolve(false);
                        });
                        request.call();
                    });
                });
            }
            canPublish() {
                return this.isValid() && this.status === "validated" /* BMCampaignStatus.validated */;
            }
            validate() {
                const campaign = this;
                const cachedData = BulkMail.BMEntityCacheData.getInstance();
                return campaign.isValid() ? new Promise((resolve, reject) => {
                    let request = cachedData.restModel.createAjaxRequest(BulkMail.BMCampaign.getUriCampaign(campaign));
                    request.options.data = { action: { type: "validate" } };
                    request.options.byPassError = true;
                    request.options.always = ((sequence, jqXHR, textStatus) => {
                        if (jqXHR.status === 200) {
                            campaign.status = jqXHR.responseJSON.status;
                            campaign.fireEvent(6 /* Tools.EventType.Dirty */);
                            resolve(this.status == "validated" /* BMCampaignStatus.validated */);
                        }
                        else
                            resolve(false);
                    }).bind(this);
                    request.call();
                })
                    : Promise.resolve(false);
            }
        }
        BulkMail.BMCampaignSocial = BMCampaignSocial;
    })(BulkMail = AFC.BulkMail || (AFC.BulkMail = {}));
})(AFC || (AFC = {}));
;
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
var AFC;
(function (AFC) {
    let BulkMail;
    (function (BulkMail) {
        /**
         * Class for cache singleton
         */
        class BMEntityCacheData {
            constructor() { } // prevent new
            static getInstance(restModel) {
                if (!BMEntityCacheData.instance) {
                    BMEntityCacheData.instance = new BMEntityCacheData();
                    BMEntityCacheData.instance.eventHandler = new AFC.Tools.EventSink();
                    BMEntityCacheData.instance.restModel = restModel;
                }
                return BMEntityCacheData.instance;
            }
            get campaignList() {
                return this._campaignList;
            }
            get providerList() {
                return this._providerList;
            }
            get sequence() {
                return this._sequence;
            }
            set sequence(value) {
                this._sequence = value;
            }
            get storeList() {
                return this._storeList;
            }
            get zoneList() {
                return this._zoneList;
            }
            /**
             * Return stored campaign corresponding to given code
             *
             * @param code
             */
            campaign(code) {
                return this.campaignList.items.find(item => item.code === code);
            }
            /**
             * Return stored provider corresponding to given code provider or given codeVersion
             *
             * @param code
             * @param codeVersion
             */
            provider(code, codeVersion) {
                return code ? this.providerList.items.find(item => item.code === code)
                    : codeVersion ? this.providerList.items.find(item => item.featureVersions?.find(itemV => itemV.code === codeVersion))
                        : void 0;
            }
            static flushCampaignList() {
                this.getInstance()._campaignList = void 0;
            }
            /**
             * Clear all cached data
             */
            static flushAll() {
                // let instance = this.getInstance();
                // instance._campaignList = new BMDataModel();
                // instance._providerList = new BMDataModel();
                // instance._storeList = new BMDataModel();
                // instance._zoneList = new BMDataModel();
                // instance._campaignList.on(Tools.EventType.UserEvent, () => { instance.getCampaigns(true); });
                // instance._campaignList.on(Tools.EventType.Dirty, () => instance.eventHandler.fireEvent(AFC.Tools.EventType.UserEvent + 32));
                // instance._providerList.on(Tools.EventType.Dirty, () => instance.getCampaigns(true)); // TODO:
                // instance._storeList.on(Tools.EventType.Dirty, () => instance.getCampaigns(true)); // TODO:
                // instance._zoneList.on(Tools.EventType.Dirty, () => instance.getCampaigns(true)); // TODO:
            }
            /**
             * Fireevent on complete XHR request
             *
             * @param sequence
             * @param jqXHR
             * @param textStatus
             */
            _onComplete(sequence, jqXHR, textStatus) {
                if (this._sequence === sequence) {
                    // this._legend = <ILayerLegendData>jqXHR.responseJSON;
                    this.eventHandler.fireEvent(65536 /* Tools.EventType.UserEvent */ + 1);
                }
            }
            /**
             * Update campaigns from DB if not already done, otherwise, get campaignList
             *
             * @param forceUpdate Set true to force call to api and refresh campaignList
             * @returns Promise<campaignList>
             */
            getCampaigns(forceUpdate = false) {
                let instance = this;
                return (instance._campaignList === void 0 || forceUpdate) ?
                    new Promise((resolve, reject) => {
                        // instance.eventHandler.notify(Tools.EventType.UserEvent + 1, (/*event: Tools.IEvent*/) => console.log("resolve(instance._campaignList)"));
                        let request = instance.restModel.createAjaxRequest(BMEntityCacheData.pathCampaign);
                        request.options.always = ((sequence, jqXHR, textStatus) => {
                            instance._campaignList = new BMDataModel();
                            jqXHR.responseJSON.forEach((value) => {
                                instance._campaignList.addItem(BulkMail.BMCampaignFactory.createCampaign(value));
                            });
                            instance._onComplete(sequence, jqXHR, textStatus);
                            resolve(instance._campaignList);
                        }).bind(this);
                        instance._sequence = request.call();
                    })
                    : Promise.resolve(instance._campaignList);
            }
            /**
             * Create new BMCampaign and add this newly created campaign to campaign list.
             * New campaign has empty dates: force user to indicate value.
             */
            createCampaign(provider) {
                // let dateNow = new Date();
                if (!provider)
                    return;
                let campaignBase = this.campaignList.items
                    .filter((cp) => cp.getProvider().code === provider.code)
                    .filter((cp) => cp.status !== "new" /* AFC.BulkMail.BMCampaignStatus.new */)
                    .sort((a, b) => a.status !== "template" /* AFC.BulkMail.BMCampaignStatus.template */ ? -1 : 1)
                    .filter((cp, index, arr) => index === arr.findIndex((_cp) => _cp.zoneCodeTargeted === cp.zoneCodeTargeted))[0];
                let campaign = BulkMail.BMCampaignFactory.createCampaign({
                    "code": AFC.Tools.Data.generateRndString(32),
                    "name": "",
                    "channel": provider.channel,
                    // "dateStart": dateNow,
                    // "dateEnd": new Date(new Date().setDate(dateNow.getDate() + 7)),
                    targeted: {
                        zoneCode: campaignBase.zoneCodeTargeted,
                        featuresVersion: provider.getCurrentVersion().code,
                        aggregates: campaignBase.targetedAggregates
                    },
                    "status": "new" /* BMCampaignStatus.new */,
                    "segments": campaignBase.segments,
                    "stores": [...campaignBase.storesCounter],
                }, true);
                campaign.copyZonesFromCampaign(campaignBase.code);
                this._campaignList.addItem(campaign);
                this.eventHandler.fireEvent(65536 /* Tools.EventType.UserEvent */ + 32);
            }
            /**
             * Call given campaign update function @see BMCampaign.update()
             *
             * @param code Campaign code to be updated
             * @returns promise
             */
            updateCampaign(code, item, silent = false) {
                const instance = this;
                const campaign = instance.campaign(code);
                return campaign ?
                    campaign.update(item, false, false, silent)
                    : Promise.reject("Campaign not found.");
            }
            /**
             * Call given campaign deletion function @see BMCampaign.delete() and remove campaign from cache
             *
             * @param code Campaign code to be removed
             * @returns promise
             */
            deleteCampaign(code) {
                const instance = this;
                const campaign = instance.campaign(code);
                return campaign ? campaign.delete().then((deleted) => {
                    if (deleted) {
                        instance.campaignList.removeItem(code);
                        instance.eventHandler.fireEvent(65536 /* Tools.EventType.UserEvent */ + 32);
                    }
                    return Promise.resolve(deleted);
                })
                    : Promise.reject("Campaign not found.");
            }
            /**
             * Copy zone from campaign to another (used in campaign creation)
             *
             * @param codeCampaignFrom
             * @param codeCampaignTo
             */
            copyZones(codeCampaignFrom, codeCampaignTo) {
                this.campaign(codeCampaignTo).copyZonesFromCampaign(codeCampaignFrom);
                this.eventHandler.fireEvent(65536 /* Tools.EventType.UserEvent */ + 32);
            }
            async getProvidersChannels() {
                let channels = [];
                let providers = await this.getProviders();
                providers.forEach((provider) => {
                    if (channels.indexOf(provider.channel) === -1) {
                        channels.push(provider.channel);
                    }
                });
                return channels;
            }
            /**
             * Update providers from DB if not already done, otherwise, get providerList
             *
             * @param forceUpdate Set true to force call to api and refresh providerList
             * @returns Promise<providerList>
             */
            getProviders(forceUpdate = false) {
                let instance = this;
                return (instance._providerList === void 0 || forceUpdate) ?
                    new Promise((resolve, reject) => {
                        // instance.eventHandler.notify(Tools.EventType.UserEvent + 1, (/*event: Tools.IEvent*/) => resolve(instance._providerList));
                        let request = instance.restModel.createAjaxRequest(BMEntityCacheData.pathProviders);
                        request.options.always = ((sequence, jqXHR, textStatus) => {
                            instance._providerList = new BMDataModel();
                            jqXHR.responseJSON.forEach((value) => {
                                instance._providerList.addItem(new BulkMail.BMProvider(value));
                            });
                            resolve(instance._providerList);
                            instance._onComplete(sequence, jqXHR, textStatus);
                        }).bind(this);
                        instance._sequence = request.call();
                    })
                    : Promise.resolve(instance._providerList);
            }
        }
        BMEntityCacheData.path = '/bm'; //eg. http://localhost/asterop/rest/ciblageISA/bm
        BMEntityCacheData.pathCampaign = `${BMEntityCacheData.path}/campaigns`; //eg. http://localhost/asterop/rest/ciblageISA/bm/campaigns
        BMEntityCacheData.pathProviders = `${BMEntityCacheData.path}/providers`; //eg. http://localhost/asterop/rest/ciblageISA/bm/providers
        BMEntityCacheData.pathZones = `${BMEntityCacheData.path}/zones`; //eg. http://localhost/asterop/rest/ciblageISA/bm/zones
        BulkMail.BMEntityCacheData = BMEntityCacheData;
        class BMDataModel extends AFC.Tools.EventSink {
            constructor() {
                super();
                this._items = new Array();
                this.fireEvent(65536 /* Tools.EventType.UserEvent */);
            }
            get length() {
                return this._items.length;
            }
            get items() {
                return this._items.map(_item => _item.entity);
            }
            entity(index) {
                return this._items[index].entity;
            }
            item(index) {
                return this._items[index];
            }
            addItem(obj) {
                this._items.push({
                    dataItem: obj,
                    dataItemIndex: this._items.length,
                    entity: obj,
                    props: {}
                });
            }
            removeItem(code) {
                this._items = this._items.filter(item => item.entity.code !== code);
            }
            flushItemProps(index) {
                let item = this.item(index);
                item.entity.fireEvent(6 /* Tools.EventType.Dirty */); // hack
                item && (item.props = {});
            }
            flushProps() {
                this._items.forEach(_item => _item.props = {});
            }
            forEach(callbackfn) {
                this.items.forEach(callbackfn);
            }
            filter(callbackfn) {
                return this.items.filter(callbackfn);
            }
        }
        BulkMail.BMDataModel = BMDataModel;
    })(BulkMail = AFC.BulkMail || (AFC.BulkMail = {}));
})(AFC || (AFC = {}));
;
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
var AFC;
(function (AFC) {
    let BulkMail;
    (function (BulkMail) {
        let BMVersionStatus;
        (function (BMVersionStatus) {
            BMVersionStatus["production"] = "production";
            BMVersionStatus["upcoming"] = "upcoming";
            BMVersionStatus["deprecated"] = "deprecated";
            BMVersionStatus["template"] = "template";
        })(BMVersionStatus = BulkMail.BMVersionStatus || (BulkMail.BMVersionStatus = {}));
        class BMProvider extends BulkMail.BMEntity {
            constructor(item) {
                super();
                this.senders = [];
                if (item) {
                    this._code = item.code;
                    this._name = item.name;
                    this.description = item.description ?? item.name;
                    this.channel = item.channel;
                    if (item.balance)
                        this.balance = item.balance;
                    else
                        this.balance = null;
                    this.senders = item.senders ?? [];
                    this.placeholders = item.placeHolders ?? [];
                    if (item.targets && item.targets.segments) {
                        this._segmentList = item.targets.segments.map((segment) => {
                            return { ...segment, code: segment.code }; // Add code: for compatibility segments/personae.........
                        });
                    }
                    else {
                        item.segments && (this._segmentList = [...item.segments]);
                    }
                    item.aggregates && (this._aggregates = [...item.aggregates]);
                    item.featuresVersions && (this._featureVersions = [...item.featuresVersions]);
                    if (item.ordering) {
                        this._ordering = item.ordering.map((v) => {
                            return { ...v, direction: v.direction.toUpperCase().trim(), checked: v.enabled ? "checked" : "" };
                        });
                    }
                }
            }
            get code() { return this._code; }
            get name() { return this._name; }
            get segments() { return this._segmentList; }
            get ordering() { return this._ordering; }
            get aggregates() { return this._aggregates; }
            get featureVersions() { return this._featureVersions; }
            /**
             * Get an array of aggregates codes, used to compute total aggregates values (in campaign details screen > charts)
             *
             * @returns An array of aggregates code eg. [ "CA", "DATA1", "DATA2" ]
             */
            getAggregatesCodeList() {
                return this.aggregates.map((agg) => agg.code);
            }
            /**
             * Get the aggregate name corresponding to given code aggergate
             *
             * @param code The aggregate code
             * @returns The corresponding aggregate name
             */
            getAggregateName(code) {
                let aggr;
                return (aggr = this.aggregates.find(_aggr => _aggr.code === code)) && aggr.name;
            }
            /**
             * Get the segment name corresponding to given code segment
             *
             * @param code The segment code
             * @returns The corresponding segment name
             */
            getSegmentName(code) {
                let segment;
                return (segment = this.segments.find(_segment => _segment.code === code)) && segment.name;
            }
            /**
             * Return provider's paramaters (= Provider.ordering) as data model
             *
             * @returns The provider's ordering aggregates as a DataModel
             */
            getConfigParameters() {
                return new BMParametersDataModel(this.ordering);
            }
            /**
             * Returns feature version current in production
             *
             * @returns The current feature version in production
             */
            getCurrentVersion() {
                return this._featureVersions.find(elem => elem.status === "production" /* BMVersionStatus.production */);
            }
            /**
             * Returns upcoming feature version
             *
             * @returns The next feature version
             */
            getNextVersion() {
                return this._featureVersions.find(elem => elem.status === "upcoming" /* BMVersionStatus.upcoming */);
            }
            /**
             * Returns feature version corresponding to given code version
             *
             * @returns
             */
            getVersion(codeVersion) {
                return this._featureVersions.find(elem => elem.code === codeVersion);
            }
        }
        BulkMail.BMProvider = BMProvider;
        class BMParametersDataModel extends AFC.Data.DataSource {
            get length() { return this._items.length; }
            constructor(items) {
                super();
                this._items = [...items];
                this.fireEvent(65536 /* Tools.EventType.UserEvent */);
            }
            item(index) {
                return {
                    dataItem: this._items[index],
                    dataItemIndex: index,
                };
            }
        }
        BulkMail.BMParametersDataModel = BMParametersDataModel;
    })(BulkMail = AFC.BulkMail || (AFC.BulkMail = {}));
})(AFC || (AFC = {}));
;
/**
 * Created by jean.rennes on 23/09/2015.
 */
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="Global.ts" />
///<reference path="DashboardView.ts" />
///<reference path="SiteFinder.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        const _sequence = Symbol();
        class ViewModel extends AFC.Tools.EventSink {
            constructor() {
                super();
                this.on(1073741824 /* Tools.EventType.Attach */, this._onAttach, this);
            }
            _onDirty(event) {
                let dashboard = this.dashboardModel?.dashboard, sequence = this[_sequence] = Symbol();
                delete this._view;
                this.fireEvent(1073741824 /* Tools.EventType.Attach */, { sequence: sequence, data: event?.data, dashboard: dashboard });
            }
            setId(value) {
                if (this._id !== value) {
                    this._id = value;
                    this._onDirty();
                    return true;
                }
            }
            set dashboardModel(value) {
                if (this._dashboardModel !== value) {
                    this._dashboardModel && this._dashboardModel.off(6 /* Tools.EventType.Dirty */, this._onDirty, this);
                    value ? (this._dashboardModel = value).on(6 /* Tools.EventType.Dirty */, this._onDirty, this) : delete this._dashboardModel;
                    this._onDirty();
                }
            }
            get dashboardModel() {
                return this._dashboardModel;
            }
            get id() {
                return (this._view && this._view.id) || this._id;
            }
            get name() {
                return this._view && this._view.name;
            }
            get label() {
                return this.name;
            }
            getView() {
                return this[_sequence] ?
                    new Promise(resolve => this.notify(1073741824 /* Tools.EventType.Attach */, () => resolve(this._view))) :
                    Promise.resolve(this._view);
            }
            getType() {
                return this.getView().then(view => view && view.type);
            }
            get properties() {
                return this._view && this._view.properties;
            }
            get dashboard() {
                return this.dashboardModel?.dashboard;
            }
            _onAttach(event) {
                let data = event.data, dashboard = data.dashboard;
                if (data.sequence === this[_sequence]) {
                    delete this[_sequence];
                    this._view = dashboard && AFC.Tools.findByIdOrName(this._id, dashboard.views, this._filter.bind(this));
                    this.fireEvent(6 /* Tools.EventType.Dirty */, data.data);
                }
            }
            release() {
                this.dashboardModel?.off(6 /* Tools.EventType.Dirty */, this._onDirty, this);
            }
            getLegendImage(width, height, horizontal, quality) {
                return this._view ? this._view.getLegend(width, height, horizontal, quality) : Promise.resolve();
            }
        }
        class MapModel extends ViewModel {
            _filter(view) {
                return view.type === 1 /* ViewType.map */;
            }
            setId(value) {
                return super.setId(value) && (delete this._foreignData, true);
            }
            setLayerForeignData(indice, foreignData) {
                (this._foreignData || (this._foreignData = []))[indice] = foreignData;
            }
            getLayerCount() {
                return this.getView().then((view) => view ? view.descriptor.layerCount : 0);
            }
            getMapTemplate() {
                return this.getView().then(view => view && view.descriptor.mapTemplate);
            }
            async getDescriptors() {
                let view = await this.getView(), descriptor = view.descriptor, promises = [];
                for (let i = 0; i < descriptor.layerCount; ++i) {
                    promises.push(descriptor.getLayer(i));
                }
                return Promise.all(promises);
            }
            async getLayer(indice) {
                let view = await this.getView(), layer = this._foreignData && this._foreignData[indice] ?
                    Object.assign({ descriptor: await view.descriptor.getLayer(indice) }, this._foreignData[indice]) :
                    await view.getLayer(indice);
                return layer?.descriptor && new AFC.Globals.MapLayerStaticModel(layer.descriptor.template, layer.dataModel, layer.thematics);
            }
            getBbox() {
                return this.getView().then(view => view && view.getBbox());
            }
        }
        Dashboards.MapModel = MapModel;
        function _getPosition(value) {
            let regexp = /^([a-z]+)([0-9]+)$/;
            let res = value.toLowerCase().match(regexp);
            if (res && (res.length === 3)) {
                let x = 0;
                for (let i = 0; i < res[1].length; ++i) {
                    x = (x * 26) + res[1].charCodeAt(i) - /* 'a'.charCodeAt(0) */ 97;
                }
                return {
                    x: x,
                    y: parseInt(res[2]) - 1
                };
            }
        }
        class GridDataSource {
            constructor(gridData) {
                this._gridData = gridData;
            }
            getData(key, stringify) {
                let position;
                let items;
                let line;
                if (position = _getPosition(key)) {
                    if (this._gridData.rowHeaders && this._gridData.rowHeaders.visibility && this._gridData.rowHeaders.items) {
                        position.x -= 1;
                    }
                    if (this._gridData.columnHeaders && this._gridData.columnHeaders.visibility && this._gridData.columnHeaders.items) {
                        if (!position.y) {
                            return position.x < 0 ? '' : this._gridData.columnHeaders.items[position.x].name;
                        }
                        position.y -= 1;
                    }
                    if (position.x < 0) {
                        return this._gridData.rowHeaders.items[position.y].name;
                    }
                    else if ((items = this._gridData.items) && (position.y < items.length) && (position.x < (line = items[position.y]).length)) {
                        return stringify ? line[position.x].text : line[position.x].value;
                    }
                }
            }
        }
        class GridModel extends ViewModel {
            setId(value) {
                return super.setId(value) && (this._releaseForeignData(), true);
            }
            _onForeignDirty(event) {
                let data = event.data;
                if (!data || data.reset || data.items.every(item => item.committed))
                    this.fireEvent(6 /* Tools.EventType.Dirty */);
            }
            _releaseForeignData() {
                this._foreignData?.dataModel?.off(6 /* Tools.EventType.Dirty */, this._onForeignDirty, this);
                delete this._foreignData;
            }
            release() {
                super.release();
                this._releaseForeignData();
            }
            _filter(view) {
                return (view.type === 3 /* ViewType.aggregatedSheet */) || (view.type === 2 /* ViewType.detailedSheet */) || (view.type === 5 /* ViewType.spreadSheet */);
            }
            setForeignData(foreignData) {
                if (foreignData !== this._foreignData) {
                    this._releaseForeignData();
                    this._foreignData = foreignData;
                    this._foreignData?.dataModel?.on(6 /* Tools.EventType.Dirty */, this._onForeignDirty, this);
                    this._onDirty();
                    return true;
                }
            }
            getForeignDataModel() {
                return this._foreignData?.dataModel;
            }
            getGridApp() {
                return this.getView().then(view => {
                    if (view) {
                        let data = this._foreignData;
                        /* Uncomment when trend symbol in metadata are available */
                        /*return view.type === ViewType.detailedSheet ?
                            Promise.all([view.getMetadata(), data || view.getData()]).then(results => new DetailedGridApp(results[0].sheetProperties, results[1], view.sortedColumns)):
                            view.getGridData().then(data => data && new GridApp(data));*/
                        let detailed = view.type === 2 /* ViewType.detailedSheet */;
                        return detailed && data ?
                            view.getMetadata().then(async (metadata) => new Dashboards.DetailedGridApp(metadata.sheetProperties, data, await view.getSortedColumns())) :
                            view.getGridData().then(async (data) => data && new Dashboards.GridApp(data, detailed, view.getSortedColumns && await view.getSortedColumns()));
                    }
                });
            }
            getDataContainer() {
                return this.getView().then(view => view && view.getGridData().then((data) => new GridDataSource(data)));
            }
        }
        Dashboards.GridModel = GridModel;
        function checkChartData(view) {
            let descriptor, chartData = false;
            if (view && (descriptor = view.descriptor) && ((descriptor.type === 4 /* ViewType.chart */) || (descriptor.type === 5 /* ViewType.spreadSheet */) || (descriptor.type === 6 /* ViewType.detailedChart */))) {
                switch (descriptor.chartType) {
                    case 9 /* ChartType.pie */:
                    case 11 /* ChartType.doughnut */:
                    case 21 /* ChartType.barHorizontal */:
                    case 1 /* ChartType.bar */:
                    case 19 /* ChartType.radar */:
                    case 5 /* ChartType.stackedBar */:
                    case 22 /* ChartType.stackedBarHorizontal */:
                        chartData = true;
                        break;
                }
            }
            return chartData;
        }
        Dashboards.checkChartData = checkChartData;
        class ChartModel extends ViewModel {
            _filter(view) {
                return (view.type === 4 /* ViewType.chart */) || (view.type === 100 /* ViewType.report */) || (view.type === 5 /* ViewType.spreadSheet */) || (view.type === 6 /* ViewType.detailedChart */);
            }
            get drawable() {
                return this._view && ((this._view.type === 100 /* ViewType.report */) || checkChartData(this._view));
            }
            getImage(width, height, page) {
                return this.getView().then(view => view && view.getImage(width, height, page));
            }
            getChartData() {
                return this.getView().then(view => view && view.getChartData && view.getChartData());
            }
            getReportMetadata() {
                return this.getView().then(view => view && view.descriptor.getReportMetadata && view.descriptor.getReportMetadata());
            }
            getReportData() {
                return this.getView().then(view => view && view.getReportData && view.getReportData());
            }
        }
        Dashboards.ChartModel = ChartModel;
        class DashboardModel extends AFC.Tools.EventSink {
            constructor(dashboard) {
                super();
                this.dashboard = dashboard;
                this.on(1073741824 /* Tools.EventType.Attach */, this._onAttach, this);
            }
            _onAttach(event) {
                this.fireEvent(6 /* Tools.EventType.Dirty */, event?.data);
            }
            _onDirty(event) {
                this.fireEvent(1073741824 /* Tools.EventType.Attach */, event?.data);
            }
            get dashboard() {
                return this._dashboard;
            }
            set dashboard(dashboard) {
                if (this._dashboard !== dashboard) {
                    this.release();
                    dashboard && (this._dashboard = dashboard).on(6 /* Tools.EventType.Dirty */, this._onDirty, this);
                    this.fireEvent(1073741824 /* Tools.EventType.Attach */);
                }
            }
            get id() {
                return this._dashboard && this._dashboard.id;
            }
            get name() {
                return this._dashboard && this._dashboard.name;
            }
            get levels() {
                return this._dashboard && this._dashboard.descriptor.levels;
            }
            get properties() {
                return this._dashboard && this._dashboard.descriptor.properties;
            }
            release() {
                if (this._dashboard) {
                    this._dashboard.off(6 /* Tools.EventType.Dirty */, this._onDirty, this);
                    delete this._dashboard;
                    this.fireEvent(1073741824 /* Tools.EventType.Attach */);
                }
            }
        }
        Dashboards.DashboardModel = DashboardModel;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
;
/**
 * Created by jean.rennes on 24/02/2021.
 */
///<reference path="../../AFC.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        let OperationType;
        (function (OperationType) {
            OperationType[OperationType["reset"] = 1] = "reset";
            OperationType[OperationType["update"] = 2] = "update";
            OperationType[OperationType["getOwnership"] = 3] = "getOwnership";
            OperationType[OperationType["delete"] = 4] = "delete";
        })(OperationType = Dashboards.OperationType || (Dashboards.OperationType = {}));
        ;
        class OperationImpl {
            constructor(zone, commit) {
                this.zone = zone;
                this.promise = commit && new Promise(resolve => this._resolve = resolve);
            }
            async send() {
                let operation = this.getOperation();
                if (operation.events.length) {
                    let promise = this.zone.createRequest('/districting', 1 /* DistrictType.redistricting */), request = await promise[1], data = request.options.data;
                    data.operation = {
                        type: operation.type,
                        events: operation.events
                    };
                    request.options.always = ( /*sequence: number, jqXHR: JQuery.jqXHR, textStatus: string*/) => this._resolve();
                    request.call();
                }
                else {
                    this._resolve();
                }
                return this.promise;
            }
            merge(operation) {
                return false;
            }
        }
        function _findEvent(operation, site, branch) {
            return operation.events.findIndex(event => event.site === site && event.branch === branch);
        }
        function _castUpdateValue(event) {
            let value = {};
            for (let unit in event.units) {
                let id = event.units[unit];
                (value[id] || (value[id] = [])).push(unit);
            }
            return value;
        }
        function _castApplyValue(event) {
            let units = [];
            for (let unit in event.units) {
                let values = event.units[unit];
                units.push({ unit: unit, values: values });
            }
            return units;
        }
        class UpdateOperation extends OperationImpl {
            constructor(zone, commit, site, branch, unit, affect, change) {
                let event = { site: site, units: {} };
                super(zone, commit);
                this.pure = affect;
                branch && (event.branch = branch);
                event.units[unit] = change;
                this.events = [event];
            }
            get type() {
                return 2 /* OperationType.update */;
            }
            push(descriptor, operations) {
                let operation = operations.length && operations[operations.length - 1]; // assume type for convenience
                if (operation && operation.type === 2 /* OperationType.update */) {
                    let pure = operation.pure && this.pure, dataNode, check = (val, pure) => {
                        let values = val, subset;
                        if (pure) {
                            dataNode || (dataNode = descriptor.dataNodes.find(dataNode => dataNode.qualifier === 4 /* DataQualifier.partition */));
                            subset = descriptor.partition.subsets.find(subset => subset.id === val);
                            values = { [dataNode.name]: subset.value };
                        }
                        return values;
                    }, sourceOp, targetOp;
                    if (this.pure) {
                        sourceOp = this;
                        targetOp = operation;
                    }
                    else {
                        sourceOp = operation;
                        targetOp = this;
                    }
                    sourceOp.events.forEach(source => {
                        let index = _findEvent(operation, source.site, source.branch), target;
                        index === -1 ? targetOp.events.push(target = { site: source.site, branch: source.branch, units: {} }) : target = targetOp.events[index];
                        for (let key in source.units) {
                            if (pure) {
                                target.units[key] = source.units[key]; // subset id copy
                            }
                            else {
                                target.units[key] = $.extend(check(target.units[key], targetOp.pure), check(source.units[key], sourceOp.pure));
                            }
                        }
                    });
                    operation.pure = pure;
                    operation.events = targetOp.events;
                }
                else {
                    operations.push(this);
                }
                return this;
            }
            getOperation() {
                return this.pure ? {
                    type: 'update',
                    events: this.events.map(event => ({
                        site: event.site,
                        branch: event.branch,
                        value: _castUpdateValue(event)
                    }))
                } : {
                    type: 'applyChanges',
                    events: this.events.map(event => ({
                        site: event.site,
                        branch: event.branch,
                        units: _castApplyValue(event)
                    }))
                };
            }
        }
        function _remove(operations, operation, position, site, branch) {
            let index = _findEvent(operation, site, branch);
            if (index !== -1) {
                operation.events.length === 1 ?
                    operations.splice(position, 1) :
                    operation.events.splice(index, 1);
            }
        }
        class ResetOperation extends OperationImpl {
            constructor(zone, commit, site, branch) {
                let event = { site: site, reset: true };
                super(zone, commit);
                branch && (event.branch = branch);
                this.events = [event];
            }
            get type() {
                return 1 /* OperationType.reset */;
            }
            push(descriptor, operations) {
                this.events = this.events.reduceRight((accumulator, event) => {
                    let push = true;
                    for (let i = operations.length; i > 0; --i) {
                        let operation = operations[i - 1];
                        if (operation.type === 2 /* OperationType.update */) {
                            _remove(operations, operation, i - 1, event.site, event.branch);
                        }
                        else {
                            if (operation.type === 1 /* OperationType.reset */) {
                                push = false;
                                _findEvent(operation, event.site, event.branch) === -1 && operation.events.push(event);
                            }
                            break;
                        }
                    }
                    push && accumulator.push(event);
                    return accumulator;
                }, []);
                this.events.length && operations.push(this);
                return this;
            }
            getOperation() {
                return {
                    type: 'update',
                    events: this.events
                };
            }
            merge(operation) {
                if (operation && operation.type === 2 /* OperationType.update */ && operation.pure) {
                    operation.events.forEach(event => {
                        let index = _findEvent(this, event.site, event.branch);
                        index === -1 ?
                            this.events.push(event) :
                            this.events[index].value = _castUpdateValue(event);
                    });
                    return true;
                }
            }
        }
        const _OperationTypeLookup = {
            [4 /* OperationType.delete */]: 'delete',
            [3 /* OperationType.getOwnership */]: 'getOwnership'
        };
        function _generator(t) {
            class _DerivedOperation extends OperationImpl {
                constructor(zone, commit, site, branch, unit) {
                    let event = { site: site, units: [unit] };
                    super(zone, commit);
                    this.type = t;
                    branch && (event.branch = branch);
                    this.events = [event];
                }
                push(descriptor, operations) {
                    let operation = operations.length && operations[operations.length - 1]; // assume type for convenience
                    if (operation && operation.type === this.type) {
                        this.events.forEach(event => {
                            let index = _findEvent(operation, event.site, event.branch);
                            index === -1 ? operation.events.push(event) : operation.events[index].units.push(...event.units);
                        });
                    }
                    else {
                        operations.push(this);
                    }
                    return this;
                }
                getOperation() {
                    return {
                        type: _OperationTypeLookup[this.type],
                        events: this.events
                    };
                }
            }
            ;
            return _DerivedOperation;
        }
        const OwnershipOperation = _generator(3 /* OperationType.getOwnership */);
        const DeleteOperation = _generator(4 /* OperationType.delete */);
        class ReaffectStorage extends AFC.Tools.EventSink {
            constructor(storages, descriptor, zones) {
                super();
                this.id = Symbol();
                this.storages = storages;
                this.descriptor = descriptor;
                this.partition = descriptor.dataNodes.find(dataNode => dataNode.qualifier === 4 /* DataQualifier.partition */);
                this.commit = false;
                this._zones = zones;
            }
            _flush() {
                if (this._pendings.length) {
                    let operation = this._pendings.shift();
                    operation.merge(this._pendings[0]) && this._pendings.shift();
                    operation.send().then(() => this._flush());
                }
                else
                    delete this._pendings;
            }
            _commit(zone, site, item) {
                let branch = zone.dashboard.branch, commit = this.commit && !!this.descriptor.partition.districtingTable, operation;
                if (item.delete) {
                    operation = new DeleteOperation(zone, commit, site, branch, item.delete);
                }
                else if (item.ownership) {
                    operation = new OwnershipOperation(zone, commit, site, branch, item.ownership);
                }
                else if (item.reset) {
                    operation = new ResetOperation(zone, commit, site, branch);
                }
                else {
                    operation = new UpdateOperation(zone, commit, site, branch, item.change.unit, item.change.pure, item.change.value);
                }
                if (commit) {
                    if (this._pendings) {
                        operation.push(this.descriptor, this._pendings);
                    }
                    else {
                        this._pendings = [operation];
                        this._flush();
                    }
                }
                this.fireEvent(6 /* Tools.EventType.Dirty */, [operation]);
                return operation;
            }
            async _update(site, item) {
                let zone = item && this._zones[0], operation;
                item = zone && this._apply(zone, site, item);
                if (item) {
                    zone.dashboard.invalidateViews(operation = this._commit(zone, site, item));
                    this._zones.forEach(zone => zone.invalidate());
                    return operation.promise;
                }
            }
            /*
            * For now, the reaffect table is considered not mutable => read it from zone descriptor reference
            * Just in case reaffect table becomes mutable, keep _loadZones async
            */
            async _loadZones() {
                let zones = this._zones;
                if (!zones) {
                    let dashboard = this.dashboard, districtingTable = this.table;
                    this._zones = zones = dashboard.zones.filter((zone) => {
                        let partition = zone.reference.partition;
                        return partition && partition.districtingMode !== 0 /* ZoneReaffectStorage.none */ && partition.districtingTable === districtingTable;
                    });
                }
                return zones;
            }
            get table() {
                return this.descriptor.partition.districtingTable;
            }
            get mode() {
                return this.descriptor.partition.districtingMode;
            }
            get dashboard() {
                return this.storages.dashboard;
            }
            reset(site) {
                return this._update(site, this.isRedistricted(site) && { reset: true });
            }
            affect(site, unit, id) {
                let subset = this.descriptor.partition.subsets.find(subset => subset.id === id);
                return subset && this._update(site, { change: { unit: unit, pure: true, value: id, subset: subset } });
            }
            getOwnership(site, unit) {
                return this._update(site, { ownership: unit });
            }
            delete(site, unit) {
                return this._update(site, { delete: unit });
            }
            async applyChanges(site, unit, values) {
                let keys = Object.keys(values), subset, change;
                if (keys.length > 0) {
                    if (values.hasOwnProperty(this.partition.name)) {
                        subset = this.descriptor.partition.subsets.find(subset => subset.value === values[this.partition.name]);
                        subset && keys.length === 1 && (change = { unit: unit, pure: true, value: subset.id, subset: subset });
                    }
                    return this._update(site, { change: change || { unit: unit, pure: false, value: values, subset: subset } });
                }
            }
        }
        class ReaffectInlineStorage extends ReaffectStorage {
            release() {
                delete this._sequence;
                delete this._units;
                delete this._zoneEntries;
            }
            _apply(zone, site, item) {
                let units = this._units, subset;
                if (units) {
                    if ((item.change && (subset = item.change.subset)) || item.delete) {
                        let entry = units[site] || (units[site] = {});
                        if (item.delete) {
                            entry[item.delete] = 'deleted';
                        }
                        else {
                            let unit = item.change.unit;
                            item.change.pure || (item = { change: { unit: unit, pure: true, value: subset.id, subset: subset } });
                            entry[unit] = subset.id;
                        }
                    }
                    else if (item.reset) {
                        delete units[site];
                        this._sequence = Symbol();
                    }
                    else if (item.ownership) {
                        let site2;
                        if (subset = this.descriptor.partition.subsets.find(subset => subset.type === 12 /* ZoneType.outOfZone */)) {
                            for (site2 in units) {
                                if (site !== site2) {
                                    let entry = units[site2];
                                    entry[item.ownership] = subset.id;
                                }
                            }
                        }
                    }
                    else {
                        item = null;
                    }
                }
                if (item) {
                    for (let key in this._zoneEntries)
                        delete this._zoneEntries[key].affected;
                }
                return item;
            }
            isRedistricted(site) {
                let entry;
                return this._units && (entry = this._units[site]) && !!Object.keys(entry).length;
            }
            async load() {
                return this._units ? void 0 : new Promise(async (resolve) => {
                    this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve());
                    if (!this._sequence) {
                        let sym = this._sequence = Symbol(), units = {}, zoneEntries = this._zoneEntries = {}, sync = new AFC.Tools.Synchronizer(() => {
                            if (sym === this._sequence) {
                                this._units = units;
                                this._zoneEntries = zoneEntries;
                                this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                            }
                        }), h = (zone, data) => {
                            if (sym === this._sequence) {
                                data?.events?.forEach(event => {
                                    let entry = units[event.site] = {}, zoneEntry = zoneEntries[zone.id];
                                    zoneEntry.sites.push(event.site);
                                    for (let subset in event.value) {
                                        event.value[subset].forEach(code => (entry[code] = subset));
                                    }
                                });
                            }
                        }, zones = this.dashboard && await this._loadZones();
                        zones.forEach(zone => {
                            let sites;
                            if (zone.reference.partition.districtingTable) {
                                let current = zone.cluster.current, branch = this.dashboard.branch, h2 = sync.push((sequence, jqXHR, textStatus) => h(zone, jqXHR.responseJSON));
                                zone.createRequest('/districting', 1 /* DistrictType.redistricting */)[1].then(request => {
                                    let site = {
                                        site: current
                                    };
                                    zone.reference.hasCannibalization && (site.cannibalization = true);
                                    branch && (site.branch = branch);
                                    request.options.data.operation = {
                                        type: 'get',
                                        sites: [site]
                                    };
                                    request.options.always = h2;
                                    request.call();
                                });
                                sites = [];
                            }
                            else {
                                sites = [zone.cluster.current];
                            }
                            zoneEntries[zone.id] = { sites: sites };
                        });
                        sync.start();
                    }
                });
            }
            updateContext(zone, data) {
                let zoneEntry = this._units && this._zoneEntries[zone.id], affected;
                if (zoneEntry) {
                    affected = zoneEntry.affected;
                    if (!affected) {
                        zoneEntry.affected = affected = [];
                        zoneEntry.sites.forEach(site => {
                            let entry = this._units[site], subset, value;
                            for (let code in entry) {
                                subset = entry[code];
                                ((value || (value = {}))[subset] || (value[subset] = [])).push(code);
                            }
                            if (value) {
                                let zoneRedistrictData = {
                                    zone: zone.id,
                                    value: value
                                };
                                (site !== zone.cluster.current) && (zoneRedistrictData.site = site);
                                affected.push(zoneRedistrictData);
                            }
                        });
                    }
                    affected.length && (data.districting || (data.districting = [])).push(...affected);
                }
            }
        }
        function _applyValues(dataModel, site, unit, values) {
            let key = [site, unit], indice = dataModel.lowerKeyBound(key), row = dataModel.getRow(indice);
            return row && !dataModel.compareKey(row, key) ?
                dataModel.modifyAt(indice, values) :
                dataModel.createAt(indice, AFC.Data.createRowFromValues(dataModel, key, values));
        }
        async function _getTable(restModel, name) {
            let table = AFC.Tools.Data.splitSQLName(name), descriptor = await AFC.Data.getTable(restModel.schema, table.dbName, table.name);
            return descriptor?.getDefinition();
        }
        class ReaffectEditableStorage extends ReaffectStorage {
            _onRequest(sequence, data, resolve, reject) {
                sequence === this._sequence ? resolve(data && AFC.Data.updateTableData(data)) : reject();
            }
            release() {
                if (this._entry) {
                    this.dashboard.requestBuilder.discardData(this._entry.key);
                    delete this._sequence;
                    delete this._dataModel;
                    delete this._entry;
                    delete this._siteCode;
                    delete this._geographicalCode;
                    delete this._partition;
                    delete this._redistricted;
                }
            }
            _set(site) {
                (this._redistricted || (this._redistricted = {}))[site] = true;
            }
            _apply(zone, site, item) {
                let dataModel = this._dataModel;
                if (dataModel) {
                    if (item.change) {
                        let values = item.change.pure ?
                            { [dataModel.columns[this._partition].name]: item.change.subset.value } :
                            item.change.value;
                        _applyValues(dataModel, site, item.change.unit, values) ? this._set(site) : (item = null);
                    }
                    else if (item.reset) {
                        // TODO find suitable way to synchronize commit with reload when possible
                        delete this._redistricted;
                        dataModel.setValues([]);
                    }
                    else if (item.ownership) {
                        let subset = this.descriptor.partition.subsets.find(subset => subset.type === 12 /* ZoneType.outOfZone */), values = {
                            [dataModel.columns[this._partition].name]: subset.value
                        };
                        values && dataModel.values.forEach((row, indice) => row[this._siteCode] !== site && row[this._geographicalCode] === item.ownership && dataModel.modifyAt(indice, values) && this._set(row[this._siteCode]));
                    }
                    else if (item.delete) {
                        dataModel.delete_([site, item.delete]) || (item = null);
                        ;
                    }
                }
                return item;
            }
            isRedistricted(site) {
                return this._redistricted && this._redistricted[site];
            }
            async load() {
                return this._entry ? void 0 : new Promise(async (resolve) => {
                    this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve());
                    if (!this._sequence) {
                        let sym = this._sequence = Symbol(), acc = {}, zones = this.dashboard && await this._loadZones(), dataModels;
                        dataModels = await Promise.all(zones.map(zone => {
                            let current = zone.cluster.current;
                            if (!acc[current] || zone.reference.hasCannibalization) {
                                let branch = this.dashboard.branch, districtingTable = zone.reference.partition.districtingTable;
                                acc[current] = true;
                                return Promise.all([
                                    districtingTable && zone.createRequest('/districting', 1 /* DistrictType.redistricting */)[1].then(request => new Promise((resolve, reject) => {
                                        let operation = request.options.data.operation = {
                                            type: 'getData',
                                        };
                                        branch && (operation.branch = branch);
                                        zone.reference.hasCannibalization || (operation.sites = [current]);
                                        request.options.always = (sequence, jqXHR /*, textStatus: string*/) => this._onRequest(sym, jqXHR.responseJSON, resolve, reject);
                                        request.call();
                                    })),
                                    zone.createRequest('/content', 1 /* DistrictType.redistricting */)[1].then(request => new Promise((resolve, reject) => {
                                        let indicators = [];
                                        zone.reference.dataNodes.forEach(dataNode => {
                                            if (!dataNode.qualifier || dataNode.qualifier === 1 /* DataQualifier.code */ || dataNode.qualifier === 4 /* DataQualifier.partition */) {
                                                indicators.push(dataNode.id);
                                            }
                                        });
                                        request.options.data.dataSourceKind = Dashboards.dataSourceKind(zone.reference.hasCannibalization ? 6 /* DataSourceKind.cannibalization */ : 11 /* DataSourceKind.outOfZone */);
                                        request.options.data.indicators = indicators;
                                        request.options.always = (sequence, jqXHR /*, textStatus: string*/) => this._onRequest(sym, jqXHR.responseJSON?.table, resolve, reject);
                                        request.call();
                                    })),
                                    districtingTable || _getTable(zone.dashboard.descriptor.restModel, zone.reference.areaTable)
                                ]).then(([districtDataModel, zoneContentDataModel, definition]) => {
                                    let key = [zone.reference.siteCodeColumn, zone.reference.geographicalCodeColumn], dataModel, values = zoneContentDataModel.values, siteCode, index, setDataModel = (d) => {
                                        let columnIndex = d.columnIndex;
                                        dataModel = d;
                                        index = new Array(dataModel.columns.length).fill(-1);
                                        zone.reference.dataNodes.forEach(dataNode => {
                                            let i = zoneContentDataModel.columns.findIndex(column => column.dataId === dataNode.id);
                                            if (i !== -1) {
                                                switch (dataNode.qualifier) {
                                                    case 1 /* DataQualifier.code */:
                                                        index[columnIndex[zone.reference.geographicalCodeColumn]] = i;
                                                        break;
                                                    case 4 /* DataQualifier.partition */:
                                                        index[columnIndex[zone.reference.partitionColumn]] = i;
                                                        break;
                                                    case void 0:
                                                        index[columnIndex[dataNode.name]] = i;
                                                        break;
                                                }
                                            }
                                        });
                                        siteCode = columnIndex[zone.reference.siteCodeColumn];
                                    }, createRow = (row) => index.map((i, j) => i === -1 ? (j === siteCode ? current : null) : row[i]);
                                    if (districtDataModel) {
                                        setDataModel(new AFC.Data.DataModel(districtDataModel.columns, key, districtDataModel.values));
                                        let localKey = [current], geographicalCodeColumn = index[dataModel.columnIndex[zone.reference.geographicalCodeColumn]];
                                        dataModel.values.forEach(row => this._set(row[siteCode]));
                                        values.forEach(row => {
                                            localKey[1] = row[geographicalCodeColumn];
                                            let indice = dataModel.lowerKeyBound(localKey), row0 = dataModel.values[indice];
                                            (!row0 || dataModel.compareKey(row0, localKey)) && dataModel.createAt(indice, createRow(row));
                                        });
                                    }
                                    else {
                                        setDataModel(new AFC.Data.DataModel(definition.columns, key));
                                        dataModel.setValues(values.map(createRow), true);
                                    }
                                    return dataModel;
                                });
                            }
                        }));
                        if (dataModels) {
                            let dataModel = dataModels.reduce((acc, dataModel) => AFC.Tools.Data.mergeTables(acc, dataModel)), dataNode, partitionColumn, siteCodeColumn, geographicalCodeColumn;
                            if (dataModel) {
                                dataNode = this.descriptor.dataNodes.find(dataNode => dataNode.qualifier === 4 /* DataQualifier.partition */);
                                partitionColumn = dataNode ? dataModel.columnIndex[dataNode.name] : void 0;
                                siteCodeColumn = partitionColumn !== void 0 && dataModel.columnIndex[this.descriptor.siteCodeColumn];
                                geographicalCodeColumn = siteCodeColumn !== void 0 && dataModel.columnIndex[this.descriptor.geographicalCodeColumn];
                                if (geographicalCodeColumn !== void 0) {
                                    this._dataModel = dataModel;
                                    this._entry = this.dashboard.requestBuilder.createData(dataModel, true);
                                    this._siteCode = siteCodeColumn;
                                    this._geographicalCode = geographicalCodeColumn;
                                    this._partition = partitionColumn;
                                }
                            }
                        }
                        this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                    }
                });
            }
            updateContext(zone, data) {
                let resource = this._entry;
                if (resource) {
                    resource.show = true;
                    return resource.key;
                }
            }
        }
        class ReaffectStorages extends AFC.Tools.EventSink {
            constructor(dashboard) {
                super();
                this._index = {};
                this.dashboard = dashboard;
            }
            async load() {
                return this._storages || new Promise(async (resolve) => {
                    this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this._storages));
                    if (!this._loaded) {
                        let storages;
                        this._loaded = Symbol();
                        storages = await Promise.all(this.dashboard.zones.map(zone => zone.getReaffectStorage()));
                        await Promise.all(storages.reduce((acc, reaffectStorage) => {
                            if (reaffectStorage && !acc[reaffectStorage.id]) {
                                acc.push(acc[reaffectStorage.id] = reaffectStorage.load());
                            }
                            return acc;
                        }, []));
                        this._storages = storages;
                        this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                    }
                });
            }
            createStorage(descriptor, districtingMode, zones) {
                if (descriptor.partition) {
                    let reaffectStorage = districtingMode === 3 /* ZoneReaffectStorage.editable */ && descriptor.type === 4 /* ZoneType.predefined */ ?
                        new ReaffectEditableStorage(this, descriptor, zones) :
                        new ReaffectInlineStorage(this, descriptor, zones), storages = this._storages;
                    storages && zones && zones.forEach(zone => storages[this.dashboard.zones.indexOf(zone)] = reaffectStorage);
                    return reaffectStorage;
                }
            }
            get(descriptor) {
                let reaffectStorage, partition = descriptor.partition, districtingTable;
                if ((districtingTable = partition?.districtingTable) && partition.districtingMode !== 0 /* ZoneReaffectStorage.none */) {
                    reaffectStorage = this._index[districtingTable];
                    if (!reaffectStorage) {
                        reaffectStorage = this.createStorage(descriptor, partition.districtingMode);
                        reaffectStorage.commit = true;
                        this._index[districtingTable] = reaffectStorage;
                    }
                }
                return reaffectStorage;
            }
            invalidate(reaffectStorage) {
                if (reaffectStorage && this._index[reaffectStorage.table]) {
                    reaffectStorage.release();
                    delete this._loaded;
                    delete this._storages;
                }
            }
        }
        function reaffectStorages(dashboard) {
            return new ReaffectStorages(dashboard);
        }
        Dashboards.reaffectStorages = reaffectStorages;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 12/10/2015.
 */
///<reference path="Global.ts" />
///<reference path="Dashboard.ts" />
///<reference path="../data/Data.ts" />
///<reference path="../../helpers/Geometry.ts" />
///<reference path="../../helpers/Data.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        let DistrictType;
        (function (DistrictType) {
            DistrictType[DistrictType["base"] = 0] = "base";
            DistrictType[DistrictType["redistricting"] = 1] = "redistricting";
            DistrictType[DistrictType["full"] = 2] = "full"; // zone configuration, district parameters
        })(DistrictType = Dashboards.DistrictType || (Dashboards.DistrictType = {}));
        let EventType;
        (function (EventType) {
            EventType[EventType["descriptor"] = 65537] = "descriptor";
            EventType[EventType["district"] = 65538] = "district";
            EventType[EventType["content"] = 65539] = "content";
        })(EventType || (EventType = {}));
        function hasOutOfZone(descriptor) {
            switch (descriptor.type) {
                case 1 /* ZoneType.radius */:
                case 2 /* ZoneType.isodistance */:
                case 3 /* ZoneType.isochrone */:
                case 4 /* ZoneType.predefined */:
                    return true;
            }
        }
        function _isRedistrictable(zone) {
            switch (zone.type) {
                case 1 /* ZoneType.radius */:
                case 2 /* ZoneType.isodistance */:
                case 3 /* ZoneType.isochrone */:
                case 4 /* ZoneType.predefined */:
                case 9 /* ZoneType.bulkMail */:
                    return true;
            }
        }
        function _checkSitesTable(zone, sitesTable) {
            switch (zone.type) {
                case 1 /* ZoneType.radius */:
                case 2 /* ZoneType.isodistance */:
                case 3 /* ZoneType.isochrone */:
                case 8 /* ZoneType.surrounding */:
                case 9 /* ZoneType.bulkMail */:
                    return sitesTable;
            }
        }
        const _descriptor = Symbol(), _storage = Symbol();
        function _deleteContent(dataHolder) {
            delete dataHolder.dataModel;
            delete dataHolder.sequence;
        }
        class Zone extends AFC.Tools.EventSink {
            constructor(dashboard, reference, cluster) {
                super();
                this.dashboard = dashboard;
                this.reference = reference;
                this.cluster = cluster;
                this.sites = new Zone._Sites(this);
                this.district = new Zone.ZoneDistrict(this);
            }
            _onAlways(sequence, jqXHR, textStatus) {
                if (this[_descriptor] === sequence) {
                    let data = jqXHR.responseJSON;
                    data && (this._descriptor = Dashboards.zoneDescriptor(this.reference.dashboard, data));
                    this.fireEvent(65537 /* EventType.descriptor */);
                }
            }
            _onContentAlways(dataHolder, kind, sequence, jqXHR, textStatus) {
                let data, dataTable;
                if (dataHolder.sequence === sequence) {
                    if ((data = jqXHR.responseJSON) && (dataTable = AFC.Data.updateTableData(data.table))) {
                        dataHolder.dataModel = new AFC.Data.DataModelBase(dataTable.columns, dataTable.primaryKey, dataTable.values);
                    }
                    this.fireEvent(65539 /* EventType.content */ + kind);
                }
            }
            _checkData(kind, values) {
                let dataHolder = (this._dataHolders || (this._dataHolders = {}))[kind];
                if (values || !dataHolder) {
                    let indicators1 = [...new Set(values)].sort();
                    if (!dataHolder) {
                        this._dataHolders[kind] = dataHolder = {
                            indicators: indicators1
                        };
                    }
                    else if (values) {
                        let indicators0 = dataHolder.indicators, dirty = !indicators0;
                        if (!dirty) {
                            let i = 0, j = 0;
                            for (; i < indicators0.length; ++i) {
                                let str0 = indicators0[i], diff = -1;
                                for (; j < indicators1.length; ++j) {
                                    diff = str0.localeCompare(indicators1[j]);
                                    if (diff <= 0) {
                                        break;
                                    }
                                }
                                if (diff < 0) {
                                    indicators1.splice(j, 0, str0);
                                    dirty = true;
                                }
                                ++j;
                            }
                            dirty = dirty || (j < indicators1.length);
                        }
                        if (dirty) {
                            _deleteContent(dataHolder);
                            dataHolder.indicators = indicators1;
                        }
                    }
                }
                return dataHolder;
            }
            _isMutable() {
                switch (this.type) {
                    case 1 /* ZoneType.radius */:
                    case 2 /* ZoneType.isodistance */:
                    case 3 /* ZoneType.isochrone */:
                    case 4 /* ZoneType.predefined */:
                        return !!(this._context || this.reference.perSiteConfiguration);
                }
            }
            _resetDistrict() {
                this.dashboard.reaffectStorages.invalidate(this.district[_storage]);
                delete this.district[_storage];
                delete this[_storage];
            }
            get id() {
                return this.reference.id;
            }
            get name() {
                return this.reference.name;
            }
            get type() {
                return this._type || this.reference.type;
            }
            get perSiteConfiguration() {
                return this._context?.perSiteConfiguration || this.reference.perSiteConfiguration;
            }
            createRequest(path, districtType = 0 /* DistrictType.base */, options) {
                return this.dashboard.createRequest(`/zones/${this.id}${path || ''}`, options, districtType);
            }
            async getReaffectStorage() {
                if (_isRedistrictable(this))
                    return this.district.hasOwnProperty(_storage) ?
                        this.district[_storage] :
                        new Promise(resolve => {
                            this.notify(65538 /* EventType.district */, () => resolve(this.district[_storage]));
                            if (!this[_storage]) {
                                this[_storage] = Symbol();
                                this.getDescriptor().then((descriptor) => {
                                    this.district[_storage] = this.dashboard.reaffectStorages.get(descriptor);
                                    this.fireEvent(65538 /* EventType.district */);
                                });
                            }
                        });
            }
            updateContext(data, reaffectStorage, sitesTable) {
                let replacement = reaffectStorage && reaffectStorage.updateContext(this, data), context;
                if ((sitesTable = _checkSitesTable(this, sitesTable)) || this._context || replacement) {
                    context = $.extend({ id: this.id }, this._context);
                    replacement && (context.areaTable = replacement);
                    sitesTable && (context.sitesTable = sitesTable);
                    (AFC.Rest.RestModel.createEntry(data, 'context').zones || (data.context.zones = [])).push(context);
                }
            }
            async getDescriptor() {
                let descriptor = this._descriptor || (!this._isMutable() && this.reference);
                return descriptor || new Promise(async (resolve) => {
                    this.notify(65537 /* EventType.descriptor */, ( /*event: Tools.IEvent*/) => resolve(this._descriptor));
                    if (!this[_descriptor]) {
                        let promise = this.createRequest(), request;
                        this[_descriptor] = promise[0];
                        request = await promise[1];
                        request.options.always = this._onAlways.bind(this);
                        request.call();
                    }
                });
            }
            async getData(kind, indicators) {
                let dataHolder = this._checkData(kind, indicators);
                return dataHolder.dataModel || new Promise(async (resolve) => {
                    this.notify(65539 /* EventType.content */ + kind, ( /*event: Tools.IEvent*/) => resolve(dataHolder.dataModel));
                    if (!dataHolder.sequence) {
                        let req = this.createRequest('/content', 2 /* DistrictType.full */), results, request, data;
                        results = await Promise.all([this.getDescriptor(), req[1]]),
                            dataHolder.sequence = req[0];
                        request = results[1],
                            data = request.options.data;
                        data.dataSourceKind = Dashboards.dataSourceKind(kind);
                        dataHolder.indicators && (data.indicators = dataHolder.indicators);
                        kind === 1 /* DataSourceKind.unknown */ && hasOutOfZone(results[0]) && (data.outofZone = true);
                        request.options.always = this._onContentAlways.bind(this, dataHolder, kind);
                        request.call();
                    }
                });
            }
            configure(configuration) {
                let context = configuration && Dashboards.buildContext(this.reference, configuration);
                this._type = configuration?.type;
                if (JSON.stringify(context) !== JSON.stringify(this._context)) {
                    // district table cannot be changed yet
                    // (_getDistrictTable(<any> this.reference) !== configuration.districtTable) && this._resetDistrict();
                    context ? this._context = context : delete this._context;
                    this.invalidate();
                    this.dashboard.invalidateViews();
                }
            }
            invalidate(siteChange) {
                if (siteChange) {
                    this._resetDistrict();
                    delete this._descriptor;
                    delete this[_descriptor];
                }
                this._dataHolders && Object.values(this._dataHolders).forEach(_deleteContent);
                this.fireEvent(6 /* Tools.EventType.Dirty */);
            }
            clone(dashboard, cluster) {
                let clone = Reflect.construct(Zone, [dashboard, this.reference, cluster], this.constructor);
                this._type && (clone._type = this._type);
                this._context && (clone._context = this._context);
                this._descriptor && (clone._descriptor = this._descriptor);
                return clone;
            }
        }
        Zone.ZoneDistrict = class {
            constructor(zone) {
                this.zone = zone;
            }
            async getReaffectStorage() {
                let reaffectStorage = this[_storage];
                if (!reaffectStorage) {
                    let zone = this.zone;
                    reaffectStorage = await zone.getReaffectStorage() || (this[_storage] = this.zone.dashboard.reaffectStorages.createStorage(await this.zone.getDescriptor(), 3 /* ZoneReaffectStorage.editable */, [zone]));
                    await reaffectStorage.load();
                }
                return reaffectStorage;
            }
            get isRedistricted() {
                return this[_storage]?.isRedistricted(this.zone.cluster.current);
            }
            async affect(unit, subset) {
                let reaffectStorage = await this.getReaffectStorage();
                return reaffectStorage?.affect(this.zone.cluster.current, unit, subset);
            }
            async applyChanges(unit, values) {
                let reaffectStorage = await this.getReaffectStorage();
                return reaffectStorage?.applyChanges(this.zone.cluster.current, unit, values);
            }
            async delete(unit) {
                let reaffectStorage = await this.getReaffectStorage();
                return reaffectStorage?.delete(this.zone.cluster.current, unit);
            }
            async getOwnership(unit) {
                let reaffectStorage = await this.getReaffectStorage();
                return reaffectStorage?.getOwnership(this.zone.cluster.current, unit);
            }
            reset() {
                return this[_storage]?.reset(this.zone.cluster.current);
            }
        };
        Zone._Sites = class {
            constructor(zone) {
                this.zone = zone;
            }
            set current(value) {
                this.zone.cluster.current = value;
            }
            get current() {
                return this.zone.cluster.current;
            }
            get columns() {
                let descriptor = this.zone._descriptor || this.zone.reference;
                return descriptor.sites && descriptor.sites.columns;
            }
        };
        //---------------------------------------------------------------------------
        function zone(dashboard, reference, cluster) {
            return new Zone(dashboard, reference, cluster);
        }
        Dashboards.zone = zone;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 16/04/2019.
 */
///<reference path="Global.ts" />
var AFC;
(function (AFC) {
    var Dashboards;
    (function (Dashboards) {
        let ZoneType;
        (function (ZoneType) {
            ZoneType[ZoneType["unknown"] = 0] = "unknown";
            ZoneType[ZoneType["radius"] = 1] = "radius";
            ZoneType[ZoneType["isodistance"] = 2] = "isodistance";
            ZoneType[ZoneType["isochrone"] = 3] = "isochrone";
            ZoneType[ZoneType["predefined"] = 4] = "predefined";
            ZoneType[ZoneType["administrative"] = 5] = "administrative";
            ZoneType[ZoneType["selection"] = 6] = "selection";
            ZoneType[ZoneType["dynamicMarket"] = 7] = "dynamicMarket";
            ZoneType[ZoneType["surrounding"] = 8] = "surrounding";
            ZoneType[ZoneType["bulkMail"] = 9] = "bulkMail";
            ZoneType[ZoneType["subset"] = 10] = "subset";
            ZoneType[ZoneType["subsetUnion"] = 11] = "subsetUnion";
            ZoneType[ZoneType["outOfZone"] = 12] = "outOfZone";
        })(ZoneType = Dashboards.ZoneType || (Dashboards.ZoneType = {}));
        let ZoneTypeLookup;
        (function (ZoneTypeLookup) {
            ZoneTypeLookup[ZoneTypeLookup["asteropDashboardRadiusZone"] = 1] = "asteropDashboardRadiusZone";
            ZoneTypeLookup[ZoneTypeLookup["asteropDashboardIsodistanceZone"] = 2] = "asteropDashboardIsodistanceZone";
            ZoneTypeLookup[ZoneTypeLookup["asteropDashboardIsochroneZone"] = 3] = "asteropDashboardIsochroneZone";
            ZoneTypeLookup[ZoneTypeLookup["asteropDashboardPrefinedZone"] = 4] = "asteropDashboardPrefinedZone";
            ZoneTypeLookup[ZoneTypeLookup["asteropDashboardAdministrativeZone"] = 5] = "asteropDashboardAdministrativeZone";
            ZoneTypeLookup[ZoneTypeLookup["asteropDashboardSelectionZone"] = 6] = "asteropDashboardSelectionZone";
            ZoneTypeLookup[ZoneTypeLookup["asteropDashboardDynamicMarketZone"] = 7] = "asteropDashboardDynamicMarketZone";
            ZoneTypeLookup[ZoneTypeLookup["asteropDashboardSurroundingZone"] = 8] = "asteropDashboardSurroundingZone";
            ZoneTypeLookup[ZoneTypeLookup["asteropDashboardBulkMailZone"] = 9] = "asteropDashboardBulkMailZone";
            ZoneTypeLookup[ZoneTypeLookup["asteropDashboardSubset"] = 10] = "asteropDashboardSubset";
            ZoneTypeLookup[ZoneTypeLookup["asteropDashboardSubsetUnion"] = 11] = "asteropDashboardSubsetUnion";
            ZoneTypeLookup[ZoneTypeLookup["asteropDashboardOutOfZone"] = 12] = "asteropDashboardOutOfZone";
        })(ZoneTypeLookup || (ZoneTypeLookup = {}));
        ;
        class ZoneBaseDescriptor {
            constructor(data) {
                this.id = data.id || '';
                this.name = data.name;
                this.type = ZoneTypeLookup[data.type];
            }
        }
        class ZoneDescriptor extends ZoneBaseDescriptor {
            constructor(dashboard, data) {
                super(data);
                this.properties = data.properties;
                this.geographicalLevels = data.geographicalLevels;
                this.dashboard = dashboard;
                this.cluster = data.cluster;
                data.sites?.columns && (this.sites = {
                    columns: AFC.Data.mapDataColumns(data.sites)
                });
                this.dataNodes = data.dataNodes;
                !data.noCannibalization && (this.hasCannibalization = true);
            }
            static buildData(configuration) {
                let data = {};
                configuration.type && (data.type = ZoneTypeLookup[configuration.type]);
                configuration.geographicalLevels && (data.geographicalLevels = configuration.geographicalLevels);
                configuration.properties && (data.properties = configuration.properties);
                return data;
            }
            createRequest(path = '') {
                return this.dashboard.createRequest(`/zones/${this.id}${path}`);
            }
        }
        class RadiusAreaDescriptor extends ZoneDescriptor {
            constructor(dashboard, data) {
                super(dashboard, data);
                this.sitesTable = data.sitesTable;
                this.bounds = data.bounds;
                this.outOfZoneExtraBound = data.outOfZoneExtraBound;
                this.unit = AFC.TradeArea.lengthUnit(data.unit);
                this.useCentroid = !!data.useCentroid;
                this.forceSurroundingToZero = !!data.forceSurroundingToZero;
                data.perSiteConfiguration && (this.perSiteConfiguration = data.perSiteConfiguration);
                data.partition && (this.partition = new ZonePartition(data.partition));
            }
            static buildData(configuration) {
                let data = ZoneDescriptor.buildData(configuration);
                configuration.sitesTable && (data.sitesTable = configuration.sitesTable);
                configuration.bounds && (data.bounds = configuration.bounds);
                (configuration.outOfZoneExtraBound !== void 0) && (data.outOfZoneExtraBound = configuration.outOfZoneExtraBound);
                (configuration.unit !== void 0) && (data.unit = AFC.TradeArea.lengthUnit(configuration.unit));
                (configuration.useCentroid !== void 0) && (data.useCentroid = configuration.useCentroid);
                (configuration.forceSurroundingToZero !== void 0) && (data.forceSurroundingToZero = configuration.forceSurroundingToZero);
                configuration.perSiteConfiguration && (data.perSiteConfiguration = configuration.perSiteConfiguration);
                return data;
            }
        }
        //---------------------------------------------------------------------------
        class TravelTimeAreaDescriptor extends ZoneDescriptor {
            constructor(dashboard, data) {
                super(dashboard, data);
                this.sitesTable = data.sitesTable;
                this.bounds = data.bounds;
                this.outOfZoneExtraBound = data.outOfZoneExtraBound;
                this.modeOfTransport = AFC.TradeArea.modeOfTransport(data.modeOfTransport);
                this.anchorThreshold = data.anchorThreshold;
                this.mode = (data.mode !== void 0) ? AFC.TradeArea.travelMode(data.mode) : 1 /* TradeArea.TravelMode.boundary */;
                this.tollFreeOnly = !!data.tollFreeOnly;
                this.reverseMode = !!data.reverseMode;
                this.forceSurroundingToZero = !!data.forceSurroundingToZero;
                data.perSiteConfiguration && (this.perSiteConfiguration = data.perSiteConfiguration);
                data.partition && (this.partition = new ZonePartition(data.partition));
            }
            static buildData(configuration) {
                let data = ZoneDescriptor.buildData(configuration);
                configuration.sitesTable && (data.sitesTable = configuration.sitesTable);
                configuration.bounds && (data.bounds = configuration.bounds);
                (configuration.outOfZoneExtraBound !== void 0) && (data.outOfZoneExtraBound = configuration.outOfZoneExtraBound);
                (configuration.modeOfTransport !== void 0) && (data.modeOfTransport = AFC.TradeArea.modeOfTransport(configuration.modeOfTransport));
                (configuration.anchorThreshold !== void 0) && (data.anchorThreshold = configuration.anchorThreshold);
                (configuration.mode !== void 0) && (data.mode = AFC.TradeArea.travelMode(configuration.mode));
                (configuration.tollFreeOnly !== void 0) && (data.tollFreeOnly = configuration.tollFreeOnly);
                (configuration.reverseMode !== void 0) && (data.reverseMode = configuration.reverseMode);
                (configuration.forceSurroundingToZero !== void 0) && (data.forceSurroundingToZero = configuration.forceSurroundingToZero);
                configuration.perSiteConfiguration && (data.perSiteConfiguration = configuration.perSiteConfiguration);
                return data;
            }
        }
        //---------------------------------------------------------------------------
        class IsodistanceAreaDescriptor extends TravelTimeAreaDescriptor {
            constructor(dashboard, data) {
                super(dashboard, data);
                this.unit = AFC.TradeArea.lengthUnit(data.unit);
            }
            static buildData(configuration) {
                let data = TravelTimeAreaDescriptor.buildData(configuration);
                (configuration.unit !== void 0) && (data.unit = AFC.TradeArea.lengthUnit(configuration.unit));
                return data;
            }
        }
        //---------------------------------------------------------------------------
        class IsochroneAreaDescriptor extends TravelTimeAreaDescriptor {
            constructor(dashboard, data) {
                super(dashboard, data);
                this.unit = AFC.TradeArea.timeUnit(data.unit);
            }
            static buildData(configuration) {
                let data = TravelTimeAreaDescriptor.buildData(configuration);
                (configuration.unit !== void 0) && (data.unit = AFC.TradeArea.timeUnit(configuration.unit));
                return data;
            }
        }
        //---------------------------------------------------------------------------
        class PrefinedAreaDescriptor extends ZoneDescriptor {
            constructor(dashboard, data) {
                super(dashboard, data);
                this.sitesTable = data.sitesTable;
                this.areaTable = data.areaTable;
                this.siteCodeColumn = data.siteCodeColumn;
                this.geographicalCodeColumn = data.geographicalCodeColumn;
                this.partitionColumn = data.partitionColumn;
                data.partition && (this.partition = new ZonePartition(data.partition));
            }
            static buildData(configuration) {
                let data = ZoneDescriptor.buildData(configuration);
                configuration.sitesTable && (data.sitesTable = configuration.sitesTable);
                configuration.areaTable && (data.areaTable = configuration.areaTable);
                configuration.siteCodeColumn && (data.siteCodeColumn = configuration.siteCodeColumn);
                configuration.geographicalCodeColumn && (data.geographicalCodeColumn = configuration.geographicalCodeColumn);
                configuration.partitionColumn && (data.partitionColumn = configuration.partitionColumn);
                return data;
            }
        }
        //---------------------------------------------------------------------------
        class AdministrativeAreaDescriptor extends ZoneDescriptor {
        }
        //---------------------------------------------------------------------------
        class SurroundingAreaDescriptor extends ZoneDescriptor {
            constructor(dashboard, data) {
                super(dashboard, data);
                this.sitesTable = data.sitesTable;
            }
            static buildData(configuration) {
                let data = ZoneDescriptor.buildData(configuration);
                configuration.sitesTable && (data.sitesTable = configuration.sitesTable);
                return data;
            }
        }
        //---------------------------------------------------------------------------
        class BulkMailAreaDescriptor extends ZoneDescriptor {
            constructor(dashboard, data) {
                super(dashboard, data);
                this.sitesTable = data.sitesTable;
                data.partition && (this.partition = new ZonePartition(data.partition));
                this.scores = data.scores;
                this.target = data.target;
            }
            static buildData(configuration) {
                let data = ZoneDescriptor.buildData(configuration);
                configuration.sitesTable && (data.sitesTable = configuration.sitesTable);
                configuration.scores && (data.scores = configuration.scores);
                configuration.target && (data.target = configuration.target);
                return data;
            }
        }
        //---------------------------------------------------------------------------
        class SubsetDescriptor extends ZoneBaseDescriptor {
            constructor(data) {
                super(data);
                this.value = data.value;
            }
        }
        //---------------------------------------------------------------------------
        const _reaffectStorageLookup = {
            none: 0 /* ZoneReaffectStorage.none */,
            incremental: 1 /* ZoneReaffectStorage.incremental */,
            complete: 2 /* ZoneReaffectStorage.complete */,
            editable: 3 /* ZoneReaffectStorage.editable */
        };
        class ZonePartition {
            constructor(data) {
                this.id = data.id;
                this.name = data.name;
                this.districtingTable = data.districtingTable;
                this.districtingMode = _reaffectStorageLookup[data.districtingMode] || (data.districtingTable ? 1 /* ZoneReaffectStorage.incremental */ : 0 /* ZoneReaffectStorage.none */);
                this.subsets = data.subsets.map(data => new SubsetDescriptor(data));
            }
        }
        const _factory = {
            asteropDashboardRadiusZone: RadiusAreaDescriptor,
            asteropDashboardIsodistanceZone: IsodistanceAreaDescriptor,
            asteropDashboardIsochroneZone: IsochroneAreaDescriptor,
            asteropDashboardPrefinedZone: PrefinedAreaDescriptor,
            asteropDashboardAdministrativeZone: AdministrativeAreaDescriptor,
            //        asteropDashboardSelectionZone: SelectionAreaDescriptor,
            //            asteropDashboardDynamicMarketZone: DynamicMarketZoneConfiguration,
            asteropDashboardSurroundingZone: SurroundingAreaDescriptor,
            asteropDashboardBulkMailZone: BulkMailAreaDescriptor
        };
        function zoneDescriptor(dashboard, data) {
            let ctor = _factory[data.type] || ZoneDescriptor;
            return new ctor(dashboard, data);
        }
        Dashboards.zoneDescriptor = zoneDescriptor;
        //---------------------------------------------------------------------------
        const _converterFactory = {
            [1 /* ZoneType.radius */]: RadiusAreaDescriptor.buildData,
            [2 /* ZoneType.isodistance */]: IsodistanceAreaDescriptor.buildData,
            [3 /* ZoneType.isochrone */]: IsochroneAreaDescriptor.buildData,
            [4 /* ZoneType.predefined */]: PrefinedAreaDescriptor.buildData,
            [5 /* ZoneType.administrative */]: AdministrativeAreaDescriptor.buildData,
            [8 /* ZoneType.surrounding */]: SurroundingAreaDescriptor.buildData,
            [9 /* ZoneType.bulkMail */]: BulkMailAreaDescriptor.buildData
        };
        //---------------------------------------------------------------------------
        function buildContext(base, configuration) {
            let data, converter0 = _converterFactory[base.type], converter1 = _converterFactory[configuration.type || base.type];
            if (converter0 && converter1) {
                let configuration0 = Object.create(base); // ugly trick ...
                configuration0.geographicalLevels = { detailed: base.geographicalLevels.detailed.id, aggregated: base.geographicalLevels.aggregated.id }; // to handle geographical levels
                configuration0.properties = Object.entries(base.properties).reduce((acc, [key, value]) => (acc[key] = value[2], acc), {}); // and properties
                let converted0 = converter0(configuration0), converted1 = converter1(configuration);
                for (let key in converted1) {
                    if (JSON.stringify(converted1[key]) !== JSON.stringify(converted0[key])) {
                        (data || (data = {}))[key] = converted1[key];
                    }
                }
            }
            return data;
        }
        Dashboards.buildContext = buildContext;
        //---------------------------------------------------------------------------
        class ZonePartitionDescriptor {
            constructor(data) {
                this.id = data.id;
                this.name = data.name;
                this.subsets = data.subsets.map(data => new SubsetDescriptor(data));
                this.districtingTable = data.districtingTable;
            }
        }
        Dashboards.ZonePartitionDescriptor = ZonePartitionDescriptor;
    })(Dashboards = AFC.Dashboards || (AFC.Dashboards = {}));
})(AFC || (AFC = {}));
///<reference path="../../helpers/EventSink.ts" />
var AFC;
(function (AFC) {
    var Data;
    (function (Data) {
        function DataConfigGroupMixin(Base) {
            class DataConfigGroup extends Base {
                constructor() {
                    super(...arguments);
                    this._list = [];
                }
                get length() {
                    return this.values && this.values.length;
                }
                item(index) {
                    return {
                        dataItem: AFC.Tools.Data.mapRow(this.columns, this.values[index]),
                        dataItemIndex: index
                    };
                }
            }
            return DataConfigGroup;
        }
        Data.DataConfigGroupMixin = DataConfigGroupMixin;
        Data.DataConfigGroup = DataConfigGroupMixin(AFC.Tools.EventSink);
    })(Data = AFC.Data || (AFC.Data = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 17/02/2021.
 */
///<reference path="../../helpers/Tools.ts" />
var AFC;
(function (AFC) {
    var Data;
    (function (Data) {
        class DataModelView extends AFC.Tools.EventSink {
            constructor(dataModel, mapping) {
                super();
                (this.dataModel = dataModel).on && dataModel.on(6 /* Tools.EventType.Dirty */, this._onDirty, this);
                this.columns = dataModel.columns.map((column) => mapping[column.name] && column.name !== mapping[column.name] ?
                    new Data.DBColumnDefinition(mapping[column.name], column.type, column.index, column.size, column.alias, column.readOnly, column.qualifiers, column.geographicalLevel, column.isSearchable) :
                    column);
                dataModel.primaryKey && (this.primaryKey = dataModel.primaryKey.map(name => mapping[name] || name));
                this.columnIndex = Data.getColumnIndex(this.columns);
            }
            _onDirty(event) {
                this.fireEvent(6 /* Tools.EventType.Dirty */, event.data);
            }
            _mapValues(values) {
                let out = {}, name, index;
                for (name in values) {
                    (((index = this.columnIndex[name])) !== void 0) && (out[this.dataModel.columns[index].name] = values[name]);
                }
                return out;
            }
            getRow(index) {
                return this.dataModel.getRow(index);
            }
            get values() {
                return this.dataModel.values;
            }
            get length() {
                return this.dataModel.length;
            }
            item(index) {
                return this.dataModel.item && this.dataModel.item(index);
            }
            getKeyFromRow(row) {
                return this.dataModel.getKeyFromRow(row);
            }
            compareKey(row, key) {
                return this.dataModel.compareKey(row, key);
            }
            compareRow(row0, row1) {
                return this.dataModel.compareRow(row0, row1);
            }
            create(key, values) {
                return this.dataModel.create && this.dataModel.create(key, this._mapValues(values));
            }
            modify(key, values) {
                return this.dataModel.modify && this.dataModel.modify(key, this._mapValues(values));
            }
            delete_(key) {
                this.dataModel.delete_ && this.dataModel.delete_(key);
            }
            indexOf(row) {
                return this.dataModel.indexOf ? this.dataModel.indexOf(row) : -1;
            }
            find(key) {
                return this.dataModel.find ? this.dataModel.find(key) : -1;
            }
        }
        Data.DataModelView = DataModelView;
    })(Data = AFC.Data || (AFC.Data = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 10/12/2020.
 */
///<reference path="../../helpers/Tools.ts" />
///<reference path="DataSource.ts" />
///<reference path="Index.ts" />
var AFC;
(function (AFC) {
    var Data;
    (function (Data) {
        class CheckMessage {
            constructor(column, value, messageType = 0 /* CheckMessageType.error */) {
                this.column = column;
                this.message = value;
                this.type = messageType;
            }
        }
        Data.CheckMessage = CheckMessage;
        class DataRecordEventData {
            constructor(column) {
                this.columns = [column];
            }
            concat(storeEventData) {
                storeEventData.columns.forEach(column => {
                    (this.columns.indexOf(column) === -1) && this.columns.push(column);
                });
                return this;
            }
        }
        class RecordOverrides {
            constructor(columns, values) {
                this.columns = columns;
                this.reset(values);
            }
            get(indice) {
                let value = this._override[indice];
                return (value === void 0) ? this.values[indice] : value;
            }
            set(indice, value) {
                let column = this.columns[indice];
                if (column !== void 0) {
                    if (column.index !== -1)
                        console.log('Cannot modify bookmark');
                    else if (column.readOnly)
                        console.log('Cannot modify read only column');
                    else {
                        if (!AFC.Tools.Data.equalValue(column.type, value, this.get(indice))) {
                            this._override[indice] = value;
                            delete this._messages[indice];
                            delete this._states[indice];
                            if (this._sinks[indice]) {
                                delete this._sinks[indice];
                                delete this._sink;
                            }
                            return new DataRecordEventData(column);
                        }
                    }
                }
            }
            isDirty(indice) {
                return this._override.hasOwnProperty(indice);
            }
            check(container, checker, column, indice) {
                return new Promise((resolve, reject) => {
                    const dirty = this.isDirty(indice), value = dirty ? this._override[indice] : this.values[indice], event = 65536 /* Tools.EventType.UserEvent */ + indice + 1, states = this._states, messages = this._messages, sinks = this._sinks;
                    let sink = sinks[indice];
                    if (sink) {
                        states.hasOwnProperty(indice) && sink.fireEvent(event, [states[indice], messages[indice]]);
                    }
                    else {
                        const final = (valid, message) => {
                            states[indice] = valid;
                            message ? (messages[indice] = message) : delete messages[indice];
                            sink.fireEvent(event, [valid, message]);
                        };
                        sinks[indice] = sink = this._sink || (this._sink = new AFC.Tools.EventSink(this));
                        (value !== void 0) && (column.nullable || (value !== null)) && AFC.Tools.Data.isValid(column.type, value) ?
                            checker.check(container, column, dirty, value, final) :
                            final(false, new CheckMessage(column, `La valeur de la colonne [${column.alias}] est incorrecte.`));
                    }
                    sink.notify(event, (event) => {
                        const data = sink === sinks[indice] && event.data;
                        data ? resolve([column, dirty, value, data[0], data[1], indice]) : reject();
                    });
                });
            }
            reset(values) {
                delete this._sink;
                this.values = values;
                this._override = [];
                this._states = [];
                this._messages = [];
                this._sinks = [];
            }
            invalidate(columns) {
                const sinks = this._sinks;
                delete this._sink;
                columns.forEach((indice) => {
                    const column = this.columns[indice];
                    if (column.index === -1 && !column.readOnly) {
                        delete this._states[indice];
                        delete this._messages[indice];
                        delete sinks[indice];
                        this.isDirty(indice) || (this._override[indice] = this.values[indice]); // force dirty flag
                    }
                });
            }
        }
        Data.RecordOverrides = RecordOverrides;
        class DataRecord extends AFC.Tools.EventSink {
            static checkColumn(dataRecord, checker, column, callback) {
                let indice = dataRecord.dataModel.columnIndex[column];
                (indice !== void 0) && dataRecord._override.check(dataRecord, checker, dataRecord.dataModel.columns[indice], indice).then(result => callback(...result));
            }
            static check(dataRecord, checker, callback) {
                if (dataRecord._valid !== void 0) {
                    callback(dataRecord._valid, dataRecord._committable, dataRecord._messages, dataRecord._events);
                }
                else {
                    delete dataRecord._messages;
                    delete dataRecord._events;
                    Promise.all(dataRecord.dataModel.columns.map((column, indice) => dataRecord._override.check(dataRecord, checker, column, indice))).then(results => {
                        let messages, events, global = true, committable = results.every(([column, dirty, value, valid, message, indice]) => {
                            message && (messages || (messages = [])).push(message);
                            dirty && !AFC.Tools.Data.equalValue(column.type, value, dataRecord._override.values[indice]) && ((events || (events = {}))[column.name] = value);
                            global = valid && global;
                            return valid || !dirty;
                        });
                        callback(dataRecord._valid = global, dataRecord._committable = committable, messages && (dataRecord._messages = messages), events && (dataRecord._events = events));
                    });
                }
            }
            static commit(dataModel, dataContainer, checker, callback) {
                let final = (valid, committed, messages, events) => callback && callback(valid, committed, messages, events);
                /*if (dataContainer._closed) {
                    return final(false);
                }*/
                DataRecord.check(dataContainer, checker, (valid, committable, messages, events) => {
                    if (committable && events) {
                        let key = dataContainer.dataModel.getKeyFromRow(dataContainer._override.values), compare = (item) => item.committed && !dataModel.compareKey(item.row, key), h = (event) => {
                            if (event.data.reset || event.data.items.some(compare)) {
                                let row = dataModel.getRow(dataModel.find(key));
                                row && dataContainer._override.reset(row);
                                final(valid, committable, messages, events);
                            }
                            else {
                                dataModel.notify(6 /* Tools.EventType.Dirty */, h);
                            }
                        };
                        dataModel.notify(6 /* Tools.EventType.Dirty */, h);
                        /*dataContainer._created ? dataModel.create(key, events) :*/ dataModel.modify(key, events);
                    }
                    else {
                        final(valid, committable, messages);
                    }
                });
            }
            constructor(dataModel, row) {
                super();
                this.dataModel = dataModel;
                this._override = new RecordOverrides(dataModel.columns, row.slice(0));
                this._valid = true;
                dataModel.modify && (this.setData = (name, value) => {
                    let indice = this.dataModel.columnIndex[name], dataRecordEventData = this._override.set(indice, value);
                    if (dataRecordEventData) {
                        delete this._valid;
                        this.fireEvent(6 /* Tools.EventType.Dirty */, dataRecordEventData);
                        return true;
                    }
                });
            }
            getColumn(name) {
                return this.dataModel.columns[this.dataModel.columnIndex[name]];
            }
            getData(name, stringify) {
                let i = this.dataModel.columnIndex[name];
                let column = this.dataModel.columns[i];
                let value;
                if (column) {
                    value = this._override.get(i);
                    if (stringify && (column.type === 2 /* Data.DataKind.real */)) {
                        value = Math.round(value * 100) / 100;
                    }
                }
                return value;
            }
        }
        Data.DataRecord = DataRecord;
    })(Data = AFC.Data || (AFC.Data = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 04/04/2016.
 */
///<reference path="../rest/RequestBuilder.ts" />
var AFC;
(function (AFC) {
    var Data;
    (function (Data) {
        class Queries extends AFC.Rest.RequestBuilder {
            constructor(restModel, base = restModel) {
                super(base);
                this.restModel = restModel;
            }
            async createAjaxRequest(commands, format = 1 /* Rest.RestFormat.json */) {
                await this.load();
                let request = this.restModel.createAjaxRequest(`/databases/query`, false, { builder: this });
                let options = request.options;
                let data = options.data;
                format && (options.format = format);
                data.commands = commands;
                options.converter = (text) => {
                    let value = JSON.parse(text);
                    return value ? value.map(item => Data.updateTableData(item)) : [];
                };
                return request;
            }
            /** @deprecated : use getDataTable instead */
            requestData(commands, callback, context, format) {
                this.getDataTable(commands, format).then(queries => callback.call(context, queries));
            }
            getDataTable(commands, format) {
                return new Promise(async (resolve) => {
                    let request = await this.createAjaxRequest(commands.map((command) => {
                        let local;
                        if (command.hasOwnProperty('maximumRows')) {
                            local = command;
                        }
                        else {
                            local = {
                                commandText: command.commandText,
                                maximumRows: 10000
                            };
                            command.parameters && (local.parameters = command.parameters);
                        }
                        return local;
                    }));
                    request.options.always = (sequence, jqXHR, textStatus) => {
                        resolve(jqXHR.responseJSON);
                    };
                    request.call();
                });
            }
        }
        Data.Queries = Queries;
    })(Data = AFC.Data || (AFC.Data = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 04/04/2016.
 */
///<reference path="Global.ts" />
///<reference path="../rest/RestModel.ts" />
var AFC;
(function (AFC) {
    var Data;
    (function (Data) {
        class Updates extends AFC.Rest.DataCreator {
            constructor(restModel) {
                super(restModel);
                this._restModel = restModel;
            }
            run(commands, callback, force) {
                let request = this._restModel.createAjaxRequest('/databases/update', false, { builder: this, modifierOptions: { noReplacements: true } });
                let options = request.options;
                let data = options.data;
                options.always = (sequence, jqXHR, textStatus) => {
                    callback(jqXHR.responseJSON);
                };
                data.commands = commands;
                force && (data.force = force);
                return request.call();
            }
        }
        Data.Updates = Updates;
    })(Data = AFC.Data || (AFC.Data = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 19/07/2017.
 */
///<reference path="Global.ts" />
var AFC;
(function (AFC) {
    var Globals;
    (function (Globals) {
        let ChartType;
        (function (ChartType) {
            ChartType[ChartType["none"] = 0] = "none";
            ChartType[ChartType["pie"] = 1] = "pie";
            ChartType[ChartType["pie3d"] = 2] = "pie3d";
            ChartType[ChartType["points"] = 3] = "points";
            ChartType[ChartType["bar"] = 4] = "bar";
            ChartType[ChartType["stackedBar"] = 5] = "stackedBar";
            ChartType[ChartType["doughnut"] = 6] = "doughnut";
            ChartType[ChartType["doughnut3d"] = 7] = "doughnut3d";
            ChartType[ChartType["boxPlot"] = 8] = "boxPlot";
            ChartType[ChartType["bubble"] = 9] = "bubble";
            ChartType[ChartType["container"] = 10] = "container";
            ChartType[ChartType["radar"] = 11] = "radar";
            ChartType[ChartType["barHorizontal"] = 12] = "barHorizontal";
            ChartType[ChartType["stackedBarHorizontal"] = 13] = "stackedBarHorizontal";
        })(ChartType = Globals.ChartType || (Globals.ChartType = {}));
        const ChartTypeLookup = {
            none: 0 /* ChartType.none */,
            pie: 1 /* ChartType.pie */,
            pie3d: 2 /* ChartType.pie3d */,
            points: 3 /* ChartType.points */,
            bar: 4 /* ChartType.bar */,
            stackedBar: 5 /* ChartType.stackedBar */,
            doughnut: 6 /* ChartType.doughnut */,
            doughnut3d: 7 /* ChartType.doughnut3d */,
            boxPlot: 8 /* ChartType.boxPlot */,
            bubble: 9 /* ChartType.bubble */,
            container: 10 /* ChartType.container */,
            radar: 11 /* ChartType.radar */,
            barHorizontal: 12 /* ChartType.barHorizontal */,
            stackedBarHorizontal: 13 /* ChartType.stackedBarHorizontal */
        };
        function chartType(value) {
            return ChartTypeLookup[value];
        }
        Globals.chartType = chartType;
        ;
    })(Globals = AFC.Globals || (AFC.Globals = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 20/01/2021.
 */
///<reference path="Global.ts" />
var AFC;
(function (AFC) {
    var PhotoManager;
    (function (PhotoManager_1) {
        const c_Header = 'base64,';
        const c_builtInStoreCodeTagName = "CODE_MAG";
        const _sequence = Symbol();
        class Picture extends AFC.Tools.EventSink {
            constructor(restModel, imagesServer, picture) {
                super();
                this[_sequence] = 0;
                this.restModel = restModel;
                this._picture = picture;
                this._data = {};
                this._imagesServer = imagesServer;
            }
            get tags() {
                return this._picture.tags;
            }
            set tags(tags) {
                this._picture.tags = tags;
            }
            get id() {
                return this._picture.id;
            }
            get name() {
                return this._picture.name;
            }
            get title() {
                return this._picture.title;
            }
            get creationDate() {
                return this._picture.creationDate;
            }
            get album() {
                return this._picture.album;
            }
            getTagValue(name) {
                let value = "";
                for (let t = 0; t < this._picture.tags.length; t++) {
                    if (this._picture.tags[t].name.toLowerCase() == name.toLowerCase())
                        return this._picture.tags[t].value.id;
                }
                return "";
            }
            getData(pictureFormat) {
                let _this = this;
                if (pictureFormat == null || pictureFormat == "")
                    pictureFormat = "original";
                if (this._data != null && this._data[pictureFormat] != null)
                    return Promise.resolve(this._data[pictureFormat]);
                return new Promise(async (resolve) => {
                    this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this._data[pictureFormat]));
                    if (!_this[_sequence]) {
                        this._imagesServer.getServerInfo().then(serverInfo => {
                            let options = {
                                format: 17 /* AFC.Rest.RestFormat.native */,
                                data: { pictureformat: pictureFormat },
                                baseURL: ""
                            };
                            if (serverInfo && serverInfo.url && serverInfo.url !== "")
                                options.baseURL = serverInfo.url;
                            let request = this.restModel.createAjaxRequest(`/images/pictures/${this.id}`, true, options);
                            request.options.encoding = "base64";
                            request.options.always = (sequence, jqXHR, textStatus) => {
                                this._data[pictureFormat] = `data:${jqXHR.getResponseHeader("content-type")};base64,${jqXHR.responseText}`;
                                this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                            };
                            if (!_this[_sequence]) {
                                _this[_sequence] = request.call();
                            }
                        });
                    }
                });
            }
        }
        PhotoManager_1.Picture = Picture;
        class Album extends AFC.Tools.EventSink {
            constructor(restModel, imagesServer, album) {
                super();
                this.restModel = restModel;
                this._album = album;
                this._imagesServer = imagesServer;
            }
            get id() {
                return this._album ? this._album.id : "";
            }
            get name() {
                return this._album ? this._album.name : "";
            }
            get description() {
                return this._album ? this._album.description : "";
            }
            deletePicture(picture) {
                return new Promise(async (resolve) => {
                    this._imagesServer.getServerInfo().then(serverInfo => {
                        let options = null;
                        if (serverInfo && serverInfo.url && serverInfo.url !== "")
                            options = { baseURL: serverInfo.url };
                        let request = this.restModel.createAjaxRequest(`/images/albums/${this.id}`, true, options);
                        let data = request.options.data;
                        data.operation = "delete";
                        data.picture = picture.id;
                        request.options.always = (sequence, jqXHR, textStatus) => {
                            let result = jqXHR.responseJSON;
                            resolve(result.success);
                        };
                        request.call();
                    });
                });
            }
            setPictureTagsValues(picture, tags) {
                return new Promise(async (resolve) => {
                    this._imagesServer.getServerInfo().then(serverInfo => {
                        let options = null;
                        if (serverInfo && serverInfo.url && serverInfo.url !== "")
                            options = { baseURL: serverInfo.url };
                        let request = this.restModel.createAjaxRequest(`/images/albums/${this.id}`, true, options);
                        let data = request.options.data;
                        data.operation = "settags";
                        data.picture = picture.id;
                        data.tags = tags;
                        request.options.always = (sequence, jqXHR, textStatus) => {
                            let result = jqXHR.responseJSON;
                            resolve(new Picture(this.restModel, this._imagesServer, result));
                        };
                        request.call();
                    });
                });
            }
            uploadPicture(file, tags, pictureToReplace) {
                return new Promise(async (resolve) => {
                    let reader = new FileReader();
                    //await new Promise(f => setTimeout(f, 10000));
                    reader.onloadend = event => {
                        let content, index, request, data;
                        if ((event.loaded === event.total) && event.loaded && ((index = (content = reader.result).indexOf(c_Header)) !== -1)) {
                            this._imagesServer.getServerInfo().then(serverInfo => {
                                let options = null;
                                if (serverInfo && serverInfo.url && serverInfo.url !== "")
                                    options = { baseURL: serverInfo.url };
                                request = this.restModel.createAjaxRequest(`/images/albums/${this.id}`, true, options);
                                data = request.options.data;
                                data.type = "";
                                data.mimeType = file.type;
                                data.name = file.name;
                                data.size = file.size;
                                data.lastModified = new Date(file.lastModified);
                                data.content = content.substr(index + c_Header.length);
                                data.operation = pictureToReplace ? "update" : "create";
                                data.tags = tags;
                                if (pictureToReplace)
                                    data.picture = pictureToReplace.id;
                                request.options.always = (sequence, jqXHR, textStatus) => {
                                    let result = jqXHR.responseJSON;
                                    resolve(new Picture(this.restModel, this._imagesServer, result.picture));
                                };
                                request.call();
                            });
                        }
                        else {
                            resolve(null);
                        }
                    };
                    reader.readAsDataURL(file);
                });
            }
            queryPictures(tags) {
                return new Promise(async (resolve) => {
                    this._imagesServer.getServerInfo().then(serverInfo => {
                        let options = null;
                        if (serverInfo && serverInfo.url && serverInfo.url !== "")
                            options = { baseURL: serverInfo.url };
                        let request = this.restModel.createAjaxRequest('/images/pictures', true, options);
                        let data = request.options.data;
                        data.operation = "search";
                        data.tags = tags;
                        data.album = this.id;
                        request.options.always = (sequence, jqXHR, textStatus) => {
                            let result = jqXHR.responseJSON;
                            resolve(result.map(picture => new Picture(this.restModel, this._imagesServer, picture)));
                        };
                        request.call();
                    });
                });
            }
        }
        PhotoManager_1.Album = Album;
        class PhotoManager extends AFC.Tools.EventSink {
            constructor(restModel) {
                super();
                this[_sequence] = 0;
                this.restModel = restModel;
                this._imagesServer = new AFC.ServerInfo.ImagesServerInfoProvider(restModel);
            }
            get albums() {
                return this._albums ? Promise.resolve(this._albums) : new Promise(async (resolve) => {
                    this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this._albums));
                    if (!this[_sequence]) {
                        this._imagesServer.getServerInfo().then(serverInfo => {
                            let options = null;
                            if (serverInfo && serverInfo.url && serverInfo.url !== "")
                                options = { baseURL: serverInfo.url };
                            let request = this.restModel.createAjaxRequest('/images/albums', true, options);
                            request.options.always = (sequence, jqXHR, textStatus) => {
                                let data = jqXHR.responseJSON;
                                this._albums = data ? data.map(item => new Album(this.restModel, this._imagesServer, item)) : [];
                                this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                            };
                            this[_sequence] = request.call();
                        });
                    }
                });
            }
            getAlbum(albumName) {
                let _this = this;
                return new Promise(async (resolve) => {
                    _this.albums.then(albums => {
                        let filteredAlbums = albums.filter(album => {
                            return album.name.toLowerCase() == albumName.toLowerCase();
                        });
                        let album = null;
                        if (filteredAlbums && filteredAlbums.length > 0)
                            album = filteredAlbums[0];
                        resolve(album);
                    });
                });
            }
            queryPictures(albumName, tags) {
                let _this = this;
                return new Promise(async (resolve) => {
                    _this.getAlbum(albumName).then(album => {
                        if (album)
                            album.queryPictures(tags).then(pictures => { resolve(pictures); });
                        else
                            resolve([]);
                    });
                });
            }
        }
        PhotoManager_1.PhotoManager = PhotoManager;
        class StorePictures extends AFC.Tools.EventSink {
            constructor(restModel) {
                super();
                this.restModel = restModel;
                this._photoManager = new PhotoManager(restModel);
                this.reset();
            }
            set album(albumName) {
                if (this._album != albumName) {
                    this._album = albumName;
                    this.reset();
                }
            }
            get album() {
                return this._album;
            }
            get albumObject() {
                return this._photoManager.getAlbum(this.album);
            }
            set store(store) {
                let storeCode = "";
                if (store)
                    storeCode = store.identifier;
                if (!storeCode || storeCode == "") {
                    if (store.key && store.key.length == 1)
                        storeCode = store.key[0];
                }
                this.storeCode = storeCode;
            }
            set storeCode(storeCode) {
                let tagValue = storeCode.toString();
                if (this._storeCodeTagValue != tagValue) {
                    this._storeCodeTagValue = tagValue;
                    this.reset();
                }
            }
            getPictures(tags) {
                let _this = this;
                if (this._storeCodeTagValue == null || this._storeCodeTagValue == "")
                    return Promise.resolve(null);
                return new Promise(async (resolve) => {
                    if (!this._pictures) {
                        this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this._filterPictures(tags)));
                        if (!this._sequence) {
                            let sequence = Date.now();
                            this._sequence = sequence;
                            //this._photoManager.getAlbum(this.album).then(album => {
                            _this.albumObject.then(album => {
                                if (album) {
                                    album.queryPictures([{ name: c_builtInStoreCodeTagName, value: _this._storeCodeTagValue }]).then(pictures => {
                                        if (sequence == _this._sequence) {
                                            _this._pictures = pictures;
                                            this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                                        }
                                    });
                                }
                                else {
                                    if (sequence == _this._sequence) {
                                        _this._pictures = [];
                                        this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                                    }
                                }
                            });
                        }
                    }
                    else
                        resolve(this._filterPictures(tags));
                });
            }
            getPicture(pictureId) {
                let _this = this;
                return new Promise(async (resolve) => {
                    _this.getPictures([]).then(pictures => {
                        let pic = pictures.find(picture => picture.id == pictureId);
                        resolve(pic);
                    });
                });
            }
            getFirstPicture(tags) {
                let _this = this;
                return new Promise(async (resolve) => {
                    _this.getPictures(tags).then(pictures => {
                        let picture = null;
                        if (pictures && pictures.length > 0) {
                            pictures.sort(function (p1, p2) {
                                if (p1.creationDate == p2.creationDate)
                                    return 0;
                                else if (p1.creationDate > p2.creationDate)
                                    return -1;
                                return 1;
                            });
                            picture = pictures[0];
                        }
                        resolve(picture);
                    });
                });
            }
            addPicture(file, tags, pictureToDelete) {
                let _this = this;
                return new Promise(async (resolve) => {
                    this._photoManager.getAlbum(this.album).then(album => {
                        let fullTags = [...tags];
                        fullTags.push({ name: c_builtInStoreCodeTagName, value: _this._storeCodeTagValue });
                        album.uploadPicture(file, fullTags, pictureToDelete).then(picture => {
                            if (picture)
                                this._pictures.push(picture);
                            if (pictureToDelete)
                                this._pictures = this._pictures.filter(p => p.id != pictureToDelete.id);
                            resolve(picture);
                        });
                    });
                });
            }
            deletePicture(picture) {
                return new Promise(async (resolve) => {
                    this._photoManager.getAlbum(this.album).then(album => {
                        this.getPictures([]).then(pictures => {
                            album.deletePicture(picture).then(success => {
                                if (success)
                                    this._pictures = this._pictures.filter(p => p.id != picture.id);
                                resolve(success);
                            });
                        });
                    });
                });
            }
            setPictureTagsValues(picture, tags) {
                return new Promise(async (resolve) => {
                    this._photoManager.getAlbum(this.album).then(album => {
                        this.getPictures([]).then(pictures => {
                            album.setPictureTagsValues(picture, tags).then(newPicture => {
                                picture.tags = newPicture.tags;
                                resolve(picture);
                            });
                        });
                    });
                });
            }
            _filterPictures(tags) {
                if (tags && tags.length > 0) {
                    return this._pictures.filter(picture => {
                        for (let t = 0; t < tags.length; t++) {
                            if (picture.getTagValue(tags[t].name).toLowerCase() != tags[t].value.toLowerCase())
                                return false;
                        }
                        return true;
                    });
                }
                return this._pictures;
            }
            reset() {
                this._sequence = 0;
                this._pictures = null;
            }
        }
        PhotoManager_1.StorePictures = StorePictures;
    })(PhotoManager = AFC.PhotoManager || (AFC.PhotoManager = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 26/03/2018.
 */
///<reference path="Global.ts" />
///<reference path="Grid.ts" />
///<reference path="Chart.ts" />
var AFC;
(function (AFC) {
    var Globals;
    (function (Globals) {
        let ReportObjectType;
        (function (ReportObjectType) {
            ReportObjectType[ReportObjectType["text"] = 1] = "text";
            ReportObjectType[ReportObjectType["dashboardView"] = 2] = "dashboardView";
            ReportObjectType[ReportObjectType["grid"] = 3] = "grid";
            ReportObjectType[ReportObjectType["bitmap"] = 4] = "bitmap";
            ReportObjectType[ReportObjectType["line"] = 5] = "line";
            ReportObjectType[ReportObjectType["shape"] = 6] = "shape";
        })(ReportObjectType = Globals.ReportObjectType || (Globals.ReportObjectType = {}));
        let ReportObjectTypeLookup;
        (function (ReportObjectTypeLookup) {
            ReportObjectTypeLookup[ReportObjectTypeLookup["TEXT"] = 1] = "TEXT";
            ReportObjectTypeLookup[ReportObjectTypeLookup["ZM_VIEW"] = 2] = "ZM_VIEW";
            ReportObjectTypeLookup[ReportObjectTypeLookup["GRID"] = 3] = "GRID";
            ReportObjectTypeLookup[ReportObjectTypeLookup["BITMAP"] = 4] = "BITMAP";
            ReportObjectTypeLookup[ReportObjectTypeLookup["LINE"] = 5] = "LINE";
            ReportObjectTypeLookup[ReportObjectTypeLookup["SHAPE_POLYGON"] = 6] = "SHAPE_POLYGON";
        })(ReportObjectTypeLookup || (ReportObjectTypeLookup = {}));
        function reportObjectType(value) {
            return ReportObjectTypeLookup[value];
        }
        Globals.reportObjectType = reportObjectType;
        let LineStyle;
        (function (LineStyle) {
            LineStyle[LineStyle["normal"] = 0] = "normal";
            LineStyle[LineStyle["dots"] = 1] = "dots";
        })(LineStyle = Globals.LineStyle || (Globals.LineStyle = {}));
        let PointStyle;
        (function (PointStyle) {
            PointStyle[PointStyle["none"] = 0] = "none";
            PointStyle[PointStyle["arrow"] = 1] = "arrow";
            PointStyle[PointStyle["openArrow"] = 2] = "openArrow";
            PointStyle[PointStyle["bullet"] = 3] = "bullet";
            PointStyle[PointStyle["diamond"] = 4] = "diamond";
        })(PointStyle = Globals.PointStyle || (Globals.PointStyle = {}));
        let Shape;
        (function (Shape) {
            Shape[Shape["none"] = 0] = "none";
            Shape[Shape["ellipse"] = 1] = "ellipse";
            Shape[Shape["star"] = 2] = "star";
            Shape[Shape["roundedRectangle"] = 3] = "roundedRectangle";
            Shape[Shape["ring"] = 4] = "ring";
            Shape[Shape["regularPolygone"] = 5] = "regularPolygone";
            Shape[Shape["diamond"] = 6] = "diamond";
            Shape[Shape["noParking"] = 7] = "noParking";
            Shape[Shape["cross"] = 8] = "cross";
            Shape[Shape["label"] = 9] = "label";
            Shape[Shape["parenthesis"] = 10] = "parenthesis";
            Shape[Shape["rectTriangle"] = 11] = "rectTriangle";
            Shape[Shape["trapezium"] = 12] = "trapezium";
            Shape[Shape["parallelogram"] = 13] = "parallelogram";
            Shape[Shape["ribbon"] = 14] = "ribbon";
            Shape[Shape["balloon"] = 15] = "balloon";
            Shape[Shape["simpleArrow"] = 16] = "simpleArrow";
            Shape[Shape["rectangleArrow"] = 17] = "rectangleArrow";
            Shape[Shape["curvedArrow"] = 18] = "curvedArrow";
            Shape[Shape["polyArrow"] = 19] = "polyArrow";
            Shape[Shape["pipeArrow"] = 20] = "pipeArrow";
            Shape[Shape["specialSimpleArrow"] = 21] = "specialSimpleArrow";
        })(Shape = Globals.Shape || (Globals.Shape = {}));
    })(Globals = AFC.Globals || (AFC.Globals = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 17/03/2016.
 */
///<reference path="Global.ts" />
///<reference path="../rest/RestModel.ts" />
///<reference path="../../helpers/Tools.ts" />
var AFC;
(function (AFC) {
    var Globals;
    (function (Globals) {
        class Data {
            constructor(entry) {
                this.entry = entry;
            }
            toJSON() {
                return this.entry && {
                    id: this.entry.key,
                    type: 'table'
                };
            }
        }
        class Dashboard {
            constructor(dashboard, reports) {
                this.dashboard = dashboard;
                this._reports = reports;
            }
            async updateBody(data, indice) {
                let id = this._id = `d${indice}`, contexts = (AFC.Rest.RestModel.createEntry(data, 'context').dashboardCreations || (data.context.dashboardCreations = {}));
                contexts[id] = await this.dashboard.getContextDashboard();
                if (this._reports)
                    contexts[id].reports = this._reports;
                return id;
            }
            toJSON() {
                return this._id && {
                    id: `dashboardCreations:${this._id}`,
                    type: 'dashboard'
                };
            }
        }
        class BBSScript extends AFC.Tools.EventSink {
            constructor(retModel, uri, callfunction, parameters, plugin) {
                super();
                this.restModel = retModel;
                this.uri = uri;
                this.callFunction = callfunction;
                this.parameters = parameters;
                this.plugin = plugin;
                this._uid = -1;
                this._tid = null;
            }
            createDataParameter(creation) {
                return new Data((this._builder || (this._builder = new AFC.Rest.DataCreator())).createData(creation));
            }
            createDashboardParameter(dashboard, reports) {
                let parameter = new Dashboard(dashboard, reports);
                (this._dashboards || (this._dashboards = [])).push(parameter);
                return parameter;
            }
            async getRequest(options) {
                let opt = $.extend({ useProgressInfo: true, builder: this._builder }, options);
                let request = this.restModel.globals.createAjaxRequest('/scripting/run', !this._builder, opt);
                let data = request.options.data;
                this._dashboards && await Promise.all(this._dashboards.map((dashboard, indice) => dashboard.updateBody(data, indice)));
                data.uri = this.uri;
                data.plugin = this.plugin;
                this._tid = request.progressId;
                if (this.callFunction)
                    data.function = this.callFunction;
                if (this.parameters)
                    data.parameters = this.parameters;
                return Promise.resolve(request);
            }
            async run() {
                return this._result || new Promise(async (resolve, reject) => {
                    this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this._result));
                    if (this._sequenceRun === void 0) {
                        this._sequenceRun = -1;
                        let runningState = await this.getRunningState();
                        if ((runningState === 3 /* AFC.Globals.ProgressStatus.completed */)
                            || (runningState === 0 /* AFC.Globals.ProgressStatus.unknown */)
                            || (runningState === 1 /* AFC.Globals.ProgressStatus.notStarted */)) {
                            let runRequest = await this.getRequest();
                            this._sequenceRun = runRequest.sequence;
                            runRequest.options.always = (sequence, jqXHR, textStatus) => {
                                if (sequence === this._sequenceRun) {
                                    this._result = jqXHR.responseJSON;
                                    this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                                }
                            };
                            runRequest.call();
                        }
                        else {
                            delete this._sequenceRun;
                            reject();
                        }
                    }
                });
            }
            getRunningState() {
                let promise = new Promise((resolve, reject) => {
                    if (this._tid) {
                        let data;
                        let progressRequest = this.restModel.createAjaxRequest('/progress');
                        let h = (sequence, jqXHR, textStatus) => {
                            let progressData = jqXHR.responseJSON;
                            let status = 0 /* AFC.Globals.ProgressStatus.unknown */;
                            if (progressData != undefined) {
                                status = AFC.Globals.progressStatus(progressData.status);
                                this._uid = progressData.uid;
                            }
                            resolve(status);
                        };
                        data = { tid: this._tid, wait: 1000 };
                        if (this._uid >= 0)
                            data.uid = this._uid;
                        progressRequest.options.always = h;
                        progressRequest.options.data = data;
                        progressRequest.call();
                    }
                    else
                        resolve(1 /* ProgressStatus.notStarted */);
                });
                return promise;
            }
        }
        Globals.BBSScript = BBSScript;
    })(Globals = AFC.Globals || (AFC.Globals = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 20/01/2021.
 */
///<reference path="Global.ts" />
var AFC;
(function (AFC) {
    var ServerInfo;
    (function (ServerInfo) {
        const _sequence = Symbol();
        class ImagesServerInfoProvider extends AFC.Tools.EventSink {
            constructor(restModel) {
                super();
                this[_sequence] = 0;
                this.restModel = restModel;
                this._serverInfo = null;
            }
            getServerInfo() {
                return this._serverInfo !== null ? Promise.resolve(this._serverInfo) : new Promise(async (resolve) => {
                    this.notify(65536 /* Tools.EventType.UserEvent */, ( /*event: Tools.IEvent*/) => resolve(this._serverInfo));
                    if (!this[_sequence]) {
                        let request = this.restModel.createAjaxRequest(`/servers/images`, true);
                        request.options.always = (sequence, jqXHR, textStatus) => {
                            this._serverInfo = jqXHR.responseJSON;
                            this.fireEvent(65536 /* Tools.EventType.UserEvent */);
                        };
                        this[_sequence] = request.call();
                    }
                });
            }
        }
        ServerInfo.ImagesServerInfoProvider = ImagesServerInfoProvider;
    })(ServerInfo = AFC.ServerInfo || (AFC.ServerInfo = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 20/01/2021.
 */
///<reference path="Global.ts" />
var AFC;
(function (AFC) {
    var Globals;
    (function (Globals) {
        let UploadType;
        (function (UploadType) {
            UploadType[UploadType["dataDump"] = 0] = "dataDump";
        })(UploadType = Globals.UploadType || (Globals.UploadType = {}));
        const c_Header = 'base64,';
        const UploadTypeLookup = {
            [0 /* UploadType.dataDump */]: "dataDump"
        };
        class Uploader {
            constructor(restModel) {
                this.restModel = restModel;
            }
            upload(type, file, options) {
                return new Promise((resolve) => {
                    let operation = UploadTypeLookup[type], reader = new FileReader();
                    if (!operation) {
                        return resolve();
                    }
                    reader.onloadend = event => {
                        let content, index, request, data;
                        if ((event.loaded === event.total) && event.loaded && ((index = (content = reader.result).indexOf(c_Header)) !== -1)) {
                            request = this.restModel.createAjaxRequest('/globals/upload', true, { useProgressInfo: true });
                            $.extend(data = request.options.data, options);
                            data.type = operation;
                            data.mimeType = file.type;
                            data.name = file.name;
                            data.size = file.size;
                            data.lastModified = new Date(file.lastModified);
                            data.content = content.substr(index + c_Header.length);
                            request.options.always = (sequence, jqXHR, textStatus) => {
                                let result = jqXHR.responseJSON;
                                resolve(result);
                            };
                            request.call();
                        }
                        else {
                            resolve();
                        }
                    };
                    reader.readAsDataURL(file);
                });
            }
        }
        Globals.Uploader = Uploader;
    })(Globals = AFC.Globals || (AFC.Globals = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 27/07/2017.
 */
///<reference path="../../AFC.ts" />
///<reference path="../rest/RestModel.ts" />
var AFC;
(function (AFC) {
    let TradeArea;
    (function (TradeArea) {
        let LengthUnit;
        (function (LengthUnit) {
            LengthUnit[LengthUnit["meter"] = 1] = "meter";
            LengthUnit[LengthUnit["kilometer"] = 2] = "kilometer";
            LengthUnit[LengthUnit["yard"] = 3] = "yard";
            LengthUnit[LengthUnit["mile"] = 4] = "mile";
        })(LengthUnit = TradeArea.LengthUnit || (TradeArea.LengthUnit = {}));
        let LengthUnitLookup;
        (function (LengthUnitLookup) {
            LengthUnitLookup[LengthUnitLookup["meter"] = 1 /* LengthUnit.meter */] = "meter";
            LengthUnitLookup[LengthUnitLookup["kilometer"] = 2 /* LengthUnit.kilometer */] = "kilometer";
            LengthUnitLookup[LengthUnitLookup["yard"] = 3 /* LengthUnit.yard */] = "yard";
            LengthUnitLookup[LengthUnitLookup["mile"] = 4 /* LengthUnit.mile */] = "mile";
        })(LengthUnitLookup || (LengthUnitLookup = {}));
        function lengthUnit(value) {
            return LengthUnitLookup[value];
        }
        TradeArea.lengthUnit = lengthUnit;
        let TimeUnit;
        (function (TimeUnit) {
            TimeUnit[TimeUnit["minute"] = 1] = "minute";
            TimeUnit[TimeUnit["decimal"] = 2] = "decimal";
            TimeUnit[TimeUnit["second"] = 3] = "second";
        })(TimeUnit = TradeArea.TimeUnit || (TradeArea.TimeUnit = {}));
        let TimeUnitLookup;
        (function (TimeUnitLookup) {
            TimeUnitLookup[TimeUnitLookup["minute"] = 1 /* TimeUnit.minute */] = "minute";
            TimeUnitLookup[TimeUnitLookup["decimal"] = 2 /* TimeUnit.decimal */] = "decimal";
            TimeUnitLookup[TimeUnitLookup["second"] = 3 /* TimeUnit.second */] = "second";
        })(TimeUnitLookup || (TimeUnitLookup = {}));
        function timeUnit(value) {
            return TimeUnitLookup[value];
        }
        TradeArea.timeUnit = timeUnit;
        let TravelMode;
        (function (TravelMode) {
            TravelMode[TravelMode["boundary"] = 1] = "boundary";
            TravelMode[TravelMode["residentialArea"] = 2] = "residentialArea";
            TravelMode[TravelMode["centroid"] = 3] = "centroid";
        })(TravelMode = TradeArea.TravelMode || (TradeArea.TravelMode = {}));
        let ISOCHRONEMODE;
        (function (ISOCHRONEMODE) {
            ISOCHRONEMODE[ISOCHRONEMODE["ISOCHRONECOMPUTEMODE_BOUNDARY"] = 1 /* TravelMode.boundary */] = "ISOCHRONECOMPUTEMODE_BOUNDARY";
            ISOCHRONEMODE[ISOCHRONEMODE["ISOCHRONECOMPUTEMODE_RESIDENTIALAREA"] = 2 /* TravelMode.residentialArea */] = "ISOCHRONECOMPUTEMODE_RESIDENTIALAREA";
            ISOCHRONEMODE[ISOCHRONEMODE["ISOCHRONECOMPUTEMODE_CENTROID"] = 3 /* TravelMode.centroid */] = "ISOCHRONECOMPUTEMODE_CENTROID";
        })(ISOCHRONEMODE || (ISOCHRONEMODE = {}));
        function travelMode(value) {
            return ISOCHRONEMODE[value];
        }
        TradeArea.travelMode = travelMode;
        let ModeOfTransport;
        (function (ModeOfTransport) {
            ModeOfTransport[ModeOfTransport["carTravel"] = 1] = "carTravel";
            ModeOfTransport[ModeOfTransport["pedestrian"] = 2] = "pedestrian";
            ModeOfTransport[ModeOfTransport["hybrid"] = 3] = "hybrid";
        })(ModeOfTransport = TradeArea.ModeOfTransport || (TradeArea.ModeOfTransport = {}));
        let MODEOFTRANSPORT;
        (function (MODEOFTRANSPORT) {
            MODEOFTRANSPORT[MODEOFTRANSPORT["CARTRAVEL"] = 1 /* ModeOfTransport.carTravel */] = "CARTRAVEL";
            MODEOFTRANSPORT[MODEOFTRANSPORT["PEDESTRIAN"] = 2 /* ModeOfTransport.pedestrian */] = "PEDESTRIAN";
            MODEOFTRANSPORT[MODEOFTRANSPORT["HYBRID"] = 3 /* ModeOfTransport.hybrid */] = "HYBRID";
        })(MODEOFTRANSPORT || (MODEOFTRANSPORT = {}));
        function modeOfTransport(value) {
            return MODEOFTRANSPORT[value];
        }
        TradeArea.modeOfTransport = modeOfTransport;
        class Networks extends AFC.Tools.EventSink {
            constructor(restModel) {
                super();
                this._restModel = restModel;
            }
            getNetworks() {
                return new Promise(resolve => {
                    let request = this._restModel.createAjaxRequest('/tradearea/traveltime/info');
                    request.options.always = (sequence, jqXHR, textStatus) => {
                        let networks = jqXHR.responseJSON;
                        networks.forEach(network => {
                            network.modeOfTransport = modeOfTransport(network.modeOfTransport);
                        });
                        resolve(networks);
                    };
                    request.call();
                });
            }
        }
        TradeArea.Networks = Networks;
    })(TradeArea = AFC.TradeArea || (AFC.TradeArea = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 21/02/2020.
 */
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        const _activity = Symbol(), _window = Symbol(), _viewState = Symbol(), _view = Symbol(), _performSetView = Symbol(), _onDismissListener = Symbol(), _outHandle = Symbol();
        class Dialog {
            constructor(activity) {
                this.setOwnerActivity(activity);
            }
            /** @internal */
            [_performSetView]() {
                let window = this[_window], view = window && this[_view];
                if (view) {
                    $(window.getElement()).empty().append(view);
                }
            }
            _onCreate(savedInstanceState) {
            }
            _onStart() {
            }
            _onStop() {
            }
            getOwnerActivity() {
                return this[_activity];
            }
            getWindow() {
                return this[_window];
            }
            show() {
                let window, query;
                this.create();
                if ((window = this[_window]) && !(query = $(window.getElement())).is(":visible")) {
                    query.show();
                    this._onStart();
                }
            }
            hide() {
                let window = this[_window], query;
                if (window && (query = $(window.getElement())).is(":visible")) {
                    query.hide();
                    this._onStop();
                }
            }
            create() {
                let window = this[_window];
                if (!window && this[_activity]) {
                    let element = (window = this[_window] = new Controls.Window(this[_activity])).getElement();
                    $(element).hide();
                    this._onCreate();
                }
            }
            dismiss() {
                let window = this[_window];
                if (window) {
                    this.hide();
                    this[_onDismissListener] && this[_onDismissListener].onDismiss(this);
                    this[_viewState] = this.onSaveInstanceState();
                    this.setCanceledOnTouchOutside(false);
                    window.destroy();
                    delete this[_window];
                }
            }
            onSaveInstanceState() {
                let view = this[_view], savedInstanceState;
                if (view) {
                    AFC.gui.onSaveInstanceState(this[_activity], view, savedInstanceState = new AFC.Application.Bundle());
                    savedInstanceState.putValue("DIALOG_SHOWING_TAG", $(this[_window].getElement()).is(":visible"));
                }
                return savedInstanceState;
            }
            onRestoreInstanceState(savedInstanceState) {
                let view = this[_view];
                if (view) {
                    AFC.gui.onRestoreViewState(this[_activity], view, this[_activity].getSupportFragmentManager(), savedInstanceState);
                    savedInstanceState.getValue("DIALOG_SHOWING_TAG") && this.show();
                }
            }
            setContentView(view) {
                if (this[_view] !== view) {
                    this[_view] = view;
                    this[_performSetView]();
                }
            }
            setTitle(title) {
                //this._window.setTextValue('title', title);
            }
            setOwnerActivity(activity) {
                this[_activity] = activity;
            }
            setOnDismissListener(listener) {
                this[_onDismissListener] = listener;
            }
            setCanceledOnTouchOutside(cancel) {
                let body = document.body;
                if (cancel) {
                    this[_outHandle] || body.addEventListener('click', this[_outHandle] = event => this[_view]?.contains(event.target) || this.dismiss(), true);
                }
                else if (this[_outHandle]) {
                    body.removeEventListener('click', this[_outHandle], true);
                    delete this[_outHandle];
                }
            }
        }
        Controls.Dialog = Dialog;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 21/02/2020.
 */
///<reference path="Dialog.ts" /> 
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        function _setupText(dialog, element, text) {
            if (element) {
                if (text !== void 0) {
                    (text === '') || element.appendChild(document.createTextNode(text));
                    return true;
                }
                else {
                    element.parentNode.removeChild(element);
                }
            }
        }
        function _setupButton(dialog, panel, whichButton, buttons) {
            let element = panel.querySelector(`#${_buttonIds[whichButton]}`), button = buttons[whichButton];
            _setupText(dialog, element, button && button[0]) && element.addEventListener('click', () => button[1](dialog, whichButton));
        }
        const _title = Symbol(), _message = Symbol(), _buttons = Symbol(), _view = Symbol();
        class AlertDialog extends Controls.Dialog {
            _setupTitle(panel) {
                _setupText(this, panel, this[_title]);
            }
            _setupContent(panel) {
                if (panel) {
                    let view, customView, inflater;
                    if (view = this[_view]) {
                        if (AFC.Tools.Data.isString(view)) {
                            inflater = this.getOwnerActivity().getLayoutInflater();
                            customView = inflater.inflate(view, panel);
                        }
                        else {
                            customView = view;
                        }
                        customView && panel.replaceChild(customView, panel.querySelector('#custom'));
                    }
                    let element = panel.querySelector('#message');
                    _setupText(this, element, this[_message]);
                }
            }
            _setupButtons(panel) {
                if (panel) {
                    _setupButton(this, panel, AlertDialog.BUTTON_POSITIVE, this[_buttons]);
                    _setupButton(this, panel, AlertDialog.BUTTON_NEUTRAL, this[_buttons]);
                    _setupButton(this, panel, AlertDialog.BUTTON_NEGATIVE, this[_buttons]);
                }
            }
            _onCreate(savedInstanceState) {
                let template = document.querySelector(`template#AlertDialog`);
                if (template) {
                    let view = document.createElement('afc-gui-div'), topPanel, contentPanel, buttonPanel;
                    view.className = 'InflatedFragment';
                    view.appendChild(document.importNode(template.content, true));
                    topPanel = view.querySelector("#topPanel");
                    contentPanel = view.querySelector("afc-gui-div#contentPanel");
                    buttonPanel = view.querySelector("#buttonPanel");
                    super._onCreate(savedInstanceState);
                    this.setContentView(view);
                    this.setCanceledOnTouchOutside(true);
                    this._setupTitle(topPanel);
                    this._setupContent(contentPanel);
                    this._setupButtons(buttonPanel);
                }
            }
            setTitle(title) {
                this[_title] = title;
            }
            setView(view) {
                this[_view] = view;
            }
            setMessage(message) {
                this[_message] = message;
            }
            setButton(whichButton, text, listener) {
                (this[_buttons] || (this[_buttons] = {}))[whichButton] = [text, listener];
            }
        }
        AlertDialog.BUTTON_POSITIVE = -1;
        AlertDialog.BUTTON_NEUTRAL = -2;
        AlertDialog.BUTTON_NEGATIVE = -3;
        Controls.AlertDialog = AlertDialog;
        const _buttonIds = {
            [AlertDialog.BUTTON_POSITIVE]: 'positive',
            [AlertDialog.BUTTON_NEUTRAL]: 'neutral',
            [AlertDialog.BUTTON_NEGATIVE]: 'negative'
        };
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 21/10/2015.
 */
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        class Autocomplete {
            constructor(element) {
                this._container = jQuery(typeof element === 'string' ? document.getElementById(element) : element);
            }
            static _createSource(provider) {
                return function (request, response) {
                    provider(request.term, response);
                };
            }
            setProvider(provider) {
                this._autocomplete = this._container.autocomplete({ minLength: 1, source: Autocomplete._createSource(provider) });
            }
            refresh() {
                if (this._autocomplete)
                    this._container.autocomplete("search", "");
            }
            on(str, callback) {
                if (this._autocomplete)
                    this._autocomplete.on(`autocomplete${str}`, callback);
            }
            destroy() {
                if (this._autocomplete)
                    this._autocomplete.autocomplete("destroy");
                delete this._container;
                delete this._autocomplete;
            }
        }
        Controls.Autocomplete = Autocomplete;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 13/07/2017.
 */
///<reference path="../Global.ts" />
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        function _getChartTTDiv() {
            if ($("#MainChartTT").length == 0) {
                let div = document.createElement('div');
                div.id = 'MainChartTT';
                div.style.position = 'absolute';
                div.style.display = 'block';
                div.style.visibility = 'hidden';
                div.style.zIndex = '99999';
                document.body.insertBefore(div, document.body.firstChild);
            }
            return d3.select("#MainChartTT");
        }
        function _closeCurrentTT(context) {
            if (context._currentTTItem) {
                context._divTT.style("visibility", "hidden")
                    .style("left", "0px")
                    .style("top", "0px")
                    .style("width", "0px");
                if (!(context instanceof RadarRenderer))
                    d3.select(context._currentTTItem).style("stroke", "none");
                d3.select(context._currentTTItem).style("stroke-dasharray", "none");
                context._currentTTItem = null;
            }
        }
        function _showTT(context, text, elem) {
            let stamp = Date.now();
            let divTT;
            ;
            let svg;
            _closeCurrentTT(context);
            context._lastOpenTT = stamp;
            divTT = context._divTT;
            svg = context._svg;
            if (divTT) {
                divTT.html(text)
                    .style("left", $(svg.node()).offset().left + "px")
                    .style("top", $(svg.node()).offset().top - 20 + "px")
                    .style("width", $(svg.node()).width() + "px")
                    .style("visibility", "visible");
            }
            if (!(context instanceof RadarRenderer)) {
                d3.select(elem).style("stroke", "black");
                d3.select(elem).style("stroke-width", "1");
                d3.select(elem).style("stroke-dasharray", "1,1");
            }
            else
                d3.select(elem).style("stroke-dasharray", "2,2");
            context._currentTTItem = elem;
        }
        function _getChartDefaultLabelFontSize() {
            return 6;
        }
        function _getChartDefaultTickFontSize() {
            return 4;
        }
        function _breakText(label) {
            let result = _breakTextEx(label, ' ', false);
            if (result.length == 1)
                result = _breakTextEx(label, '-', true);
            return result;
        }
        function _breakTextEx(label_source, breakChar, keepBreak) {
            let label = label_source.trim();
            let result = Array(label);
            let middle = Math.floor(label.length / 2);
            let before = label.lastIndexOf(breakChar, middle);
            let after = label.indexOf(breakChar, middle);
            if (before == -1)
                middle = after;
            else if (after == -1)
                middle = before;
            else {
                let maxAfter = after;
                let maxBefore = label.length - before;
                if (maxAfter <= maxBefore)
                    middle = before;
                else
                    middle = after;
                /*
                if (middle - before < after - middle)
                    middle = before;
                else
                    middle = after;
                */
            }
            if (middle != -1) {
                result = Array(label.substr(0, middle + (keepBreak ? 1 : 0)));
                result.push(label.substr(middle + 1));
            }
            else {
                result = label.split(breakChar);
                if (keepBreak) {
                    for (var i = 0; i < result.length; i++) {
                        if (i != result.length - 1)
                            result[i] = breakChar + result[i];
                    }
                }
            }
            return result;
        }
        function _getOpacity(color) {
            return 1 - (color / 0xff000000);
        }
        function _getPieData(data, j, properties) {
            let parts = properties.parts;
            let sum = 0;
            let computed = [];
            let remainders = [];
            let aggregationPercentage = properties.pie.aggregation.active ? properties.pie.aggregation.aggregationPercentage : 0;
            let aggregated;
            let push = (datum) => {
                remainders.push(datum.index = computed.length);
                computed.push(datum);
            };
            let round = (indice, ceil) => {
                let item = computed[remainders[indice]], percent = item.percent, rounding = ceil ? Math.ceil(percent) : Math.floor(percent);
                return (item.percent = rounding) - percent;
            };
            data.forEach((d, i) => sum += data[i][j].value);
            data.forEach((d, i) => {
                let value = data[i][j].value, percent = 100 * value / sum;
                if (percent < aggregationPercentage) {
                    if (!aggregated) {
                        let label = parts[i].label;
                        aggregated = {
                            part: {
                                name: properties.pie.aggregation.name,
                                fillColor: parts[i].fillColor,
                                borderColor: parts[i].borderColor,
                                label: {
                                    showPercent: label.showPercent,
                                    font: label.font,
                                    color: 0,
                                    backgroundColor: label.backgroundColor,
                                    borderColor: label.borderColor,
                                    visible: true,
                                    align: label.align
                                }
                            },
                            value: 0
                        };
                    }
                    aggregated.value += value;
                }
                else {
                    push({
                        part: parts[i],
                        value: value,
                        percent: percent
                    });
                }
            });
            if (aggregated) {
                aggregated.percent = 100 * aggregated.value / sum;
                push(aggregated);
            }
            // Round values
            remainders.sort((i0, i1) => {
                let percent0 = computed[i0].percent, remainder0 = percent0 - Math.floor(percent0), percent1 = computed[i1].percent, remainder1 = percent1 - Math.floor(percent1);
                return remainder0 - remainder1;
            });
            for (let min = 0, max = remainders.length - 1, delta = 0; min <= max;) {
                delta += round(min++);
                while ((min <= max) && (delta !== 0)) {
                    delta += delta < 0 ? round(max--, true) : round(min++);
                }
            }
            return computed;
        }
        function _appendSVGGradientColor(svg, svgColorId, color, reverse, isHorizontal) {
            let svgGradient;
            if (color.type === 'twoColorsGradient') {
                let x1 = 0, x2 = 0, y1 = 0, y2 = 0;
                svgGradient = svg.append('linearGradient')
                    .attr('id', svgColorId);
                if (color.style == 'vertical') {
                    if (color.subStyle == 'start')
                        x2 = 100;
                    else
                        x1 = 100;
                }
                else if (color.style == 'horizontal') {
                    if (color.subStyle == 'start')
                        y1 = 100;
                    else
                        y2 = 100;
                }
                else if (color.style == 'upperDiag') {
                    x1 = 100;
                    y1 = 100;
                }
                else if (color.style == 'lowerDiag') {
                    x2 = 100;
                    y2 = 100;
                }
                else if (color.style == 'upperCorner') {
                    x2 = 100;
                    y1 = 100;
                }
                else if (color.style == 'lowerCorner') {
                    x1 = 100;
                    y2 = 100;
                }
                else if (color.style == 'center') {
                    x1 = 100;
                    y2 = 100;
                }
                svgGradient.attr('x1', x1 + '%')
                    .attr('y1', y1 + '%')
                    .attr('x2', x2 + '%')
                    .attr('y2', y2 + '%');
                svgGradient.append('stop')
                    .attr('offset', '0%')
                    .attr('stop-color', reverse ? AFC.Tools.Style.convertColor(color.color2) : AFC.Tools.Style.convertColor(color.color))
                    .attr('stop-opacity', 1);
                svgGradient.append('stop')
                    .attr('offset', '100%')
                    .attr('stop-color', reverse ? AFC.Tools.Style.convertColor(color.color) : AFC.Tools.Style.convertColor(color.color2))
                    .attr('stop-opacity', 1);
            }
        }
        class BarRenderer {
            constructor(subtitles, properties, isHorizontal, stacked) {
                this._subtitles = subtitles;
                this._properties = properties;
                this._isHorizontal = isHorizontal;
                this._nrSeries = 0;
                this._currentTTItem = null;
                this._margin = { top: 0, left: 0, bottom: 0, right: 0 };
                this._stacked = stacked;
            }
            setData(rawData, dataTransposed) {
                this._data = [];
                this._nrSeries = 0;
                this._dataTransposed = dataTransposed;
                if (!this._dataTransposed)
                    this._data = rawData;
                else {
                    let rows = rawData.length;
                    let cols = rawData[0].length;
                    this._data = [];
                    for (let j = 0; j < cols; j++) {
                        this._data[j] = Array(rows);
                    }
                    for (let i = 0; i < rows; i++) {
                        for (let j = 0; j < cols; j++) {
                            this._data[j][i] = rawData[i][j];
                        }
                    }
                }
                if (this._data.length > 0)
                    this._nrSeries = this._data[0].length;
            }
            makeSVG(element, initWidth, initHeight) {
                let _this = this;
                _this._viewPortHeight = 100;
                _this._viewPortWidth = (initHeight > 0) ? _this._viewPortHeight * (initWidth / initHeight) : _this._viewPortHeight;
                _this._svg = d3.select(element)
                    .append("svg")
                    .attr("style", "overflow:visible")
                    .attr("viewBox", "0 0 " + _this._viewPortWidth + " " + _this._viewPortHeight);
                _this._divTT = _getChartTTDiv();
                _this._addColors();
                _this._computeScales();
                this._seriesDataGroups = _this._svg.selectAll(".oneSeriesDataGroup")
                    .data(_this._data)
                    .enter()
                    .append("g")
                    .attr("class", "oneSeriesDataGroup")
                    .attr("transform", function (d, index) {
                    if (_this._isHorizontal)
                        return "translate(0," + _this._yScale(_this._getValueAxisLabel(index).id) + ")";
                    return "translate(" + _this._yScale(_this._getValueAxisLabel(index).id) + ", " + _this._originPos + ")";
                });
                _this._appendBars();
                _this._appendLinesAndSymbols();
                _this._appendAxis();
            }
            getSVG() {
                return this._svg;
            }
            _labelsPostProcess(text, width, isHeight) {
                let noDrawCount = 0;
                let minPos = 0;
                let maxPos = width * (text.nodes().length + 1);
                text.each(function (t, idx) {
                    let text = d3.select(this);
                    let textWidth = isHeight ? _getChartDefaultLabelFontSize() : text.node().getComputedTextLength() + 4;
                    let pos0 = (idx + 1) * width - textWidth / 2.0;
                    let pos1 = (idx + 1) * width + textWidth / 2.0;
                    if ((pos0 >= minPos) && (pos1 <= maxPos)) {
                        minPos = pos1;
                    }
                    else {
                        text.remove();
                    }
                });
                /*
                 let text = d3.select(this),
                    words = text.text().split(/\s+/).reverse(),
                    word,
                    line: Array<string>,
                    lineNumber = 0,
                    lineHeight = 1.1, // ems
                    y = text.attr("y"),
                    dy = parseFloat(text.attr("dy")),
                    tspan : D3Selection;

                tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
                line = new Array();
                while (word = words.pop()) {
                    line.push(word);
                    tspan.text(line.join(" "));
                    if ((<SVGTextContentElement>tspan.node()).getComputedTextLength() > width) {
                        line.pop();
                        tspan.text(line.join(" "));
                        line = [word];
                        tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                        lineNumber++;
                    }
                }
                */
            }
            _getValueAxisLabel(index) {
                let axisLabel = { id: '', name: '' };
                axisLabel.id = 'AxisLabel' + index;
                if (this._dataTransposed) {
                    if (index < this._subtitles.columnHeaders.length)
                        axisLabel.name = this._subtitles.columnHeaders[index] || '';
                }
                else {
                    if (index < this._subtitles.rowHeaders.length)
                        axisLabel.name = this._subtitles.rowHeaders[index] || '';
                }
                return axisLabel;
            }
            _getSerieLabel(index) {
                let name = '';
                if (this._dataTransposed) {
                    if (index < this._subtitles.rowHeaders.length)
                        name = this._subtitles.rowHeaders[index];
                }
                else if (this._subtitles.columnHeaders) {
                    if (index < this._subtitles.columnHeaders.length)
                        name = this._subtitles.columnHeaders[index];
                }
                return name || '';
            }
            _addColors() {
                let svgDefs = this._svg.append('defs');
                let _this = this;
                _this._seriesColor = new Array();
                _this._properties.series.forEach(function (serie, index) {
                    let serieColor = { default: '', negative: '' };
                    if (serie.bar.color.type === 'solid')
                        serieColor.default = AFC.Tools.Style.convertColor(serie.bar.color.color);
                    else if (serie.bar.color.type === 'transparent')
                        serieColor.default = 'none';
                    else {
                        let colorId = 'gradientBar' + index;
                        _appendSVGGradientColor(svgDefs, colorId, serie.bar.color, false, _this._isHorizontal);
                        serieColor.default = 'url(#' + colorId + ')';
                    }
                    if (serie.bar.negative) {
                        if (serie.bar.negative.color.type === 'solid')
                            serieColor.negative = AFC.Tools.Style.convertColor(serie.bar.negative.color.color);
                        else if (serie.bar.color.type === 'transparent')
                            serieColor.negative = 'none';
                        else {
                            let colorId = 'gradientBarNegatice' + index;
                            _appendSVGGradientColor(svgDefs, colorId, serie.bar.negative.color, true, _this._isHorizontal);
                            serieColor.negative = 'url(#' + colorId + ')';
                        }
                    }
                    _this._seriesColor.push(serieColor);
                });
            }
            _computeScales() {
                let dataExtent;
                let longestLabel;
                let minMarginForLabels = 0;
                let bottomAxisProps;
                let leftAxisProps;
                let rawOrigin;
                let _this = this;
                _this._margin.right += _getChartDefaultLabelFontSize();
                _this._margin.top += _getChartDefaultLabelFontSize();
                if (_this._isHorizontal) {
                    bottomAxisProps = _this._properties.xAxis;
                    leftAxisProps = _this._properties.yAxis[0];
                }
                else {
                    bottomAxisProps = _this._properties.yAxis[0];
                    leftAxisProps = _this._properties.xAxis;
                }
                if (bottomAxisProps.showTickers || bottomAxisProps.showLine)
                    _this._margin.bottom += _getChartDefaultLabelFontSize();
                if (bottomAxisProps.showValues && !_this._isHorizontal)
                    _this._margin.bottom += 2 * _getChartDefaultLabelFontSize();
                if (_this._properties.title.visible && _this._properties.title.text && _this._properties.title.text != '')
                    _this._margin.bottom += _getChartDefaultLabelFontSize();
                if (leftAxisProps.showTickers || leftAxisProps.showLine) {
                    _this._margin.left += _getChartDefaultLabelFontSize();
                    if (_this._isHorizontal)
                        _this._margin.bottom += _getChartDefaultLabelFontSize();
                }
                if (leftAxisProps.showValues || (_this._isHorizontal && bottomAxisProps.showValues))
                    minMarginForLabels = -1;
                longestLabel = '';
                if (_this._properties.yAxis[0].min.automatic || _this._properties.yAxis[0].max.automatic) {
                    _this._data.forEach(function (d, index) {
                        let e = d3.extent(d, function (dd) { return dd.value || 0; });
                        if (_this._stacked) {
                            let sum = d.reduce((sum, v) => sum + (v.value || 0), 0);
                            e[0] = 0;
                            e[1] = sum;
                        }
                        if (!index)
                            dataExtent = e;
                        else {
                            dataExtent[0] = d3.min([dataExtent[0], e[0]]);
                            dataExtent[1] = d3.max([dataExtent[1], e[1]]);
                        }
                    });
                }
                {
                    let order = Math.floor(Math.log(dataExtent[1] - dataExtent[0]) / Math.log(10));
                    if (dataExtent[1] == dataExtent[0])
                        order = 1;
                    let zeta = (dataExtent[1] - dataExtent[0]) / Math.pow(10.0, order);
                    let epsilon = 5;
                    if (zeta >= 1 && zeta < 2)
                        epsilon = 5;
                    else if (zeta >= 2 && zeta < 5)
                        epsilon = 2;
                    else if (zeta >= 5 && zeta < 10)
                        epsilon = 1;
                    let max = Math.ceil(epsilon * dataExtent[1] / Math.pow(10.0, order));
                    let min = Math.floor(epsilon * dataExtent[0] / Math.pow(10.0, order));
                    let tick = Math.pow(10.0, order) / epsilon;
                    dataExtent[0] = min * tick;
                    dataExtent[1] = max * tick;
                    //dataExtent[0] = Math.floor(dataExtent[0] / 10) * 10;
                    //dataExtent[1] = Math.ceil(dataExtent[1] / 10) * 10;
                }
                if (!_this._properties.yAxis[0].min.automatic)
                    dataExtent[0] = _this._properties.yAxis[0].min.value;
                if (!_this._properties.yAxis[0].max.automatic)
                    dataExtent[1] = _this._properties.yAxis[0].max.value;
                rawOrigin = dataExtent[0];
                if (!_this._properties.yAxis[0].axisIntersectPoint.automatic) {
                    rawOrigin = _this._properties.yAxis[0].axisIntersectPoint.value;
                    if (rawOrigin < dataExtent[0])
                        dataExtent[0] = rawOrigin;
                    if (rawOrigin > dataExtent[1])
                        dataExtent[1] = rawOrigin;
                }
                if (!(_this._properties.title.visible && _this._properties.title.text && _this._properties.title.text != '')) {
                    if (!_this._properties.yAxis[0].showValues && !_this._properties.yAxis[0].showTickers && !_this._properties.yAxis[0].showLine) {
                        if (!_this._properties.xAxis.showValues && !_this._properties.xAxis.showTickers && !_this._properties.xAxis.showLine) {
                            _this._margin.left = _this._margin.top = _this._margin.right = _this._margin.bottom = 0;
                        }
                    }
                }
                let expandMargin = false;
                let defaultLeftMargin = _this._margin.left;
                do {
                    _this._xScale = d3.scaleLinear()
                        .rangeRound([_this._isHorizontal ? _this._margin.left : _this._viewPortHeight - _this._margin.bottom, _this._isHorizontal ? _this._viewPortWidth - _this._margin.right : _this._margin.top])
                        .domain(d3.extent(dataExtent));
                    _this._yScale = d3.scaleBand()
                        .range([_this._isHorizontal ? _this._margin.top : _this._margin.left, _this._isHorizontal ? _this._viewPortHeight - _this._margin.bottom : _this._viewPortWidth - _this._margin.right])
                        .domain(_this._data.map(function (d, index) {
                        let label = _this._getValueAxisLabel(index).name;
                        if (label) {
                            if (longestLabel.length < label.length)
                                longestLabel = label;
                        }
                        return _this._getValueAxisLabel(index).id;
                    }))
                        .padding(_this._properties.spaceX / 100.0);
                    _this._originPos = _this._xScale(rawOrigin);
                    if (!expandMargin && (minMarginForLabels < 0)) {
                        let maxWidth = 0;
                        let extraMargin = _this._isHorizontal ? _this._originPos : 0;
                        _this._svg.append("text").text(_this._isHorizontal ? longestLabel : dataExtent[1].toString())
                            .attr("font-size", _getChartDefaultLabelFontSize())
                            .attr("font-family", leftAxisProps.font.fontFamily)
                            .each(function () { maxWidth = this.getBBox().width + 15; })
                            .remove();
                        if (Math.max(0, extraMargin) < (maxWidth + _getChartDefaultLabelFontSize())) {
                            _this._margin.left = (defaultLeftMargin + maxWidth + _getChartDefaultLabelFontSize() - extraMargin);
                            expandMargin = true;
                        }
                    }
                    else
                        expandMargin = false;
                } while (expandMargin);
            }
            _getDataCoords(d, valueIndex, serieIndex) {
                let x;
                let y;
                let dataPos;
                let valuePos;
                let oneSerieWidth = this._yScale.bandwidth() / this._nrSeries;
                valuePos = this._xScale(d[serieIndex].value || 0);
                if (this._stacked) {
                    oneSerieWidth = this._yScale.bandwidth();
                    dataPos = this._yScale(this._getValueAxisLabel(valueIndex).id) + oneSerieWidth / 2;
                }
                else
                    dataPos = this._yScale(this._getValueAxisLabel(valueIndex).id) + oneSerieWidth * serieIndex + oneSerieWidth / 2;
                x = this._isHorizontal ? valuePos : dataPos;
                y = this._isHorizontal ? dataPos : valuePos;
                return { x: x, y: y };
            }
            _appendLinesAndSymbols() {
                let _this = this;
                let seriesWithLines = new Array();
                let seriesWithSymbols = new Array();
                _this._properties.series.forEach(function (serie, serieIndex) {
                    if (serie.line.visible) {
                        seriesWithLines.push({ _serieIndex: serieIndex, _path: '', _tweenStartPath: '' });
                    }
                    if (serie.symbol.visible) {
                        seriesWithSymbols.push({ _serieIndex: serieIndex });
                    }
                });
                if (seriesWithLines.length > 0) {
                    _this._data.forEach(function (d, valueIndex) {
                        seriesWithLines.forEach(function (seriePath) {
                            let coords = _this._getDataCoords(d, valueIndex, seriePath._serieIndex);
                            let command = '';
                            if (seriePath._path == '')
                                command = 'M';
                            else
                                command = 'L';
                            seriePath._path += ' ' + command + ' ' + coords.x + ' ' + coords.y;
                            seriePath._tweenStartPath += ' ' + command + ' ' + (_this._isHorizontal ? _this._originPos : coords.x).toString() + ' ' + (_this._isHorizontal ? coords.y : _this._originPos).toString();
                        });
                        seriesWithSymbols.forEach(function (seriePath) {
                            let coords = _this._getDataCoords(d, valueIndex, seriePath._serieIndex);
                            let isNegative = (_this._xScale(d[seriePath._serieIndex].value) - _this._originPos) < 0 ? true : false;
                            let font;
                            let color;
                            let charCode;
                            if (isNegative && _this._properties.series[seriePath._serieIndex].symbol.negative) {
                                color = _this._properties.series[seriePath._serieIndex].symbol.negative.color;
                                font = _this._properties.series[seriePath._serieIndex].symbol.negative.font;
                                charCode = _this._properties.series[seriePath._serieIndex].symbol.negative.charCode;
                            }
                            else {
                                color = _this._properties.series[seriePath._serieIndex].symbol.color;
                                font = _this._properties.series[seriePath._serieIndex].symbol.font;
                                charCode = _this._properties.series[seriePath._serieIndex].symbol.charCode;
                            }
                            _this._svg.append("text")
                                .attr(_this._isHorizontal ? "y" : "x", _this._isHorizontal ? coords.y : coords.x)
                                .attr('text-anchor', "middle")
                                .attr('alignment-baseline', "middle")
                                .attr('dominant-baseline', 'middle')
                                .attr("font-family", font.fontFamily)
                                .attr('text-weight', font.fontWeight)
                                .attr('fill', AFC.Tools.Style.convertColor(color))
                                .text(String.fromCharCode(charCode.charCodeAt(0)))
                                .attr('pointer-events', 'none')
                                .attr("font-size", Math.max(7, (_this._yScale.bandwidth() / _this._nrSeries)) / 2)
                                .transition().duration(750)
                                .attrTween(_this._isHorizontal ? "x" : "y", tweenPos);
                            function tweenPos() {
                                var pos = _this._isHorizontal ? coords.x : coords.y, i = d3.interpolateString(_this._originPos, pos);
                                return function (t) { return i(t); };
                            }
                            ;
                        });
                    });
                    seriesWithLines.forEach(function (seriePath) {
                        _this._svg.append("path")
                            .attr("fill", "none")
                            .attr('pointer-events', 'none')
                            .attr("stroke", AFC.Tools.Style.convertColor(_this._properties.series[seriePath._serieIndex].line.color))
                            .attr("stroke-width", 0.5)
                            .transition().duration(750)
                            .attrTween("d", tweenPath);
                        function tweenPath() {
                            var l = this.getTotalLength(), i = d3.interpolateString(seriePath._tweenStartPath, seriePath._path);
                            return function (t) { return i(t); };
                        }
                        ;
                    });
                }
            }
            _formatTTValue(value) {
                let roundedValue = value;
                if (Math.abs(roundedValue) < 10)
                    roundedValue = Math.round(value * 100) / 100;
                else if (Math.abs(roundedValue) < 100)
                    roundedValue = Math.round(value * 10) / 10;
                else
                    roundedValue = Math.round(value);
                return roundedValue.toLocaleString();
            }
            _openTT(context, elem, datumArray, serieIndex, axisIndex) {
                let datum = datumArray[serieIndex];
                let text = '';
                let s = '';
                _closeCurrentTT(context);
                text = context._getSerieLabel(serieIndex);
                s = context._getValueAxisLabel(axisIndex).name.trim();
                if (text != '') {
                    text = '<span class="title">' + text + '&nbsp;:&nbsp;</span>';
                }
                text += '<span>';
                text += (s == '' ? 'Valeur' : s);
                text += " : ";
                text += this._formatTTValue(datum.value || 0);
                text += '</span>';
                _showTT(context, text, elem);
            }
            _appendBars() {
                let _this = this;
                let previousHeights = [];
                let interSpacePct = _this._properties.spaceX ? (_this._properties.spaceX / 100.0) : 0.0;
                _this._properties.series.forEach(function (serie, serieIndex) {
                    if (!serie.bar.visible)
                        return;
                    _this._seriesDataGroups.append("rect")
                        .attr("class", function (d) { return "serieBar serieBars" + serieIndex; })
                        .attr("fill", function (d) {
                        let datumArray = (d);
                        let datum = datumArray[serieIndex];
                        let isNegative = (_this._xScale(datum.value || 0) - _this._originPos) < 0 ? true : false;
                        let serieColor = _this._seriesColor[serieIndex];
                        if (!_this._isHorizontal)
                            isNegative = !isNegative;
                        if (isNegative && serieColor.negative !== '')
                            return serieColor.negative;
                        return serieColor.default;
                    })
                        .attr('pointer-events', 'all')
                        .attr(_this._isHorizontal ? "height" : "width", function (d) {
                        let ret;
                        if (_this._stacked)
                            ret = (1.0 - interSpacePct) * _this._yScale.bandwidth();
                        else
                            ret = (1.0 - interSpacePct) * _this._yScale.bandwidth() / _this._nrSeries;
                        return ret;
                    })
                        .on("click", function (event, datum) {
                        if (_this._currentTTItem == this)
                            _closeCurrentTT(_this);
                        else {
                            let e = _this._seriesDataGroups.nodes(), idx = e.indexOf(this.parentElement);
                            _this._openTT(_this, this, datum, serieIndex, idx);
                        }
                    })
                        .on("mouseover", function (event, datum) {
                        let e = _this._seriesDataGroups.nodes(), idx = e.indexOf(this.parentElement);
                        _this._openTT(_this, this, datum, serieIndex, idx);
                    })
                        .on("mouseout", function (d) {
                        _closeCurrentTT(_this);
                    })
                        .attr("transform", function (d, idx) {
                        let datumArray = (d);
                        let datum = datumArray[serieIndex];
                        let previousHeight = 0;
                        if (!_this._isHorizontal) {
                            let height = _this._xScale(datum.value || 0) - _this._originPos;
                            let xTransform = ((_this._yScale.bandwidth() / _this._nrSeries) * serieIndex);
                            let yTransform = height;
                            if (_this._stacked) {
                                xTransform = 0;
                                if (idx < previousHeights.length) {
                                    previousHeight = previousHeights[idx];
                                    previousHeights[idx] = previousHeight + height;
                                }
                                else {
                                    previousHeight = 0;
                                    previousHeights.push(height);
                                }
                                previousHeight = Math.abs(previousHeight);
                            }
                            yTransform = 0;
                            if (height > 0) {
                                xTransform += 0.5 * interSpacePct * _this._yScale.bandwidth();
                                return "translate(" + xTransform + "," + yTransform + ") translate(0," + previousHeight + ")";
                            }
                            if (!_this._stacked) {
                                xTransform -= 0.5 * interSpacePct * _this._yScale.bandwidth();
                                xTransform += _this._yScale.bandwidth() / _this._nrSeries;
                            }
                            else {
                                xTransform += _this._yScale.bandwidth();
                                xTransform -= 0.5 * interSpacePct * _this._yScale.bandwidth();
                            }
                            return "translate(" + xTransform + ",0) rotate(180)" + " translate(0," + previousHeight + ")";
                        }
                        else {
                            let width = _this._xScale(datum.value || 0) - _this._originPos;
                            let yTransform = ((_this._yScale.bandwidth() / _this._nrSeries) * serieIndex);
                            let xTransform = _this._originPos;
                            let previousWidth = 0;
                            if (_this._stacked) {
                                yTransform = 0;
                                if (idx < previousHeights.length) {
                                    previousWidth = previousHeights[idx];
                                    previousHeights[idx] = previousWidth + width;
                                }
                                else {
                                    previousWidth = 0;
                                    previousHeights.push(width);
                                }
                                previousWidth = Math.abs(previousWidth);
                            }
                            yTransform += 0.5 * interSpacePct * _this._yScale.bandwidth();
                            if (width < 0) {
                                yTransform += (_this._yScale.bandwidth() / _this._nrSeries) - interSpacePct * _this._yScale.bandwidth();
                                return "rotate(180) translate(-" + xTransform + ",-" + yTransform + ")";
                            }
                            return "translate(" + xTransform + "," + yTransform + ")" + " translate(" + previousWidth + ", 0)";
                        }
                    })
                        .transition().duration(750)
                        .attr(_this._isHorizontal ? "width" : "height", function (d) {
                        let datumArray = (d);
                        let datum = datumArray[serieIndex];
                        let width = _this._xScale(datum.value || 0) - _this._originPos;
                        return Math.abs(width || 0);
                    });
                });
            }
            _insertSVGAxis(classAttr, axis, propAxis) {
                let axisGroup = this._svg.append('g')
                    .attr("class", classAttr)
                    .call(axis);
                if (!propAxis.showValues)
                    axisGroup.selectAll("text").remove();
                else {
                    axisGroup.selectAll("text").attr("font-size", _getChartDefaultLabelFontSize());
                    axisGroup.selectAll("text").attr("font-weight", propAxis.font.fontWeight);
                    axisGroup.selectAll("text").attr("font-family", propAxis.font.fontFamily);
                }
                if (!propAxis.showLine)
                    axisGroup.selectAll(".domain").remove();
                else
                    axisGroup.selectAll(".domain").attr("stroke-width", 0.4);
                if (!propAxis.showTickers)
                    axisGroup.selectAll(".tick line").remove();
                else
                    axisGroup.selectAll(".tick line").attr("stroke-width", 0.4);
                return axisGroup;
            }
            _appendAxis() {
                let _this = this;
                let xAxis;
                let yAxis;
                if (_this._isHorizontal) {
                    xAxis = d3.axisBottom(_this._xScale).tickSize(4).tickSizeOuter(0);
                    yAxis = d3.axisLeft(_this._yScale).tickSize(4).tickSizeOuter(0);
                }
                else {
                    xAxis = d3.axisLeft(_this._xScale).tickSize(4).tickSizeOuter(0);
                    yAxis = d3.axisBottom(_this._yScale).tickSize(4).tickSizeOuter(0);
                }
                xAxis.tickFormat(function (tickValue) { return tickValue.toLocaleString(); });
                yAxis.tickFormat(function (tickId, index) { return _this._getValueAxisLabel(index).name; });
                if (_this._isHorizontal) {
                    let xAxisGroup = _this._insertSVGAxis("x axis", xAxis, _this._properties.yAxis[0]);
                    let yAxisGroup = _this._insertSVGAxis("y axis", yAxis, _this._properties.xAxis);
                    yAxisGroup.attr("transform", "translate(" + _this._originPos + ", 0)");
                    xAxisGroup.attr("transform", "translate(0, " + (_this._viewPortHeight - _this._margin.bottom) + ")");
                    yAxisGroup.selectAll(".tick text").attr('pointer-events', 'none');
                    xAxisGroup.selectAll(".tick text").attr('pointer-events', 'none');
                    if (_this._properties.xAxis.showValues) {
                        let v0 = _this._xScale.ticks()[0], v1 = _this._xScale.ticks()[1];
                        let xTickIntervalHeight = Math.abs(_this._xScale(v1) - _this._xScale(v0));
                        xAxisGroup.selectAll(".tick text").call(_this._labelsPostProcess, xTickIntervalHeight - 1, true);
                    }
                }
                else {
                    let xAxisGroup = _this._insertSVGAxis("x axis", xAxis, _this._properties.yAxis[0]);
                    let yAxisGroup = _this._insertSVGAxis("y axis", yAxis, _this._properties.xAxis);
                    yAxisGroup.attr("transform", "translate(0, " + _this._originPos + ")");
                    xAxisGroup.attr("transform", "translate(" + _this._margin.left + " , 0)");
                    if (_this._properties.yAxis[0].showValues) {
                        let v0 = _this._xScale.ticks()[0], v1 = _this._xScale.ticks()[1];
                        let xTickIntervalHeight = Math.abs(_this._xScale(v1) - _this._xScale(v0));
                        xAxisGroup.selectAll(".tick text").call(_this._labelsPostProcess, xTickIntervalHeight, true);
                    }
                    if (_this._properties.xAxis.showValues) {
                        yAxisGroup.selectAll(".tick text").call(_this._labelsPostProcess, _this._yScale.bandwidth(), false);
                    }
                    yAxisGroup.selectAll(".tick text").attr('pointer-events', 'none');
                    xAxisGroup.selectAll(".tick text").attr('pointer-events', 'none');
                }
                if (_this._properties.title.visible && _this._properties.title.text && _this._properties.title.text != '') {
                    _this._svg.append("text")
                        .attr("font-size", _getChartDefaultLabelFontSize())
                        .attr("font-weight", _this._properties.title.font.fontWeight)
                        .attr("font-family", _this._properties.title.font.fontFamily)
                        .attr('x', _this._viewPortWidth / 2)
                        .attr('y', _this._viewPortHeight - _getChartDefaultLabelFontSize())
                        .attr('text-anchor', "middle")
                        .attr('alignment-baseline', "hanging")
                        .attr('dominant-baseline', 'hanging')
                        .attr('fill', AFC.Tools.Style.convertColor(_this._properties.title.color))
                        .text(_this._properties.title.text);
                }
            }
        }
        function _renderBar(element, subtitles, rawData, properties, isHorizontal, dataTransposed, initWidth, initHeight, stacked) {
            let barRendererData = new BarRenderer(subtitles, properties, isHorizontal, stacked);
            if (element.style) {
                element.style.overflow = "visible";
                //element.style.zIndex 	= "9999";
            }
            barRendererData.setData(rawData, dataTransposed);
            barRendererData.makeSVG(element, initWidth, initHeight);
            return barRendererData.getSVG();
        }
        function _transpose(data) {
            return data && data[0] && data[0].map((value, x) => data.map((row, y) => data[y][x]));
        }
        function _round(value, precision = 1) {
            const dec = Math.pow(10, precision);
            return Math.round(value * dec) / dec;
        }
        function _applyFont(d3, height, font, defaultFont) {
            let fontSize;
            if (font) {
                const f = defaultFont || {};
                font.fontFamily && f.fontFamily !== font.fontFamily && d3.attr("font-family", font.fontFamily);
                font.fontSize && (fontSize = font.fontSize);
                font.fontWeight && f.fontWeight !== font.fontWeight && d3.attr("font-weight", font.fontWeight);
                font.fontStyle && f.fontStyle !== font.fontStyle && d3.attr("font-style", font.fontStyle);
                font.textDecoration && f.textDecoration !== font.textDecoration && d3.attr("text-decoration", font.textDecoration);
            }
            if (font.fontSize || !defaultFont) {
                d3.attr("style", `font-size: ${font.fontSize || /*_getChartDefaultLabelFontSize()*/ 12}pt`);
            }
            return d3;
        }
        function _drawPie(selection, style, values, radius, innerRadius) {
            let arc = d3.arc()
                .innerRadius(innerRadius || 0)
                .outerRadius(radius);
            let arcs = selection
                .selectAll("g")
                .data(values)
                .enter().append("g");
            let enterClockwise = {
                startAngle: 0,
                endAngle: 0
            };
            let path = arcs.append("path")
                .each(function (d) {
                let part = d.data.part;
                this.setAttribute("fill", AFC.Tools.Style.convertColor(part.fillColor));
                if (_getOpacity(part.borderColor)) {
                    this.setAttribute("stroke-width", (radius / 50));
                    this.setAttribute("stroke", AFC.Tools.Style.convertColor(part.borderColor));
                }
                this.setAttribute("d", arc(enterClockwise));
                if (style.explode && style.explode === d.index) {
                    var centroid = arc.centroid(d);
                    centroid[0] *= 2.0 * style.radial / 100.0;
                    centroid[1] *= 2.0 * style.radial / 100.0;
                    this.setAttribute("transform", "translate(" + centroid[0] + ", " + centroid[1] + ")");
                }
                this._current = {
                    data: d.data,
                    value: d.value,
                    startAngle: enterClockwise.startAngle,
                    endAngle: enterClockwise.endAngle
                };
            }); // store the initial values                    
            path.transition() // update
                .duration(750)
                .attrTween("d", arcTween);
            function arcTween(a) {
                var i = d3.interpolate(this._current, a);
                this._current = i(0);
                return function (t) {
                    return arc(i(t));
                };
            }
            return [arc, arcs];
        }
        function _drawSubtitle(selection, style, title, height, translateY, defaultFont) {
            let ret = [height, selection], text, titleHeight;
            if (style.visible) {
                text = _applyFont(selection.append("text"), height, style.font, defaultFont)
                    .attr('text-anchor', "middle")
                    .attr('dominant-baseline', 'text-before-edge')
                    .attr('fill', AFC.Tools.Style.convertColor(style.color))
                    .text(title || '');
                titleHeight = text.node().getBBox().height;
                text.attr('y', _round(height - translateY - titleHeight));
                ret = [height - titleHeight, selection
                        .append('g')
                        .attr("transform", `translate(0, ${-titleHeight / 2})`)];
            }
            return ret;
        }
        function _renderPie(element, subtitles, data, properties, hole, width, height, dataTransposed) {
            const svg = _applyFont(d3.select(element).append("svg")
                .attr("style", "overflow:visible")
                .attr("viewBox", `0 0 ${width} ${height}`), height, properties.font);
            const borderLeft = 5, borderRight = width - 5; // TODO : implement correct label positioning
            if (element.style)
                element.style.overflow = "visible";
            const formattedData = dataTransposed ? _transpose(data) : data;
            const part0 = formattedData?.[0];
            if (part0) {
                const titleProperties = properties.title, labelProperties = properties.label;
                const showLabels = labelProperties.visible;
                const showPercent = labelProperties.showPercent;
                const stackMode = part0.length > 1; // stack mode = chart are drawn over its predecessor
                let availableHeight = height;
                let translateY = height / 2;
                if (titleProperties.visible) {
                    let titleHeight, textAnchor = 'start', x = null, y = 0;
                    if (titleProperties?.align !== 'left') {
                        if (titleProperties.align === 'center') {
                            textAnchor = 'middle';
                            x = width / 2;
                        }
                        if (titleProperties.align === 'right') {
                            textAnchor = 'end';
                            x = width;
                        }
                    }
                    const text = _applyFont(svg.append("text"), height, titleProperties.font, properties.font)
                        .attr('x', x)
                        .attr('y', y)
                        .attr('text-anchor', textAnchor)
                        .attr('dominant-baseline', 'text-before-edge')
                        .attr('fill', AFC.Tools.Style.convertColor(titleProperties.color))
                        .text(titleProperties.text);
                    titleHeight = text.node().getBBox().height;
                    availableHeight -= titleHeight;
                    if (titleProperties.placement === 'bottom') {
                        y = availableHeight;
                        text.attr('y', y);
                    }
                    translateY += _round(titleHeight / (y ? -2 : 2), 1);
                }
                const translateX = width / 2;
                const g = svg
                    .append("g")
                    .attr("transform", `translate(${width / 2}, ${translateY})`);
                const pie = d3.pie()
                    .value((d) => d.value)
                    .startAngle(((properties.pie.angle || 0) - 90) * Math.PI / 180)
                    .sort(null);
                const radius = Math.min(width, availableHeight) / 2;
                const ring = ((100 - hole) / 100) * radius;
                let draw = function (d, j) {
                    const values = pie(_getPieData(formattedData, j, properties));
                    values.forEach((d) => {
                        d.startAngle = -d.startAngle;
                        d.endAngle = -d.endAngle;
                    });
                    let selection = d3.select(this);
                    if (stackMode) {
                        let outerRadius = radius - (j * ring), innerRadius = (outerRadius - ring) * (j === (part0.length - 1) ? 1 : 0.99);
                        _drawPie(selection, properties.pie, values, outerRadius, innerRadius);
                    }
                    else if (!j) {
                        [availableHeight, selection] = _drawSubtitle(selection, properties.subtitle, subtitles?.columnHeaders[j], availableHeight, translateY, properties.font);
                        let radius = Math.min(width, availableHeight) * ((showLabels || showPercent) ? 0.5 : 0.9) / 2;
                        let [arc, arcs] = _drawPie(selection, properties.pie, values, radius, radius * hole / 100);
                        let labelRadius = radius + 10;
                        if (showLabels || showPercent) {
                            function _getTextPos(d) {
                                let c = arc.centroid(d), x = c[0], y = c[1], 
                                // pythagorean theorem for hypotenuse
                                h = Math.sqrt(x * x + y * y), bias = labelProperties.showPartColor ? 5 : 0;
                                return { x: ((x / h * labelRadius) - bias), y: ((y / h * labelRadius) - bias) };
                            }
                            arcs.append("g")
                                .attr("transform", function (d) {
                                let pos = _getTextPos(d);
                                return "translate(" + pos.x + ',' + pos.y + ")";
                            })
                                .each(function (d) {
                                let part = d.data.part;
                                let val = (d.endAngle + d.startAngle) / 2;
                                let left = ((val) < 0) && (val > -Math.PI);
                                let top = Math.abs(val) < Math.PI / 2;
                                let selection = d3.select(this);
                                if ((d.value != 0) && ((part.label.visible && part.name) || part.label.showPercent)) {
                                    let percent = (part.label.showPercent && showPercent) && `${d.data.percent} %`;
                                    let pos = _getTextPos(d);
                                    let textWidth = 0;
                                    let textHeight = 0;
                                    let text = (part.label.visible && showLabels) ? part.name + (percent ? ` (${percent})` : '') : percent;
                                    let toDraw;
                                    let font = $.extend({}, labelProperties.font, d.data.part.label.font);
                                    _applyFont(selection, height, font, properties.font)
                                        .append("text")
                                        .text(text)
                                        .each(function () {
                                        textWidth = this.getBBox().width;
                                        textHeight = this.getBBox().height;
                                    })
                                        .remove();
                                    toDraw = Array(text);
                                    if (left) {
                                        if ((pos.x + translateX - textWidth) <= borderLeft)
                                            toDraw = _breakText(text);
                                    }
                                    else {
                                        if ((pos.x + translateX + textWidth) >= borderRight)
                                            toDraw = _breakText(text);
                                    }
                                    const xOffset = top && toDraw.length > 1 && text ? -textWidth * 2 / text.length : 0; // roughly 2 characters
                                    toDraw.forEach(function (line, index) {
                                        selection.append('text')
                                            .text(line)
                                            .each(function () {
                                            this.setAttribute('fill', AFC.Tools.Style.convertColor(d.data.part.label.color));
                                            this.setAttribute('text-anchor', left ? 'end' : 'start');
                                            this.setAttribute('dominant-baseline', 'middle');
                                            if (labelProperties.showPartColor) {
                                                this.setAttribute('x', (left ? -2 : 9) + xOffset);
                                                this.setAttribute('y', (6 + textHeight * index));
                                            }
                                            else
                                                xOffset && this.setAttribute('x', xOffset);
                                            this.setAttribute('y', (textHeight * index));
                                        });
                                    });
                                }
                                if (labelProperties.showPartColor) {
                                    selection.insert('rect', function () {
                                        return left ? this.firstChild : null;
                                    })
                                        .each(function () {
                                        if (d.value != 0) {
                                            this.setAttribute('width', 7);
                                            this.setAttribute('height', 7);
                                            this.setAttribute('fill', AFC.Tools.Style.convertColor(d.data.part.fillColor));
                                            this.setAttribute('stroke', 'black');
                                            this.setAttribute('stroke-width', (radius / 50));
                                        }
                                    });
                                }
                            });
                        }
                    }
                };
                g.selectAll("g")
                    .data(part0)
                    .enter()
                    .append("g")
                    .each(draw);
            }
            return svg;
        }
        class RadarRenderer {
            constructor(subtitles, properties) {
                this._subtitles = subtitles;
                this._properties = properties;
                this._currentTTItem = null;
                this._margin = { top: 0, left: 0, bottom: 0, right: 0 };
                this._axisInfo = { width: 0,
                    originX: 0,
                    originY: 0,
                    tick: 0,
                    maxValue: 0,
                    minValue: 0
                };
            }
            _openTT(context, elem, iSerie) {
                let text = '<div class="title">' + context._properties.series[iSerie].name + '</div>';
                _showTT(context, text, elem);
            }
            setData(rawData, dataTransposed) {
                this._data = [];
                this._nrSeries = 0;
                this._dataTransposed = dataTransposed;
                if (!this._dataTransposed)
                    this._data = rawData;
                else {
                    let rows = rawData.length;
                    let cols = rawData[0].length;
                    this._data = [];
                    for (let j = 0; j < cols; j++) {
                        this._data[j] = Array(rows);
                    }
                    for (let i = 0; i < rows; i++) {
                        for (let j = 0; j < cols; j++) {
                            this._data[j][i] = rawData[i][j];
                        }
                    }
                }
                if (this._data.length > 0)
                    this._nrSeries = this._data[0].length;
            }
            _computeScales() {
                let dataExtent;
                let _this = this;
                _this._margin.left += _getChartDefaultLabelFontSize();
                _this._margin.right += _getChartDefaultLabelFontSize();
                _this._margin.top += _getChartDefaultLabelFontSize();
                _this._margin.bottom += _getChartDefaultLabelFontSize();
                if (_this._properties.axes.min.automatic || _this._properties.axes.max.automatic) {
                    _this._data.forEach(function (d, index) {
                        let e = d3.extent(d, function (dd) { return dd.value; });
                        if (!index)
                            dataExtent = e;
                        else {
                            dataExtent[0] = d3.min([dataExtent[0], e[0]]);
                            dataExtent[1] = d3.max([dataExtent[1], e[1]]);
                        }
                    });
                }
                {
                    let order = Math.floor(Math.log(dataExtent[1] - dataExtent[0]) / Math.log(10));
                    let zeta = (dataExtent[1] - dataExtent[0]) / Math.pow(10.0, order);
                    let epsilon = 5;
                    if (zeta >= 1 && zeta < 2)
                        epsilon = 5;
                    else if (zeta >= 2 && zeta < 5)
                        epsilon = 2;
                    else if (zeta >= 5 && zeta < 10)
                        epsilon = 1;
                    let max = Math.ceil(epsilon * dataExtent[1] / Math.pow(10.0, order));
                    let min = Math.floor(epsilon * dataExtent[0] / Math.pow(10.0, order));
                    let tick = Math.pow(10.0, order) / epsilon;
                    dataExtent[0] = min * tick;
                    dataExtent[1] = max * tick;
                    //dataExtent[0] = Math.floor(dataExtent[0] / 10) * 10;
                    //dataExtent[1] = Math.ceil(dataExtent[1] / 10) * 10;
                    _this._axisInfo.tick = tick;
                }
                if (!_this._properties.axes.min.automatic)
                    dataExtent[0] = _this._properties.axes.min.value;
                if (!_this._properties.axes.max.automatic)
                    dataExtent[1] = _this._properties.axes.max.value;
                //_this._axisInfo.width       = Math.min(_this._viewPortWidth / 2 - (_this._margin.right + _this._margin.left), _this._viewPortHeight / 2 - (_this._margin.bottom + _this._margin.top));
                _this._axisInfo.width = Math.min(_this._viewPortWidth / 2 - Math.max(_this._margin.right, _this._margin.left), _this._viewPortHeight / 2 - Math.max(_this._margin.bottom, _this._margin.top));
                _this._axisInfo.originX = _this._viewPortWidth / 2;
                _this._axisInfo.originY = _this._viewPortHeight / 2;
                _this._axisInfo.minValue = dataExtent[0];
                _this._axisInfo.maxValue = dataExtent[1];
                let minWidth = 3.0 * (_this._axisInfo.width / 4.0);
                _this._properties.axes.labels.forEach(function (label, index) {
                    let localLabels = _breakText(label);
                    let labelWidth = 0;
                    let textAnchor = _this._getAxisTextAnchor(index);
                    let newWidth = _this._axisInfo.width;
                    let newWidthToTest = newWidth;
                    localLabels.forEach(function (localLabel, index2) {
                        let fontTooBig = true;
                        while (fontTooBig) {
                            fontTooBig = false;
                            _this._svg.append("text").text(localLabel)
                                .attr("font-size", _this._labelFontSize)
                                .attr("font-family", _this._properties.axes.font.fontFamily)
                                .attr('text-weight', _this._properties.axes.font.fontWeight)
                                .each(function () { labelWidth = this.getBBox().width; })
                                .remove();
                            let maxValueCoords = _this._getCoords(index, _this._axisInfo.maxValue);
                            if (textAnchor == 'start') {
                                if ((maxValueCoords.x + labelWidth) >= (_this._viewPortWidth - 1)) {
                                    fontTooBig = true;
                                    newWidthToTest -= maxValueCoords.x + labelWidth - _this._viewPortWidth + 1 + 1;
                                }
                            }
                            else if (textAnchor == 'end') {
                                if ((maxValueCoords.x - labelWidth) <= 0) {
                                    fontTooBig = true;
                                    newWidthToTest -= labelWidth - maxValueCoords.x + 1;
                                }
                            }
                            if (fontTooBig) {
                                if (newWidth <= minWidth)
                                    _this._labelFontSize -= 0.1;
                                else
                                    newWidth = newWidthToTest;
                            }
                            if (_this._labelFontSize < 1)
                                fontTooBig = false;
                            _this._axisInfo.width = Math.max(minWidth, newWidth);
                        }
                    });
                });
            }
            _getAxisTextAnchor(index) {
                let angle = this._getAxisAngle(index);
                let result = 'start';
                if (angle == Math.PI / 2.0)
                    result = 'middle';
                else if (angle < 3 * (Math.PI / 2.0) && (angle > (Math.PI / 2.0)))
                    result = 'end';
                else if (angle == 3 * (Math.PI / 2.0))
                    result = 'middle';
                return result;
            }
            _getAxisTextBaseLine(index) {
                let angle = this._getAxisAngle(index);
                let result = 'start';
                if ((angle >= 0) && (angle <= Math.PI))
                    result = 'baseline';
                else
                    result = 'hanging';
                return result;
            }
            _getAxisAngle(iAxe) {
                let angle = 0;
                if (this._properties.axes.labels.length == 2) {
                    if (!iAxe)
                        angle = Math.PI / 2.0;
                    else
                        angle = 0.0;
                }
                else
                    angle = (Math.PI / 2.0) + 2 * iAxe * Math.PI / this._properties.axes.labels.length;
                return (angle % (2 * Math.PI));
            }
            _getCoords(iAxe, iValue) {
                let result = { x: 0, y: 0 };
                let angle = this._getAxisAngle(iAxe);
                let proj = ((iValue || 0) - this._axisInfo.minValue) * this._axisInfo.width / (this._axisInfo.maxValue - this._axisInfo.minValue);
                result.x = this._axisInfo.originX + proj * Math.cos(angle);
                result.y = this._axisInfo.originY - proj * Math.sin(angle);
                return result;
            }
            _appendAxis() {
                let _this = this;
                _this._properties.axes.labels.forEach(function (label, index) {
                    let axis = _this._svg.append('svg:line').attr("class", "axes");
                    let minValueCoords = _this._getCoords(index, _this._axisInfo.minValue);
                    let maxValueCoords = _this._getCoords(index, _this._axisInfo.maxValue);
                    let localLabels = Array(label);
                    let labelWidth = 0;
                    let baseLine = _this._getAxisTextBaseLine(index);
                    let textAnchor = _this._getAxisTextAnchor(index);
                    let multiLine = false;
                    axis.attr("x1", minValueCoords.x)
                        .attr("y1", minValueCoords.y)
                        .attr("x2", maxValueCoords.x)
                        .attr("y2", maxValueCoords.y)
                        .attr('pointer-events', 'none');
                    if (_this._properties.axes.showLine) {
                        axis.attr("stroke", AFC.Tools.Style.convertColor(_this._properties.axes.color))
                            .attr("stroke-width", 0.5);
                    }
                    _this._svg.append("text").text(label)
                        .attr("font-size", _this._labelFontSize)
                        .attr("font-family", _this._properties.axes.font.fontFamily)
                        .attr('text-weight', _this._properties.axes.font.fontWeight)
                        .each(function () { labelWidth = this.getBBox().width; })
                        .remove();
                    if (textAnchor == 'start') {
                        if ((maxValueCoords.x + labelWidth) > (_this._viewPortWidth - 5))
                            multiLine = true;
                    }
                    else if (textAnchor == 'end') {
                        if ((maxValueCoords.x - labelWidth) < 5)
                            multiLine = true;
                    }
                    if (multiLine)
                        localLabels = _breakText(label);
                    else
                        localLabels = Array(label);
                    localLabels.forEach(function (localLabel, index) {
                        _this._svg.append("text").text(localLabel).attr("font-size", _this._labelFontSize)
                            .attr("x", maxValueCoords.x + (textAnchor == 'start' ? 1 : 0))
                            .attr("y", maxValueCoords.y - (baseLine == 'baseline' ? 1 : 0) + (index * _this._labelFontSize))
                            .attr('pointer-events', 'none')
                            .attr('text-anchor', textAnchor)
                            .attr('alignment-baseline', baseLine)
                            .attr('dominant-baseline', baseLine)
                            .attr("font-family", _this._properties.axes.font.fontFamily)
                            .attr('text-weight', _this._properties.axes.font.fontWeight)
                            .attr('fill', AFC.Tools.Style.convertColor(_this._properties.axes.textColor));
                    });
                    if (!index && _this._properties.axes.showValues) {
                        let iTickValue = _this._axisInfo.minValue;
                        for (; iTickValue <= _this._axisInfo.maxValue; iTickValue += _this._axisInfo.tick) {
                            let coords = _this._getCoords(index, iTickValue);
                            _this._svg.append("text").text(iTickValue.toString()).attr("font-size", _getChartDefaultTickFontSize())
                                .attr("x", coords.x)
                                .attr("y", coords.y)
                                .attr('pointer-events', 'none')
                                .attr('alignment-baseline', 'hanging')
                                .attr('dominant-baseline', 'hanging')
                                .attr("font-family", _this._properties.axes.font.fontFamily)
                                .attr('text-weight', _this._properties.axes.font.fontWeight)
                                .attr('fill', AFC.Tools.Style.convertColor(_this._properties.axes.textColor));
                        }
                    }
                });
            }
            _appendGrid() {
                let _this = this;
                let iTickValue = _this._axisInfo.minValue + _this._axisInfo.tick;
                for (; iTickValue <= _this._axisInfo.maxValue; iTickValue += _this._axisInfo.tick) {
                    let i = 0;
                    let path = '';
                    for (i = 0; i < _this._properties.axes.labels.length; i++) {
                        let command = '';
                        let coords = _this._getCoords(i, iTickValue);
                        if (path == '')
                            command = 'M';
                        else
                            command = 'L';
                        path += ' ' + command + ' ' + coords.x + ' ' + coords.y;
                    }
                    let coords = _this._getCoords(0, iTickValue);
                    path += ' L ' + coords.x + ' ' + coords.y;
                    _this._svg.append("path")
                        .attr('pointer-events', 'none')
                        .attr("fill", "transparent")
                        .attr("stroke", AFC.Tools.Style.convertColor(_this._properties.axes.color))
                        .attr("stroke-width", 0.5)
                        .attr("d", path);
                }
            }
            _appendSeries() {
                let _this = this;
                let svgDefs = _this._svg.append('defs');
                let iSerie = 0;
                for (; iSerie < _this._data.length; iSerie++) {
                    let i = 0;
                    let _iSerie = iSerie;
                    let path = '';
                    let tweenStartPath = '';
                    let strokeStyle = _this._properties.series[iSerie].line.visible ? AFC.Tools.Style.convertColor(_this._properties.series[iSerie].line.color) : 'none';
                    for (i = 0; i < _this._properties.axes.labels.length; i++) {
                        let command = '';
                        let coords = _this._getCoords(i, _this._data[iSerie][i].value);
                        if (path == '')
                            command = 'M';
                        else
                            command = 'L';
                        path += ' ' + command + ' ' + coords.x + ' ' + coords.y;
                        tweenStartPath += ' ' + command + ' ' + _this._axisInfo.originX + ' ' + _this._axisInfo.originY;
                    }
                    let coords = _this._getCoords(0, _this._data[iSerie][0].value);
                    path += ' L ' + coords.x + ' ' + coords.y;
                    tweenStartPath += ' L ' + _this._axisInfo.originX + ' ' + _this._axisInfo.originY;
                    let svgPath = _this._svg.append("path").attr("d", path);
                    if (_this._properties.series[iSerie].filling.visible) {
                        let color = 'none';
                        if (_this._properties.series[iSerie].filling.color.type === 'solid')
                            color = AFC.Tools.Style.convertColor(_this._properties.series[iSerie].filling.color.color);
                        else {
                            let colorId = 'gradientBar' + iSerie;
                            _appendSVGGradientColor(svgDefs, colorId, _this._properties.series[iSerie].filling.color, false, false);
                            color = 'url(#' + colorId + ')';
                        }
                        svgPath.attr("fill", color);
                        if (_this._properties.series[iSerie].filling.transparency)
                            svgPath.attr("fill-opacity", _this._properties.series[iSerie].filling.transparency / 100.0);
                    }
                    else
                        svgPath.attr("fill", "transparent");
                    svgPath.attr('pointer-events', 'all');
                    if (_this._properties.series[iSerie].line.visible) {
                        svgPath.attr("stroke", strokeStyle);
                        svgPath.attr("stroke-width", _this._properties.series[iSerie].line.width / 2);
                        svgPath.attr('pointer-events', 'stroke');
                    }
                    else
                        svgPath.attr("stroke-width", 0.0);
                    svgPath.on("click", function (d) {
                        if (_this._currentTTItem == this)
                            _closeCurrentTT(_this);
                        else
                            _this._openTT(_this, this, _iSerie);
                    })
                        .on("mouseover", function (d) {
                        _this._openTT(_this, this, _iSerie);
                    })
                        .on("mouseout", function (d) {
                        _closeCurrentTT(_this);
                    });
                    svgPath.transition().duration(750)
                        .attrTween("d", function () {
                        var l = this.getTotalLength(), i = d3.interpolateString(tweenStartPath, path);
                        return function (t) { return i(t); };
                    });
                }
            }
            makeSVG(element, initWidth, initHeight) {
                let _this = this;
                let titleVisible = false;
                if (_this._properties.title.visible && _this._properties.title.text && _this._properties.title.text != '')
                    titleVisible = true;
                _this._viewPortHeight = 100;
                if (titleVisible)
                    _this._margin.bottom += _getChartDefaultLabelFontSize();
                _this._viewPortWidth = (initHeight > 0) ? _this._viewPortHeight * (initWidth / initHeight) : _this._viewPortHeight;
                _this._svg = d3.select(element).append("svg").attr("viewBox", "0 0 " + _this._viewPortWidth + " " + _this._viewPortHeight).attr("style", "overflow:visible");
                _this._divTT = _getChartTTDiv();
                _this._labelFontSize = _getChartDefaultLabelFontSize();
                _this._computeScales();
                _this._appendGrid();
                _this._appendSeries();
                _this._appendAxis();
                if (titleVisible) {
                    _this._svg.append("text")
                        .attr("font-size", _getChartDefaultLabelFontSize())
                        .attr("font-weight", _this._properties.title.font.fontWeight)
                        .attr("font-family", _this._properties.title.font.fontFamily)
                        .attr('x', _this._viewPortWidth / 2)
                        .attr('y', _this._viewPortHeight - _getChartDefaultLabelFontSize())
                        .attr('text-anchor', "middle")
                        .attr('alignment-baseline', "hanging")
                        .attr('dominant-baseline', 'hanging')
                        .attr('fill', AFC.Tools.Style.convertColor(_this._properties.title.color))
                        .text(_this._properties.title.text);
                }
            }
            getSVG() {
                return this._svg;
            }
        }
        function _renderRadar(element, subtitles, rawData, properties, dataTransposed, initWidth, initHeight) {
            let radarRendererData = new RadarRenderer(subtitles, properties);
            if (element.style)
                element.style.overflow = "visible";
            radarRendererData.setData(rawData, dataTransposed);
            radarRendererData.makeSVG(element, initWidth, initHeight);
            return radarRendererData.getSVG();
        }
        const _renderers = {
            [1 /* Globals.ChartType.pie */]: (element, chart, width, height) => _renderPie(element, chart.subtitles, chart.data, chart.chartProperties, 0, width, height, chart.chartDataTransposed),
            [6 /* Globals.ChartType.doughnut */]: (element, chart, width, height) => _renderPie(element, chart.subtitles, chart.data, chart.chartProperties, chart.chartProperties.pie.hole, width, height, chart.chartDataTransposed),
            [12 /* Globals.ChartType.barHorizontal */]: (element, chart, width, height) => _renderBar(element, chart.subtitles, chart.data, chart.chartProperties, true, chart.chartDataTransposed ? true : false, width, height, false),
            [4 /* Globals.ChartType.bar */]: (element, chart, width, height) => _renderBar(element, chart.subtitles, chart.data, chart.chartProperties, false, chart.chartDataTransposed ? true : false, width, height, false),
            [11 /* Globals.ChartType.radar */]: (element, chart, width, height) => _renderRadar(element, chart.subtitles, chart.data, chart.chartProperties, chart.chartDataTransposed ? true : false, width, height),
            [13 /* Globals.ChartType.stackedBarHorizontal */]: (element, chart, width, height) => _renderBar(element, chart.subtitles, chart.data, chart.chartProperties, true, chart.chartDataTransposed ? true : false, width, height, true),
            [5 /* Globals.ChartType.stackedBar */]: (element, chart, width, height) => _renderBar(element, chart.subtitles, chart.data, chart.chartProperties, false, chart.chartDataTransposed ? true : false, width, height, true),
        };
        class Charts extends Controls.Image {
            _size(svg) {
                let width = Math.floor(this.width), height = Math.floor(this.height);
                svg
                    .attr("width", width)
                    .attr("height", height);
            }
            clear() {
                let container = $(this.node);
                this._chart = null;
                container.empty();
                this.loadingStart();
            }
            setData(chart) {
                let container = $(this.node);
                let element;
                let renderer;
                let width = this.width, height = this.height;
                this._chart = chart;
                container.empty();
                if (width && height) {
                    if (chart && (element = container[0]) && (renderer = _renderers[chart.chartProperties.type])) {
                        this._size(renderer(element, chart, width, height));
                        this.loadingEnd();
                    }
                    else
                        this.loadingStart();
                }
            }
            invalidateSize() {
                if (this._chart) {
                    this.setData(this._chart);
                }
                else {
                    let element;
                    (element = this.node) && this._size(d3.select(element).select("svg"));
                }
            }
        }
        Controls.Charts = Charts;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 20/05/2020.
 */
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        const _element = Symbol(), _pointerdown = Symbol();
        class Draggable {
            static destroy(draggable) {
                if (draggable && draggable[_pointerdown]) {
                    draggable[_element].removeEventListener('pointerdown', draggable[_pointerdown], true);
                    delete draggable[_pointerdown];
                    delete draggable[_element];
                }
            }
            constructor(element) {
                this.moveThreshold = Draggable.moveThreshold;
                this.swipeTimeThreshold = Draggable.swipeTimeThreshold;
                this.clickTimeThreshold = Draggable.clickTimeThreshold;
                this.moveThrottle = Draggable.moveThrottle;
                this.swipeThreshold = Draggable.swipeThreshold;
                element.style.touchAction = 'none';
                (this[_element] = element).addEventListener('pointerdown', this[_pointerdown] = (event) => {
                    let start = Date.now(), initialClientX = event.clientX, initialClientY = event.clientY, lastClientX = initialClientX, lastClientY = initialClientY, swipeStamps = [{ timestamp: start, x: initialClientX, y: initialClientY }], moveMode = false, refreshFrame, currentClientX, currentClientY, _end = (clientX, clientY) => {
                        let event;
                        refreshFrame && cancelAnimationFrame(refreshFrame);
                        document.removeEventListener('pointermove', pointermove, true);
                        document.removeEventListener('pointerup', pointerup, true);
                        if (moveMode) {
                            event = new DragEvent('drag:end', { clientX: clientX, clientY: clientY });
                        }
                        else if ((Date.now() - start) <= this.clickTimeThreshold) {
                            event = new MouseEvent('vclick', { clientX: clientX, clientY: clientY });
                        }
                        event && element.dispatchEvent(event);
                    }, pointermove = (event) => {
                        currentClientX = event.clientX;
                        currentClientY = event.clientY;
                        refreshFrame || (refreshFrame = requestAnimationFrame(() => {
                            if ((Math.abs(lastClientX - currentClientX) >= this.moveThrottle) || (Math.abs(lastClientY - currentClientY) >= this.moveThrottle)) {
                                let timestamp = Date.now();
                                for (let i = 0; i < swipeStamps.length; ++i) {
                                    if ((timestamp - swipeStamps[i].timestamp) > this.swipeTimeThreshold) {
                                        swipeStamps.splice(0, i - 1);
                                        break;
                                    }
                                }
                                for (let i = 0; i < swipeStamps.length; ++i) {
                                    let offsetX = currentClientX - swipeStamps[i].x;
                                    if (Math.abs(offsetX) >= this.swipeThreshold) {
                                        _end(currentClientX, currentClientY);
                                        element.dispatchEvent(new DragEvent(offsetX > 0 ? 'swipe:right' : 'swipe:left', { clientX: currentClientX, clientY: currentClientY }));
                                        return;
                                    }
                                }
                                swipeStamps.push({ timestamp: timestamp, x: currentClientX, y: currentClientY });
                                if (!moveMode && ((Math.abs(lastClientX - currentClientX) >= this.moveThreshold) || (Math.abs(lastClientY - currentClientY) >= this.moveThreshold))) {
                                    moveMode = true;
                                    element.dispatchEvent(new DragEvent('drag:start', { clientX: lastClientX, clientY: lastClientY }));
                                }
                                if (moveMode) {
                                    element.dispatchEvent(new DragEvent('drag:move', { clientX: lastClientX = currentClientX, clientY: lastClientY = currentClientY }));
                                }
                            }
                            refreshFrame = 0;
                        }));
                    }, pointerup = (event) => _end(event.clientX, event.clientY);
                    document.addEventListener('pointermove', pointermove, true);
                    document.addEventListener('pointerup', pointerup, true);
                }, true);
            }
        }
        Draggable.moveThreshold = 75; // px
        Draggable.moveThrottle = 5; // px
        Draggable.swipeThreshold = 200; // px
        Draggable.swipeTimeThreshold = 200; // ms
        Draggable.clickTimeThreshold = 1000; // ms
        Controls.Draggable = Draggable;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
///<reference types="leaflet" />
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        const _highlightKeys = Symbol(), _highlighted = Symbol(), _index = Symbol(), _keyProvider = Symbol();
        function _highlight(layer) {
            if (layer) {
                if (layer.bringToFront) {
                    let element = layer.getElement();
                    layer.bringToFront();
                    element ? L.DomUtil.addClass(element, 'Selected') : layer.setStyle({ className: 'Selected' });
                }
                return layer;
            }
        }
        const _getOptions = (options) => $.extend({ minZoom: 0 }, options);
        Controls.GeoJSON = L.GeoJSON.extend({
            initialize: function (keyProvider, geojson, options) {
                this[_keyProvider] = keyProvider;
                L.GeoJSON.prototype.initialize.call(this, geojson, _getOptions(options));
            },
            highlight: function (keys) {
                let highlighted = this[_highlighted];
                if (highlighted) {
                    delete this[_highlightKeys];
                    delete this[_highlighted];
                    highlighted.forEach(layer => {
                        if (layer) {
                            let element = layer.getElement();
                            L.DomUtil.removeClass(element, 'Selected');
                        }
                    });
                }
                if (keys) {
                    this[_highlighted] = (this[_highlightKeys] = keys.slice(0).sort(AFC.Data.compareKey)).map(key => _highlight(this.findItem(key)));
                }
            },
            addLayer: function (layer) {
                let indice, map = this._map;
                delete this[_index];
                if (this[_highlightKeys] && ((indice = this[_highlightKeys].findIndex(key => !this[_keyProvider].compareKey(layer.feature.properties.data, key))) !== -1)) {
                    this[_highlighted][indice] = layer = _highlight(layer);
                }
                this.isVisible() || (this._map = null);
                L.GeoJSON.prototype.addLayer.call(this, layer);
                this._map = map;
                return this;
            },
            onAdd: function (map) {
                this.isVisible() && L.GeoJSON.prototype.onAdd.call(this, map);
                return this;
            },
            removeLayer: function (layer) {
                delete this[_index];
                return L.GeoJSON.prototype.removeLayer.call(this, layer);
            },
            findItem: function (key) {
                let keyProvider = this[_keyProvider];
                if (AFC.Tools.Data.isValidKey(keyProvider, key)) {
                    let layers = this[_index] || (this[_index] = this.getLayers()).sort((layer0, layer1) => keyProvider.compareRow(layer0.feature.properties.data, layer1.feature.properties.data)), compare = (layer, key) => keyProvider.compareKey(layer.feature.properties.data, key), i = AFC.Tools.lower_bound(layers, key, compare), layer = layers[i];
                    if (layer && !compare(layer, key)) {
                        return layer;
                    }
                }
            },
            isVisible: function () {
                const map = this._map, zoom = map ? map.getZoom() : -1, options = this.options, minZoom = options.minZoom, maxZoom = options.maxZoom ?? Number.MAX_SAFE_INTEGER;
                return (zoom >= minZoom) && (zoom <= maxZoom);
            },
            _resetView: function () {
                const layers = this._layers, map = this._map;
                if (map) {
                    for (let i in layers) {
                        const hasLayer = map.hasLayer(layers[i]);
                        if (this.isVisible()) {
                            hasLayer || this.eachLayer(map.addLayer, map);
                        }
                        else {
                            hasLayer && this.eachLayer(map.removeLayer, map);
                        }
                        break;
                    }
                }
            },
            getEvents: function () {
                const options = this.options;
                return options.minZoom || (options.maxZoom !== void 0) ? {
                    viewreset: this._resetView,
                    zoom: this._resetView,
                } : {};
            }
        });
        const GeoJSONLayerProvider = L.GeoJSON.extend({
            initialize: function (options, geojson) {
                L.Util.setOptions(this, options);
                this.layers = [];
                if (geojson) {
                    this.addData(geojson);
                }
            },
            addLayer: function (layer) {
                this.layers.push(layer);
                return this;
            }
        });
        const _provider = Symbol();
        Controls.MarkerClusterGroup = L.MarkerClusterGroup.extend({
            initialize: function (keyProvider, clusterOptions, options) {
                L.MarkerClusterGroup.prototype.initialize.call(this, _getOptions(clusterOptions));
                this[_keyProvider] = keyProvider;
                this[_provider] = new GeoJSONLayerProvider(options);
                const _this = this, _addTo = this._featureGroup.addTo;
                this._featureGroup.addTo = this._nonPointGroup.addTo = function (map) {
                    if (_this.isVisible()) {
                        _addTo.call(this, map);
                    }
                    return this;
                };
            },
            highlight: function (keys) {
            },
            addData: function (data) {
                delete this[_index];
                this[_provider].addData(data);
                L.MarkerClusterGroup.prototype.addLayers.call(this, this[_provider].layers);
                this[_provider].layers.length = 0;
                return this;
            },
            addLayer: function (layer) {
                delete this[_index];
                return L.MarkerClusterGroup.prototype.addLayer.call(this, layer);
            },
            removeLayer: function (layer) {
                delete this[_index];
                return L.MarkerClusterGroup.prototype.removeLayer.call(this, layer);
            },
            findItem: Controls.GeoJSON.prototype.findItem,
            isVisible: Controls.GeoJSON.prototype.isVisible,
            _resetView: function () {
                const map = this._map;
                if (map) {
                    const hasLayer = map.hasLayer(this._featureGroup);
                    if (this.isVisible()) {
                        hasLayer || (map.addLayer(this._featureGroup), map.addLayer(this._nonPointGroup));
                    }
                    else {
                        hasLayer && (map.removeLayer(this._featureGroup), map.removeLayer(this._nonPointGroup));
                    }
                }
            },
            getEvents: Controls.GeoJSON.prototype.getEvents
        });
        Object.defineProperty(Controls.MarkerClusterGroup.prototype, "geoJSONOptions", {
            get: function () {
                return this[_provider].options;
            },
            enumerable: true,
            configurable: true
        });
        function markerClusterGroup(keyProvider, options, clusterOptions) {
            return new Controls.MarkerClusterGroup(keyProvider, $.extend({
                showCoverageOnHover: false,
                disableClusteringAtZoom: 19
            }, clusterOptions), options);
        }
        Controls.markerClusterGroup = markerClusterGroup;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 20/02/2017.
 */
///<reference path="../Global.ts" />
///<reference path="Control.ts" />
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        function _getLabel(pattern, data) {
            let ret = pattern;
            if (data) {
                for (let s in data) {
                    if (data.hasOwnProperty(s)) {
                        ret = ret.replace(new RegExp(s, 'g'), data[s].text);
                    }
                }
            }
            return ret;
        }
        let _generators = [];
        _generators[0 /* Globals.LegendType.fillColor */] = (label, value, key, clickable, state) => {
            let doc = document.createDocumentFragment();
            let div = document.createElement('DIV');
            let text = document.createTextNode(label);
            div.style.backgroundColor = AFC.Tools.Style.convertColor(value);
            doc.appendChild(div);
            if (clickable) {
                let input = document.createElement('INPUT');
                let label = document.createElement('LABEL');
                input.id = label.htmlFor = `__${clickable}_${key}`;
                input.setAttribute('name', clickable);
                input.type = "checkbox";
                input.value = key;
                input.checked = state;
                input.hidden = true;
                doc.appendChild(text);
                doc.appendChild(input);
                doc.appendChild(label);
            }
            else {
                doc.appendChild(text);
            }
            return doc;
        };
        function _mapClasses(classes, values) {
            if (classes && values && !AFC.Globals.isQuali(values)) {
                let lastClass = classes.length - 1, lastValue = values.length - 1;
                if (lastValue > 0 && lastValue < lastClass) {
                    classes = Array.from(values, (value, indice) => classes[indice === lastValue ? lastClass : indice]);
                }
            }
            return [classes, values];
        }
        class Legends extends Controls.Control {
            update(data, enableFiltering) {
                const query = $(this.node);
                query.empty();
                if (data && data.length) {
                    this.loadingEnd();
                    data.forEach((item) => {
                        let thematic = item.property.thematic;
                        if (thematic) {
                            let generator = _generators[item.type], div = document.createElement('div'), [thematicClasses, thematicValues] = _mapClasses(thematic.classes, item.data?.thematic?.classes), id = enableFiltering && item.id, ul;
                            thematicClasses && thematicValues && thematicClasses.forEach((thematicClass, indice) => {
                                let li, child, state, thematicValue = thematicValues[indice];
                                if (thematicValue) {
                                    if (id) {
                                        state = !!((1 << indice) & item.states);
                                    }
                                    if (child = generator(_getLabel(thematicClass.pattern, thematicValue), thematicClass.value, indice, id, state)) {
                                        li = document.createElement('li');
                                        li.appendChild(child);
                                        (ul || (query.append(ul = document.createElement('ul')), ul)).appendChild(li);
                                    }
                                }
                            });
                            thematic.title && div.appendChild(document.createTextNode(thematic.title));
                            query.append(div);
                        }
                    });
                }
                else {
                    this.loadingStart();
                }
            }
        }
        Controls.Legends = Legends;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        /*
        class _ProgressInfoBarTask {
            public readonly progressData:       AFC.Globals.IProgressData;
            /*private _htmlElement:               HTMLElement;
            private _progressBarDiv:            HTMLElement;
            private _commentNode:               Text;*
                    
            constructor(progressData: AFC.Globals.IProgressData) {
                this.progressData = progressData;
                //this._htmlElement = null;
            }
            
            /*
            public stop() {
                if (this._commentNode) {
                    this._commentNode.textContent = 'Terminé (' + ((Date.now() - this._timerStart) / 1000) + ' s)';
                }
                            
                if (this._htmlElement) {
                    this._htmlElement.style.opacity     = '0.5';
                    this._htmlElement.style.background  = '#45ff73';
                    this._progressBarDiv.style.width    = '100%';
                }
                
            }*/
        /*
        public getHTMLElement() : HTMLElement {
            if (!this._htmlElement) {
                let mainDiv: HTMLElement;
                let commentDiv: HTMLElement;
                let progressDiv: HTMLElement;
                let titleText: Text;
                let titleDiv: HTMLElement;
                let spinnerDiv: HTMLElement;
                
                this._timerStart = Date.now();
                
                mainDiv = document.createElement('div');
                if (mainDiv) {
                    mainDiv.setAttribute('id', 'ProgressInfoBarTask' + this.tid);
                    mainDiv.classList.add('ProgressInfoBarTask');
                    
                    titleDiv    = document.createElement('div');
                    titleDiv.classList.add('ProgressInfoBarTaskTitle');
                    
                    titleText   = document.createTextNode(this.title);
                    titleDiv.appendChild(titleText);
                    
                    spinnerDiv  = document.createElement('div');
                    this._spinner = new Spinner( {
                                                    lines: 6, // The number of lines to draw
                                                    length: 4, // The length of each line
                                                    width: 2, // The line thickness
                                                    radius: 4, // The radius of the inner circle
                                                    corners: 1, // Corner roundness (0..1)
                                                    rotate: 0, // The rotation offset
                                                    direction: 1, // 1: clockwise, -1: counterclockwise
                                                    color: '#ff0000', // #rgb or #rrggbb or array of colors
                                                    speed: 1, // Rounds per second
                                                    trail: 47, // Afterglow percentage
                                                    shadow: false, // Whether to render a shadow
                                                    hwaccel: false, // Whether to use hardware acceleration
                                                    className: 'spinner', // The CSS class to assign to the spinner
                                                    zIndex: 2e9, // The z-index (defaults to 2000000000)
                                                    top: '-5px', // Top position relative to parent in px
                                                    left: 'calc(100% - 15px)', // Left position relative to parent in px
                                                    position: 'relative'
                                                  }).spin(spinnerDiv);
                    titleDiv.appendChild(spinnerDiv);
                    
                    commentDiv    = document.createElement('div');
                    commentDiv.classList.add('ProgressInfoBarTaskComment');
                    this._commentNode = document.createTextNode('Préparation');
                    commentDiv.appendChild(this._commentNode);
                    
                    progressDiv = document.createElement('div');
                    progressDiv.classList.add('ProgressPctBackground');
                    this._progressBarDiv = document.createElement('div');
                    this._progressBarDiv.classList.add('ProgressPct');
                    progressDiv.appendChild(this._progressBarDiv);
                    
                    mainDiv.appendChild(titleDiv);
                    mainDiv.appendChild(commentDiv);
                    mainDiv.appendChild(progressDiv);
                    this._htmlElement = mainDiv;
                }
            }
            return this._htmlElement;
        }
        *
    }*/
        class ProgressBar extends Controls.Control {
            constructor(element) {
                super(element);
                this._allTasksBar = null;
                this._fullDetailsMode = false;
            }
            isFullDetailsMode() {
                return this._fullDetailsMode;
            }
            setFullDetailsMode(full) {
                let value = !full;
                if (this._fullDetailsMode === value) {
                    this._fullDetailsMode = !value;
                    this._refresh();
                }
            }
            refresh(tasks) {
                this._runningTasks = tasks;
                this._refresh();
            }
            _refresh() {
                let runningTasks = this._runningTasks;
                let bEmpty = runningTasks.length <= 0;
                let messageTxt = '';
                let target = this.node;
                this._initHTMLControls();
                if (!bEmpty) {
                    let completedSum = 0.0;
                    let allCompleted;
                    allCompleted = true;
                    runningTasks.forEach(task => {
                        if (task.progressData.status != 3 /* AFC.Globals.ProgressStatus.completed */) {
                            completedSum += task.progressData.completed;
                            allCompleted = false;
                        }
                        else
                            completedSum += 1.0;
                        let stepAndMessage = task.progressData.step;
                        if (!stepAndMessage)
                            stepAndMessage = '';
                        if (task.progressData.progress) {
                            if (stepAndMessage != '')
                                stepAndMessage += ' - ';
                            stepAndMessage += task.progressData.progress;
                        }
                        messageTxt = task.progressData.title;
                        if (!messageTxt)
                            messageTxt = '';
                        if (messageTxt != '') {
                            if (stepAndMessage != '')
                                messageTxt += ' : ';
                        }
                        messageTxt += stepAndMessage;
                    });
                    if (runningTasks.length != 1)
                        messageTxt = runningTasks.length + ' tâches en cours';
                    if (!allCompleted) {
                        let globalPct = (completedSum / runningTasks.length) * 100.0;
                        this._progressBarDiv.style.width = globalPct + '%';
                    }
                    else
                        this._progressBarDiv.style.width = '100%';
                    this._textNode.textContent = messageTxt;
                }
                if (target)
                    target.style.visibility = bEmpty ? 'hidden' : 'visible';
            }
            _initHTMLControls() {
                if (this._allTasksBar == null) {
                    let target = this.node;
                    let mainDiv;
                    let progressTextDiv;
                    let progressDiv;
                    $(target).empty();
                    mainDiv = document.createElement('div');
                    mainDiv.setAttribute('id', 'ProgressInfoBarMain');
                    mainDiv.classList.add('ProgressInfoBarMain');
                    progressDiv = document.createElement('div');
                    progressDiv.classList.add('ProgressPctBackgroundMain');
                    this._progressBarDiv = document.createElement('div');
                    this._progressBarDiv.classList.add('ProgressPctMain');
                    progressDiv.appendChild(this._progressBarDiv);
                    this._textNode = document.createTextNode('');
                    progressTextDiv = document.createElement('div');
                    progressTextDiv.classList.add('ProgressTextMain');
                    progressTextDiv.appendChild(this._textNode);
                    progressDiv.appendChild(progressTextDiv);
                    mainDiv.appendChild(progressDiv);
                    this._allTasksBar = mainDiv;
                    if (target)
                        target.appendChild(this._allTasksBar);
                }
            }
        }
        Controls.ProgressBar = ProgressBar;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 26/03/2018.
 */
///<reference path="../Global.ts" />
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        let ReportViewBlockType;
        (function (ReportViewBlockType) {
            ReportViewBlockType[ReportViewBlockType["none"] = 0] = "none";
            ReportViewBlockType[ReportViewBlockType["image"] = 1] = "image";
            ReportViewBlockType[ReportViewBlockType["charts"] = 2] = "charts";
            ReportViewBlockType[ReportViewBlockType["gridView"] = 3] = "gridView";
            ReportViewBlockType[ReportViewBlockType["legends"] = 4] = "legends";
        })(ReportViewBlockType = Controls.ReportViewBlockType || (Controls.ReportViewBlockType = {}));
        function _setSize(container, width, height, initialWidth, initialHeight) {
            let ratio = Math.min(width / initialWidth, height / initialHeight), correctedWidth, correctedHeight, style = container.style;
            style.width = `${correctedWidth = Math.floor(initialWidth * ratio)}px`;
            style.height = `${correctedHeight = Math.floor(initialHeight * ratio)}px`;
            ratio = Math.min(correctedWidth / initialWidth, correctedHeight / initialHeight);
            ratio *= 0.352777778; /* initial values are in mm  -> convert in pt at 72 dpi */
            style.fontSize = `${Math.ceil(1000000 * ratio) / 100000}pt`; // reference is 10pt
            style.left = correctedWidth < width ? `${(width - correctedWidth) / 2}px` : '';
            return [width, height, initialWidth, initialHeight];
        }
        function _percent(num, denum) {
            return `${Math.round((num * 10000) / denum) / 100}%`;
        }
        function _renderBase(container, width, height, reportObject) {
            /* readonly shadow: {
                 readonly color: number;
                 readonly XMove: number;
                 readonly YMove: number;
                 readonly XPosition: number;
                 readonly YPosition: number;
                 readonly visible: boolean;
             };
             */
            let element = document.createElement('DIV');
            let style = element.style;
            style.position = 'absolute';
            style.boxSizing = 'border-box';
            style.left = _percent(reportObject.left, width);
            style.top = _percent(reportObject.top, height);
            style.width = _percent(reportObject.width, width);
            style.height = _percent(reportObject.height, height);
            style.overflow = 'hidden';
            if (reportObject.backgroundColor !== void 0) {
                style.backgroundColor = AFC.Tools.Style.convertColor(reportObject.backgroundColor);
            }
            if ((reportObject.borderColor !== void 0) && (reportObject.borderWidth > 0)) {
                style.border = `${Math.round(reportObject.borderWidth) / 10}em solid ${AFC.Tools.Style.convertColor(reportObject.borderColor)}`;
            }
            return element;
        }
        function _rendererPoint(element, pointReportObject) {
        }
        const _flexDirection = {
            middle: 'center',
            bottom: 'flex-end'
        };
        const _renderers = {
            [1 /* Globals.ReportObjectType.text */]: function (element, report, textReportObject /*, indice: number*/) {
                if (textReportObject.text != void 0) {
                    let innerElement = element;
                    let innerStyle = element.style;
                    let font = textReportObject.font;
                    let flexDirection = _flexDirection[textReportObject.verticalAlign];
                    let htmlText;
                    if (flexDirection) {
                        let style = innerStyle;
                        innerElement = document.createElement('div');
                        innerStyle = innerElement.style;
                        style.display = 'flex';
                        style.flexDirection = 'column';
                        style.justifyContent = flexDirection;
                        innerStyle.width = '100%';
                        innerStyle.overflow = 'hidden';
                        element.appendChild(innerElement);
                    }
                    innerStyle.color = AFC.Tools.Style.convertColor(textReportObject.color);
                    textReportObject.textAlign && (innerStyle.textAlign = textReportObject.textAlign);
                    if (font) {
                        innerStyle.fontFamily = font.fontFamily;
                        innerStyle.fontSize = `${font.fontSize / 10}em`;
                        innerStyle.fontWeight = font.fontWeight;
                        innerStyle.fontStyle = font.fontStyle;
                        innerStyle.textDecoration = font.textDecoration;
                    }
                    htmlText = textReportObject.text.replace(/{\$(.*?)\$}/g, (match, p1) => {
                        return report.data.tokens[p1] || '';
                    });
                    innerElement.innerHTML = htmlText;
                }
            },
            [2 /* Globals.ReportObjectType.dashboardView */]: function (element, report, dashboardViewReportObject, indice) {
                let promise = report.data.views[indice];
                promise && promise.then(blockView => {
                    switch (blockView.type) {
                        case 1 /* ReportViewBlockType.image */:
                            (new Controls.Image(element)).setUrl(blockView.data);
                            break;
                        case 2 /* ReportViewBlockType.charts */:
                            (new Controls.Charts(element)).setData(blockView.data);
                            break;
                        case 3 /* ReportViewBlockType.gridView */:
                            (new Controls.GridView(element, true)).setGrid(blockView.data);
                            break;
                        case 4 /* ReportViewBlockType.legends */:
                            (new Controls.Legends(element)).update(blockView.data);
                            break;
                    }
                });
            },
            [3 /* Globals.ReportObjectType.grid */]: function (element, report, gridReportObject /*, indice: number*/) {
                (new Controls.GridView(element, true)).setGrid(new AFC.Dashboards.GridApp(gridReportObject.content));
            },
            [4 /* Globals.ReportObjectType.bitmap */]: function (element, report, bitmapReportObject /*, indice: number*/) {
                let image = report.metadata.images && report.metadata.images[bitmapReportObject.id];
                if (image) {
                    if (image.charAt(0) === '<') {
                        element.innerHTML += image;
                        if (bitmapReportObject.representationMode && (bitmapReportObject.representationMode !== 'none')) {
                            let svg = element.querySelector('svg');
                            if (svg) {
                                let style = svg.style;
                                style.width = style.height = '100%';
                                svg.setAttribute('preserveAspectRatio', bitmapReportObject.representationMode === 'contain' ? 'xMinYMin meet' : 'none');
                            }
                        }
                    }
                    else {
                        let style = element.style;
                        style.backgroundRepeat = 'no-repeat';
                        bitmapReportObject.representationMode && (bitmapReportObject.representationMode !== 'none') && (style.backgroundSize = bitmapReportObject.representationMode);
                        style.backgroundImage = `url("${image}")`;
                    }
                }
            },
            [5 /* Globals.ReportObjectType.line */]: function (element, report, lineReportObject) {
            },
            [6 /* Globals.ReportObjectType.shape */]: function (element, report, shapeReportObject) {
            }
        };
        class ReportPage extends Controls.Charts {
            clear() {
                let container = $(this.node);
                super.clear();
                this._report = null;
                container.empty();
                this.loadingStart();
                this.node.style.backgroundColor = null;
            }
            setPage(report, index) {
                this._report = report;
                this._index = index || 0;
                $(this.node).empty();
                if (report) {
                    this.loadingEnd();
                    let metadata = report.metadata;
                    if (metadata) {
                        let width = metadata.width, height = metadata.height, container = document.createElement('div'), page;
                        container.style.position = 'absolute';
                        if (metadata.pages && (page = metadata.pages[this._index])) {
                            (page.backgroundColor !== void 0) && (this.node.style.backgroundColor = AFC.Tools.Style.convertColor(page.backgroundColor));
                            page.width && (width = page.width);
                            page.height && (height = page.height);
                            page.objects.forEach((reportObject, indice) => {
                                let renderer = _renderers[reportObject.type], element = _renderBase(container, width, height, reportObject);
                                renderer && renderer(element, report, reportObject, indice);
                                container.appendChild(element);
                            });
                        }
                        this._lengths = _setSize(container, this.width, this.height, width, height);
                        this.node.appendChild(container);
                    }
                }
                else
                    this.loadingStart();
            }
            invalidateSize() {
                if (this._report) {
                    let container = this._lengths && this.node.querySelector('div');
                    if (container) {
                        let width = this.width, height = this.height;
                        if (this._lengths[0] !== width || this._lengths[1] !== height)
                            this._lengths = _setSize(container, width, height, this._lengths[2], this._lengths[3]);
                    }
                }
                else {
                    super.invalidateSize();
                    /*
                    let children: JQuery = this._element && $(this._element).children('DIV');
                    if (children && children.length)
                        _setSize(children[0], this.width, this.height, this._width, this._height);
                    */
                }
            }
        }
        Controls.ReportPage = ReportPage;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 27/10/2016.
 */
///<reference path="../Global.ts" />
///<reference path="Control.ts" />
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        ;
        class BlockList extends Controls.ListBox {
            constructor() {
                super(...arguments);
                this.displayNames = true;
            }
            _build(container, items) {
                let index = {};
                return (this.block === void 0) ? super._build(container, items) : $(items.map((item) => {
                    let li = document.createElement('li');
                    let anchor = document.createElement('a');
                    let block = item.properties[this.block][2];
                    let ul = index[block];
                    if (!ul) {
                        let div = document.createElement('div');
                        ul = index[block] = document.createElement('ul');
                        block && this.displayNames && div.appendChild(document.createTextNode(block));
                        container.append(div);
                        container.append(ul);
                    }
                    anchor.id = item.id;
                    anchor.href = 'javascript:void 0;';
                    anchor.appendChild(document.createTextNode(item.name || ''));
                    li.appendChild(anchor);
                    ul.appendChild(li);
                    return anchor;
                }));
            }
        }
        class Selector extends Controls.Control {
            constructor(list, radio) {
                super(list);
                (this._radioGroup = new Controls.RadioGroup(radio)).dispatchChange = this._onRadioChange.bind(this);
                (this._blockList = new BlockList(list)).dispatchChange = this._onListChange.bind(this);
            }
            get HTMLElement2() {
                return this._radioGroup.node;
            }
            set block(value) {
                this._blockList.block = value;
            }
            get block() {
                return this._blockList.block;
            }
            get selected() {
                let value = {};
                let group = this._groups && this._groups[this._radioGroup.checked];
                let items = this._blockList.getItems();
                let selected;
                group && (value.group = group);
                items && ((selected = this._blockList.selected).length > 0) && (value.item = selected[0]);
                return value;
            }
            setGroups(groups, selected) {
                if (groups) {
                    this._groups = groups;
                    this._selected = selected || [];
                    this._radioGroup.setItems(groups);
                }
                else {
                    delete this._groups;
                    delete this._selected;
                    this._radioGroup.setItems();
                }
                this._radioGroup.visible = groups && (groups.length > 1);
            }
            select(groupId, itemId) {
                if (this._groups) {
                    let group;
                    let item;
                    for (let i = 0; i < this._groups.length; ++i) {
                        group = this._groups[i];
                        if (group.id === groupId) {
                            (i !== this._radioGroup.check(i)) && this._blockList.setItems(group.items);
                            for (let j = 0; j < group.items.length; ++j) {
                                item = group.items[j];
                                if (item.id === itemId) {
                                    this._blockList.select([j]);
                                    break;
                                }
                            }
                            return;
                        }
                    }
                }
            }
            _onRadioChange(typeArg, eventInitDict) {
                let checked = this._radioGroup.checked;
                let selection;
                if (checked !== void 0) {
                    let group = this._groups[checked];
                    let item = this._selected[checked];
                    this._blockList.setItems(group.items);
                    (item !== void 0) && (selection = [item]);
                }
                else
                    this._blockList.setItems();
                this._blockList.select(selection);
            }
            _onListChange(typeArg, eventInitDict) {
                let checked = this._radioGroup.checked;
                let selected = this._blockList.selected;
                (checked !== void 0) && (selected.length > 0) && (this._selected[checked] = selected[0]);
                this._dispatchChange();
            }
        }
        Controls.Selector = Selector;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
///<reference path="../Global.ts" />
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        function _check(value) {
            return (value === null) ? void 0 : value;
        }
        function _f1(key, value) {
            return value && _check(value[key]);
        }
        function _f2(key0, key1, value) {
            return value && value[key0] && _check(value[key0][key1]);
        }
        function _fn(keys, value) {
            for (let i = 0; i < keys.length; ++i) {
                if (_check(value) === void 0)
                    return;
                value = value[keys[i]];
            }
            return value;
        }
        function resolveTemplate(value, key, dataBinder, formatNumbers, formatter) {
            let ret = dataBinder && dataBinder("", key, value);
            let items = key.split('.');
            let accelerator = items.length < 2 ? _f1.bind(null, items[0]) : (items.length < 3 ? _f2.bind(null, items[0], items[1]) : _fn.bind(null, items));
            ret = accelerator(value);
            if (formatter === "formatNumberM") {
                ret = `${(ret / 1000000).toFixed(2).toLocaleString()}M`;
            }
            if (formatNumbers && AFC.Tools.Data.isNumber(ret)) {
                let formatHelper = new AFC.Tools.StringTools.FormatString('', 2 /* AFC.Data.DataKind.real */);
                ret = formatHelper.getFormated(ret);
            }
            return ret === void 0 ? '' : ret;
        }
        class TemplateElem extends Controls.Control {
            set template(contentHtml) {
                this._template = contentHtml;
            }
            get template() {
                return this._template;
            }
            setTemplate(value, name) {
                if (name === void 0) {
                    value ? this._template = value : delete this._template;
                }
                else if (value) {
                    (this._templates || (this._templates = {}))[name] = value;
                }
                else if (this._templates) {
                    delete this._templates[name];
                }
            }
            getTemplate(name) {
                if (!this._templates) {
                    return this.template;
                }
                else {
                    return this._templates[name] || this.template;
                }
            }
            setFormatNumbers(formatNumbers) {
                this._formatNumbers = formatNumbers;
            }
            /**
             * Interpret template and replace{{MY_VAR_NAME|MY_FORMATTER}}
             * @param value
             */
            generateContent(value) {
                let div = document.createElement('div');
                let dataBinder = this.dataBinder;
                let formatNumbers = this._formatNumbers;
                let template = this.getTemplate(value.templateName ?? void 0);
                let innerHTML = (template && template.replace(/{{([A-Z0-9_.]+)(?:\|([A-Z0-9_.]+))?}}/ig, (match, variable, formatter) => resolveTemplate(value, variable, dataBinder, formatNumbers, formatter))) || '';
                div.innerHTML = innerHTML; //.replace(/ /g, "&nbsp;");
                while (div.childNodes.length) {
                    this.node.appendChild(div.firstChild);
                }
            }
            /**
             * Empty htmlcontent of node
             */
            empty() {
                while (this.node.firstChild) {
                    this.node.removeChild(this.node.firstChild);
                }
            }
        }
        Controls.TemplateElem = TemplateElem;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/**
 * Created by jean.rennes on 06/12/2019.
 */
///<reference path="../Global.ts" />
///<reference path="../../application/Fragment.ts" />
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        function _create(width, height, styleEx) {
            let element = new AFC.gui.AfcGuiDiv(), style = element.style;
            element.init({ width: width, height: height });
            styleEx && $.extend(style, styleEx);
            return element;
        }
        const _fragmentManager = Symbol();
        class FragmentStateAdapter {
            constructor(fragmentManager) {
                this[_fragmentManager] = fragmentManager;
            }
        }
        Controls.FragmentStateAdapter = FragmentStateAdapter;
        ;
        class ViewPager extends Controls.Control {
            static _ease(n) {
                return n * n * n * n * n;
            }
            constructor(element) {
                super(element);
                this.duration = 400; // in ms
            }
            _onPageScrollStateChanged(state) {
                this.onPageScrollStateChanged && this.onPageScrollStateChanged(state);
            }
            _getContext() {
                let frameGroup = this._frameGroup;
                return frameGroup && {
                    frameGroup: frameGroup,
                    frameGroupStyle: frameGroup.style,
                    width: this.node.offsetWidth,
                    height: this.node.offsetHeight
                };
            }
            _stop() {
                // stop all animations
                if (this._animation) {
                    this._animation.stop();
                }
            }
            _createFrame(frameGroup, width, height, item, offset, referenceNode = null) {
                let container = _create(width, height, { cssFloat: "left", position: "relative" }), inner = _create(width, height, { position: "absolute" });
                if (item !== void 0) {
                    inner.id = `page${item}`;
                }
                return new ViewPager._Frame(frameGroup, container, inner, item, offset, referenceNode);
            }
            _reset(item = 0) {
                this._stop();
                let adapter = this._adapter, element = this.node;
                if (element) {
                    let width = element.offsetWidth, height = element.offsetHeight, frameGroup = this._frameGroup, div = document.createElement('div');
                    this._frame && this._frame.detach(this);
                    $(element).empty();
                    $.extend(div.style, {
                        top: 0,
                        left: 0,
                        width: `${width}px`,
                        height: `${height}px`,
                        overflow: 'hidden',
                        position: 'absolute'
                    });
                    element
                        .appendChild(div)
                        .appendChild(this._frameGroup = frameGroup = _create(width, height, { position: "absolute" }));
                    if (adapter && (item >= 0) && (item < adapter.getItemCount())) {
                        let frame = this._frame = this._createFrame(frameGroup, width, height, item, 0);
                        frame.drawNoCheck(this);
                    }
                    this._onPageScrollStateChanged(ViewPager.SCROLL_STATE_IDLE);
                }
            }
            _expandFrameGroup(context, frame, left, right, position) {
                let frameGroup = context.frameGroup, frames;
                if ((frameGroup.childNodes.length !== 1) || (frame.offset != 0)) {
                    return;
                }
                context.frameGroupStyle.width = `${3 * context.width}px`;
                context.frameGroupStyle.left = `-${context.width}px`;
                frames = [
                    this._createFrame(frameGroup, context.width, context.height, left, -1, frame.container),
                    frame,
                    this._createFrame(frameGroup, context.width, context.height, right, 1)
                ];
                this._frame = frames[position + 1];
                return frames;
            }
            _transform(context, frames, position) {
                // position between -1 and 1
                if (Math.abs(position) <= 1) {
                    let offset = (-position - 1) * context.width;
                    context.frameGroupStyle.left = `${offset}px`;
                    frames.forEach((frame, indice) => {
                        if (frame.item !== void 0) {
                            this._transformer?.transformPage(frame.inner, indice - position - 1);
                            frame.draw(this, context, position);
                        }
                    });
                }
            }
            _shrinkFrameGroup(context, frames) {
                if (this._animation) {
                    let frame = this._frame;
                    frames.forEach(item => (item !== frame) && item.detach(this));
                    context.frameGroupStyle.width = `${context.width}px`;
                    context.frameGroupStyle.left = "0";
                    frame.offset = 0;
                    frame.drawNoCheck(this);
                    delete this._animation;
                    this._onPageScrollStateChanged(ViewPager.SCROLL_STATE_IDLE);
                    return frame.fragment;
                }
            }
            _getTarget(start, end, max) {
                let target;
                if (start < end) {
                    target = {
                        position: 1,
                        right: end
                    };
                    if (start > 0) {
                        target.left = start - 1;
                    }
                }
                else {
                    target = {
                        position: -1,
                        left: end
                    };
                    if (max > start) {
                        target.right = start + 1;
                    }
                }
                return target;
            }
            setCurrentItem(item) {
                return new Promise((resolve) => {
                    let adapter = this._adapter, frame = this._frame, count, context, target, frames;
                    this._stop();
                    if (adapter && frame && (item >= 0) && (item < (count = adapter.getItemCount())) && (frame.item !== item) && (context = this._getContext(), target = this._getTarget(frame.item, item, count - 1), frames = this._expandFrameGroup(context, frame, target.left, target.right, target.position))) {
                        this._animation = new ViewPager._Animation(this, context, frames, target.position, resolve);
                    }
                    else {
                        this._reset(item);
                        resolve(this._frame && this._frame.fragment);
                    }
                });
            }
            getCurrentItem() {
                return this._frame && this._frame.item;
            }
            setAdapter(adapter) {
                this._stop();
                delete this._frame;
                this._adapter = adapter;
            }
            setPageTransformer(transformer) {
                this._transformer = transformer;
            }
            invalidateSize() {
                this._reset(this.getCurrentItem());
            }
        }
        ViewPager.SCROLL_STATE_IDLE = 0;
        ViewPager.SCROLL_STATE_DRAGGING = 1;
        ViewPager.SCROLL_STATE_SETTLING = 2;
        ViewPager._Frame = class {
            constructor(frameGroup, container, inner, item, offset, referenceNode) {
                this.container = container;
                this.inner = inner;
                this.item = item;
                this.offset = offset;
                frameGroup.insertBefore(container, referenceNode);
            }
            drawNoCheck(pager) {
                if (!this.fragment) {
                    let adapter = pager._adapter, fragment = this.fragment = adapter.getFragment(this.item), view;
                    this.container.appendChild(this.inner);
                    view = adapter[_fragmentManager].attachView(this.inner, fragment, `p${pager.getCurrentItem()}`);
                }
            }
            draw(pager, context, position) {
                if (!this.fragment) {
                    let truePosition = this.offset - position + (this.inner.left / context.width);
                    if (Math.abs(truePosition) < 1) {
                        this.drawNoCheck(pager);
                    }
                }
            }
            detach(pager) {
                if (this.fragment) {
                    AFC.Application.FragmentManager.detachView(this.fragment);
                }
                this.container.parentNode.removeChild(this.container);
            }
        };
        ViewPager._Animation = class {
            constructor(pager, context, frames, position, resolve) {
                let duration = pager.duration, ease = pager.ease || ViewPager._ease, start = null, step = (timestamp) => {
                    let progress;
                    if (start === null)
                        start = timestamp;
                    progress = (timestamp - start);
                    if (progress < duration) {
                        id = requestAnimationFrame(step);
                        pager._transform(context, frames, position * ease(progress / duration));
                    }
                    else {
                        pager._transformer?.transformPage(frames[1 + position].inner, 0);
                        resolve(pager._shrinkFrameGroup(context, frames));
                    }
                }, id = requestAnimationFrame(step);
                this.stop = () => {
                    cancelAnimationFrame(id);
                    resolve(pager._shrinkFrameGroup(context, frames));
                };
                pager._onPageScrollStateChanged(ViewPager.SCROLL_STATE_SETTLING);
            }
        };
        Controls.ViewPager = ViewPager;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
;
/*---------------------------------------------------------------------*/
var Spinner;
// @ts-ignore
if (typeof module != "undefined")
    ({ Spinner: Spinner } = require("../../../node_modules/spin.js"));
/*---------------------------------------------------------------------*/
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        class WaitBar extends Controls.Control {
            constructor(element) {
                super(element);
            }
            set options(options) {
                options ? this._options = options : delete this._options;
                this._spinner && this.show();
            }
            get options() {
                return this._options;
            }
            show() {
                let target = this.node;
                this._spinner?.stop();
                if (target) {
                    let options = $.extend({ ...WaitBar.defaultOptions }, this._options);
                    this._spinner = new Spinner(options).spin(target);
                    target.style.visibility = 'visible';
                }
            }
            hide() {
                let target = this.node;
                this._spinner?.stop();
                this._spinner = void 0;
                if (target) {
                    target.style.visibility = 'hidden';
                }
            }
        }
        WaitBar.defaultOptions = new Spinner({
            width: 4,
            color: "#f35f23",
            speed: 0.5,
            lines: 14,
            length: 2,
            radius: 1.5,
        }).opts;
        Controls.WaitBar = WaitBar;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
var AFC;
(function (AFC) {
    var Controls;
    (function (Controls) {
        const _timeout = Symbol(), _resizeThreshold = 500;
        function _getValues(container) {
            let parent = container?.getElement();
            /*
                        if (view.left !== void 0 && view.width !== void 0) {
                            width = view.left + view.width;
                            if (parent.clientWidth > width)
                                left = (parent.clientWidth - width) >> 1;
                        }
                        if (view.top !== void 0 && view.height !== void 0) {
                            height = view.top + view.height;
                            if (parent.clientHeight > height)
                                top = (parent.clientHeight - height) >> 1;
                        }
                        */
            return parent ?
                { left: parent.offsetLeft, top: parent.offsetTop, width: parent.offsetWidth, height: parent.offsetHeight } :
                { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
        }
        class Window {
            constructor(context) {
                this._context = context;
                this[_timeout] = null;
            }
            getContainer() {
                return this._container;
            }
            setContainer(container) {
                this._container = container;
            }
            setContentView(view) {
                this.getElement().init(_getValues(this._container)).appendChild(view);
            }
            getElement() {
                let element = this._element;
                if (!element) {
                    let parent = this._container ? this._container.getElement() : document.body;
                    parent.appendChild(this._element = element = document.createElement('afc-gui-root'));
                    window.addEventListener('resize', this._handler = () => {
                        let timeout = this[_timeout];
                        (timeout !== null) && clearInterval(timeout);
                        this[_timeout] = setTimeout(() => element.resize(_getValues(this._container)), _resizeThreshold);
                    });
                }
                return element;
            }
            destroy() {
                if (this._element) {
                    window.removeEventListener('resize', this._handler);
                    delete this._handler;
                    this._element.parentNode.removeChild(this._element);
                    delete this._element;
                }
            }
        }
        Controls.Window = Window;
    })(Controls = AFC.Controls || (AFC.Controls = {}));
})(AFC || (AFC = {}));
//# sourceMappingURL=afc.js.map