/// <reference types="jquery" />
/// <reference types="jquery" />
/// <reference types="jquery" />
/// <reference types="jqueryui" />
/**
 * Created by jean.rennes on 25/09/2015.
 */
declare namespace AFC {
    const Version: string;
}
declare module 'afc' {
    export default AFC;
}
/**
 * Created by jean.rennes on 29/09/2015.
 */
declare namespace AFC.Tools {
    export const enum EventType {
        NetworkError = 1,
        NetworkBegin = 2,
        NetworkComplete = 3,
        IdentityError = 4,
        Internal = 5,
        Dirty = 6,
        UserEvent = 65536,
        Attach = 1073741824,
        Ready = 1073741825,
        Refresh = 1073741826
    }
    export interface IEventData {
        concat?: (d: any) => IEventData;
        onDispatch?: () => IEventData;
    }
    export interface IEvent<TObservable extends INotifier = INotifier, TData extends IEventData = IEventData> {
        type: EventType;
        target: TObservable;
        data?: TData;
    }
    export interface INotifier<TObservable extends INotifier = any, TData extends IEventData = IEventData> {
        on(type: EventType, callback: (event: IEvent<TObservable, TData>) => any, context?: any): any;
        off(type: EventType, callback: (event: IEvent<TObservable, TData>) => any, context?: any): any;
    }
    export interface IObservable<TObservable extends IObservable = any, TData extends IEventData = IEventData> extends INotifier<TObservable, TData> {
        once(type: EventType, callback: (event: IEvent<TObservable, TData>) => any, callbackref: any, context?: any): any;
        notify(type: EventType, callback: (event: IEvent<TObservable, TData>) => any): this;
        fireEvent(type: EventType, data?: TData): any;
        dispatchEvent(type: EventType, data?: TData): void;
    }
    export interface IPendingEvent {
        sink: IObservable & {
            dispatchEvent: (type: EventType, data?: IEventData) => any;
        };
        type: EventType;
        data?: IEventData;
    }
    export type Callable = (...args: any[]) => any;
    export var AfcReferenceMixin: (callback: Callable, ref: any) => Callable;
    export type Constructor<T = {}> = new (...args: any[]) => T;
    export interface IEventSink extends IObservable {
        countObservers(type: EventType): number;
    }
    export const EventSinkMixin: <T extends abstract new (...args: any[]) => any, TObservable extends IObservable = any, TData extends IEventData = IEventData>(Base: T) => abstract new (...args: any[]) => (InstanceType<T> & IEventSink);
    const EventSink_base: abstract new (...args: any[]) => {} & IEventSink;
    export class EventSink<TObservable extends IObservable = any, TData extends IEventData = IEventData> extends EventSink_base {
        constructor(target?: any);
    }
    export function observableObject<T extends Object>(t?: T): T & IObservable;
    export interface IForward {
        type: EventType;
        targetType?: EventType;
        observable: IObservable;
        callback: (event: IEvent) => any;
    }
    export class AutoSubscribeForwarder<TObservable extends IObservable = any, TData extends IEventData = IEventData> extends EventSink<TObservable, TData> {
        private static _update;
        protected _setForwards(forwards: IForward[]): void;
        once(type: EventType, callback: (event: IEvent<TObservable, TData>) => any, callbackref: any, context: any): void;
        on(type: EventType, callback: (event: IEvent<TObservable, TData>) => any, context?: any): void;
        off(type: EventType, callback: (event: IEvent<TObservable, TData>) => any, context?: any): void;
        dispatchEvent(type: EventType, data?: TData): void;
    }
    export {};
}
/**
 * Created by jean.rennes on 13/10/2015.
 */
declare namespace AFC.Data {
    const enum DataKind {
        unknown = 0,
        character = 1,
        real = 2,
        integer = 3,
        bool = 4,
        date = 5,
        time = 6,
        timestamp = 7,
        currency = 8,
        blob = 9,
        dynamic = 10,
        formula = 11,
        rectangle = 12,
        point = 1048576,
        line = 2097152,
        polygon = 4194304,
        geometry = 7340032
    }
    const enum TableType {
        undef = 0,
        table = 1,
        view = 2,
        query = 3,
        compound = 4,
        cubeView = 5,
        memory = 6,
        filter = 7,
        seamless = 8,
        history = 9,
        synonym = 10
    }
    const enum CreationType {
        query = 1,
        modification = 2,
        embedded = 3,
        historyView = 4
    }
    const enum Qualifier {
        identifier = 1,
        mainAddress = 2,
        address = 3,
        zipCode = 4,
        city = 5,
        country = 6,
        totalSurface = 7,
        surface = 8,
        symbol = 9,
        brand = 10,
        businessCode = 11,
        revenue = 12,
        changes = 13
    }
    interface IDataCreation {
        readonly type?: CreationType;
    }
    interface IQueryCreation extends IDataCreation {
        readonly type: CreationType.query;
        commandText: string;
        parameters?: {
            [key: string]: number | boolean | string | GeoJSON.GeometryObject;
        };
    }
    type IModificationEventValues = {
        [key: string]: any;
    };
    interface IModificationEventInfo {
        code: any;
        values: IModificationEventValues;
    }
    interface IModificationEvents {
        fullDeletion?: boolean;
        creations?: IModificationEventInfo[];
        modifications?: IModificationEventInfo[];
        deletions?: (number | string | ReadonlyArray<number | string>)[];
    }
    interface IModificationCreation extends IDataCreation {
        readonly type?: CreationType.modification;
        readonly reference: string;
        readonly events?: IModificationEvents;
        readonly branchInfo?: IDBHistoryBranchInfo;
    }
    interface IDBColumn {
        readonly name: string;
        readonly alias: string;
        readonly dataId: string;
        readonly type: DataKind;
        readonly size: number;
        readonly index: number;
        readonly nullable: boolean;
        readOnly?: boolean;
        toJSON(): any;
    }
    interface IDBColumnDefinition extends IDBColumn {
        qualifiers?: Qualifier[];
        geographicalLevel?: string;
        isSearchable?: boolean;
    }
    interface IDBTableDefinition {
        columns: ReadonlyArray<IDBColumnDefinition>;
        primaryKey?: ReadonlyArray<string>;
    }
    interface IDataTable {
        readonly columns: ReadonlyArray<IDBColumn>;
        readonly primaryKey?: ReadonlyArray<string>;
        readonly values: ReadonlyArray<ReadonlyArray<any>>;
    }
    const enum DataEventType {
        none = 0,
        create = 1,
        modify = 2,
        delete_ = 4,
        drop = 8,
        reset = 16
    }
    interface IKeyProvider {
        readonly columns: ReadonlyArray<IDBColumn>;
        readonly primaryKey: ReadonlyArray<string>;
        getKeyFromRow(row: ReadonlyArray<any>): ReadonlyArray<any>;
        compareKey(row: ReadonlyArray<any>, key: ReadonlyArray<any>): number;
        compareRow(row0: ReadonlyArray<any>, row1: ReadonlyArray<any>): number;
    }
    interface IColumnIndexProvider {
        readonly columnIndex: {
            readonly [key: string]: number;
        };
    }
    interface IRowCollection {
        readonly length: number;
        indexOf(row: ReadonlyArray<any>): number;
        getRow(index: number): ReadonlyArray<any>;
    }
    interface IDataItemContainer<T = {
        readonly [key: string]: any;
    }> {
        readonly dataItem: T;
        readonly dataItemIndex: number;
    }
    interface IDataSource<T = {
        readonly [key: string]: any;
    }> {
        readonly length: number;
        item(index: number): IDataItemContainer<T>;
    }
    interface IReadonlyStore extends IDataContainer {
        readonly tableDefinition: IDBTableDefinition;
        readonly key: ReadonlyArray<any>;
        readonly geometry: GeoJSON.Point | null;
        readonly identifier: string | null;
        readonly mainAddress: string | null;
        readonly address: string | null;
        readonly zipCode: string | null;
        readonly city: string | null;
        readonly country: string | null;
        readonly totalSurface: number | null;
        readonly surface: number | null;
        readonly symbol: string | null;
        readonly brand: string | null;
        readonly businessCode: string | null;
        readonly revenue: number | null;
        readonly changes: string | null;
        getData(column: string, stringify?: boolean): any;
        hasQualifier(qualifier: Qualifier): boolean;
        getQualifiedColumn(qualifier: Qualifier): IDBColumn;
        getColumn(name: string): IDBColumn;
    }
    const enum CheckMessageType {
        error = 0,
        info = 1,
        confirm = 2,
        user = 3
    }
    interface ICheckMessage {
        column: IDBColumnDefinition;
        message: string;
        type: CheckMessageType;
    }
    interface IStore extends IReadonlyStore, Tools.IObservable {
        readonly tableDescriptor: TableDescriptor;
        readonly exist: boolean;
        geometry: GeoJSON.Point | null;
        identifier: string | null;
        mainAddress: string | null;
        address: string | null;
        zipCode: string | null;
        city: string | null;
        country: string | null;
        totalSurface: number | null;
        surface: number | null;
        symbol: string | null;
        brand: string | null;
        businessCode: string | null;
        revenue: number | null;
        readonly changes: string | null;
        getOldData(column: string): any;
        setData(column: string, value: any): boolean;
        isDirty(columns?: ReadonlyArray<string>): boolean;
        checkColumn(column: string, callback: (column: IDBColumnDefinition, dirty: boolean, value: any, valid: boolean, message: Readonly<ICheckMessage>, indice: number) => any): void;
        check(callback: (valid: boolean, messages?: ReadonlyArray<Readonly<ICheckMessage>>) => any): void;
        commit(callback?: (valid: boolean, messages?: ReadonlyArray<Readonly<ICheckMessage>>) => any): void;
        close(): void;
        getState(): IReadonlyStore;
        invalidate(columns?: ReadonlyArray<string>): void;
    }
    interface IDataItemStoreData<S extends IReadonlyStore = IReadonlyStore> {
        readonly key: ReadonlyArray<any>;
        readonly store: S;
    }
    interface IReadonlyStoreSource<T extends IDataItemStoreData = IDataItemStoreData> extends IDataSource<T> {
        hasQualifier(qualifier: Qualifier): boolean;
        getQualifiedColumn(qualifier: Qualifier): IDBColumnDefinition;
        readonly fullName: string;
        readonly geometry: IDBColumnDefinition;
    }
    interface IDataEditor {
        create(key: ReadonlyArray<any>, values: {
            [key: string]: any;
        }): any;
        modify(key: ReadonlyArray<any>, values: {
            [key: string]: any;
        }): any;
        delete_(key: ReadonlyArray<any>): void;
    }
    interface IStoreSource<T extends IDataItemStoreData<IStore> = IDataItemStoreData<IStore>> extends IReadonlyStoreSource<T>, IDataEditor {
        check: (storeSource: IStoreSource, store: Store, column: IDBColumnDefinition, dirty: boolean, value: string, callback: (valid: boolean, message?: Readonly<ICheckMessage>) => void) => void;
        createStore(code?: any): Store;
        dropEvents: (key: ReadonlyArray<any>) => void;
    }
    interface IDataModelBase extends IDataTable, IDataSource {
        readonly primaryKey?: ReadonlyArray<string>;
        readonly columnIndex: {
            [key: string]: number;
        };
    }
    interface IDataModel extends IDataModelBase, IKeyProvider, Tools.IObservable, IRowCollection, IDataEditor {
        readonly primaryKey: ReadonlyArray<string>;
        indexOf(row: ReadonlyArray<any>): number;
        find(key: ReadonlyArray<any>): number;
    }
    interface IDataModelViewFilter {
        session?: string;
    }
    interface IDataModelView extends IDataModel, IDataCreation {
        branch?: string;
        branchInfo?: IDBHistoryBranchInfo;
        session: string;
        getVariations(): {
            row: ReadonlyArray<any>[];
            old: ReadonlyArray<any>[];
        };
        dropEvents(key: ReadonlyArray<any>, filter?: IDataModelViewFilter): void;
    }
    interface IEmbeddedCreation extends IDataCreation {
        readonly type: CreationType.embedded;
        columns: ReadonlyArray<IDBColumn>;
        primaryKey?: ReadonlyArray<string>;
        values: ReadonlyArray<ReadonlyArray<any>>;
    }
    interface IHistory {
        readonly stamp?: number;
        readonly refreshStamp?: number;
        readonly session?: string;
    }
    interface IHistoryView extends IDataCreation {
        reference: string;
        history: IHistory;
        branch?: string;
    }
    interface IDataEventItem {
        readonly type: DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none;
        readonly row: ReadonlyArray<any>;
        readonly committed: boolean;
    }
    interface IDataModelEventData<I extends IDataEventItem = IDataEventItem> extends Tools.IEventData {
        reset?: boolean;
        items?: I[];
    }
    type IDataEvent<I extends IDataEventItem = IDataEventItem> = Tools.IEvent<IDataModelBase & Tools.IObservable, Data.IDataModelEventData<I>>;
    interface IDataRecordEventData extends Tools.IEventData {
        columns: ReadonlyArray<Data.IDBColumn>;
    }
    interface IDataRecordEvent extends Tools.IEvent {
        target: IStore;
        data: IDataRecordEventData;
    }
    interface IDataContainer {
        getData: (key: string, stringify?: boolean) => any;
    }
    interface IDataContainerProvider extends Tools.IObservable {
        getDataContainer: () => Promise<IDataContainer>;
    }
    interface IFilterable<M extends Data.IRowCollection = Data.IRowCollection> {
        filter: ((row: ReadonlyArray<any>, dataModel: M) => boolean) | undefined;
    }
}
/**
 * Created by jean.rennes on 29/09/2015.
 */
declare namespace AFC.Rest {
    interface ICreationContext {
        dataCreations?: {
            [key: string]: Data.IDataCreation;
        };
    }
    interface IDataCreatorEntry<T extends Data.IDataCreation = Data.IDataCreation> {
        readonly key: string;
        readonly creation: T;
        readonly persist: boolean;
        show?: boolean;
    }
    type IContextModifierOptions = {
        [key: string]: any;
        noReplacements?: boolean;
    };
    interface IContextModifier<T extends IRequestBody = IRequestBody> {
        updateBody(body: T, options?: IContextModifierOptions): void;
        readonly load?: (options?: IContextModifierOptions) => Promise<any>;
        readonly release?: () => void;
    }
    class DataCreator<T extends IRequestBody<ICreationContext> = IRequestBody<ICreationContext>> extends Tools.EventSink implements IContextModifier<T> {
        private static _global;
        readonly base: IContextModifier;
        constructor(base?: IContextModifier);
        load(options?: IContextModifierOptions): Promise<any>;
        updateBody(body: IRequestBody<ICreationContext>, options?: IContextModifierOptions): void;
        createData<T extends Data.IDataCreation = Data.IDataCreation>(creation: T, autoDisable?: boolean): IDataCreatorEntry<T>;
        getData(id: string): Data.IDataCreation;
        updateData(id: string, creation: Data.IDataCreation): string;
        discardData(id?: string): void;
        clone(): DataCreator;
    }
    class DataResource<Type extends DataCreator> {
        protected _provider: Type;
        protected _entry: IDataCreatorEntry;
        get provider(): Type;
        get id(): string;
        create(provider: Type, creation: AFC.Data.IDataCreation): boolean;
        release(): void;
        clone<Type2 extends DataCreator>(provider: Type2): DataResource<Type2>;
    }
}
/**
 * Created by jean.rennes on 29/09/2015.
 */
declare namespace AFC.Rest {
    export interface IDataUpdate {
        readonly reference: string;
        readonly replacement: any;
    }
    class DataUpdates {
        readonly index: {
            [key: string]: any;
        };
        push(id: string, replacement: any): void;
        toJSON(): any;
    }
    export interface IDataUpdateContext extends ICreationContext {
        dataUpdates?: DataUpdates;
    }
    export class RequestBuilder<T extends IRequestBody<IDataUpdateContext> = IRequestBody<IDataUpdateContext>> extends DataCreator implements IContextModifier<T> {
        get modifiers(): IContextModifier<T>[];
        pushModifier<M extends IContextModifier<T> = IContextModifier<T>>(modifier: M): M;
        popModifier(modifier: IContextModifier<T>): void;
        load(options?: IContextModifierOptions): Promise<void[]>;
        updateBody(body: T, options?: IContextModifierOptions): T;
        clone(): RequestBuilder<T>;
        release(): void;
    }
    export class ContextSubstitute<T extends IRequestBody<IDataUpdateContext> = IRequestBody> implements IContextModifier<T>, IDataUpdate {
        readonly reference: string;
        replacement: string;
        constructor(reference: string, replacement?: string);
        updateBody(body: T): any;
    }
    export class ResourceSubstitute<T extends IRequestBody = IRequestBody> implements IContextModifier<T>, IDataUpdate {
        protected _resource: DataResource<DataCreator>;
        protected _replacement: string;
        readonly reference: string;
        readonly dataCreator: DataCreator;
        constructor(dataCreator: DataCreator, reference: string);
        get replacement(): string;
        set replacement(value: string);
        create(creation: AFC.Data.IDataCreation): void;
        updateBody(body: T): any;
        release(): void;
    }
    export {};
}
/**
 * Created by jean.rennes on 03/02/2016.
 */
declare namespace AFC.Tools.Data {
    import IDBColumn = AFC.Data.IDBColumn;
    export function checkGeometryType(column: AFC.Data.IDBColumn, geometryType: AFC.Data.DataKind): boolean;
    export function findFirstGeometry(data: AFC.Data.IDBTableDefinition | ReadonlyArray<AFC.Data.IDBColumn>, geometryType?: AFC.Data.DataKind): number;
    export var generateRndString: (l: number) => string;
    export function generateRndValue(column: IDBColumn): any;
    export function getKeyColumns(data: AFC.Data.IDataTable): IDBColumn[];
    export function isString(value: any): boolean;
    export function isNumber(value: any): boolean;
    export function isValid(kind: AFC.Data.DataKind, value: any): boolean;
    export function isValidKey(keyProvider: AFC.Data.IKeyProvider & AFC.Data.IColumnIndexProvider, value: any): boolean;
    export function equalValue(kind: AFC.Data.DataKind, v0: any, v1: any): boolean;
    export function splitSQLName(n: string): {
        dbName: string;
        name: string;
    };
    export function makeSQLName(dbName: string, name: string): string;
    export function getSQLNameParts(schema: AFC.Data.SchemaDescriptor, tableName: string): Promise<{
        dbName: string;
        name: string;
    }>;
    export function normalizeSQLName(schema: AFC.Data.SchemaDescriptor, tableName: string): Promise<string>;
    export function sort(dataModel: AFC.Data.IDataModel, columns: string[]): ReadonlyArray<any>[];
    export function mapRow(columns: ReadonlyArray<AFC.Data.IDBColumn>, row: ReadonlyArray<any>): {
        [key: string]: any;
    };
    export function toInteger(s: string, defaultValue?: number): number;
    export function toFloat(s: string, defaultValue?: number): number;
    export function toBoolean(s: string): boolean;
    export function castInputValue(column: AFC.Data.IDBColumn, value: string | boolean): any;
    export const QueryTemplateParameters: {
        1: string;
        2: string;
        3: string;
        4: string;
        5: string;
        1048576: string;
        2097152: string;
        4194304: string;
        7340032: string;
    };
    interface ITableComponent {
        key: ReadonlyArray<any>;
        row: ReadonlyArray<any>;
    }
    class TableIterator implements Iterator<ITableComponent> {
        readonly reader: TableReader;
        private _i;
        private _key;
        private _iEx;
        private _keyEx;
        private _next;
        private _nextEx;
        private _merge;
        constructor(reader: TableReader);
        next(): {
            done: boolean;
            value: ITableComponent;
        };
    }
    interface IDataTemplate {
        readonly columns: ReadonlyArray<IDBColumn>;
        readonly primaryKey: ReadonlyArray<string>;
        readonly columnIndex: {
            [key: string]: number;
        };
    }
    class PartReader {
        readonly values: ReadonlyArray<ReadonlyArray<any>>;
        readonly key: ReadonlyArray<number>;
        readonly index: ReadonlyArray<number>;
        constructor(dataModel: IDataTemplate, key: ReadonlyArray<number>, part: AFC.Data.IDataModelBase);
        getKey(i: number): ReadonlyArray<any>;
        getRow(i: number): ReadonlyArray<any>;
    }
    export class TableReader extends PartReader implements Iterable<ITableComponent> {
        readonly readerEx: PartReader;
        constructor(dataModel: IDataTemplate, dataModel0: AFC.Data.IDataModelBase, dataModel1: AFC.Data.IDataModelBase);
        getKeyEx(i: number): ReadonlyArray<any>;
        getRowEx(i: number): ReadonlyArray<any>;
        [Symbol.iterator](): TableIterator;
    }
    export function mergeTables(dataModel0: AFC.Data.IDataModelBase, dataModel1?: AFC.Data.IDataModelBase, dataModel?: IDataTemplate): AFC.Data.DataModel;
    export {};
}
declare namespace AFC.Application {
    type Primitive = bigint | boolean | null | number | string | symbol | undefined;
    export type JSONValue = Primitive | JSONObject | JSONArray;
    interface JSONObject {
        [key: string]: JSONValue;
    }
    interface JSONArray extends Array<JSONValue> {
    }
    export class Parcel {
        [key: string | number]: JSONValue;
    }
    export interface IParcelable<T = any> {
        writeToParcel(out: Parcel): void;
    }
    export namespace Parcelable {
        interface Creator<T = any> {
            createFromParcel(parcel: Parcel): T;
        }
        const Creator: new <T = any>(createFromParcel: (parcel: Parcel) => T) => Creator<T>;
        function writeToParcel(parcelable: IParcelable): Parcel;
        function createFromParcel<T extends IParcelable>(parcel: Parcel): T;
    }
    export {};
}
/**
 * Created by jean.rennes on 20/11/2015.
 */
declare namespace AFC.Rest {
    export const enum ConnectionStatus {
        ok = 1,
        failed = 2,
        maxConnection = 3,
        error = 4,
        resetPassword = 5,
        timeout = 6
    }
    interface IRequestInfo {
        session?: string;
        rnd?: string;
    }
    export interface IUserRequestInfo extends IRequestInfo {
        name: string;
        password: string;
    }
    export interface ISecurityToken {
        providerKey: any;
        provider: any;
        productKey: string;
        creationDate: Date;
        expiryDate: Date;
        data?: any;
    }
    export interface IUserResponseInfo {
        status: number;
        userName?: string;
        credentials?: string;
        data?: any;
    }
    export interface IIdentity<T = any> extends Application.IParcelable<IIdentity<T>> {
        readonly authorizationPolicy: IAuthorizationPolicy;
        readonly name: string;
        readonly isAuthenticated: boolean;
        readonly status: ConnectionStatus;
        readonly data: T;
        readonly logoutUri: string;
        getAjaxBody(): string;
        getCredentials<T = {
            [key: string]: any;
        }>(): T;
        refresh(): Promise<this>;
        invalidate(): void;
    }
    export interface IAuthorizationPolicy extends UrlLoader {
        init(): Promise<AuthType>;
        invalidate(): void;
        getIdentity(): Promise<IIdentity>;
        restart(loose?: boolean): void;
    }
    export const enum AuthType {
        uninitialized = 0,
        loading = 1,
        error = 2,
        self = 3,
        direct = 16,
        openIdForward = 1048576,
        authorizationCode = 1048592
    }
    interface IIdentityEx extends IIdentity {
    }
    export class UrlLoader {
        readonly searchParams: URLSearchParams;
        constructor();
    }
    const AuthorizationPolicy_base: abstract new (...args: any[]) => UrlLoader & Tools.IEventSink;
    export class AuthorizationPolicy extends AuthorizationPolicy_base implements IAuthorizationPolicy {
        readonly baseUrl: string;
        private _sequence;
        static Identity: {
            new (policy: AuthorizationPolicy, userName?: string, credentials?: string, status?: ConnectionStatus, data?: any): IIdentityEx;
        };
        constructor(url: string);
        getLogoutUri(): string;
        protected _onTokenAlways(sequence: number, key: string, jqXHR: JQueryXHR, textStatus: string): void;
        protected _getBody(key: string, message: any): string;
        protected _buildAjaxSettings(key: string, endPoint: string, message?: IRequestInfo & {
            [key: string]: any;
        }): JQueryAjaxSettings;
        protected _loadCertificate(url: string): Promise<boolean>;
        protected _setAuthorizationCode(code: string): Promise<IIdentity>;
        protected _refresh<U extends InstanceType<typeof AuthorizationPolicy.Identity>>(identity: U): Promise<U>;
        restart(loose?: boolean): void;
        getAuthorizationUri(): string;
        getRedirectUri(): string;
        init(): Promise<AuthType>;
        getIdentity(): Promise<IIdentity>;
        setDirectIdentity(name: string, password: string): Promise<IIdentity>;
        resetPasswordUntrusted(name: string, oldPassword: string, newPassword: string): Promise<IIdentity>;
        resetPasswordTrusted(credentials: string, newPassword: string): Promise<IIdentity>;
        sendReminder(name: string, returnUrl: string): Promise<boolean>;
        invalidate(): void;
    }
    export class SelfAuthorizationPolicy<T = any> extends UrlLoader implements IAuthorizationPolicy {
        constructor(key: string, name: string, data?: T);
        init(): Promise<AuthType>;
        restart(loose?: boolean): void;
        getIdentity(): Promise<IIdentity<T>>;
        getAuthorizationUri(): string;
        invalidate(): void;
    }
    export {};
}
/**
 * Created by jean.rennes on 27/01/2016.
 */
declare namespace AFC {
    type PartialMutable<T> = {
        -readonly [P in keyof T]+?: T[P];
    };
    type Mutable<T> = {
        -readonly [P in keyof T]: T[P];
    };
    namespace Tools {
        function lower_bound<Item, Value>(a: ReadonlyArray<Item>, v: Value, pred?: (item: Item, value: Value) => number): number;
        function findById<Interface extends {
            id: string;
        }>(id: string, interfaces: ReadonlyArray<Interface>): Interface;
        function indexOf(a: {
            readonly length: number;
            [index: number]: any;
        }, pred: (item: any) => boolean): number;
        function findByIdOrName<Interface extends {
            id: string;
            name?: string;
        }>(id: string, interfaces: ReadonlyArray<Interface>, filter?: (i: Interface) => boolean): Interface;
        function arrayCompare(v0: ReadonlyArray<any>, v1: ReadonlyArray<any>): number;
        const alert: (activity: Application.Activity, message: string, title?: string) => Promise<boolean>;
        const confirm: (activity: Application.Activity, message: string, title?: string) => Promise<boolean>;
        namespace Lang {
            const enum Locale {
                fr = 1,
                us = 2,
                en = 3
            }
        }
        namespace Style {
            function convertColor(v: number): string;
            function convertRGBAColor(v: number): string;
            const transparent1Pixel = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";
        }
        namespace StringTools {
            function normalizeString(s: string): string;
            function buildUrl(host: string, path: string, secure?: boolean, port?: number): string;
            class FormatString {
                protected _format: string;
                protected _datakind: AFC.Data.DataKind;
                private _decodedFormat;
                constructor(format: string, datakind: AFC.Data.DataKind);
                getFormated(value: any): string;
                isNumeric(): boolean;
                private _decodeFormat;
            }
        }
    }
}
/**
 * Created by jean.rennes on 27/01/2016.
 */
declare namespace AFC.Data {
    function DataSourceMixin<T extends Tools.Constructor<{}>>(Base: T): (abstract new (...args: any[]) => {
        readonly columns: readonly IDBColumn[];
        readonly values: readonly (readonly any[])[];
        readonly length: number;
        item(index: number): AFC.Data.IDataItemContainer<T>;
        [Symbol.iterator](): Iterator<IDataItemContainer<T>, null>;
    }) & T;
    const DataSource: Tools.Constructor<Tools.EventSink & IDataSource>;
    type DataSource = typeof DataSource;
}
/**
 * Created by jean.rennes on 11/02/2019.
 */
declare namespace AFC.Data {
    function compareValue(v0: any, v1: any): number;
    function compareRows(columns: ReadonlyArray<number>, row0: ReadonlyArray<any>, row1: ReadonlyArray<any>): number;
    class RowComparator {
        readonly getKeyFromRow: (row: ReadonlyArray<any>) => ReadonlyArray<any>;
        readonly compareKey: (row: ReadonlyArray<any>, key: ReadonlyArray<any>) => number;
        readonly compareRow: (row0: ReadonlyArray<any>, row1: ReadonlyArray<any>) => number;
        constructor(columns: ReadonlyArray<number>);
    }
    class Index extends RowComparator {
        readonly values: ReadonlyArray<any>[];
        constructor(columns: ReadonlyArray<number>, rows: ReadonlyArray<ReadonlyArray<any>>);
    }
    class UniqueIndex extends Index {
        clone(): UniqueIndex;
        find(key: ReadonlyArray<any>): number;
        lowerKeyBound(value: any): number;
        indexOf(row: ReadonlyArray<any>): number;
        lowerBound(row: ReadonlyArray<any>): number;
        insert(indice: number, row: ReadonlyArray<any>): void;
        modify(indice: number, row: ReadonlyArray<any>): void;
        delete_(indice: number): void;
    }
}
/**
 * Created by jean.rennes on 27/01/2016.
 */
declare namespace AFC.Data {
    interface IHistorizedDataEventItemBase<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none> extends IDataEventItem {
        readonly branch: number;
        readonly type: T;
    }
    export type IHistorizedDataEventItem<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none = DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none> = T extends DataEventType.create | DataEventType.modify ? IHistorizedDataEventItemBase<T> & {
        readonly values: {
            readonly [key: string]: any;
        };
    } : IHistorizedDataEventItemBase<T>;
    interface IDataModelArray extends Array<any> {
        __pos: number;
    }
    interface IHistorizedDataEventItemBaseEx<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none> extends Mutable<IHistorizedDataEventItemBase<T>> {
        row: IDataModelArray;
    }
    type IHistorizedDataEventItemEx<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none = DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none> = T extends DataEventType.create | DataEventType.modify ? IHistorizedDataEventItemBaseEx<T> & {
        values: {
            readonly [key: string]: any;
        };
    } : IHistorizedDataEventItemBaseEx<T>;
    type IHistorizedDataEventInfo<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none = DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none> = IHistorizedDataEventItemEx<T> & {
        stamp: number;
        session: number;
    };
    interface IDataEventSeedBase<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none | DataEventType.drop | DataEventType.reset> {
        type: T;
        branch: number;
        session: number;
    }
    type IDataEventDropSeed = IDataEventSeedBase<DataEventType.drop> & {
        filter: IDataModelViewFilter;
        key: ReadonlyArray<any>;
    };
    interface IDataEventUpdateSeedBase<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none> extends IDataEventSeedBase<T> {
        info?: IHistorizedDataEventInfo<T>;
        key: ReadonlyArray<any>;
    }
    type IDataEventUpdateSeed<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none = DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none> = T extends DataEventType.create | DataEventType.modify ? IDataEventUpdateSeedBase<T> & {
        values: {
            [key: string]: any;
        };
    } : IDataEventUpdateSeedBase<T>;
    type ISeed<T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none | DataEventType.drop | DataEventType.reset = DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none | DataEventType.drop | DataEventType.reset> = T extends DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.none ? IDataEventUpdateSeed<T> : T extends DataEventType.drop ? IDataEventDropSeed : IDataEventSeedBase<DataEventType.reset>;
    interface ISeedsEvent extends Tools.IEvent {
        data: ISeed[];
    }
    class ModifiedArray extends Array implements IDataModelArray {
        __pos: number;
        constructor(pos: number, row?: IDataModelArray);
        clone(): ModifiedArray;
    }
    export class DataEventData implements IDataModelEventData {
        reset: boolean;
        items: IDataEventItem[];
        constructor(items?: IDataEventItem[], reset?: boolean);
        concat(d: IDataModelEventData): DataEventData;
    }
    interface IDataEventData extends DataEventData {
        items: IHistorizedDataEventItemEx[];
    }
    export class DBColumn implements IDBColumn {
        readonly name: string;
        readonly alias: string;
        readonly dataId: string;
        readonly type: DataKind;
        readonly size: number;
        readonly index: number;
        readonly nullable: boolean;
        readonly readOnly: boolean;
        constructor(name: string, type: DataKind, index: number, size?: number, alias?: string, readOnly?: boolean, nullable?: boolean, dataId?: string);
        toJSON(): any;
    }
    abstract class DataCreation implements IDataCreation {
        abstract get type(): CreationType;
        toJSON(): any;
    }
    export class QueryCreation extends DataCreation implements IQueryCreation {
        commandText: string;
        parameters?: {
            [key: string]: number | boolean | string | GeoJSON.GeometryObject;
        };
        constructor(commandText: string, parameters?: {
            [key: string]: number | boolean | string | GeoJSON.GeometryObject;
        });
        get type(): CreationType.query;
        toJSON(): any;
    }
    export class ModificationCreation extends DataCreation implements IModificationCreation {
        readonly reference: string;
        readonly events: IModificationEvents;
        readonly branchInfo: IDBHistoryBranchInfo;
        constructor(reference: string, events: IModificationEvents, branchInfo?: IDBHistoryBranchInfo);
        get type(): CreationType.modification;
        toJSON(): any;
    }
    export class EmbeddedCreation extends DataCreation implements IEmbeddedCreation {
        columns: ReadonlyArray<IDBColumn>;
        primaryKey: ReadonlyArray<string>;
        values: ReadonlyArray<ReadonlyArray<any>>;
        constructor(columns: ReadonlyArray<IDBColumn>, primaryKey: ReadonlyArray<string>, values: ReadonlyArray<ReadonlyArray<any>>);
        get type(): CreationType.embedded;
        toJSON(): any;
    }
    export function isValidHistory(history: IHistory): boolean;
    export class HistoryView extends DataCreation implements IHistoryView {
        readonly reference: string;
        readonly history: IHistory;
        readonly branch: string;
        constructor(reference: string, history?: IHistory, branch?: string);
        get type(): CreationType.historyView;
        toJSON(): any;
    }
    export function mapDataColumns(definition: {
        columns: ReadonlyArray<{
            name: string;
            type: string;
            alias?: string;
            dataId?: string;
            size?: number;
            isPseudoColumn?: boolean;
            notNullable?: boolean;
        }>;
        primaryKey?: ReadonlyArray<string>;
    }): IDBColumn[];
    export function updateDataRows(columns: ReadonlyArray<IDBColumn>, rows: any[][]): any[][];
    export function updateTableData(data: {
        columns: ReadonlyArray<{
            name: string;
            type: string;
            alias?: string;
            dataId?: string;
            size?: number;
            isPseudoColumn?: boolean;
            notNullable?: boolean;
        }>;
        primaryKey?: ReadonlyArray<string>;
        values?: any[][];
    }): IDataTable;
    export function compareKey(key0: ReadonlyArray<any>, key1: ReadonlyArray<any>): number;
    export function getColumnIndex(columns: ReadonlyArray<IDBColumn>): {
        [key: string]: number;
    };
    abstract class DataModelBaseEx extends DataSource implements IDataModelBase, IDataCreation {
        readonly columns: ReadonlyArray<IDBColumn>;
        readonly columnIndex: {
            readonly [key: string]: number;
        };
        values: ReadonlyArray<ReadonlyArray<any>>;
        abstract primaryKey: ReadonlyArray<string>;
        constructor(columns: ReadonlyArray<IDBColumn>, values?: ReadonlyArray<ReadonlyArray<any>>);
        get type(): CreationType;
        toJSON(): any;
    }
    export class DataModelBase extends DataModelBaseEx {
        readonly primaryKey: ReadonlyArray<string>;
        constructor(columns: ReadonlyArray<IDBColumn>, primaryKey?: ReadonlyArray<string>, values?: ReadonlyArray<ReadonlyArray<any>>);
    }
    interface IModel {
        readonly columns: ReadonlyArray<IDBColumn>;
        readonly columnIndex: {
            readonly [key: string]: number;
        };
    }
    export function createRowFromValues(model: IModel, key: ReadonlyArray<any>, values: {
        [key: string]: any;
    }, newValues?: {
        [key: string]: any;
    }): ReadonlyArray<any>;
    export function modifyRowWithValues(model: IModel, row: ReadonlyArray<any>, values: {
        [key: string]: any;
    }, oldValues?: {
        [key: string]: any;
    }, newValues?: {
        [key: string]: any;
    }): ReadonlyArray<any>;
    export class DataModel extends DataModelBaseEx implements IDataModel {
        protected _index: UniqueIndex;
        protected _primaryKey: ReadonlyArray<number>;
        constructor(columns: ReadonlyArray<IDBColumn>, primaryKey: ReadonlyArray<string>, values?: ReadonlyArray<ReadonlyArray<any>>);
        get primaryKey(): ReadonlyArray<string>;
        setValues(values?: ReadonlyArray<ReadonlyArray<any>>, noFire?: boolean): void;
        getKeyFromRow(row: ReadonlyArray<any>): ReadonlyArray<any>;
        compareKey(row: ReadonlyArray<any>, key: ReadonlyArray<any>): number;
        compareRow(row0: ReadonlyArray<any>, row1: ReadonlyArray<any>): number;
        create(key: ReadonlyArray<any>, values: {
            [key: string]: any;
        }): boolean;
        modify(key: ReadonlyArray<any>, values: {
            [key: string]: any;
        }): boolean;
        delete_(key: ReadonlyArray<any>): boolean;
        indexOf(row: ReadonlyArray<any>): number;
        find(key: ReadonlyArray<any>): number;
        getRow(index: number): ReadonlyArray<any>;
    }
    class DataModelMap {
        protected _counter: number;
        protected _dict: any;
        constructor();
        add(value: string): number;
        remove(value: number | string): void;
        get(value: string): number;
        get(value: number): string;
    }
    abstract class BranchBaseEx extends DataSource implements IDataModelView {
        protected readonly _pool: Pool;
        protected readonly _map: DataModelMap;
        protected readonly _branch: number;
        protected _dispatcher: EventDispatcher;
        protected _dataModel: DataModelRef;
        protected _session: number;
        protected _index: UniqueIndex;
        constructor(pool: Pool, map: DataModelMap, branch: number);
        protected static _ready(branch: BranchBaseEx, callback: () => any): void;
        static getIndex(branch: BranchBaseEx): UniqueIndex;
        static cloneIndex(branch: BranchBaseEx): UniqueIndex;
        static branchNb(branch: BranchBaseEx): number;
        static sessionNb(branch: BranchBaseEx): number;
        protected _init(dataModel: DataModelRef, dispatcher: EventDispatcher): void;
        protected abstract _getReferenceRow(pos: number): IDataModelArray;
        protected abstract _createIndex(): UniqueIndex;
        protected _createInternal(i: number, key: ReadonlyArray<any>, values: {
            [key: string]: any;
        }, pos?: number, filteredValues?: {
            [key: string]: any;
        }): ModifiedArray;
        protected _create(key: ReadonlyArray<any>, values: {
            [key: string]: any;
        }, committed: boolean, pos?: number): IHistorizedDataEventInfo;
        protected _modifyInternal(i: number, values: {
            [key: string]: any;
        }, oldValues?: {
            [key: string]: any;
        }, filteredValues?: {
            [key: string]: any;
        }): ModifiedArray;
        protected _modify(key: ReadonlyArray<any>, values: {
            [key: string]: any;
        }, committed: boolean, oldValues?: {
            [key: string]: any;
        }): IHistorizedDataEventInfo;
        protected _deleteInternal(i: number): IDataModelArray;
        protected _delete(key: ReadonlyArray<any>): IHistorizedDataEventInfo;
        protected _restoreRow(sample: IDataModelArray, reference?: IDataModelArray): number;
        protected _dropEvent(key: ReadonlyArray<any>, filter: IDataModelViewFilter): IHistorizedDataEventItemEx;
        protected _refresh(): void;
        protected _onAttach(): void;
        getRow(pos: number): IDataModelArray;
        applySeeds(seeds: (IDataEventUpdateSeed | IDataEventDropSeed)[], stamp: number, committed: boolean): IDataEventData;
        set session(value: string);
        get session(): string;
        get columns(): ReadonlyArray<IDBColumn>;
        get primaryKey(): ReadonlyArray<string>;
        get values(): ReadonlyArray<any>[];
        get columnIndex(): {
            [key: string]: number;
        };
        get type(): CreationType;
        getKeyFromRow(row: ReadonlyArray<any>): ReadonlyArray<any>;
        compareKey(row: ReadonlyArray<any>, key: ReadonlyArray<any>): number;
        compareRow(row0: ReadonlyArray<any>, row1: ReadonlyArray<any>): number;
        create(key: ReadonlyArray<any>, values: {
            [key: string]: any;
        }): void;
        modify(key: ReadonlyArray<any>, values: {
            [key: string]: any;
        }): void;
        delete_(key: ReadonlyArray<any>): void;
        find(key: ReadonlyArray<any>): number;
        indexOf(row: ReadonlyArray<any>): number;
        dropEvents(key: ReadonlyArray<any>, filter: IDataModelViewFilter): void;
        reset(allSession: boolean): void;
        toJSON(): any;
        getVariations(): {
            row: IDataModelArray[];
            old: IDataModelArray[];
        };
    }
    export class Pool {
        protected readonly _map: DataModelMap;
        trunk: TrunkModel;
        branches: BranchModel[];
        constructor(map: DataModelMap);
        dispatchSeeds(branch: number, seeds: (IDataEventUpdateSeed | IDataEventDropSeed)[], stamp: number, commit?: boolean): IDataEventData;
        findBranch(b: number): BranchModel;
        attach(viewModel: BranchModel): void;
        detach(viewModel: BranchModel): void;
    }
    export class EventDispatcher extends Tools.EventSink {
        readonly pool: Pool;
        stamp: number;
        dataEvents: IHistorizedDataEventInfo[];
        constructor(eventTarget: any, pool: Pool);
        protected _filterResetEvents(seeds: ISeed[]): ISeed<DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.drop>[];
        protected _onEvents(e: ISeedsEvent): void;
        pushEvent(e: ISeed<DataEventType.create | DataEventType.modify | DataEventType.delete_ | DataEventType.drop | DataEventType.reset>): void;
    }
    class DataModelRef extends DataModelBaseEx {
        protected _primaryKey: ReadonlyArray<number>;
        readonly values: ReadonlyArray<IDataModelArray>;
        protected _cnt: number;
        constructor(columns: ReadonlyArray<IDBColumn>, primaryKey: ReadonlyArray<string>, values: ReadonlyArray<any>[]);
        get primaryKey(): ReadonlyArray<string>;
        getKeyForContext(row: IDataModelArray): any;
        createContextInfo(row: IDataModelArray, old?: IDataModelArray): IModificationEventInfo;
        createIndex(): UniqueIndex;
        getKeyFromRow(row: ReadonlyArray<any>): ReadonlyArray<any>;
        create(): number;
    }
    class TrunkModel extends BranchBaseEx {
        protected _branch: never;
        protected _pool: Pool;
        protected _dataModel: DataModelRef;
        protected _session: number;
        constructor(pool: Pool, map: DataModelMap);
        protected _getReferenceRow(pos: number): IDataModelArray;
        protected _createIndex(): UniqueIndex;
        get branch(): string;
    }
    class BranchModel extends BranchBaseEx {
        branchInfo: IDBHistoryBranchInfo;
        constructor(pool: Pool, map: DataModelMap, dataModel: DataModelRef, dispatcher: EventDispatcher, branch: string);
        protected _createIndex(): UniqueIndex;
        protected _getReferenceRow(pos: number): IDataModelArray;
        get branch(): string;
        release(): void;
    }
    export class DataRecordProvider extends Tools.AutoSubscribeForwarder implements IDataContainerProvider {
        protected readonly _dataModel: IDataModel;
        protected _index: UniqueIndex;
        protected _key: any[];
        protected _record: DataRecord;
        constructor(dataModel: IDataModel);
        protected _onDirty(e: IDataEvent): void;
        protected get index(): UniqueIndex;
        set key(value: any[]);
        getDataContainer(): Promise<IDataContainer>;
    }
    class HistorizedModelBase extends TrunkModel {
        constructor(pool: Pool, map: DataModelMap);
        protected _getBranch(s: string): BranchModel;
        initFrom(columns: ReadonlyArray<IDBColumn>, primaryKey: ReadonlyArray<string>, rows?: any[][]): void;
        ready(): Promise<void>;
        findBranch(s: string): BranchModel;
        getBranch(s: string): Promise<BranchModel>;
        releaseBranch(s: string): void;
        generateEvents(s?: string): Data.IModificationEvents;
        appendEvents(events: IModificationEvents, commit: boolean, branch: string, session: string): void;
    }
    export interface IHistorizedModelRemote {
        confirmUpdate?: (pendings: IUpdateCommandResult) => Promise<boolean>;
        onUpdate: (results: ReadonlyArray<Data.IUpdateCommandResult>, force: boolean) => void;
    }
    export class HistorizedModel extends HistorizedModelBase {
        constructor(remote?: IHistorizedModelRemote);
        initFrom(columns: ReadonlyArray<IDBColumn>, primaryKey: ReadonlyArray<string>, rows?: any[][], content?: ITableResourceContent): void;
    }
    export {};
}
/**
 * Created by jean.rennes on 19/05/2016.
 */
declare namespace AFC.Data {
    export const enum DBOpenStatus {
        open = 0,
        failed = 1,
        closed = 2
    }
    export const enum HistoryEventType {
        none = 0,
        backup = 1,
        creation = 2,
        modification = 3,
        deletion = 4,
        cancel = 5
    }
    export const enum HistoryBranchStatus {
        none = 0,
        archive = 1,
        remove = 2
    }
    export interface IDBHistoryEventsFilter {
        stamp?: number;
        refreshStamp?: number;
        age?: number;
        authors?: string[];
        session?: string;
        branches?: (string | number)[];
    }
    export interface IDBHistoryEvent {
        id: string;
        type: HistoryEventType;
        author: string;
        eventDate: Date;
        dateOfEffect: Date;
        data: IModificationEventInfo;
    }
    export interface IDBHistoryBranchInfo {
        properties?: Application.JSONValue;
        description?: string;
        rating?: number;
    }
    export interface IDBHistoryBranchBase extends IDBHistoryBranchInfo {
        id: string;
        author: string;
        creationDate: Date;
        status?: HistoryBranchStatus;
        name?: string;
        bbox?: number[];
    }
    export interface IDBHistoryBranchRow extends IDBHistoryBranchBase {
        values?: {
            [key: string]: any;
        }[];
    }
    export interface IDBHistoryBranchesFilter {
        ids?: [string, ...string[]];
        authors?: [string, ...string[]];
        age?: number;
        proximity?: {
            location: [number, number];
            distance: number;
        };
        timeReference?: Date;
    }
    export type IDBHistoryBranchesFilters = IDBHistoryBranchesFilter | IDBHistoryBranchesFilter[];
    export interface IDBHistoryDataSelector {
        columns: string[];
        history?: IHistory;
        fromProperties: string;
    }
    export interface IDBHistoryBranch extends IDBHistoryBranchBase {
        events: IDBHistoryEvent[];
    }
    interface ITableBase {
        name: string;
        alias: string;
        type: string;
        interactiveMode?: boolean;
        isHistorized?: boolean;
        stamp?: number;
        refreshStamp?: number;
    }
    interface IDatabase {
        id: string;
        name: string;
        status: string;
        error?: string;
        readOnly?: boolean;
        noCache?: boolean;
    }
    export function qualifier(value: Qualifier): keyof typeof AFC.Data.Qualifier;
    export function qualifier(value: string): Qualifier;
    export class DBColumnDefinition extends DBColumn implements IDBColumnDefinition {
        readonly qualifiers: Qualifier[];
        readonly geographicalLevel: string;
        readonly isSearchable: boolean;
        constructor(name: string, type: DataKind, index: number, size?: number, alias?: string, readOnly?: boolean, qualifiers?: Qualifier[], geographicalLevel?: string, isSearchable?: boolean);
    }
    export function dataKind(value: DataKind): string;
    export function dataKind(value: string): DataKind;
    export class TableDescriptor extends Tools.EventSink implements Controls.IListItem {
        protected _sequence: number;
        protected _definition: IDBTableDefinition & {
            stamp?: number;
            refreshStamp?: number;
        };
        readonly database: DatabaseDescriptor;
        readonly name: string;
        readonly alias: string;
        readonly type: TableType;
        readonly interactiveMode: boolean;
        constructor(d: DatabaseDescriptor, i: ITableBase);
        get id(): string;
        get fullName(): string;
        get isHistoricized(): boolean;
        invalidate(): void;
        createAjaxRequest<T = any>(path?: string, bypassContext?: boolean, options?: Rest.IRestRequestOptions): Rest.IAjaxRequest<T>;
        protected _onRestAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void;
        getDefinition(): Promise<IDBTableDefinition>;
    }
    export function historyBranchStatus(value: HistoryBranchStatus): string;
    export function historyBranchStatus(value: string): HistoryBranchStatus;
    export class HistoricizedTableDescriptor extends TableDescriptor {
        get isHistoricized(): boolean;
        requestStamps(callback: (stamp: number, refreshStamp: number, sequence: number) => void): number;
        private _doSingleOperation;
        insertBranch(options?: {
            properties?: Application.JSONValue;
            description?: string;
            rating?: number;
            status?: HistoryBranchStatus;
        }): Promise<IDBHistoryBranchBase>;
        deleteBranch(name: string): Promise<IDBHistoryBranchBase>;
        updateBranch(name: string, { properties, description, rating, status }: {
            properties?: Application.JSONValue;
            description?: string;
            rating?: number;
            status?: HistoryBranchStatus;
        }): Promise<IDBHistoryBranchBase>;
        selectBranches(options?: {
            filter?: IDBHistoryBranchesFilters;
            dataSelector?: IDBHistoryDataSelector;
        }): Promise<IDBHistoryBranchRow[]>;
        getBranchInfo(id: string, history?: IHistory): Promise<IDBHistoryBranch>;
        rollbackEvents(codes: any[], callback: (e: IDBHistoryEvent[]) => any, options?: {
            session?: string;
            filter?: IDBHistoryEventsFilter;
        }): number;
    }
    export type DatabaseInfoItem = {
        description: string;
        version: string;
    };
    export type DatabaseInfoVersion = {
        title: string;
        items: DatabaseInfoItem[];
    };
    export type DatabaseInfo = IDatabase & {
        versions: DatabaseInfoVersion[];
    };
    export class DatabaseDescriptor extends Tools.EventSink implements Controls.IListItem {
        protected _tables: TableDescriptor[];
        protected _sequence: number;
        readonly schema: SchemaDescriptor;
        readonly id: string;
        readonly name: string;
        readonly status: DBOpenStatus;
        readonly error: string;
        readonly readOnly: boolean;
        readonly noCache: boolean;
        constructor(schema: SchemaDescriptor, database: IDatabase);
        invalidate(): void;
        createAjaxRequest<T = any>(path?: string, bypassContext?: boolean, options?: Rest.IRestRequestOptions): Rest.IAjaxRequest<T>;
        private _onRestAlways;
        getTables(): Promise<ReadonlyArray<TableDescriptor>>;
        getInfo(): Promise<DatabaseInfo>;
        refresh(): void;
    }
    export class SchemaDescriptor extends Tools.EventSink {
        readonly restModel: Rest.RestModel;
        private _databases;
        private _sequence;
        constructor(restModel: Rest.RestModel);
        invalidate(): void;
        createAjaxRequest<T = any>(path?: string, bypassContext?: boolean, options?: Rest.IRestRequestOptions): Rest.IAjaxRequest<T>;
        private _onRestAlways;
        getDatabases(): Promise<ReadonlyArray<DatabaseDescriptor>>;
    }
    export function getDatabase(schema: SchemaDescriptor, dbName: string): Promise<DatabaseDescriptor>;
    export function getTable(schema: SchemaDescriptor, dbName: string, tableName: string): Promise<TableDescriptor>;
    export {};
}
/**
 * Created by jean.rennes on 10/03/2016.
 */
declare namespace AFC.Globals {
    export const enum LayerType {
        raster = -1,
        unknown = 0,
        polygon = 1,
        line = 2,
        symbol = 3,
        pie = 4,
        label = 5,
        olap = 100,
        mxd = 200
    }
    export interface IGeoJsonProperties {
        data: ReadonlyArray<any>;
    }
    export type GeoJSONFeature<P extends IGeoJsonProperties = IGeoJsonProperties> = GeoJSON.Feature<GeoJSON.GeometryObject, P>;
    export type GeoJSONFilterOverride = (visible: boolean, feature: GeoJSONFeature) => boolean;
    export interface GeoJSONOptionOverrides extends L.LayerOptions {
        style: L.PathOptions | ((options: L.LayerOptions, feature: GeoJSONFeature) => L.PolylineOptions);
        pointToLayer?(options: L.LayerOptions, point: GeoJSON.Feature<GeoJSON.Point>, latlng: L.LatLng): L.Layer;
        onEachFeature?(options: L.LayerOptions, feature: GeoJSONFeature, layer: L.Layer): void;
        coordsToLatLng?(options: L.LayerOptions, coords: [number, number] | [number, number, number]): L.LatLng;
    }
    export interface IThematicValue<T = any> {
        readonly value: T;
        readonly pattern: string;
    }
    export interface IThematic<T = any> {
        readonly title: string;
        readonly columns: ReadonlyArray<string>;
        readonly classes: ReadonlyArray<IThematicValue<T>>;
    }
    export interface ILayerProperty<V = any, T extends IThematic<V> = IThematic<V>, C extends string = string> {
        readonly value: V;
        readonly column?: C;
        readonly thematic?: T;
    }
    export interface IShadowValue {
        readonly dx: number;
        readonly dy: number;
        readonly hardness: number;
        readonly transparency: number;
        readonly color: number;
    }
    export interface ILayerProperties {
        readonly transparency?: ILayerProperty<number>;
        readonly color?: ILayerProperty<number>;
        readonly visibility?: ILayerProperty<boolean, never>;
        readonly shadow?: ILayerProperty<IShadowValue, never, never>;
    }
    export interface ISymbolProperties extends ILayerProperties {
        readonly fillColor?: ILayerProperty<number>;
        readonly size?: ILayerProperty<number>;
        readonly icon?: ILayerProperty<string, never>;
        readonly clustering?: ILayerProperty<boolean, never>;
    }
    export interface IPolygonProperties extends ILayerProperties {
        readonly fillColor?: ILayerProperty<number>;
        readonly weight?: ILayerProperty<number>;
        readonly pattern?: ILayerProperty<number>;
        readonly patternBkColor?: ILayerProperty<number>;
        readonly patternAngle?: ILayerProperty<number>;
        readonly patternSpacing?: ILayerProperty<number>;
    }
    export interface IPolyLineProperties extends ILayerProperties {
        readonly weight?: ILayerProperty<number>;
    }
    export interface ICompoundTable {
        readonly name: string;
        readonly relations?: ReadonlyArray<ITableRelation>;
    }
    interface ITableRelation {
        readonly sourceKey: ReadonlyArray<string>;
        readonly targetKey: ReadonlyArray<string>;
        readonly target: ICompoundTable;
    }
    export interface ILayerPropertiesForLayerType {
        [LayerType.polygon]: IPolygonProperties;
        [LayerType.line]: IPolyLineProperties;
        [LayerType.symbol]: ISymbolProperties;
    }
    export type DrawableLayerType = keyof ILayerPropertiesForLayerType;
    export interface IMapLayerMetaData<P extends ILayerProperties = ILayerProperties> {
        readonly name: string;
        readonly type: LayerType;
        readonly properties: P;
        readonly minScale: number;
        readonly maxScale: number;
        readonly minZ: number;
        readonly maxZ: number;
        readonly grayLevels?: boolean;
        readonly selectable?: boolean;
        readonly hidden?: boolean;
    }
    export interface IMapVectorLayerMetaData<K extends DrawableLayerType = DrawableLayerType> extends IMapLayerMetaData<ILayerPropertiesForLayerType[K]> {
        readonly type: K;
        readonly tooltips?: ReadonlyArray<{
            readonly id: string;
            readonly name: string;
            readonly shortId?: string;
            readonly format?: string;
        }>;
        readonly table?: ICompoundTable & Readonly<Data.IDBTableDefinition>;
        readonly symbolFactory?: SymbolFactory;
    }
    export interface IRasterProvider {
        readonly name: string;
        readonly host: string;
        readonly path: string;
        readonly external?: boolean;
        readonly secure?: boolean;
        readonly port?: number;
        readonly subdomains?: ReadonlyArray<string>;
    }
    export interface IMapRasterLayerMetaData extends IMapLayerMetaData {
        readonly type: LayerType.raster;
        readonly provider: IRasterProvider;
    }
    export interface IClassInfo {
        [key: string]: {
            text: string;
            value: number | string;
        };
    }
    export interface IThematicData {
        readonly classes: ReadonlyArray<IClassInfo>;
    }
    export interface ILegendData {
        readonly thematic: IThematicData;
    }
    export interface ILayerLegendData {
        readonly color?: ILegendData;
    }
    export interface ISymbolLegendData extends ILayerLegendData {
        readonly fillColor?: ILegendData;
        readonly size?: ILegendData;
        readonly icon?: ILegendData;
    }
    export interface IPolygonLegendData extends ILayerLegendData {
        readonly fillColor?: ILegendData;
        readonly transparency?: ILegendData;
        readonly weight?: ILegendData;
    }
    export interface IPolyLineLegendData extends ILayerLegendData {
        readonly weight?: ILegendData;
    }
    export interface ILayerLegendDataMap {
        [LayerType.symbol]: ISymbolLegendData;
        [LayerType.polygon]: IPolygonLegendData;
        [LayerType.line]: IPolyLineLegendData;
    }
    export interface IMapLayerData {
        table: {
            columns: {
                name: string;
                alias: string;
                dataId: string;
                type: string;
                size: number;
            }[];
            primaryKey?: string[];
            values: any[][];
        };
        legend?: ILayerLegendData;
    }
    export interface IMapViewDescriptor {
        id: string;
        name: string;
    }
    export interface IMapLayerModelData extends Data.IKeyProvider, Data.IColumnIndexProvider, Data.IRowCollection {
        readonly name: string;
        readonly geometryIndice: number;
        filter: (row: ReadonlyArray<any>, dataModel: IMapLayerModelData) => boolean;
    }
    export interface IMapLayerModel<K extends DrawableLayerType = DrawableLayerType, D extends IMapLayerModelData = IMapLayerModelData> extends Tools.IObservable {
        readonly name: string;
        readonly type: K;
        readonly legend: ILayerLegendData;
        readonly isTiled: boolean;
        readonly symbolFactory: SymbolFactory;
        readonly properties: ILayerProperties;
        readonly data: D;
        readonly tooltips: ReadonlyArray<{
            readonly id: string;
            readonly name: string;
            readonly format?: string;
        }>;
        minZ: number;
        maxZ: number;
        hidden: boolean;
        clustering: boolean;
        clusteringMaxZoom: number;
        options: GeoJSONOptionOverrides;
        filter: GeoJSONFilterOverride;
        selectable: boolean;
        override: {
            properties: {
                readonly fillColor?: ILayerProperty<number>;
                readonly pattern?: ILayerProperty<number>;
                readonly patternBkColor?: ILayerProperty<number>;
                readonly patternAngle?: ILayerProperty<number>;
                readonly patternSpacing?: ILayerProperty<number>;
            };
            legendData: ILegendData;
        };
    }
    export interface ITileFeatureProperties<K extends DrawableLayerType = DrawableLayerType> extends IGeoJsonProperties {
        compoundData?: ReadonlyArray<any>;
        layer?: LayerForLayerType<K, ITileFeatureProperties<K>>;
        count: number;
    }
    export interface ITileLayerProvider<K extends DrawableLayerType = DrawableLayerType> {
        requestTiles(layer: ITileLayer<K>, tiles: ReadonlyArray<string>, callback: (tiles: ReadonlyArray<string>, rows: ReadonlyArray<any>[]) => any): void;
    }
    export interface ITileVectorModel<K extends DrawableLayerType = DrawableLayerType, P extends ITileLayerProvider<K> = ITileLayerProvider<K>> extends IMapLayerModelData, Data.IRowCollection, Tools.IObservable {
        readonly provider: P;
        readonly entities: ReadonlyArray<GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>>;
        dispatchChange: () => any;
        lowerBound(geometry: GeometryForLayerType[K], row: ReadonlyArray<any>): {
            readonly feature: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>;
            insert(): boolean;
        };
        find(key: ReadonlyArray<any>): number;
        remove(entity: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>): boolean;
        compareKey(row: ReadonlyArray<any>, key: ReadonlyArray<any>): number;
        empty(): void;
    }
    export interface IMapLayerTiledModel<K extends DrawableLayerType = DrawableLayerType, D extends ITileVectorModel<K> = ITileVectorModel<K>> extends IMapLayerModel<K, D> {
        readonly isTiled: true;
        data: D;
        minNativeZ: number;
        maxNativeZ: number;
    }
    export interface IStaticModelData extends IMapLayerModelData, Data.IRowCollection {
        dataModel: Data.IRowCollection & Data.IKeyProvider;
    }
    export interface IMapLayerStaticModel<K extends DrawableLayerType = DrawableLayerType, D extends IStaticModelData = IStaticModelData> extends IMapLayerModel<K, D> {
        readonly geoJSON: GeoJSON.GeoJsonObject;
        readonly isTiled: false;
        clone(): void;
    }
    export interface ILegendModel extends Tools.IObservable {
        getLegendImage(width: number, height: number, horizontal: boolean, quality?: number): Promise<string | void>;
        readonly getLegendInfo?: () => Promise<Globals.ILegendInfo | void>;
    }
    export interface IMapEventDataLayer {
        data: Data.IDataModelEventData;
        layer: IMapLayerModel;
        indice: number;
        visibility: boolean;
        style: boolean;
        filter: boolean;
    }
    export interface IMapEventData extends Tools.IEventData {
        layers: IMapEventDataLayer[];
    }
    export interface IMapEvent extends Tools.IEvent {
        data?: IMapEventData;
    }
    export const enum LegendType {
        fillColor = 0,
        size = 1,
        icon = 2
    }
    export interface ILegendInfo {
        type: LegendType;
        property: {
            thematic: {
                readonly title?: string;
                readonly classes: ReadonlyArray<IThematicValue>;
            };
        };
        data?: Globals.ILegendData;
    }
    export interface IGeographicalLevels {
        readonly hierarchies: ReadonlyArray<ReadonlyArray<string>>;
        readonly levels: {
            readonly [key: string]: {
                readonly name: string;
                readonly table: string;
                readonly bookmarkColumn: string;
                readonly codeColumn: string;
                readonly nameColumn: string;
                readonly mappings: {
                    readonly [key: string]: {
                        readonly table: string;
                        readonly column: string;
                        readonly upperColumn: string;
                        readonly bookmark: boolean;
                    };
                };
            };
        };
    }
    export const enum ProgressStatus {
        unknown = 0,
        notStarted = 1,
        inProgress = 2,
        completed = 3,
        registered = 4
    }
    export function progressStatus(value: string): ProgressStatus;
    export interface IProgressData {
        title?: string;
        step?: string;
        tid: string;
        completed: number;
        progress?: string;
        uid?: number;
        status: ProgressStatus;
    }
    export {};
}
/**
 * Created by jean.rennes on 29/09/2015.
 */
declare namespace AFC {
    namespace Rest {
        export const enum RestFormat {
            json = 1,
            pdf = 2,
            xml = 3,
            googleservice = 4,
            geojson = 5,
            pptx = 6,
            jpeg = 7,
            png4 = 8,
            png8 = 9,
            png24 = 10,
            png32 = 11,
            gif = 12,
            bmp = 13,
            tiff = 14,
            xlsx = 15,
            csv = 16,
            native = 17
        }
        export const enum RestMethod {
            POST = "POST",
            GET = "GET"
        }
        export const enum MimeType {
            xlsx = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        }
        export const enum LogAction {
            authenticate = 0,
            reset = 1,
            forgotten = 2,
            logout = 3,
            openIdInvalidJWT = 1000,
            openIdCheckFailed = 1001,
            openIdUnknownUser = 1002,
            reportGeneration = 10000,
            user = 20000
        }
        export interface IRequestBody<T = any> {
            context?: T;
            tid?: string;
            lang?: never;
            encoding?: never;
            f?: never;
            token?: never;
            key?: never;
        }
        export interface IAjaxOptions<T = any> {
            done?(sequence: number, data: any, textStatus: string, jqXHR: JQueryXHR): any;
            fail?(sequence: number, jqXHR: JQueryXHR, textStatus: string, errorThrown: string): boolean;
            always?(sequence: number, jqXHR: JQueryXHR, textStatus: string): any;
            byPassError?: boolean;
            method?: string;
            async?: boolean;
            format?: RestFormat;
            encoding?: string;
            skipDefaultParameters?: boolean;
            locale: Tools.Lang.Locale;
            data: T & IRequestBody<ICreationContext>;
            converter?: (text: string) => any;
            xhrFields?: any;
        }
        export interface IAjaxRequest<T = any> {
            readonly sequence: number;
            readonly uri?: string;
            readonly options: IAjaxOptions<T>;
            readonly progressId: string;
            enableCompression: boolean;
            getBody(): string;
            call(): number;
        }
        export class NetworkStatus {
            readonly request: Rest.IAjaxRequest;
            readonly jqXHR: JQueryXHR;
            readonly textStatus: string;
            readonly errorThrown: string;
            constructor(request: Rest.IAjaxRequest, jqXHR: JQueryXHR, textStatus: string, errorThrown?: string);
        }
        type Version = {
            majorVersion: number;
            minorVersion: number;
            majorBuildNumber: number;
            minorBuildNumber: number;
            neighborhoodMatrices: {
                id: string;
                name: string;
                countryCode: string;
                adminLevel: string;
                unitVersion: string;
                unitName: string;
                comment: string;
                creationDate: Date;
            }[];
            serverScript: {
                version: string;
            };
        };
        export interface IRestRequestOptions<T = any> {
            format?: Rest.RestFormat;
            locale?: Tools.Lang.Locale;
            baseURL?: string;
            useProgressInfo?: boolean;
            data?: T & IRequestBody<ICreationContext>;
            builder?: DataCreator;
            modifierOptions?: IContextModifierOptions;
            byPassError?: boolean;
        }
        export function getServiceUrl(directory: string, baseUrl?: string): string;
        export class RestModel extends RequestBuilder {
            protected _schema: Data.SchemaDescriptor;
            protected _pending: number;
            protected _locale: Tools.Lang.Locale;
            protected _zip: boolean;
            readonly baseUrl: string;
            readonly identity: IIdentity;
            readonly globals: Globals.GlobalsDescriptor;
            readonly dashboardsDescriptor: Dashboards.DashboardsDescriptor;
            static AjaxRequest: {
                new (restModel: RestModel, sequence: number, uri: string, options?: IAjaxOptions, useProgressInfo?: boolean, enableCompression?: boolean): IAjaxRequest;
            };
            constructor(identity: IIdentity, url: string);
            get pending(): number;
            get schema(): Data.SchemaDescriptor;
            set enableCompression(b: boolean);
            set locale(locale: Tools.Lang.Locale);
            static createEntry<T = any>(o: any, key: string): T;
            getVersion(): Promise<Version>;
            private _onRequestBegin;
            private _onRequestComplete;
            private _onRequestError;
            private _onIdentityError;
            createAjaxRequest<T = any>(path?: string, bypassContext?: boolean, options?: IRestRequestOptions): IAjaxRequest<T>;
            log(action: number, comment?: string): void;
        }
        export type Info = {
            afc: string;
            components: Version;
            databases: ReadonlyArray<Data.DatabaseInfo>;
            networks: ReadonlyArray<TradeArea.NetworkDescriptor>;
            dma: ReadonlyArray<TradeArea.DMAConfigDescriptor>;
        };
        export function getInfo(rest: Rest.RestModel): Promise<Readonly<Info>>;
        export {};
    }
    function createRest(identity: Rest.IIdentity, url: string): Rest.RestModel;
}
/**
 * Created by jean.rennes on 07/10/2015.
 */
declare namespace AFC.Controls {
    interface IListItem {
        id: string;
        name?: string;
    }
}
/**
 * Created by jean.rennes on 02/10/2015.
 */
declare namespace AFC.Dashboards {
    const enum DataQualifier {
        none = 0,
        code = 1,
        name = 2,
        bookmark = 3,
        partition = 4,
        proximity = 5,
        cannibalizationPct1 = 65542,
        cannibalizationPct100 = 131078,
        cannibalizationCount = 262150,
        cannibalizationReverse = 524294,
        scoringValue = 65543,
        scoringRank = 131079,
        targetingCumulative = 65544,
        targetingPercentage = 131080,
        targetingRank = 262152,
        targetingpartition = 524296
    }
    type IDashboardProperty = readonly [string, string, any];
    interface IGeographicalLevel {
        id: string;
        name: string;
        version?: string;
    }
    interface IGeographicalLevels {
        detailed: IGeographicalLevel;
        aggregated: IGeographicalLevel;
    }
    interface ISitesTable {
        codecolumn: string;
        namecolumn: string;
        table: string;
    }
    interface IZoneBaseDescriptor<T extends ZoneType = ZoneType> {
        readonly id: string;
        readonly name: string;
        readonly type: T;
    }
    interface ISubsetDescriptor extends IZoneBaseDescriptor<ZoneType.subset | ZoneType.subsetUnion | ZoneType.outOfZone> {
        readonly value: string;
    }
    const enum ZoneReaffectStorage {
        none = 0,
        incremental = 1,
        complete = 2,
        editable = 3
    }
    interface IZonePartition {
        readonly id: string;
        readonly name: string;
        readonly districtingTable: string;
        readonly districtingMode: ZoneReaffectStorage;
        readonly subsets: ReadonlyArray<ISubsetDescriptor>;
    }
    interface IZoneDescriptor<T extends ZoneType.radius | ZoneType.unknown | ZoneType.isodistance | ZoneType.isochrone | ZoneType.predefined | ZoneType.administrative | ZoneType.selection | ZoneType.dynamicMarket | ZoneType.surrounding | ZoneType.bulkMail = ZoneType.radius | ZoneType.unknown | ZoneType.isodistance | ZoneType.isochrone | ZoneType.predefined | ZoneType.administrative | ZoneType.selection | ZoneType.dynamicMarket | ZoneType.surrounding | ZoneType.bulkMail> extends IZoneBaseDescriptor<T> {
        readonly dashboard: IDashboardDescriptor;
        readonly properties: ReadonlyArray<IDashboardProperty>;
        readonly geographicalLevels: Readonly<IGeographicalLevels>;
        readonly cluster: string;
        readonly dataNodes: ReadonlyArray<IDataNode>;
        readonly hasCannibalization: boolean;
        readonly sites: {
            columns: ReadonlyArray<Data.IDBColumn>;
        };
    }
    interface IRadiusAreaDescriptor extends IZoneDescriptor<ZoneType.radius> {
        readonly sitesTable: Readonly<ISitesTable>;
        readonly bounds: ReadonlyArray<number>;
        readonly outOfZoneExtraBound: number;
        readonly unit: TradeArea.LengthUnit;
        readonly useCentroid: boolean;
        readonly forceSurroundingToZero: boolean;
        readonly partition: IZonePartition;
    }
    interface ITravelTimeAreaDescriptor<T extends ZoneType.isodistance | ZoneType.isochrone = ZoneType.isodistance | ZoneType.isochrone> extends IZoneDescriptor<T> {
        readonly sitesTable: Readonly<ISitesTable>;
        readonly bounds: ReadonlyArray<number>;
        readonly outOfZoneExtraBound: number;
        readonly modeOfTransport: TradeArea.ModeOfTransport;
        readonly anchorThreshold: number;
        readonly mode: TradeArea.TravelMode;
        readonly tollFreeOnly: boolean;
        readonly reverseMode: boolean;
        readonly forceSurroundingToZero: boolean;
        readonly perSiteConfiguration?: string;
        readonly partition: IZonePartition;
    }
    interface IIsodistanceAreaDescriptor extends ITravelTimeAreaDescriptor<ZoneType.isodistance> {
        readonly unit: TradeArea.LengthUnit;
    }
    interface IIsochroneAreaDescriptor extends ITravelTimeAreaDescriptor<ZoneType.isochrone> {
        readonly unit: TradeArea.TimeUnit;
    }
    interface IPredefinedAreaDescriptor extends IZoneDescriptor<ZoneType.predefined> {
        readonly sitesTable: Readonly<ISitesTable>;
        readonly areaTable: string;
        readonly siteCodeColumn: string;
        readonly geographicalCodeColumn: string;
        readonly partitionColumn: string;
        readonly partition: IZonePartition;
    }
    interface IAdministrativeAreaDescriptor extends IZoneDescriptor<ZoneType.administrative> {
    }
    interface ISurroundingAreaDescriptor extends IZoneDescriptor<ZoneType.surrounding> {
        readonly sitesTable: Readonly<ISitesTable>;
    }
    interface IBulkMailAreaScore {
        weight: number;
        name: string;
        id: string;
    }
    interface IBulkMailAreaTarget {
        limit: {
            percent: boolean;
            value?: number;
            column?: string;
        };
    }
    interface IBulkMailAreaDescriptor extends IZoneDescriptor<ZoneType.bulkMail> {
        readonly sitesTable: Readonly<ISitesTable>;
        readonly partition: IZonePartition;
        readonly scores: ReadonlyArray<IBulkMailAreaScore>;
        readonly target: IBulkMailAreaTarget;
    }
    interface IZoneConfiguration<T extends ZoneType.radius | ZoneType.isodistance | ZoneType.isochrone | ZoneType.predefined | ZoneType.surrounding | ZoneType.bulkMail = ZoneType.radius | ZoneType.isodistance | ZoneType.isochrone | ZoneType.predefined | ZoneType.surrounding | ZoneType.bulkMail> {
        type?: T;
        properties?: {
            [key: string]: any;
        };
        geographicalLevels?: {
            detailed?: string;
            aggregated?: string;
        };
        perSiteConfiguration?: string;
    }
    interface IRadiusAreaConfiguration extends IZoneConfiguration<ZoneType.radius> {
        sitesTable?: ISitesTable;
        bounds?: ReadonlyArray<number>;
        outOfZoneExtraBound?: number;
        unit?: TradeArea.LengthUnit;
        useCentroid?: boolean;
        forceSurroundingToZero?: boolean;
    }
    interface ITravelTimeAreaConfiguration<T extends ZoneType.isodistance | ZoneType.isochrone = ZoneType.isodistance | ZoneType.isochrone> extends IZoneConfiguration<T> {
        sitesTable?: ISitesTable;
        bounds?: ReadonlyArray<number>;
        outOfZoneExtraBound?: number;
        modeOfTransport?: TradeArea.ModeOfTransport;
        anchorThreshold?: number;
        mode?: TradeArea.TravelMode;
        tollFreeOnly?: boolean;
        reverseMode?: boolean;
        forceSurroundingToZero?: boolean;
        perSiteConfiguration?: string;
    }
    interface IIsodistanceAreaConfiguration extends ITravelTimeAreaConfiguration<ZoneType.isodistance> {
        unit?: TradeArea.LengthUnit;
    }
    interface IIsochroneAreaConfiguration extends ITravelTimeAreaConfiguration<ZoneType.isochrone> {
        unit?: TradeArea.TimeUnit;
    }
    interface IPredefinedAreaConfiguration extends IZoneConfiguration<ZoneType.predefined> {
        sitesTable?: ISitesTable;
        areaTable?: string | Data.IEmbeddedCreation;
        siteCodeColumn?: string;
        geographicalCodeColumn?: string;
        partitionColumn?: string;
    }
    interface ISurroundingAreaConfiguration extends IZoneConfiguration<ZoneType.surrounding> {
        sitesTable?: ISitesTable;
    }
    interface IBulkMailAreaConfiguration extends IZoneConfiguration<ZoneType.bulkMail> {
        sitesTable?: ISitesTable;
        scores?: IBulkMailAreaScore[];
        target?: IBulkMailAreaTarget;
    }
    interface IViewDescriptor {
        readonly id: string;
        readonly name: string;
        readonly type: ViewType;
        readonly properties: ReadonlyArray<IDashboardProperty>;
        readonly dashboard: IDashboardDescriptor;
    }
    interface IDataNode {
        id: string;
        qualifier?: DataQualifier;
        name?: string;
        children?: IDataNode[];
    }
    interface IZoneBaseData {
        readonly id: string;
        readonly name: string;
        readonly type: string;
    }
    interface IZoneSubsetData extends IZoneBaseData {
        readonly value: any;
    }
    interface IZoneData extends IZoneBaseData {
        readonly cluster: string;
        readonly properties: ReadonlyArray<IDashboardProperty>;
        readonly geographicalLevels?: Readonly<IGeographicalLevels>;
        readonly sites: {
            readonly columns: ReadonlyArray<{
                name: string;
                type: string;
            }>;
            readonly current: number | string;
        };
        readonly dataNodes: IDataNode[];
        readonly noCannibalization: boolean;
    }
    interface ISitesData {
        readonly current: any;
        readonly columns: ReadonlyArray<{
            readonly name: string;
            readonly alias: string;
            readonly type: string;
            readonly size: number;
        }>;
    }
    interface IZoneRedistrictData {
        readonly value: {
            readonly [key: string]: ReadonlyArray<any>;
        };
        readonly zone: string;
        readonly site?: string | number;
    }
    interface IContextZone {
        id: string;
        type?: string;
        geographicalLevels?: {
            detailed?: string;
            aggregated?: string;
        };
        properties?: {
            [key: string]: any;
        };
        perSiteConfiguration?: string;
        areaTable?: string | Data.IEmbeddedCreation;
    }
    interface IContextRadius extends IContextZone {
        sitesTable?: ISitesTable;
        bounds?: ReadonlyArray<number>;
        outOfZoneExtraBound?: number;
        unit?: string;
        useCentroid?: boolean;
        forceSurroundingToZero?: boolean;
    }
    interface IContextTravelTime extends IContextZone {
        sitesTable?: ISitesTable;
        bounds?: ReadonlyArray<number>;
        outOfZoneExtraBound?: number;
        modeOfTransport?: string;
        anchorThreshold?: number;
        mode?: string;
        tollFreeOnly?: boolean;
        reverseMode?: boolean;
        forceSurroundingToZero?: boolean;
        perSiteConfiguration?: string;
        unit?: string;
    }
    interface IContextPredefinedArea extends IContextZone {
        sitesTable?: ISitesTable;
        areaTable?: string | Data.IEmbeddedCreation;
        siteCodeColumn?: string;
        geographicalCodeColumn?: string;
        partitionColumn?: string;
    }
    interface IContextSurroundingArea extends IContextZone {
        sitesTable?: ISitesTable;
    }
    interface IContextBulkMailArea extends IContextZone {
        sitesTable?: ISitesTable;
        scores?: IBulkMailAreaScore[];
        target?: IBulkMailAreaTarget;
    }
    interface IContextView {
        id: string;
    }
    interface IContextSpreadsheet extends IContextView {
        content: Globals.IContextSheet;
    }
    interface IDashboardContext extends Rest.ICreationContext {
        zones?: IContextZone[];
        views?: IContextView[];
        reports?: IContextReport[];
    }
    interface IDashboardContextDataBase {
        sites?: {
            zone: string;
            site: any;
        }[];
        districting?: IZoneRedistrictData[];
        context?: IDashboardContext;
    }
    type IDashboardContextData = Rest.IRequestBody & IDashboardContextDataBase;
    interface IGlobalDashboardContextData extends IDashboardContextDataBase, Rest.ICreationContext {
        id?: string;
        reports?: Array<string>;
    }
    type IMultiDashboardContextData = Rest.IRequestBody<Rest.ICreationContext & {
        dashboardCreations: {
            [key: string]: IGlobalDashboardContextData;
        };
    }>;
    interface IViewModel extends Readonly<Controls.IListItem>, Globals.ILabelProvider, Globals.ILegendModel {
        readonly properties: ReadonlyArray<IDashboardProperty>;
        readonly dashboard: IDashboard;
        setId(value?: string): void;
        dashboardModel: DashboardModel;
        getType(): Promise<ViewType>;
    }
    interface IMapModel extends IViewModel {
        getMapTemplate(): Promise<string>;
        getDescriptors(): Promise<ReadonlyArray<IMapLayerDescriptor>>;
        getLayerCount(): Promise<number>;
        getLayer(indice: number): Promise<Globals.IMapLayerStaticModel>;
        getBbox(): Promise<Tools.Geometry.Rectangle>;
    }
    interface IGridModelEventData {
    }
    interface IGridModel extends IViewModel {
        getGridApp(): Promise<Globals.IGridApp>;
        getForeignDataModel(): Data.IDataModel;
    }
    interface IReportContentData {
        readonly tokens: {
            [key: string]: string;
        };
    }
    interface IChartModel extends IViewModel {
        readonly drawable: boolean;
        getImage(width: number, height: number): Promise<string | void>;
        getChartData(): Promise<Globals.IChartModel | void>;
    }
    interface IReportModel extends IViewModel {
        getImage(width: number, height: number, page?: number): Promise<string | void>;
        getReportMetadata(): Promise<Globals.IReportMetadata | void>;
        getReportData(): Promise<IReportContentData | void>;
    }
    const enum RendererType {
        unknown = 0,
        preview = 1,
        infoPreview = 2,
        legend = 3
    }
    function rendererType(value: RendererType): string;
    function rendererType(value: string): RendererType;
    interface IDashboardViewReportObject extends Globals.IReportObject {
        readonly type: Globals.ReportObjectType.dashboardView;
        readonly viewId: string;
        readonly rendererType: RendererType;
    }
    interface IDashboardViewLegendReportObject extends IDashboardViewReportObject {
        readonly horizontal: boolean;
    }
    type ISpreadSheetModel = IGridModel & Data.IDataContainerProvider;
}
/**
 * Created by jean.rennes on 16/10/2015.
 */
/**
 * Created by jean.rennes on 17/04/2019.
 */
declare namespace AFC.Dashboards {
    interface IZonesProperties {
        readonly [key: string]: number;
    }
    interface IDashboardProperties {
        readonly [key: string]: number;
    }
    interface IViewsProperties {
        readonly [key: string]: number | undefined;
        visible?: number;
        order?: number;
        link?: number;
        iswide?: number;
        redistrict?: number;
        width?: number;
    }
    interface IDashboardContent {
        readonly zones: ReadonlyArray<IZoneDescriptor>;
        readonly zonesProperties: Readonly<IZonesProperties>;
        readonly views: ReadonlyArray<IViewDescriptor>;
        readonly viewsProperties: Readonly<IViewsProperties>;
        readonly reportTemplates: ReadonlyArray<IReportTemplateDescriptor>;
        readonly mainCluster: string;
    }
    function propertiesLookup(properties: ReadonlyArray<IDashboardProperty>): {
        [s: string]: number;
    };
    interface IDashboardDescriptor extends Controls.IListItem {
        readonly levels: ReadonlyArray<Readonly<IGeographicalLevel>>;
        readonly properties: ReadonlyArray<IDashboardProperty>;
        readonly restModel: Rest.RestModel;
        getProperty(value: string): any;
        createRequest<T = any>(path?: string): Rest.IAjaxRequest<T>;
        getContent(): Promise<Readonly<IDashboardContent>>;
    }
    class DashboardsDescriptor extends Tools.EventSink {
        readonly restModel: Rest.RestModel;
        protected _dashboards: ReadonlyArray<IDashboardDescriptor>;
        protected _sequence: number;
        constructor(restModel: Rest.RestModel);
        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void;
        createRequest<T = any>(path?: string, options?: Rest.IRestRequestOptions): Rest.IAjaxRequest<T>;
        getDashboards(): Promise<ReadonlyArray<IDashboardDescriptor>>;
    }
}
/**
 * Created by jean.rennes on 27/03/2018.
 */
declare namespace AFC.Globals {
    export const enum GridRenderer {
        none = 0,
        text = 1,
        checkbox = 2,
        color = 3,
        trend = 4,
        trendAndText = 5
    }
    export function gridRender(value: string): GridRenderer;
    export function gridRender(value: GridRenderer): string;
    export interface ISortedColumn {
        readonly name: string;
        descending: boolean;
    }
    export type BorderStyle = "none" | "solid" | "double";
    export type BorderWidth = "medium" | "thin" | "thick";
    export interface ITemplateSheetClass {
        align?: "left" | "center" | "right" | "justified";
        backgroundColor: number;
        borderColor: number | [number, number] | [number, number, number, number];
        borderStyle: BorderStyle | [BorderStyle, BorderStyle] | [BorderStyle, BorderStyle, BorderStyle, BorderStyle];
        borderWidth?: BorderWidth | [BorderWidth, BorderWidth] | [BorderWidth, BorderWidth, BorderWidth, BorderWidth];
        color: number;
        fontFamily?: string;
        fontSize: number;
        fontStyle?: "italic";
        fontWeight?: "bold";
        padding: number | [number, number] | [number, number, number, number];
        textDecoration?: "underline" | "line-through" | "underline line-through";
        verticalAlign?: "top" | "middle" | "bottom";
        whiteSpace?: "pre-wrap";
    }
    export interface ITemplateSheetCellBase {
        className?: string;
        format?: string;
        image?: string;
        renderer?: GridRenderer;
        dynamic?: boolean;
        value?: any;
        text?: string;
    }
    export interface ITemplateSheetColumnHeader extends ITemplateSheetCellBase {
        width: number;
        column?: string;
    }
    export interface ITemplateSheetRowHeader extends ITemplateSheetCellBase {
        height: number;
    }
    export type ITemplateSheetCell = ITemplateSheetCellBase;
    export interface ITemplateSheet {
        classes?: {
            [key: string]: ITemplateSheetClass;
        };
        columnHeaders: {
            height?: number;
            visibility: boolean;
            items: ITemplateSheetColumnHeader[];
        };
        images?: {
            [key: string]: string;
        };
        items: ITemplateSheetCell[][];
        rowHeaders?: {
            width?: number;
            visibility: boolean;
            items: ITemplateSheetRowHeader[];
        };
    }
    export const enum SortOrientation {
        none = 0,
        ascending = 1,
        descending = 2
    }
    export interface ISortColumn {
        readonly column: Readonly<string>;
        readonly orientation: SortOrientation;
    }
    export interface ITemplateDetailedSheet extends ITemplateSheet {
        thematic?: IThematic<number>;
        readonly sortColumns: ReadonlyArray<ISortColumn>;
    }
    export interface IDataSheetCell {
        value?: any;
        image?: string;
    }
    export interface IDataSheet {
        columnHeaders?: {
            items: IDataSheetCell[];
        };
        items: IDataSheetCell[][];
        rowHeaders?: {
            items: IDataSheetCell[];
        };
    }
    export interface IDetailData {
        dataModel: Data.IDataModelBase;
        thematic: IThematicData;
    }
    export type ISheet = ITemplateSheet & IDataSheet;
    interface IContextSheetCell {
        className?: string;
        format?: string;
        image?: string;
        renderer?: string;
        value?: any;
    }
    export interface IContextSheet {
        classes?: {
            [key: string]: Globals.ITemplateSheetClass;
        };
        columnHeaders?: {
            height?: number;
            visibility?: boolean;
            items?: IContextSheetCell[];
        };
        items?: IContextSheetCell[][];
        rowHeaders?: {
            width?: number;
            visibility?: boolean;
            items?: IContextSheetCell[];
        };
    }
    export interface IGridAppData {
        readonly value: any;
        readonly symbol: string;
        readonly image: string;
        readonly color: string;
        readonly backgroundColor: string;
    }
    export interface IGridAppCell extends IGridAppData {
        readonly renderer: GridRenderer;
        readonly padding: string;
        readonly fontSize: string;
        readonly textAlign: string;
        readonly verticalAlign: string;
        readonly fontWeight: string;
        readonly fontFamily: string;
        readonly borderStyle: string;
        readonly borderWidth: string;
        readonly borderColor: string;
        readonly textDecoration: string;
        readonly fontStyle: string;
        readonly whiteSpace: string;
        readonly text: string;
        className: string;
    }
    export interface IGridAppColumnInfo {
        readonly name: string;
        readonly type: Data.DataKind;
        readonly supportOrdering: boolean;
    }
    export interface IGridApp {
        readonly sortedColumns: ISortedColumn[];
        readonly allowOrdering: boolean;
        readonly hasRowHeader: boolean;
        getRowCount(): number;
        getRowHeader(line: number): IGridAppCell;
        getRowHeaderWidth(): number;
        getRowHeight(line: number): number;
        readonly hasColumnHeader: boolean;
        getColumnInfo(column: number): IGridAppColumnInfo;
        getColumnCount(): number;
        getColumnHeader(column: number): IGridAppCell;
        getColumnHeaderHeight(): number;
        getColumnWidth(column: number): number;
        getCell(column: number, line: number): IGridAppCell;
        getValue(column: string, line: number): number | string;
        getSymbol(key: string): string;
    }
    export {};
}
/**
  * Created by jean.rennes on 17/04/2019.
*/
declare namespace AFC.Dashboards {
    export const enum ViewType {
        unknown = 0,
        map = 1,
        detailedSheet = 2,
        aggregatedSheet = 3,
        chart = 4,
        spreadSheet = 5,
        detailedChart = 6,
        report = 100
    }
    export const enum ChartType {
        undefined = 0,
        bar = 1,
        invertedBar = 2,
        lines = 3,
        symbol = 4,
        stackedBar = 5,
        stackedInvertedBar = 6,
        stackedLines = 7,
        stackedSymbol = 8,
        pie = 9,
        pied3d = 10,
        doughnut = 11,
        doughnut3d = 12,
        scatterLines = 13,
        scatterSymbol = 14,
        scatterString = 15,
        boxPlot = 16,
        bubble = 17,
        bubbleAsymetric = 18,
        radar = 19,
        radarFill = 20,
        barHorizontal = 21,
        stackedBarHorizontal = 22,
        linesHorizontal = 23,
        stackedLinesHorizontal = 24,
        symbolHorizontal = 25,
        stackedSymbolHorizontal = 26
    }
    export const enum SpreadSheetDisplayType {
        grid = 0,
        chart = 1
    }
    export const enum LayerType {
        undefined = 0,
        thematic = 1,
        outline = 2,
        symbol = 3,
        label = 4,
        graph = 5
    }
    export const enum DataSourceKind {
        unknown = 1,
        zoneUnits = 2,
        itemInfo = 3,
        filteredTable = 4,
        sites = 5,
        cannibalization = 6,
        cannibalizationSites = 7,
        DMAImpactedSites = 8,
        subset = 9,
        subsetUnion = 10,
        outOfZone = 11,
        siteFilteredTable = 12
    }
    interface IViewDataBase {
        readonly id: string;
        readonly name: string;
        readonly properties: ReadonlyArray<IDashboardProperty>;
    }
    export interface IViewData extends IViewDataBase {
        readonly type: string;
    }
    interface IMapViewData extends IViewData {
        readonly layerCount: number;
        readonly mapTemplate: string;
    }
    interface IChartData extends IViewData {
        readonly chartType: string;
    }
    interface ISpreadSheetData extends IChartData {
        readonly displayType: string;
    }
    export interface IReportData extends IViewDataBase {
    }
    export interface IReportTemplateDescriptor {
        readonly id: string;
        readonly name: string;
        readonly kind: string;
    }
    class ViewDescriptor<T extends ViewType> extends Tools.EventSink implements IViewDescriptor {
        readonly id: string;
        readonly name: string;
        readonly type: T;
        readonly properties: ReadonlyArray<IDashboardProperty>;
        readonly dashboard: IDashboardDescriptor;
        constructor(dashboard: IDashboardDescriptor, type: T, data: IViewDataBase);
        createRequest<T2 = any>(path?: string): Rest.IAjaxRequest<T2>;
    }
    export function dataSourceKind(value: string): DataSourceKind;
    export function dataSourceKind(value: DataSourceKind): string;
    export interface IMapLayerDescriptor<K extends Globals.LayerType.polygon | Globals.LayerType.line | Globals.LayerType.symbol = any> {
        readonly name: string;
        readonly type: LayerType;
        readonly zone: string;
        readonly dataSourceKind: DataSourceKind;
        readonly hiddenClasses: boolean;
        readonly zoomOnLayer: boolean;
        readonly template: Readonly<Globals.IMapVectorLayerMetaData<K>>;
        readonly dataNodes: Readonly<{
            [key: string]: string;
        }>;
    }
    export interface IMapDescriptor extends IViewDescriptor {
        readonly mapTemplate: string;
        readonly layerCount: number;
        readonly type: ViewType.map;
        getLayer(indice: number): Promise<IMapLayerDescriptor>;
    }
    export interface ISheetMetadata<T extends Globals.ITemplateSheet = Globals.ITemplateSheet> {
        readonly id: Readonly<string>;
        readonly sheetProperties: Readonly<T>;
    }
    export interface IDetailedSheetMetadata extends ISheetMetadata<Globals.ITemplateDetailedSheet> {
        readonly dataSourceKind: DataSourceKind;
        readonly zone: Readonly<string>;
        readonly dataNodes: Readonly<{
            readonly [key: string]: string;
        }>;
        readonly maxRowCount: number;
    }
    export interface IChartMetadata<T extends Globals.ChartType = any> extends Globals.IChartMetadata<T> {
        readonly id: Readonly<string>;
    }
    export interface ISpreadSheetMetadata<T extends Globals.ChartType = any> extends ISheetMetadata, IChartMetadata<T> {
    }
    export interface SheetMetadataForGridType {
        [ViewType.detailedSheet]: IDetailedSheetMetadata;
        [ViewType.aggregatedSheet]: ISheetMetadata;
        [ViewType.spreadSheet]: ISpreadSheetMetadata;
    }
    export interface ISheetDescriptor<T extends keyof SheetMetadataForGridType = keyof SheetMetadataForGridType> extends IViewDescriptor {
        getMetadata(): Promise<Readonly<SheetMetadataForGridType[T]>>;
    }
    interface ISheetPropertiesCell {
        renderer?: Globals.GridRenderer;
    }
    interface ISheetProperties {
        columnHeaders?: {
            items: ISheetPropertiesCell[];
        };
        items: ISheetPropertiesCell[][];
        rowHeaders?: {
            items: ISheetPropertiesCell[];
        };
    }
    export function convertSheetInfo<T extends ISheetProperties>(t: T): T;
    export type IAggregatedSheetDescriptor = ISheetDescriptor<ViewType.aggregatedSheet>;
    export type IDetailedSheetDescriptor = ISheetDescriptor<ViewType.detailedSheet>;
    export interface IChartDescriptor extends IViewDescriptor {
        readonly chartType: ChartType;
    }
    export interface ISpreadSheetDescriptor extends IChartDescriptor, ISheetDescriptor<ViewType.spreadSheet> {
        readonly displayType: SpreadSheetDisplayType;
        getMetadata(): Promise<Readonly<ISpreadSheetMetadata>>;
    }
    export interface IReportDescriptor extends IViewDescriptor {
        readonly type: ViewType.report;
        getReportMetadata(): Promise<Globals.IReportMetadata>;
    }
    class ReportDescriptor extends ViewDescriptor<ViewType.report> implements IReportDescriptor {
        protected _metadata: Globals.IReportMetadata;
        protected _sequence: number;
        constructor(dashboard: IDashboardDescriptor, data: IReportData);
        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void;
        createRequest<T = any>(path?: string): Rest.IAjaxRequest<T>;
        getReportMetadata(): Promise<Globals.IReportMetadata>;
    }
    interface ViewDataForViewType {
        [key: number]: IViewData;
        [ViewType.map]: IMapViewData;
        [ViewType.detailedSheet]: IViewData;
        [ViewType.aggregatedSheet]: IViewData;
        [ViewType.chart]: IChartData;
        [ViewType.spreadSheet]: ISpreadSheetData;
        [ViewType.detailedChart]: IChartData;
    }
    interface ViewDescriptorForViewType {
        [key: number]: IViewDescriptor;
        [ViewType.map]: IMapDescriptor;
        [ViewType.detailedSheet]: IDetailedSheetDescriptor;
        [ViewType.aggregatedSheet]: IAggregatedSheetDescriptor;
        [ViewType.chart]: IChartDescriptor;
        [ViewType.spreadSheet]: ISpreadSheetDescriptor;
        [ViewType.detailedChart]: IChartDescriptor;
    }
    export function viewDescriptor<T extends keyof ViewDescriptorForViewType = any>(dashboard: IDashboardDescriptor, data: ViewDataForViewType[T]): ViewDescriptorForViewType[T];
    export function reportDescriptor(dashboard: IDashboardDescriptor, data: IReportData): ReportDescriptor;
    export {};
}
/**
 * Created by jean.rennes on 12/10/2015.
 */
declare namespace AFC.Dashboards {
    export interface IView {
        readonly dashboard: IDashboard;
        readonly id: string;
        readonly name: string;
        readonly type: ViewType;
        readonly descriptor: IViewDescriptor;
        readonly properties: ReadonlyArray<Dashboards.IDashboardProperty>;
        readonly getLegendInfo?: () => Promise<Globals.ILegendInfo>;
        createRequest<T2>(path?: string, options?: Rest.IRestRequestOptions): [number, Promise<Rest.IAjaxRequest<T2>>];
        getLegend(width: number, height: number, horizontal?: boolean, quality?: number): Promise<string>;
        invalidate(): void;
        clone(dashboard: IDashboard): IView;
    }
    export interface IReportTemplate {
        readonly dashboard: IDashboard;
        readonly descriptor: IReportTemplateDescriptor;
        createRequest<T2>(path?: string, options?: Rest.IRestRequestOptions): [number, Promise<Rest.IAjaxRequest<T2>>];
        invalidate(): void;
        clone(dashboard: IDashboard): IReportTemplate;
    }
    export interface ILayer {
        readonly descriptor: IMapLayerDescriptor;
        readonly dataModel: Data.DataModel;
        readonly thematics: Globals.ILayerLegendData;
    }
    export interface IMapView extends IView {
        readonly descriptor: IMapDescriptor;
        getLayer(indice: number): Promise<ILayer>;
        getImage(width: number, height: number, quality?: number): Promise<string>;
        getBbox(): Promise<Tools.Geometry.Rectangle>;
    }
    interface ViewDescriptorForViewType {
        [key: number]: IViewDescriptor;
        [ViewType.map]: IMapDescriptor;
        [ViewType.detailedSheet]: IDetailedSheetDescriptor;
        [ViewType.aggregatedSheet]: IAggregatedSheetDescriptor;
        [ViewType.chart]: IChartDescriptor;
        [ViewType.spreadSheet]: ISpreadSheetDescriptor;
        [ViewType.detailedChart]: IChartDescriptor;
        [ViewType.report]: IReportDescriptor;
    }
    interface GridDataForGridType {
        [ViewType.detailedSheet]: Globals.IDetailData;
        [ViewType.aggregatedSheet]: Globals.IDataSheet;
        [ViewType.spreadSheet]: Globals.IDataSheet;
    }
    export interface IGrid<T extends keyof GridDataForGridType = any> extends IView {
        getGridData(): Promise<IGridData | void>;
        getData(): Promise<Readonly<GridDataForGridType[T]>>;
        getRequest<T2 = any>(options?: IReportRequestOptions): Promise<Rest.IAjaxRequest<T2>>;
    }
    export interface ISheet<T extends keyof SheetMetadataForGridType = any> extends IGrid<T> {
        getMetadata(): Promise<Readonly<SheetMetadataForGridType[T]>>;
    }
    export interface IAggregatedSheet extends IGrid<ViewType.aggregatedSheet> {
        readonly descriptor: IAggregatedSheetDescriptor;
    }
    export interface IDetailedSheet extends ISheet<ViewType.detailedSheet> {
        readonly descriptor: IDetailedSheetDescriptor;
        readonly sortable: boolean;
        getSortedColumns(): Promise<Globals.ISortedColumn[]>;
    }
    export interface IChart extends IView {
        readonly descriptor: IChartDescriptor;
        getImage(width: number, height: number, quality?: number): Promise<string>;
        getChartData(): Promise<Globals.IChartModel>;
    }
    export interface ISpreadSheet extends IChart, IGrid {
        readonly descriptor: ISpreadSheetDescriptor;
    }
    interface IReportReplacement {
        id: string;
        type: Globals.ReportObjectType;
    }
    export interface IReportTextReplacement extends IReportReplacement {
        value: string;
    }
    export interface IReportGridReplacement extends IReportReplacement {
        content: Globals.IContextSheet;
    }
    export interface IReportDashboardViewReplacement extends IReportReplacement {
        renderer: RendererType;
        view: string;
    }
    export interface IContextReport {
        id: string;
        pageFilter?: {
            show?: string;
            hide?: string;
        };
        objects?: {
            [key: string]: {
                content: any;
            };
        };
    }
    export interface IReportContentData {
        readonly tokens: {
            [key: string]: string;
        };
    }
    export interface IReportRequestOptions extends Rest.IRestRequestOptions {
        pageFilter?: {
            show?: string;
            hide?: string;
        };
        replacements?: IReportReplacement[];
    }
    export interface IReport extends IView {
        readonly descriptor: IReportDescriptor;
        getImage(width: number, height: number, page: number): Promise<string>;
        getReportData(): Promise<IReportContentData>;
        getRequest<T2 = any>(options?: IReportRequestOptions): Promise<Rest.IAjaxRequest<T2>>;
    }
    interface ViewForViewType {
        [ViewType.map]: IMapView;
        [ViewType.detailedSheet]: IDetailedSheet;
        [ViewType.aggregatedSheet]: IAggregatedSheet;
        [ViewType.chart]: IChart;
        [ViewType.spreadSheet]: ISpreadSheet;
        [ViewType.report]: IReport;
    }
    export function view<T extends keyof ViewDescriptorForViewType = any>(dashboard: IDashboard, descriptor: ViewDescriptorForViewType[T]): ViewForViewType[T];
    export function reportTemplate(dashboard: IDashboard, descriptor: IReportTemplateDescriptor): IReportTemplate;
    export {};
}
/**
 * Created by jean.rennes on 23/09/2015.
 */
declare namespace AFC.Dashboards {
    interface IDashboardEventData extends Tools.IEventData {
        readonly views: boolean;
        readonly districting: boolean;
    }
    interface IZoneCluster {
        readonly id: string;
        readonly zones: ReadonlyArray<IZone>;
        readonly dashboard: IDashboard;
        current: string | number;
        setSite(point: GeoJSON.Point): void;
    }
    interface IDashboard extends Tools.EventSink {
        readonly descriptor: IDashboardDescriptor;
        readonly reaffectStorages: IReaffectStorages;
        readonly id: string;
        readonly name: string;
        readonly branch: string;
        readonly zones: ReadonlyArray<IZone>;
        readonly views: ReadonlyArray<IView>;
        readonly reportTemplates: ReadonlyArray<IReportTemplate>;
        readonly properties: IDashboardProperties;
        readonly viewsProperties: Readonly<IViewsProperties>;
        readonly mainCluster: IZoneCluster;
        readonly clusters: ReadonlyArray<IZoneCluster>;
        readonly requestBuilder: Rest.RequestBuilder<IDashboardContextData>;
        createRequest<T extends IDashboardContextData = IDashboardContextData>(path?: string, options?: Rest.IRestRequestOptions, districtType?: DistrictType): [number, Promise<Rest.IAjaxRequest<T>>];
        getContextDashboard(): Promise<IGlobalDashboardContextData>;
        getProperty(value: string): any;
        invalidateViews(districtOperation?: IDistrictOperation): void;
        invalidate(): void;
        clone(): IDashboard;
    }
    interface IDashboardContextModifierOptions extends Rest.IContextModifierOptions {
        districtType: DistrictType;
    }
    function dashboard(descriptor: IDashboardDescriptor, branch?: string): Promise<IDashboard>;
    function getDashboard(restModel: Rest.RestModel, id?: string, branch?: string): Promise<IDashboard>;
    function getDashboards(restModel: Rest.RestModel, branch?: string): Promise<ReadonlyArray<IDashboard>>;
}
/**
 * Created by jean.rennes on 13/09/2016.
 */
declare namespace AFC.Controls {
    class ControlLoadingState {
        private _parent;
        private _waitElement;
        private _displayloading;
        constructor(parent: HTMLElement, force: boolean);
        show(): void;
        hide(): void;
        isLoading(): boolean;
    }
    class Control<T extends HTMLElement = HTMLElement> {
        protected _loadingState: ControlLoadingState;
        dispatchChange: () => any;
        readonly node: T;
        constructor(node: string | T, forceLoadingState?: boolean);
        isLoading(): boolean;
        loadingStart(): void;
        loadingEnd(): void;
        protected _dispatchChange(): void;
        get width(): number;
        get height(): number;
        set visible(b: boolean);
    }
}
/**
 * Created by jean.rennes on 08/10/2015.
 */
declare namespace AFC.Controls {
    class Image extends Control {
        setUrl(url?: string): HTMLImageElement;
    }
}
/**
 * Created by jean.rennes on 03/02/2016.
 */
declare namespace AFC.Tools {
    abstract class AdapterBase<Model extends Partial<INotifier>> extends Tools.EventSink {
        protected _model: Model;
        static disable<Model extends Partial<INotifier>>(adapter: AdapterBase<Model>, value: boolean): void;
        constructor();
        set mute(value: boolean);
        get model(): Model;
        get mute(): boolean;
        get ready(): boolean;
        protected abstract _update(model: Model, event?: Tools.IEvent): void;
        protected _onDirty(event?: Tools.IEvent<Required<Model>>): void;
        bindTo(model: Model): void;
        unbind(): void;
        refresh(): void;
    }
}
/**
 * Created by jean.rennes on 20/07/2017.
 */
declare namespace AFC.Dashboards {
    interface IImageModel extends IViewModel {
        getImage(width: number, height: number): Promise<string | void>;
    }
    export class ImageAdapter<T extends IImageModel = IImageModel, C extends Controls.Image = Controls.Image> extends AFC.Tools.AdapterBase<T> {
        readonly control: C;
        static readonly header: string;
        constructor(image: C);
        protected _onImageReady(data: string | void): void;
        protected _update(model: T): void;
        unbind(): void;
    }
    export {};
}
/**
 * Created by jean.rennes on 08/10/2015.
 */
declare namespace AFC.Dashboards {
    interface IChartOptions {
        page: number;
    }
    class ChartAdapter extends ImageAdapter<IChartModel | IReportModel, Controls.ReportPage> {
        protected readonly _data: boolean;
        protected _isData: boolean;
        protected _options: Partial<Dashboards.IChartOptions>;
        protected _sequence: number;
        constructor(control: Controls.ReportPage, chartData: boolean);
        protected _onChartReady(chart: Globals.IChartModel | void, sequence: number): void;
        protected _onReport(model: IReportModel, metadata: Globals.IReportMetadata | void, data: Dashboards.IReportContentData | void, indice: number, sequence: number): void;
        protected _updateReport(model: IReportModel, indice: number, sequence: number): void;
        protected _update(model: IChartModel | IReportModel): void;
        get options(): Partial<Dashboards.IChartOptions>;
        set options(value: Partial<Dashboards.IChartOptions>);
        get isData(): boolean;
    }
}
declare namespace AFC.Dashboards {
    interface IITemData {
        [key: string]: any;
    }
    interface IITemConfig {
        dataItem: IITemData;
        dataItemIndex: number;
    }
    class ConfigGroupModel extends Tools.EventSink implements AFC.Data.IDataSource {
        protected _curSel: number;
        protected _list: any[];
        protected _defaultList: any[];
        protected _mode: string;
        protected _sortedList: any[];
        protected _fnCompare?: (a: any, b: any) => number;
        _maxListSize: number;
        maxItem: number;
        constructor(handlers: any, curSelDefault?: number, maxListSize?: number, maxItem?: number);
        addItem(item: any): void;
        get maxListSize(): number;
        set maxListSize(maxListSize: number);
        get length(): number;
        set mode(collapse: string);
        get mode(): string;
        get list(): any[];
        set selection(index: number);
        get selection(): number;
        get fnCompare(): (a: any, b: any) => number;
        set fnCompare(fnCompare: (a: any, b: any) => number);
        /**
         * Construct data from default list and storage, then sort
         * @returns ConfigGroupModel self for chaining
         */
        protected _buildData(): ConfigGroupModel;
        /**
         * Select item from group
         * @param item
         * @returns ConfigGroupModel self for chaining
         */
        select(item: IITemData): ConfigGroupModel;
        /**
         * Format item for display, eg. override for Config list
         * @param item
         * @returns
         */
        formatItem(item: any): any;
        /**
         * Return item value in sortedList or list, according to given index
         * @param itemIndex
         * @param rawIndex
         * @returns
         */
        item(itemIndex: number, rawIndex?: boolean): IITemConfig;
        private _selectItem;
        private _compareItems;
        private _sortList;
        copyList(list: any): any;
        setDefaultList(data: Array<any>): ConfigGroupModel;
        getDefaultList(): Array<any>;
        setList(data: Array<any>): ConfigGroupModel;
    }
}
/**
 * Created by jean.rennes on 19/09/2017.
 */
declare namespace AFC.Controls {
    interface ITemplate {
        content: string;
        accelerators?: {
            [key: string]: (value: {
                [key: string]: any;
            }) => string;
        };
    }
    class Repeater extends Control {
        protected _template: ITemplate;
        protected _templates: {
            [key: string]: ITemplate;
        };
        private _formatNumbers;
        static splitKey(key: string): string[];
        dataBinder: (name: string, key: string, value: Data.IDataItemContainer) => any;
        setFormatNumbers(formatNumbers: boolean): void;
        static generateContent(container: Node, templateName: string, template: ITemplate, value: {
            [key: string]: any;
        }, dataBinder?: (templateName: string, key: string, value: {
            [key: string]: any;
        }) => any, formatNumbers?: boolean): void;
        setTemplate(value: string, name?: string): void;
        addItem(value: {
            [key: string]: any;
        }, templateName?: string): void;
        empty(): void;
    }
}
/**
 * Created by jean.rennes on 19/09/2017.
 */
declare namespace AFC.Data {
    class RepeaterAdapter<M extends IDataSource & Partial<Tools.IObservable> = IDataSource & Partial<Tools.IObservable>> extends AFC.Tools.AdapterBase<M> {
        readonly control: Controls.Repeater;
        template: (value: IDataItemContainer) => string;
        compare: (value0: IDataItemContainer, value1: IDataItemContainer) => number;
        filter: (value: IDataItemContainer) => boolean;
        maxItem: number;
        onClear: () => any;
        onGenerate: () => any;
        constructor(control: Controls.Repeater);
        protected _update(model: M): void;
        unbind(): void;
    }
}
/**
 * Created by jean.rennes on 19/09/2017.
 */
declare namespace AFC.Dashboards {
    interface IStorageHandlers {
        getItems: (key: string) => any;
        setItems: (key: string, items: IITemData[]) => void;
    }
    interface IConfigGroupHandlers {
        [key: string]: Function;
    }
    class StorageHelper {
        mruSize: number;
        mruId: string;
        protected _setItems?: (key: string, items: IITemData[]) => void;
        protected _getItems?: (key: string) => IITemData[];
        storageActive: boolean;
        constructor(mruId?: string, storageActive?: boolean);
        set customSetItems(fnSetItems: (key: string, items: IITemData[]) => void);
        get customSetItems(): (key: string, items: IITemData[]) => void;
        set customGetItems(fnGetItems: (key: string) => any);
        get customGetItems(): (key: string) => any;
        setItems: (key: string, item: IITemData[]) => void;
        getItems: (key: string) => IITemData[];
    }
    export class ConfigGroupAdapter extends AFC.Data.RepeaterAdapter {
        protected _list: any[];
        protected _sortedList: any[];
        protected _model: ConfigGroupModel;
        protected _builtInModel: ConfigGroupModel;
        handlers: IConfigGroupHandlers;
        storageHelper: StorageHelper;
        defaultSelection: string;
        constructor(control: Controls.Repeater);
        get storageSetItems(): (items: IITemData[]) => void;
        get storageGetItems(): () => IITemData[];
        get mruId(): string;
        set mruId(mruId: string);
        get mruSize(): number;
        set mruSize(mruSize: number);
        set storageHandlers(handlers: IStorageHandlers);
        /**
         * Return template name according to current model.mode
         *
         * @param item
         * @returns "collapsed-selected" | "collapsed" | "selected"
         */
        template: (item: AFC.Data.IDataItemContainer) => string;
        set model(model: ConfigGroupModel);
        get model(): ConfigGroupModel;
        set mode(collapse: string);
        get mode(): string;
        selectByDefault(item: {
            dataItem: IITemData;
            dataIndex: number;
        }): void;
        select(item: {
            dataItem: IITemData;
            dataIndex: number;
        }): void;
        bindTo(model: ConfigGroupModel): void;
        toggleCollapse(forceCollapse?: boolean): void;
        /**
         * Do something before show or hide manual edition box (DOM elem #manualEdition),
         * then triggers control AfcGuiConfigGroup toggleManualEdition default function
         * @see AFC.gui.AfcGuiConfigGroup.toggleManualEdition
         * @param event
         * @param itemElem
         * @param forceCollapse
         * @returns
         */
        toggleManualEdition(event: any, itemElem: HTMLElement, forceCollapse?: boolean): boolean;
        onListItemClick(event: MouseEvent, itemElem: HTMLElement): Promise<boolean>;
        onListBtnClick(event: MouseEvent, params?: Array<string>): Promise<any>;
    }
    export {};
}
/**
 * Created by jean.rennes on 06/10/2015.
 */
declare namespace AFC.Controls {
    class ListBox extends Control {
        protected _list: JQuery;
        protected _items: ReadonlyArray<IListItem>;
        protected _selected: number[];
        protected _multiSelect: boolean;
        protected _pending: number;
        constructor(element: string | HTMLElement);
        get selected(): number[];
        protected _build(container: JQuery, items: ReadonlyArray<IListItem>): JQuery;
        protected _checkSelection(oldItems: ReadonlyArray<IListItem>, oldSelected: number[]): void;
        protected _refresh(): void;
        protected _onClick(e: JQuery.ClickEvent): void;
        set multiSelect(value: boolean);
        get multiSelect(): boolean;
        setItems(items?: ReadonlyArray<IListItem>): void;
        getItems(): ReadonlyArray<IListItem>;
        select(selection?: ReadonlyArray<number>): void;
    }
}
/**
 * Created by jean.rennes on 28/09/2015.
 */
declare namespace AFC.Dashboards {
    const enum SelectorType {
        map = 1,
        grid = 2,
        chart = 3
    }
    const enum SelectorMode {
        none = 0,
        type = 1,
        link = 2
    }
    interface ISelectorEventData {
        group: string;
        item: string;
        map?: Dashboards.IMapView;
        grid?: Dashboards.IGrid;
        chart?: Dashboards.IChart | Dashboards.IReport;
    }
    class SelectorAdapter extends AFC.Tools.AdapterBase<DashboardModel> {
        protected _selector: Controls.Selector;
        protected _mode: SelectorMode;
        protected _dashboard: IDashboard;
        protected _filter: (dashboard: Dashboards.IDashboard, view: Dashboards.IView) => boolean;
        protected _groups: Controls.ISelectorGroup[];
        protected _selection: Partial<Controls.ISelection>;
        protected [SelectorType.map]: Dashboards.IMapModel;
        protected [SelectorType.grid]: Dashboards.IGridModel;
        protected [SelectorType.chart]: Dashboards.IChartModel;
        protected _initial: string;
        onChange: (eventData: ISelectorEventData) => void;
        constructor(selector: Controls.Selector);
        protected _update(model: DashboardModel, event: Tools.IEvent<DashboardModel, IDashboardEventData>): void;
        protected _refresh(): void;
        set filter(value: (dashboard: Dashboards.IDashboard, view: Dashboards.IView) => boolean);
        get filter(): (dashboard: Dashboards.IDashboard, view: Dashboards.IView) => boolean;
        set mode(value: SelectorMode);
        get mode(): SelectorMode;
        get map(): IMapModel;
        get grid(): IGridModel;
        get chart(): IChartModel;
        protected _updateView(view: Dashboards.IView, group: string, item: string, _type: SelectorType, eventData?: ISelectorEventData): ISelectorEventData;
        protected _onClick(): void;
        protected _setViews(selection: Partial<Controls.ISelection>): ISelectorEventData;
        protected _selectItem(group: Controls.ISelectorGroup, indice: number): ISelectorEventData;
        bindTo(model: DashboardModel): void;
        unbind(): void;
        next(): Promise<ISelectorEventData>;
        previous(): Promise<ISelectorEventData>;
        selectItem(value?: string): Promise<ISelectorEventData>;
        getDashboardFilter(mode: SelectorMode): (dashboard: Dashboards.IDashboard) => Controls.ISelectorGroup[];
    }
}
/**
 * Created by jean.rennes on 03/02/2016.
 */
declare namespace AFC.Controls {
    class RadioGroup extends Control {
        protected static _cnt: number;
        protected _items: ReadonlyArray<IListItem>;
        protected _checked: number;
        protected _name: string;
        constructor(element: string | HTMLElement, name?: string);
        get checked(): number;
        protected _build(items: ReadonlyArray<IListItem>, query: JQuery, name: string): void;
        protected _onClick(event: JQuery.ClickEvent): void;
        setItems(items?: ReadonlyArray<IListItem>): void;
        getItems(): ReadonlyArray<IListItem>;
        check(i?: number): number;
    }
}
/**
 * Created by jean.rennes on 03/02/2016.
 */
declare namespace AFC.Dashboards {
    class RedistrictAdapter extends AFC.Tools.AdapterBase<IZone> {
        protected _control: Controls.RadioGroup;
        protected _codeColumn: number;
        constructor(radioGroup: Controls.RadioGroup);
        protected _onDescriptor(descriptor: IRadiusAreaDescriptor | IIsodistanceAreaDescriptor | IIsochroneAreaDescriptor | IPredefinedAreaDescriptor | IBulkMailAreaDescriptor): void;
        protected _update(model: IZone): void;
        affectRow(row: ReadonlyArray<any>): void;
    }
}
/**
 * Created by jean.rennes on 08/10/2015.
 */
declare namespace AFC.Controls {
    interface IGridCell {
        positionX: number;
        positionY: number;
        templateCell: Globals.IGridAppCell;
    }
    class GridView extends Control {
        private _widths;
        private _gridApp;
        private _allowSelection;
        private _highlighted;
        autoSize: boolean;
        template: (cell: IGridCell) => string;
        dataBinder: (name: string, key: string, value: {
            [key: string]: any;
        }) => string;
        templates: {
            [key: string]: ITemplate;
        };
        onCellClick: (column: number, line: number) => any;
        constructor(element: string | HTMLElement, noAutoSize?: boolean);
        protected _onClick(e: MouseEvent): void;
        protected _highlight(tbody: HTMLTableSectionElement, indice: number, oldIndice?: number): void;
        protected _buildFromGridApp(gridApp: Globals.IGridApp): void;
        refreshCell(positionX: number, positionY: number): void;
        protected _build(): void;
        get selection(): number;
        get gridApp(): Globals.IGridApp;
        setTemplate(value: string, name?: string): void;
        setGrid(gridApp?: Globals.IGridApp, allowSelection?: boolean): void;
        highlight(indice?: number): void;
        invalidateSize(): void;
    }
}
/**
 * Created by jean.rennes on 08/10/2015.
 */
declare namespace AFC.Dashboards {
    const enum ConversionDirection {
        positionToNative = 0,
        nativeToPosition = 1
    }
    class GridAdapter extends AFC.Tools.AdapterBase<IGridModel> {
        private _sortableGridApp;
        readonly control: Controls.GridView;
        onGenerate: () => any;
        onCellClick: (column: number, line: number) => any;
        enableSelection: boolean;
        constructor(grid: Controls.GridView);
        protected _update(model: IGridModel, event: Tools.IEvent<IGridModel, IDashboardEventData | Array<number>>): void;
        convertLine(line: number, conversionDirection?: ConversionDirection): number;
        unbind(): void;
    }
}
/**
 * Created by jean.rennes on 04/10/2016.
 */
declare namespace AFC.gui {
    function registerElement(name: string, constructor: CustomElementConstructor, options?: ElementDefinitionOptions): void;
    function _dispatchEvent<T>(element: HTMLElement, name: string, eventInitDict?: CustomEventInit<T>): void;
    function StringToObject(s: string, converters?: {
        [key: string]: (value: string) => any;
    }): {
        [key: string]: any;
    };
    function StringToFunction(s: string): (...args: any[]) => any;
    interface ICustomElement {
        attributeChangedCallback?: (attrName: string, oldVal: string, newVal: string) => void;
        connectedCallback?: () => void;
        disconnectedCallback?: () => void;
    }
    type Window = HTMLElement;
    interface IScreenRect {
        top: number;
        left: number;
        width: number;
        height: number;
    }
    interface IView extends ICustomElement, HTMLElement, Readonly<IScreenRect> {
        invalidateSize(): void;
    }
    interface IDataHolder extends Tools.IEventData {
        hasData: boolean;
    }
    function onSaveInstanceState(context: Application.Context, node: Node, savedInstanceState: Application.Bundle): void;
    function onRestoreViewState(context: Application.Context, node: Node, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
    class AfcGuiElement extends HTMLElement implements ICustomElement {
        static observedAttributes: string[];
        protected static _setMute(mute: boolean, element: Element): void;
        static onSaveInstanceState(context: Application.Context, node: Node, savedInstanceState: Application.Bundle): void;
        static onRestoreViewState(context: Application.Context, node: Node, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
        protected static _resize(screenRect: Partial<IScreenRect>, element: Element): void;
        get hidden(): boolean;
        set hidden(value: boolean);
        protected _setMute(bMute: boolean): void;
        protected _setHide(bHide: boolean): void;
        protected _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void;
        protected _onRestoreViewState(context: Application.Context, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
        protected _resize(screenRect: Partial<IScreenRect>): void;
        init({ top, left, width, height }: Partial<IScreenRect>): this;
        set top(value: number);
        get top(): number;
        set left(value: number);
        get left(): number;
        set width(value: number);
        get width(): number;
        set height(value: number);
        get height(): number;
        invalidateSize(): void;
        isEmpty(): boolean;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
    }
    class AfcBindableElement<Model extends Partial<Tools.INotifier>, Adapter extends Tools.AdapterBase<Model>> extends AfcGuiElement {
        protected _connected: boolean;
        protected _model: Model;
        protected _adapter: Adapter;
        static observedAttributes: string[];
        protected _setMute(bMute: boolean): void;
        protected _bindTo(model: Model): void;
        get model(): Model;
        connectedCallback(): void;
        disconnectedCallback(): void;
        bindTo(model: Model): void;
        unbind(): void;
    }
    class AfcGuiAnimation extends AfcGuiElement {
        private _toggle;
        static observedAttributes: string[];
        constructor();
        protected _setHide(bHide: boolean): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
        guiAnimate(): void;
    }
}
/**
 * Created by jean.rennes on 18/01/2017.
 */
declare namespace AFC.gui {
    export interface IEventLayerInfo<K extends Globals.DrawableLayerType = Globals.DrawableLayerType, M extends Globals.IMapLayerModel<K> = Globals.IMapLayerModel<K>> extends Globals.IEventLayerInfo<K> {
        readonly provider: ILayerProviderElement<M>;
    }
    export type IMapEventHandlers = {
        [K in keyof Globals.IMapEventHandlers]: Parameters<Globals.IMapEventHandlers[K]>[0] extends L.LeafletMouseEvent ? (latLng: L.LatLng, info: IEventLayerInfo, event: Parameters<Globals.IMapEventHandlers[K]>[0]) => boolean : (event: Parameters<Globals.IMapEventHandlers[K]>[0], info: IEventLayerInfo) => boolean;
    };
    export interface ILayer<T extends Globals.IMapLayerModel = Globals.IMapLayerModel> {
        readonly id: string;
        readonly layerModel: T | null;
    }
    export interface IBaseLayerProvider<T extends Globals.IMapLayerModel = Globals.IMapLayerModel> {
        readonly name: string;
        readonly filterable?: boolean;
        getLayer(): Promise<Readonly<ILayer<T>>>;
    }
    export interface ILayerProvider<T extends Globals.IMapLayerModel = Globals.IMapLayerModel> extends IBaseLayerProvider<T>, Data.IFilterable<Globals.IMapLayerModelData> {
        readonly filterable: true;
        refresh(): void;
    }
    export interface ILayerProviderInfo {
        grayLevelsEnabled?: boolean;
        grayLevelsRaster?: boolean;
        provider: Globals.IRasterProvider;
    }
    export interface ILayerProviderElement<T extends Globals.IMapLayerModel = Globals.IMapLayerModel> extends HTMLElement {
        readonly handlers?: gui.IMapEventHandlers;
        readonly getBbox?: () => Promise<Tools.Geometry.Rectangle>;
        getCount(): number;
        getLayerProvider(indice: number): IBaseLayerProvider<T>;
        getInfo(): Promise<Readonly<ILayerProviderInfo>>;
    }
    export type ILayerSavedState = Partial<Pick<MapLayerProvider, 'hidden' | 'filter' | 'options' | 'clusteringMaxZoom' | 'clustering' | 'minZ'>>;
    export type IMapLayerProviderFilter = (row: ReadonlyArray<any>, dataModel: Globals.IMapLayerModelData) => boolean;
    interface IMapLayerProviderDescriptor {
        readonly name: string;
    }
    const _configuration: unique symbol;
    export abstract class MapLayerProvider<T extends Globals.IMapLayerModel = Globals.IMapLayerModel, D extends IMapLayerProviderDescriptor = IMapLayerProviderDescriptor> extends Tools.EventSink implements ILayerProvider<T> {
        protected _sequence: Symbol;
        protected _layerModel: T;
        protected readonly [_configuration]: ILayerSavedState;
        readonly id: string;
        readonly descriptor: D;
        readonly filterable: true;
        abstract type: Globals.LayerType;
        constructor(id: string, descriptor: D, configuration?: ILayerSavedState);
        protected abstract _getLayerModel(): Promise<T>;
        get name(): string;
        set hidden(value: boolean);
        get hidden(): boolean;
        set clusteringMaxZoom(value: number);
        get clusteringMaxZoom(): number;
        set clustering(value: boolean);
        get clustering(): boolean;
        set filter(value: IMapLayerProviderFilter);
        get filter(): IMapLayerProviderFilter;
        set options(value: Globals.GeoJSONOptionOverrides);
        get options(): Globals.GeoJSONOptionOverrides;
        set minZ(value: number);
        get minZ(): number;
        refresh(): void;
        getLayer(): Promise<Readonly<ILayer<T>>>;
    }
    abstract class GlobalLayerProvider<T extends Globals.IMapLayerModel> extends MapLayerProvider<T, Globals.MapLayerDescriptor> {
        constructor(descriptor: Globals.MapLayerDescriptor, configuration?: ILayerSavedState);
        get type(): Globals.LayerType;
        getDrawingInfo<D extends Globals.IMapLayerMetaData = Globals.IMapLayerMetaData>(): Promise<Globals.IMapLayerDrawingInfo<D>>;
        getLegendData(): Promise<Globals.ILayerLegendData>;
    }
    type ITileLayerProviderData = AFC.Globals.TileVectorModel<AFC.Globals.DrawableLayerType, AFC.Globals.ITileLayerProviderImpl<AFC.Globals.DrawableLayerType>>;
    export class TileLayerProvider extends GlobalLayerProvider<Globals.IMapLayerTiledModelImpl> {
        constructor(descriptor: Globals.MapLayerDescriptor, configuration: ILayerSavedState, dataModel?: ITileLayerProviderData);
        protected _getLayerModel(): Promise<Globals.IMapLayerTiledModelImpl>;
    }
    export class StaticLayerProvider extends GlobalLayerProvider<Globals.IMapLayerStaticModel> {
        constructor(descriptor: Globals.MapLayerDescriptor, configuration: ILayerSavedState, dataModel?: Data.IRowCollection & Data.IKeyProvider);
        protected _getLayerModel(): Promise<Globals.IMapLayerStaticModel>;
    }
    export function getProviderInfoFromMapMetadata(metadata: Readonly<Globals.IMapViewMetadata>): Promise<ILayerProviderInfo>;
    export const enum LayerDataMode {
        none = 0,
        static = 1,
        tiled = 2
    }
    export class AfcGuiLayer extends AfcGuiElement implements ILayerProviderElement {
        static observedAttributes: string[];
        handlers: gui.IMapEventHandlers;
        protected _setHide(bHide: boolean): void;
        protected _onRestoreViewState(activity: Application.RestActivity, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
        protected _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void;
        set template(value: string);
        set mode(value: LayerDataMode);
        get mode(): LayerDataMode;
        set dataModel(value: Data.IRowCollection & Data.IKeyProvider);
        get dataModel(): Data.IRowCollection & Data.IKeyProvider;
        set noClustering(value: boolean);
        set clusteringMaxZoom(value: number);
        set filter(value: (row: ReadonlyArray<any>, dataModel: Globals.IMapLayerModelData) => boolean);
        get filter(): (row: ReadonlyArray<any>, dataModel: Globals.IMapLayerModelData) => boolean;
        set minZ(value: number);
        getCount(): number;
        getLayerProvider(indice: number): ILayerProvider;
        getInfo(): Promise<Readonly<ILayerProviderInfo>>;
        getBbox(): Promise<Tools.Geometry.Rectangle>;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
        refresh(): void;
    }
    export interface ILayerInfo {
        layer: Globals.IMapLayerModel;
        provider: ILayerProviderElement;
    }
    interface ILayerInfoEx extends ILayerInfo {
        id: string;
        pos: number;
        loc: number;
        container: number;
        handlers?: gui.IMapEventHandlers;
        dataReader?: (row: any[], indice: number) => string;
        filterable?: Data.IFilterable;
    }
    class MapLegends extends Tools.EventSink implements Globals.ILegendsProvider {
        protected _control: L.Map;
        protected _infos: ILayerInfoEx[];
        protected _model: Globals.MapModel;
        protected _filterables: {
            [key: string]: Mutable<Controls.IFilterableLegendInfo>;
        };
        protected _legends: Controls.IFilterableLegendInfo[];
        constructor(control: L.Map);
        protected _refresh(): void;
        protected _update(): boolean;
        get legends(): ReadonlyArray<Controls.IFilterableLegendInfo>;
        setLayers(model: Globals.MapModel, infos?: ILayerInfoEx[]): void;
    }
    export function generateTooltips(info: Globals.IEventLayerInfo, dataReader?: (row: ReadonlyArray<any>, indice: number) => string): string;
    export interface IMapButtonOptions {
        text: string;
        iconUrl: string;
        toggle: boolean;
        hideText: boolean;
        maxWidth: string;
    }
    const _smartZoom: unique symbol;
    export class AfcGuiMapButton extends HTMLElement {
        protected _name: string;
        protected _options: L.ButtonOptions;
        protected _position: L.ControlPosition;
        protected _hidden: boolean;
        protected _button: L.Control.Button;
        static readonly observedAttributes: string[];
        static defaultSize: string;
        onButtonClick: (event: L.LeafletEvent) => any;
        constructor();
        set name(value: string);
        get name(): string;
        set position(value: L.ControlPosition);
        get position(): L.ControlPosition;
        get hidden(): boolean;
        set hidden(value: boolean);
        set options(value: Partial<IMapButtonOptions>);
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
        connectedCallback(): void;
        disconnectedCallback(): void;
    }
    export function autoZoom(map: AfcGuiMapHolder): void;
    export class AfcGuiMapHolder extends AfcGuiElement implements ILegendsProviderHolder {
        protected _adapter: Globals.MapAdapter;
        handlers: gui.IMapEventHandlers;
        readonly model: Globals.MapModel;
        readonly control: L.Map;
        readonly legends: MapLegends;
        static readonly observedAttributes: string[];
        static readonly Button: typeof AfcGuiMapButton;
        protected _setHide(bHide: boolean): void;
        protected _setMute(bMute: boolean): void;
        constructor();
        get adapter(): Globals.MapAdapter;
        set center(value: L.LatLng);
        get center(): L.LatLng;
        set scale(value: number);
        get scale(): number;
        get providers(): ILayerInfo[];
        protected _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void;
        protected _onRestoreViewState(context: Application.Context, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
        set disableSmartZoom(value: boolean);
        get disableSmartZoom(): boolean;
        get layers(): ReadonlyArray<Globals.ILayerDescriptor>;
        get selection(): {
            group: Controls.GeoJSON<Globals.LayerType.polygon, any> | Globals.ITileLayer<Globals.LayerType.polygon, Globals.ITileVectorModel<Globals.LayerType.polygon, Globals.ITileLayerProvider<Globals.LayerType.polygon>>> | Controls.GeoJSON<Globals.LayerType.line, any> | Globals.ITileLayer<Globals.LayerType.line, Globals.ITileVectorModel<Globals.LayerType.line, Globals.ITileLayerProvider<Globals.LayerType.line>>> | Controls.GeoJSON<Globals.LayerType.symbol, any> | Globals.ITileLayer<Globals.LayerType.symbol, Globals.ITileVectorModel<Globals.LayerType.symbol, Globals.ITileLayerProvider<Globals.LayerType.symbol>>> | Controls.MarkerClusterGroup<any>;
            keys: (readonly any[])[];
        };
        get buttons(): {
            [key: string]: import("leaflet").Control.Button;
            [_smartZoom]?: import("leaflet").Control.Button;
        };
        setView(center: L.LatLngExpression, zoom?: number, options?: L.ZoomPanOptions): Promise<L.LeafletEvent>;
        fitBounds(bounds: L.LatLngBoundsExpression): Promise<L.LeafletEvent>;
        smartZoom(): Promise<L.LeafletEvent>;
        addButton(options: Partial<L.ButtonOptions>, key?: string, position?: L.ControlPosition, hidden?: boolean): L.Control.Button;
        protected _removeButton(key: string): boolean;
        removeButton(button: L.Control.Button): void;
        refresh(): void;
        connectedCallback(): void;
        disconnectedCallback(): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
        protected _resize(screenRect: Partial<IScreenRect>): void;
        highlight(selection?: {
            model: Globals.IMapLayerModel;
            keys: ReadonlyArray<any>[];
        }): boolean;
    }
    export class AfcGuiLayerTooltip extends AfcGuiElement {
        protected _hidden: boolean;
        private _pinned;
        private _ttIsEmpty;
        private _ttFeatureId;
        static observedAttributes: string[];
        protected _setHide(bHide: boolean): void;
        constructor();
        hideTT(fromPin: boolean): boolean;
        pinTT(latlng: L.LatLng, info: Globals.IEventLayerInfo): boolean;
        protected onShowTT(latlng: L.LatLng, info: Globals.IEventLayerInfo): boolean;
        protected onHideTT(latlng: L.LatLng, info: Globals.IEventLayerInfo): boolean;
        showTT(latlng: L.LatLng, info: Globals.IEventLayerInfo, fromPin: boolean): boolean;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
        connectedCallback(): void;
        disconnectedCallback(): void;
        refresh(): void;
    }
    export {};
}
/**
 * Created by jean.rennes on 03/02/2016.
 */
declare namespace AFC.Dashboards {
    class MapAdapter extends Tools.AdapterBase<IMapModel> {
        protected _sequence: number;
        protected _redistrict: boolean;
        protected _district: number;
        protected _indicators: ReadonlyArray<string>;
        onUpdate: (districtLayerProvider: gui.IDistrictLayerProvider) => any;
        readonly layers: (gui.IBaseLayerProvider & {
            release?: () => void;
        })[];
        constructor();
        protected _update(model: IMapModel, event: Tools.IEvent<IMapModel, IDashboardEventData>): void;
        protected _onLayers(sequence: number, model: IMapModel, dashboard: Dashboards.IDashboard, descriptors: ReadonlyArray<Dashboards.IMapLayerDescriptor>, template: string, name: string): void;
        canDistrict(): boolean;
        isRedistricted(): boolean;
        resetDistrict(): void;
        getCount(): number;
        getLayerProvider(indice: number): gui.IBaseLayerProvider;
        getInfo(): Promise<Readonly<gui.ILayerProviderInfo>>;
        enableDistricting(enable: boolean, indicators?: ReadonlyArray<string>): void;
    }
}
/**
 * Created by jean.rennes on 19/09/2017.
 */
declare namespace AFC.Controls {
    class ComboBox extends Control {
        private _select;
        private _disabled;
        constructor(element: string | HTMLElement);
        private _onclick;
        private _onover;
        private _onout;
        private _onSelChange;
        onSelChange(ev: Event): any;
        get disabled(): boolean;
        set disabled(newVal: boolean);
        set value(newVal: string);
        get value(): string;
        addItem(value: {
            [key: string]: any;
        }, templateName?: string): void;
        empty(): void;
        private _getBckImage;
    }
}
/**
 * Created by jean.rennes on 19/09/2017.
 */
declare namespace AFC.Data {
    class ComboBoxAdapter extends AFC.Tools.AdapterBase<IDataSource & Tools.IObservable> {
        readonly control: Controls.ComboBox;
        onGenerate: () => any;
        private _value;
        constructor(control: Controls.ComboBox);
        onControlChange(this: GlobalEventHandlers, ev: Event): void;
        set value(newVal: string);
        get value(): string;
        private empty;
        protected _update(model: IDataSource): void;
        unbind(): void;
    }
}
/**
 * Created by jean.rennes on 08/09/2016.
 */
declare namespace AFC.Controls {
    class Label {
        protected _label: HTMLSpanElement;
        private _displayloading;
        constructor(element: any);
        setHTML(html?: string): void;
    }
}
/**
 * Created by jean.rennes on 31/03/2017.
 */
declare namespace AFC.Data {
    interface IPanel {
        update: (datasource?: IDataContainer) => any;
    }
    class LabelPanel implements IPanel {
        protected readonly _named: {
            name: string;
        };
        protected readonly _label: Controls.Label;
        constructor(named: {
            name: string;
        }, label: Controls.Label);
        update(dataContainer?: IDataContainer): void;
    }
    class PanelAdapter extends AFC.Tools.AdapterBase<IDataContainerProvider> {
        protected _cnt: number;
        protected _panels: {
            [key: string]: IPanel;
        };
        protected _dataContainer: IDataContainer;
        protected _onContainer(dataContainer: IDataContainer): void;
        protected _refresh(): void;
        protected _update(model: IDataContainerProvider): void;
        add(panel: IPanel): any;
        remove(key: any): void;
        unbind(): void;
        refresh(key?: any): void;
    }
}
/**
 * Created by jean.rennes on 08/09/2016.
 */
declare namespace AFC.Globals {
    interface ILabelProvider extends Tools.INotifier {
        readonly label: string;
    }
    class LabelAdapter extends Tools.AdapterBase<ILabelProvider> {
        readonly control: Controls.Label;
        constructor(label: Controls.Label);
        protected _update(model: ILabelProvider): void;
    }
}
/**
 * Created by jean.rennes on 17/03/2016.
 */
declare namespace AFC.Globals {
    interface ISymbolDescriptor {
        brands: string[];
        types: string[];
        symbols: string[];
        images: string[];
        index: {
            keys: number[];
            values: number[];
        };
    }
    interface ISymbol {
        url: string;
        width: number;
        height: number;
    }
    class SymbolFactory {
        private _data;
        private _reverse;
        private _index;
        private _widths;
        private _heights;
        constructor(descriptor: ISymbolDescriptor, widths: ReadonlyArray<number>, heights: ReadonlyArray<number>);
        get brands(): ReadonlyArray<string>;
        get businessCodes(): ReadonlyArray<string>;
        indexOf(brand: string): number;
        symbols(brand: string): {
            readonly [key: string]: string;
        };
        symbol(symbol: string): Readonly<ISymbol>;
    }
}
/**
 * Created by jean.rennes on 27/06/2016.
 */
declare namespace AFC.Data {
    export interface IFilteredDataModel extends IKeyProvider, IRowCollection, Partial<IColumnIndexProvider>, Partial<Tools.IObservable>, Partial<IDataEditor> {
        readonly values?: ReadonlyArray<ReadonlyArray<any>>;
        dropEvents?(key: ReadonlyArray<any>): void;
        find?(key: ReadonlyArray<any>): number;
        item?(index: number): IDataItemContainer;
        createStore?(): AFC.Data.IStore;
    }
    interface IIndex {
        readonly length: number;
        values: ReadonlyArray<ReadonlyArray<any>>;
        getRow(index: number): ReadonlyArray<any>;
        indexOf(row: ReadonlyArray<any>): number;
        find(key: ReadonlyArray<any>): number;
    }
    export class FilterModel<T extends IFilteredDataModel = IFilteredDataModel> extends Tools.AutoSubscribeForwarder implements IDataModel {
        protected _columnIndex: {
            readonly [key: string]: number;
        };
        protected _dataModel: T;
        protected _filter: (row: ReadonlyArray<any>, self: this) => boolean;
        protected _index: IIndex;
        constructor(filter?: (row: ReadonlyArray<any>, self: FilterModel<T>) => boolean, dataModel?: T);
        protected _getIndex(): IIndex;
        protected _filterEvent(item: IDataEventItem, a: IDataEventItem[]): void;
        protected _onDirty(event: IDataEvent): void;
        set filter(filter: (row: ReadonlyArray<any>, self: this) => boolean);
        get filter(): (row: ReadonlyArray<any>, self: this) => boolean;
        set dataModel(dataModel: T);
        get dataModel(): T;
        get columns(): ReadonlyArray<IDBColumn>;
        get primaryKey(): ReadonlyArray<string>;
        get length(): number;
        getRow(index: number): ReadonlyArray<ReadonlyArray<any>>;
        get values(): ReadonlyArray<ReadonlyArray<any>>;
        item(index: number): IDataItemContainer;
        get columnIndex(): {
            readonly [key: string]: number;
        };
        getKeyFromRow(row: any[]): ReadonlyArray<any>;
        compareKey(row: ReadonlyArray<any>, key: ReadonlyArray<any>): number;
        compareRow(row0: ReadonlyArray<any>, row1: ReadonlyArray<any>): number;
        create(key: any[], values: {
            [key: string]: any;
        }): boolean;
        modify(key: any[], values: {
            [key: string]: any;
        }): boolean;
        delete_(key: any[]): void;
        dropEvents(key: ReadonlyArray<any>): void;
        indexOf(row: ReadonlyArray<any>): number;
        find(key: ReadonlyArray<any>): number;
        refresh(): void;
        createStore(): AFC.Data.IStore;
    }
    export {};
}
/**
 * Created by jean.rennes on 03/02/2016.
 */
declare namespace AFC.Tools.Geometry {
    type Rectangle = [number, number, number, number];
    function inflateRect(bbox: Rectangle, position: GeoJSON.Position): void;
    function inflateRectWithRect(bbox0: Rectangle, bbox1: Rectangle): void;
    function getBoundRect(geometry: GeoJSON.GeoJsonObject): Rectangle;
    function equalPoint(g0: GeoJSON.Point, g1: GeoJSON.Point): boolean;
    function makePoint(x: number, y: number): GeoJSON.Point;
    function getCentroid(geometry: GeoJSON.Geometry): GeoJSON.Point;
    function pointInGeometry(point: GeoJSON.Position, geometry: GeoJSON.Point | GeoJSON.MultiPoint | GeoJSON.LineString | GeoJSON.MultiLineString | GeoJSON.Polygon | GeoJSON.MultiPolygon): boolean;
}
/**
 * Created by jean.rennes on 08/04/2016.
 */
declare namespace AFC.Tools.Cartographer {
    function getRowConverter<K extends keyof Globals.GeometryForLayerType, G extends GeoJSON.Geometry = Globals.GeometryForLayerType[K]>(layerType: K, iGeometry: number): (row: ReadonlyArray<any>) => G;
    function feature<G extends GeoJSON.Geometry = GeoJSON.Geometry, P extends Globals.IGeoJsonProperties = Globals.IGeoJsonProperties>(geometry: G, properties: P): GeoJSON.Feature<G, P>;
    function getGeoJSONFromCollection(collection: AFC.Data.IRowCollection, iGeometry: number, layerType: Globals.LayerType, options?: Globals.IConverterOptions): GeoJSON.GeoJsonObject;
}
/**
 * Created by jean.rennes on 10/03/2016.
 */
declare namespace AFC.Globals {
    export interface IConverterOptions {
        allow?(row: ReadonlyArray<any>): boolean;
        toBBox?(row: ReadonlyArray<any>): boolean;
    }
    interface IMapLayerEventData extends Tools.IEventData {
        visibility?: boolean;
        data?: Data.IDataModelEventData;
        style?: boolean;
        filter?: boolean;
    }
    export type IMapLayerEvent = Tools.IEvent<IMapLayerModel, IMapLayerEventData>;
    class MapLayerModelEventData implements IMapLayerEventData {
        visibility: boolean;
        data: Data.IDataModelEventData;
        style: boolean;
        filter: boolean;
        constructor(reset: boolean, visibility?: boolean, data?: Data.IDataModelEventData, filter?: boolean, style?: boolean);
        concat(d: IMapLayerEventData): MapLayerModelEventData;
    }
    export const mapLayerModelEventData: (reset: boolean, visibility?: boolean, data?: Data.IDataModelEventData, filter?: boolean, style?: boolean) => MapLayerModelEventData;
    export abstract class MapLayerModel<K extends DrawableLayerType, D extends IMapLayerModelData> extends Tools.AutoSubscribeForwarder implements IMapLayerModel<K> {
        protected _template: IMapVectorLayerMetaData<K>;
        protected _thematics: ILayerLegendData;
        protected _clustering: boolean;
        protected _clusteringMaxZoom: number;
        protected _filter: GeoJSONFilterOverride;
        protected _options: GeoJSONOptionOverrides;
        protected _hidden: boolean;
        abstract isTiled: boolean;
        minZ: number;
        maxZ: number;
        selectable: boolean;
        abstract data: D;
        override: IMapLayerModel['override'];
        constructor(template: IMapVectorLayerMetaData<K>, thematics: ILayerLegendData);
        get name(): string;
        get type(): K;
        get properties(): ILayerProperties;
        get symbolFactory(): SymbolFactory;
        get tooltips(): ReadonlyArray<{
            readonly id: string;
            readonly name: string;
            readonly format?: string;
        }>;
        set filter(filter: GeoJSONFilterOverride);
        get filter(): GeoJSONFilterOverride;
        set options(options: GeoJSONOptionOverrides);
        get options(): GeoJSONOptionOverrides;
        set hidden(value: boolean);
        get hidden(): boolean;
        get legend(): ILayerLegendData;
        set clustering(value: boolean);
        get clustering(): boolean;
        set clusteringMaxZoom(value: number);
        get clusteringMaxZoom(): number;
    }
    export class MapLayerStaticModel<K extends DrawableLayerType = DrawableLayerType> extends MapLayerModel<K, IStaticModelData> implements IMapLayerStaticModel<K, IStaticModelData> {
        protected _geoJSON: GeoJSON.GeoJsonObject;
        protected _converter: IConverterOptions;
        readonly data: IStaticModelData;
        readonly isTiled: false;
        constructor(template: IMapVectorLayerMetaData<K>, dataModel?: Data.IRowCollection & Data.IKeyProvider, thematics?: ILayerLegendData);
        protected _onDirty(e: Data.IDataEvent): void;
        set dataModel(dataModel: Data.IRowCollection & Data.IKeyProvider);
        set thematics(value: ILayerLegendData);
        set converter(value: IConverterOptions);
        set hidden(value: boolean);
        get hidden(): boolean;
        clone(): MapLayerStaticModel<K>;
        get geoJSON(): GeoJSON.GeoJsonObject;
        refresh(): void;
    }
    export class MapModel extends Tools.EventSink {
        protected _layers: IMapLayerModel[];
        constructor();
        protected _onAttach(event: IMapEvent): void;
        protected _onDirty(event: IMapLayerEvent): void;
        static getLegendInfo(layer: IMapLayerModel): ILegendInfo;
        get layers(): IMapLayerModel[];
        addLayer(layer: IMapLayerModel): void;
        clearLayers(): void;
    }
    export function layerType(value: LayerType): string;
    export function layerType(value: string): LayerType;
    interface IMapLayerMetaDataInternal {
        readonly name: string;
        readonly type: string;
        readonly properties: ILayerProperties;
        readonly tooltips: ReadonlyArray<{
            readonly id: string;
            readonly name: string;
        }>;
        readonly minScale: number;
        readonly maxScale: number;
        readonly minZ: number;
        readonly maxZ: number;
        readonly grayScale?: boolean;
        readonly selectable?: boolean;
        readonly hidden?: boolean;
        readonly table?: ICompoundTable & {
            readonly columns: ReadonlyArray<{
                name: string;
                type: string;
                alias?: string;
                size?: number;
                isPseudoColumn?: boolean;
            }>;
            readonly primaryKey?: ReadonlyArray<string>;
        };
        readonly symbolFactory?: SymbolFactory;
    }
    export function convertMapLayerMetaData<T extends Globals.IMapLayerMetaData = Globals.IMapLayerMetaData>(value: IMapLayerMetaDataInternal, globals: GlobalsDescriptor): Promise<IMapLayerMetaData>;
    export interface IMapLayerContent {
        table: Data.IRowCollection & Data.IKeyProvider;
        legend: ILayerLegendData;
    }
    export class MapLayerDescriptor extends Tools.EventSink implements Controls.IListItem {
        readonly id: string;
        readonly name: string;
        readonly type: LayerType;
        readonly filterable: true;
        readonly mapView: MapViewDescriptor;
        protected _seqData: number;
        protected _seqLegend: number;
        protected _globals: GlobalsDescriptor;
        protected _metadata: IMapLayerMetaData;
        protected _legend: ILayerLegendData;
        protected _content: IMapLayerContent;
        constructor(globals: GlobalsDescriptor, descriptor: MapViewDescriptor, data: {
            id: string;
            name: string;
        }, type: LayerType);
        createRequest<T = any>(path?: string, bypassContext?: boolean, options?: Rest.IRestRequestOptions): Rest.IAjaxRequest<T>;
        protected _onDataDone(metadata: IMapLayerMetaData, sequence: number, jqXHR?: JQueryXHR, textStatus?: string): void;
        protected _onLegendDone(sequence: number, jqXHR: JQueryXHR, textStatus: string): void;
        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void;
        getMetadata<T extends IMapLayerMetaData = IMapLayerMetaData>(): Promise<T>;
        getLegendData(): Promise<ILayerLegendData>;
        getContent(): Promise<Readonly<IMapLayerContent>>;
        invalidate(): void;
    }
    export interface IMapViewMetadata {
        grayLevelsEnabled?: boolean;
        layers: ReadonlyArray<MapLayerDescriptor>;
    }
    export class MapViewDescriptor extends Tools.EventSink implements Controls.IListItem {
        readonly id: string;
        readonly name: string;
        readonly globals: GlobalsDescriptor;
        protected _metadata: IMapViewMetadata;
        constructor(d: GlobalsDescriptor, i: IMapViewDescriptor);
        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void;
        createRequest<T = any>(path?: string, bypassContext?: boolean, options?: Rest.IRestRequestOptions): Rest.IAjaxRequest<T>;
        getMetadata(): Promise<Readonly<IMapViewMetadata>>;
        invalidate(): void;
    }
    export class GlobalsDescriptor extends Tools.EventSink {
        readonly restModel: Rest.RestModel;
        protected _mapViews: MapViewDescriptor[];
        protected symbols: SymbolFactory;
        protected _symbolSequence: number;
        protected _levels: IGeographicalLevels;
        protected _levelsSequence: number;
        constructor(restModel: Rest.RestModel);
        invalidate(): void;
        createAjaxRequest<T = any>(path?: string, bypassContext?: boolean, options?: Rest.IRestRequestOptions): Rest.IAjaxRequest<T>;
        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void;
        getMapViews(): Promise<ReadonlyArray<MapViewDescriptor>>;
        protected _onSymbolRestDone(sequence: number, jqXHR: JQueryXHR, textStatus: string): void;
        getSymbolFactory(): Promise<SymbolFactory>;
        protected _onLevelsRestDone(sequence: number, jqXHR: JQueryXHR, textStatus: string): void;
        getGeographicalLevels(): Promise<IGeographicalLevels>;
    }
    export interface IMapLayerDrawingInfo<T extends IMapLayerMetaData = IMapLayerMetaData> {
        descriptor: Globals.MapLayerDescriptor;
        map: Readonly<IMapViewMetadata>;
        layer: Readonly<T>;
        thematics?: Readonly<Globals.ILayerLegendData>;
    }
    export function isVectorLayer(metadata: {
        readonly type: LayerType;
    }): boolean;
    export function getMapLayerDrawingInfo<T extends IMapLayerMetaData = IMapLayerMetaData>(globals: GlobalsDescriptor, mapViewName: string, mapLayerName: string): Promise<IMapLayerDrawingInfo<T> | undefined>;
    export {};
}
/**
 * Created by jean.rennes on 20/02/2017.
 */
declare namespace AFC.Globals {
    export interface ILegendsProvider extends Tools.INotifier {
        legends: ReadonlyArray<Controls.IFilterableLegendInfo | Globals.ILegendInfo>;
    }
    class Filter {
        readonly legend: Controls.IFilterableLegendInfo;
        readonly map: number[];
        constructor(legend: Controls.IFilterableLegendInfo);
        protected _convert(solver: (row: ReadonlyArray<any>) => number, row: ReadonlyArray<any>): number;
        assign(mask: number): void;
        update(inputs: NodeListOf<HTMLInputElement>): number;
    }
    export class LegendsAdapter extends Tools.AdapterBase<ILegendsProvider> {
        protected _filters: {
            [key: string]: Filter;
        };
        readonly control: Controls.Legends;
        enableFiltering: boolean;
        constructor(control: Controls.Legends);
        protected _onChange(e: Event): void;
        protected _update(model: ILegendsProvider): void;
        isEmpty(): boolean;
    }
    export {};
}
declare namespace AFC.Controls {
    export interface TileLayerOptions<K extends Globals.DrawableLayerType = Globals.DrawableLayerType> {
        tileSize?: number | L.Point;
        updateWhenIdle?: boolean;
        updateWhenZooming?: boolean;
        updateInterval?: number;
        zIndex?: number;
        bounds?: L.LatLngBounds;
        minZoom?: number;
        maxZoom?: number;
        maxNativeZoom?: number;
        minNativeZoom?: number;
        noWrap?: boolean;
        pane?: string;
        keepBuffer?: number;
        layerProvider?: (options: L.GeoJSONOptions<Globals.ITileFeatureProperties<K>>) => IGeoJSON<K, Globals.ITileFeatureProperties<K>>;
    }
    export interface ITileLayer<K extends Globals.DrawableLayerType> extends L.FeatureGroup<Globals.ITileFeatureProperties<K>> {
        readonly options: TileLayerOptions<K>;
        getContainer(): HTMLElement | null;
        setOpacity(opacity: number): this;
        setZIndex(zIndex: number): this;
        isLoading(): boolean;
        redraw(): this;
        getTileSize(): L.Point;
        getGeometryFromResult: (row: ReadonlyArray<any>) => Globals.GeometryForLayerType[K];
        setStyle(style: L.PathOptions | L.StyleFunction): this;
        setFilter(filter: (feature: GeoJSON.Feature<Globals.GeometryForLayerType[K]>) => boolean): this;
        addData(data: GeoJSON.GeoJsonObject | ReadonlyArray<GeoJSON.GeoJsonObject>): this;
        removeLayer(layer: Globals.LayerForLayerType<K>): this;
        findItem(key: ReadonlyArray<any>): Globals.LayerForLayerType<K>;
        requestTiles(keys: ReadonlyArray<string>, callback: (keys: ReadonlyArray<string>, rows: ReadonlyArray<ReadonlyArray<any>>) => any): void;
        getTileFeaturesForLatLng(latLng: L.LatLng, zoom?: number): Promise<Globals.LayerForLayerType<K>[]>;
        zoomToShowLayer(layer: L.Layer, callback?: () => void): void;
        isVisible(): boolean;
        setZIndex(zIndex: number): this;
        getLayers(): Globals.LayerForLayerType<K>[];
        highlight(keys?: ReadonlyArray<any>[]): void;
    }
    class TileLayerImpl<K extends Globals.DrawableLayerType> extends L.FeatureGroup<Globals.ITileFeatureProperties<K>> implements ITileLayer<K> {
        protected _tiles: L.InternalTiles & {
            [key: string]: {
                features: GeoJSON.Feature<Globals.GeometryForLayerType[K], Globals.ITileFeatureProperties<K>>[];
            };
        };
        protected _map: L.Map & {
            _animateToZoom: number;
            _animatingZoom: boolean;
        };
        protected _loading: boolean;
        protected _zoomAnimated: boolean;
        protected _tileZoom: number;
        protected _layers: {
            [key: number]: L.Layer;
        };
        protected _geoJSON: IGeoJSON<K, Globals.ITileFeatureProperties<K>>;
        protected _tileSize: number;
        protected _globalTileRange: L.Bounds;
        protected _wrapX: [number, number];
        protected _wrapY: [number, number];
        protected _removeAllTiles(): void;
        protected _update(center?: L.LatLng): void;
        protected _invalidateAll(): void;
        protected _addTile(coords: L.Coords): void;
        protected _removeTile(key: string): void;
        protected _tileCoordsToKey(coords: L.Coords): string;
        protected _keyToTileCoords(key: string): L.Coords;
        protected _abortLoading?: () => void;
        protected _clampZoom(zoom: number): number;
        protected _getTiledPixelBounds(center: L.LatLng): L.Bounds;
        protected _resetView(): void;
        protected _animateZoom(): void;
        protected _resetGrid(): void;
        protected _onMoveEnd(event: L.LeafletEvent): void;
        protected _pxBoundsToTileRange(bounds: L.Bounds): L.Bounds;
        protected _isValidTile(coords: L.Coords): boolean;
        protected _tileCoordsToNwSe(coords: L.Coords): L.Point;
        protected _tileCoordsToBounds(coords: L.Coords): L.LatLngBounds;
        protected _setZoomTransforms(center: L.LatLng, zoom: number): void;
        protected _updateLevels(): void;
        protected _retainParent(x: number, y: number, z: number, minZoom: number): boolean;
        protected _retainChildren(x: number, y: number, z: number, maxZoom: number): void;
        protected _pruneTiles(): void;
        protected _noTilesToLoad(): boolean;
        protected _setView(center: L.LatLng, zoom: number, noPrune?: boolean, noUpdate?: boolean): void;
        protected _keyToBounds(key: string): L.Bounds;
        bringToFront(): this;
        bringToBack(): this;
        getContainer(): HTMLElement | null;
        setOpacity(opacity: number): this;
        setZIndex(zIndex: number): this;
        isLoading(): boolean;
        redraw(): this;
        getTileSize(): L.Point;
        protected _callback: (keys: ReadonlyArray<string>, rows: ReadonlyArray<ReadonlyArray<any>>) => void;
        protected _geojsonOptions: L.GeoJSONOptions;
        protected _features: Globals.ITileVectorModel<K>;
        protected _pending: boolean;
        protected _getGeoJSONOptions(geojsonOptions?: L.GeoJSONOptions): L.GeoJSONOptions;
        protected _onEachFeature(feature: GeoJSON.Feature<Globals.GeometryForLayerType[K], Globals.ITileFeatureProperties<K>>, layer: Globals.LayerForLayerType<K, Globals.ITileFeatureProperties<K>>): void;
        protected _onEachFeatureOption: (feature: GeoJSON.Feature<Globals.GeometryForLayerType[K], Globals.ITileFeatureProperties<K>>, layer: L.Layer) => void;
        protected _loadTiles(): boolean;
        protected _getPixelBoundsFromRect(rectangle: Tools.Geometry.Rectangle, zoom: number): L.Bounds;
        protected _tilesReady(keys: ReadonlyArray<string>, rows: ReadonlyArray<ReadonlyArray<any>>): void;
        protected _removeFeature(entity: GeoJSON.Feature<Globals.GeometryForLayerType[K], Globals.ITileFeatureProperties<K>>): void;
        protected _eachIntersectingTile(rectangle: Tools.Geometry.Rectangle, method: (tile: TileLayerImpl<K>['_tiles'][0]) => void): void;
        readonly options: TileLayerOptions<K>;
        getGeometryFromResult: (row: ReadonlyArray<any>) => Globals.GeometryForLayerType[K];
        setStyle(style: L.PathOptions | L.StyleFunction): this;
        setFilter(filter: (feature: GeoJSON.Feature<Globals.GeometryForLayerType[K]>) => boolean): this;
        addData(data: GeoJSON.GeoJsonObject | ReadonlyArray<GeoJSON.GeoJsonObject>): this;
        removeLayer(layer: Globals.LayerForLayerType<K>): this;
        findItem(key: ReadonlyArray<any>): Globals.LayerForLayerType<K>;
        requestTiles(keys: ReadonlyArray<string>, callback: (keys: ReadonlyArray<string>, rows: ReadonlyArray<ReadonlyArray<any>>) => any): void;
        getTileFeaturesForLatLng(latLng: L.LatLng, zoom?: number): Promise<Globals.LayerForLayerType<K>[]>;
        zoomToShowLayer(layer: L.Layer, callback?: () => void): void;
        isVisible(): boolean;
        setZIndex(zIndex: number): this;
        getLayers(): Globals.LayerForLayerType<K>[];
        highlight(keys?: ReadonlyArray<any>[]): void;
    }
    export const TileLayer: {
        new <K extends Globals.DrawableLayerType = Globals.DrawableLayerType>(model: Globals.ITileVectorModel<K>, options?: TileLayerOptions<K>, geojsonOptions?: L.GeoJSONOptions<Globals.IGeoJsonProperties>): TileLayerImpl<K>;
    };
    export function tileLayer<K extends Globals.DrawableLayerType>(model: Globals.ITileVectorModel<K>, options?: TileLayerOptions<K>, geojsonOptions?: L.GeoJSONOptions<Globals.IGeoJsonProperties>): TileLayerImpl<K>;
    export {};
}
/**
 * Created by jean.rennes on 30/06/2016.
 */
declare namespace L {
    interface StripePatternOptions {
        weight?: number;
        spaceWeight?: number;
        color?: string;
        spaceColor?: string;
        opacity?: number;
        spaceOpacity?: number;
        angle?: number;
        width?: number;
        height?: number;
    }
    class Pattern {
        addTo(map: Map): this;
        remove(): this;
        removeFrom(map: Map): this;
    }
    class StripePattern extends Pattern {
        constructor(options?: StripePatternOptions);
    }
    function stripePattern(options?: StripePatternOptions): StripePattern;
}
declare namespace AFC.Globals {
    export interface GeometryForLayerType {
        [Globals.LayerType.polygon]: GeoJSON.Polygon | GeoJSON.MultiPolygon;
        [Globals.LayerType.line]: GeoJSON.LineString | GeoJSON.MultiLineString;
        [Globals.LayerType.symbol]: GeoJSON.Point;
        [Globals.LayerType.unknown]: never;
        [Globals.LayerType.label]: never;
        [Globals.LayerType.pie]: never;
        [Globals.LayerType.olap]: never;
        [Globals.LayerType.raster]: never;
        [Globals.LayerType.mxd]: never;
    }
    export type Point<P extends IGeoJsonProperties = IGeoJsonProperties> = (L.CircleMarker<P> & {
        feature: GeoJSON.Feature<GeoJSON.Point, P>;
    }) | (L.Marker<P> & {
        feature: GeoJSON.Feature<GeoJSON.Point, P>;
    });
    export type PolyLine<P extends IGeoJsonProperties = IGeoJsonProperties> = L.Polyline<GeoJSON.LineString | GeoJSON.MultiLineString, P> & {
        feature: GeoJSON.Feature<GeoJSON.LineString, P> | GeoJSON.Feature<GeoJSON.MultiLineString, P>;
    };
    export type Polygon<P extends IGeoJsonProperties = IGeoJsonProperties> = L.Polygon<P> & {
        feature: GeoJSON.Feature<GeoJSON.Polygon, P> | GeoJSON.Feature<GeoJSON.MultiPolygon, P>;
    };
    export type LayerForLayerType<K extends LayerType = LayerType, P extends Globals.IGeoJsonProperties = IGeoJsonProperties> = K extends LayerType.symbol ? Point<P> : K extends LayerType.line ? PolyLine<P> : K extends LayerType.polygon ? Polygon<P> : never;
    export interface ITileLayer<K extends DrawableLayerType = DrawableLayerType, D extends ITileVectorModel<K> = ITileVectorModel<K>> extends Controls.ITileLayer<K> {
        readonly tiledModel: IMapLayerTiledModel<K, D>;
        getBoundsFromKeys(keys: ReadonlyArray<string>): L.LatLngBounds;
        intersect(keys: ReadonlyArray<string>, rectangle: Tools.Geometry.Rectangle): boolean;
    }
    type GeoJSON<K extends DrawableLayerType = DrawableLayerType> = Controls.GeoJSON<K, any>;
    type MarkerClusterGroup = Controls.MarkerClusterGroup<any>;
    export type FeatureGroup<K extends DrawableLayerType = DrawableLayerType> = K extends LayerType.symbol ? GeoJSON<LayerType.symbol> | ITileLayer<LayerType.symbol> | MarkerClusterGroup : GeoJSON<K> | ITileLayer<K>;
    export interface ILayerDescriptor<K extends DrawableLayerType = DrawableLayerType> {
        model: IMapLayerModel;
        options: L.GeoJSONOptions;
        featureGroup: FeatureGroup<K>;
    }
    export interface IEventLayerInfo<K extends DrawableLayerType = DrawableLayerType> extends ILayerDescriptor<K> {
        feature?: LayerForLayerType<K>;
        index: number;
        options: L.GeoJSONOptions<Globals.IGeoJsonProperties>;
    }
    type _extendedEvents = 'animationend';
    export type MapEventHandler<K extends keyof L.LeafletEventHandlerFnMap | _extendedEvents = keyof L.LeafletEventHandlerFnMap | _extendedEvents> = (event: K extends keyof L.LeafletEventHandlerFnMap ? Parameters<L.LeafletEventHandlerFnMap[K]>[0] : L.LeafletEvent, info: IEventLayerInfo) => any;
    const _mouseEvents: string[];
    export type IMapEventHandlers = {
        [K in keyof L.LeafletEventHandlerFnMap | _extendedEvents]?: K extends typeof _mouseEvents[number] ? MapEventHandler<K> : never;
    };
    export function isQuali(data: ReadonlyArray<IClassInfo>): boolean;
    export function getMonoThematicSolver(column: string, classes: ReadonlyArray<IThematicValue>, legendData: Partial<ILegendData>, columnIndex: {
        readonly [key: string]: number;
    }): (row: ReadonlyArray<any>) => number;
    export function getThematicSolver(property: Partial<ILayerProperty>, legendData: Partial<ILegendData>, columnIndex: {
        readonly [key: string]: number;
    }): (row: ReadonlyArray<any>) => number;
    interface ILayerPropertyReader<V> {
        readValue(row: ReadonlyArray<any>): V;
    }
    export class LayerPropertyReader<T, V = T> implements ILayerPropertyReader<V> {
        protected _reader: (row: ReadonlyArray<any>) => T;
        protected _converter: (t: T) => V;
        constructor(property: Partial<ILayerProperty<T>>, legendData: Partial<ILegendData>, columnIndex: {
            readonly [key: string]: number;
        }, converter?: (t: T) => V);
        readValue(row: ReadonlyArray<any>): V;
    }
    export const enum PatternStyle {
        empty = 0,
        solid = 1,
        hatch = 10,
        thickHatch = 11,
        crossHatch = 15,
        cross = 16,
        emptyCircle = 20,
        circle = 21,
        emptyDiamond = 25,
        diamond = 26,
        checkered = 30
    }
    export class MapAdapter extends Tools.AdapterBase<Globals.MapModel> {
        readonly control: L.Map;
        protected _featureGroup: L.FeatureGroup;
        protected _patterns: {
            [key: string]: L.StripePattern;
        };
        handlers: IMapEventHandlers;
        onComplete: (layers: ReadonlyArray<ILayerDescriptor>) => void;
        constructor(mapControl: L.Map);
        protected _buildFeature({ model, options }: {
            model: IMapLayerModel;
            options: L.GeoJSONOptions;
        }): FeatureGroup<any>;
        protected _addItem(layerModel: Globals.IMapLayerModel, modelData: Globals.IMapLayerModelData, featureGroup: FeatureGroup, row: ReadonlyArray<any>, iGeometry: number): void;
        protected _modifyItem(layerModel: Globals.IMapLayerModel, modelData: Globals.IMapLayerModelData, featureGroup: FeatureGroup, row: ReadonlyArray<any>, iGeometry: number): void;
        protected _removeItem(modelData: Globals.IMapLayerModelData, featureGroup: FeatureGroup, row: ReadonlyArray<any>): void;
        protected _needReset(item: IMapEventDataLayer): boolean;
        protected _createPane(layerModel: IMapLayerModel, counters: number[]): string;
        protected _update(model: Globals.MapModel, event?: IMapEvent): void;
        protected _raiseLayerEvent(e: L.LeafletEvent, handlers: IMapEventHandlers, fn: MapEventHandler): void;
        protected _handleClick(e: L.LeafletMouseEvent & {
            originalEvent: {
                readonly _stopped: boolean;
            };
        }): void;
        protected _onLayerEvent(e: L.LeafletEvent): void;
        protected _onMapEvent(e: L.LeafletEvent): void;
        protected _attachHandlers(events: string[], o: L.Evented, fn: L.LeafletEventHandlerFn): void;
        protected _attachLayerHandlers(o: L.Evented): void;
        protected _detachHandlers(events: string[], o: L.Evented, fn: L.LeafletEventHandlerFn): void;
        protected _detachLayerHandlers(o: L.Evented): void;
        clearMap(): void;
        get featureGroup(): L.FeatureGroup;
        get layers(): ReadonlyArray<ILayerDescriptor>;
        addPattern(key: string, options: L.StripePatternOptions): L.StripePattern;
        unbind(): void;
    }
    export {};
}
declare namespace AFC.Globals {
    interface IElemProvider extends Tools.INotifier {
        readonly [key: string]: any;
    }
    class TemplateElemAdapter extends Tools.AdapterBase<IElemProvider> {
        readonly control: Controls.TemplateElem;
        onClear: () => any;
        onGenerate: () => any;
        constructor(elem: Controls.TemplateElem);
        protected _update(model: IElemProvider): void;
    }
}
/**
 * Created by jean.rennes on 29/07/2022.
 */
declare namespace AFC.Globals {
    const enum TaskStatus {
        idle = 0,
        updating = 1,
        completed = 2
    }
    export interface IProgressInfoBarTask {
        readonly tid: string;
        readonly progressData: Readonly<AFC.Globals.IProgressData>;
        readonly status: TaskStatus;
        update(): void;
    }
    export class WaitAdapter {
        readonly waitBar: Controls.WaitBar;
        readonly progressBar: Controls.ProgressBar;
        dummyEnabled: boolean;
        constructor({ waitBar, progressBar }: {
            waitBar?: Controls.WaitBar;
            progressBar?: Controls.ProgressBar;
        });
        register(): void;
        unregister(): void;
        push(restModel: Rest.RestModel, tid?: string): void;
        pop(restModel: Rest.RestModel, tid?: string): void;
    }
    export {};
}
/**
 * Created by jean.rennes on 06/12/2019.
 */
declare namespace AFC.Application {
    export interface ILayoutInflater {
        inflate(resource: string, root: gui.IView): gui.IView;
    }
    export interface IFragmentHostCallback {
        onGetLayoutInflater(): ILayoutInflater;
    }
    export type IBundleValue = any;
    export class Bundle {
        getKeys(): ReadonlyArray<string>;
        getValue<T extends IBundleValue = IBundleValue>(key: string | symbol): T;
        putValue<T extends IBundleValue = IBundleValue>(key: string | symbol, value: T): void;
        getBundle(key: string | symbol): Bundle;
        putBundle(key: string | symbol, value: Bundle): void;
        isEmpty(): boolean;
    }
    class FragmentState {
        constructor();
        initFrom(fragment: Fragment): this;
        instantiate(activity: Activity, parent: Fragment): Fragment;
    }
    export class Fragment {
        protected containerId: string;
        static SavedState: typeof FragmentState;
        getTag(): string;
        getActivity<T extends Activity>(): T;
        getView<T extends gui.IView>(): T;
        addEventListener(view: gui.IView, query: string, event: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        getArguments(): Bundle;
        setArguments(bundle: Bundle): void;
        onAttach(context: Context): void;
        onAttachFragment(childFragment: Fragment): void;
        onCreate(savedInstanceState?: Bundle): void;
        onCreateView(inflater: ILayoutInflater, container: Readonly<gui.IView>, savedInstanceState?: Bundle): Readonly<gui.IView>;
        onActivityCreated(savedInstanceState?: Bundle): void;
        onViewStateRestored(savedInstanceState?: Bundle): void;
        onSaveInstanceState(savedInstanceState: Bundle): void;
        onDestroyView(): void;
        onDestroy(): void;
        getChildFragmentManager(): FragmentManager;
        getFragmentManager(): FragmentManager;
        getParentFragment(): Fragment;
        getLayoutInflater(savedInstanceState: Bundle): ILayoutInflater;
    }
    export type FragmentManager = InstanceType<typeof Fragment.FragmentManager>;
    export const FragmentManager: {
        new (activity: Activity, host: IFragmentHostCallback, parentFragment?: Fragment): FragmentManager;
        detachView(fragment: Fragment, noDestroy?: boolean): void;
        destroyFragment(fragment: Fragment): void;
    };
    export type FragmentManagerState = ReadonlyArray<FragmentState>;
    export {};
}
/**
 * Created by jean.rennes on 18/09/2020.
 */
declare namespace AFC.Application {
    class Intent extends Bundle {
        readonly packageContext: Context;
        readonly cls: Tools.Constructor;
        constructor(packageContext: Context, cls: Tools.Constructor);
    }
    class Context {
        constructor(base: Context);
        startActivity(intent: Intent): void;
        getBaseContext<T extends Context = Context>(): T;
    }
    class Activity extends Context {
        protected _onCreate(icicle: Bundle): void;
        protected _onStart(): void;
        protected _onStop(): void;
        protected _onDestroy(): void;
        getWindow(): Controls.Window;
        getIntent(): Intent;
        setContentView(view: gui.IView): void;
        getSupportFragmentManager(): FragmentManager;
        getLayoutInflater(): ILayoutInflater;
        finish(): void;
    }
}
/**
 * Created by jean.rennes on 18/09/2020.
 */
declare namespace AFC.Application {
    class Application extends Context {
        constructor();
        onCreate(): void;
    }
}
/**
 * Created by jean.rennes on 18/09/2020.
 */
declare namespace AFC.Application {
    function ShowWaitBar(restModel?: Rest.RestModel, tid?: string): void;
    function HideWaitBar(restModel?: Rest.RestModel, tid?: string): void;
    interface RestActivityOptions {
        url: string;
    }
    class RestActivity extends Activity {
        protected _onCreate(icicle?: Bundle): void;
        getRestModel(): Rest.RestModel;
        getAuthorizationPolicy(): Rest.IAuthorizationPolicy;
        getIdentity(): Rest.IIdentity;
    }
}
/**
 * Created by jean.rennes on 13/02/2017.
 */
declare namespace AFC.Data {
    interface IScenarioCreation {
        [key: string]: any;
    }
    interface IScenarioModification {
        oldValues: {
            [key: string]: any;
        };
        values: {
            [key: string]: any;
        };
    }
    interface IScenarioDeletion {
        [key: string]: any;
    }
    class Scenario extends Tools.EventSink implements IRowCollection, IKeyProvider, IDataSource<Globals.IEventInfo> {
        constructor(storeSource: StoreSource, model: IDataModelView);
        protected _onDirty(event: Data.IDataEvent): void;
        get creations(): ReadonlyArray<IScenarioCreation>;
        get modifications(): ReadonlyArray<IScenarioModification>;
        get deletions(): ReadonlyArray<IScenarioDeletion>;
        private _filter;
        get length(): number;
        indexOf(row: ReadonlyArray<any>): number;
        getRow(index: number): ReadonlyArray<any>;
        get columns(): ReadonlyArray<IDBColumn>;
        get primaryKey(): ReadonlyArray<string>;
        getKeyFromRow(row: ReadonlyArray<any>): ReadonlyArray<any>;
        compareKey(row: ReadonlyArray<any>, key: ReadonlyArray<any>): number;
        compareRow(row0: ReadonlyArray<any>, row1: ReadonlyArray<any>): number;
        item(index: number): IDataItemContainer<Globals.IEventInfo>;
        dropEvents(key: ReadonlyArray<any>): void;
        readonly source: StoreSource;
        readonly model: IDataModelView;
    }
}
/**
 * Created by jean.rennes on 22/06/2018.
 */
declare namespace AFC.Data {
    interface ITableResourceContent<T extends TableDescriptor = TableDescriptor> {
        readonly resource: string;
        readonly descriptor: T;
        readonly definition: IDBTableDefinition;
        readonly history?: IHistory;
    }
    interface ISessionProvider {
        getSession(): string;
    }
    interface ITableResource {
        readonly dbName: string;
        readonly name: string;
        readonly session: string;
        refreshStamps(): void;
        reset(rest: AFC.Rest.RestModel, dbName: string, name: string): this;
        load(): Promise<ITableResourceContent>;
        release(): void;
    }
    const tableResource: (sessionProvider?: ISessionProvider) => ITableResource;
    abstract class ResourceLoader<T extends ITableResourceContent = ITableResourceContent> extends Tools.EventSink {
        constructor(resource: ITableResource);
        getMetadata(): Promise<T>;
        get tableResource(): ITableResource;
        clone(): ResourceLoader;
        protected _content: T;
    }
}
/**
 * Created by jean.rennes on 22/04/2016.
 */
declare namespace AFC.TradeArea {
    export type DMAConfigDescriptor = Readonly<{
        id: string;
        name: string;
        comment: string;
        income: boolean;
        dataInput: ReadonlyArray<Readonly<{
            table: string;
            columns: ReadonlyArray<string>;
        }>>;
    }>;
    export interface IDMAContext {
        source: TradeArea.IDMASites;
        target: TradeArea.IDMASites;
    }
    export class DMAConfigsDescriptor extends Tools.EventSink {
        protected _dma: ReadonlyArray<DMAConfigDescriptor>;
        protected _sequence: number;
        readonly restModel: Rest.RestModel;
        constructor(restModel: Rest.RestModel);
        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void;
        getConfigurations(): Promise<ReadonlyArray<DMAConfigDescriptor>>;
    }
    export interface IDMASites {
        readonly reference: string;
        readonly events?: Data.IModificationEvents;
    }
    interface IDMA {
        area?: {
            columns: any[];
            primaryKey: string[];
            values: any[][];
        };
        income?: {
            columns: any[];
            primaryKey: string[];
            values: any[][];
        };
        neighbors?: {
            columns: any[];
            primaryKey: string[];
            values: any[][];
        };
    }
    export interface IDMASimulation {
        sites: IDMASites;
        readonly area: Data.IDataTable & Data.IDataCreation;
        readonly income: Data.IDataTable & Data.IDataCreation;
        readonly neighbors: Data.IDataTable & Data.IDataCreation;
    }
    class DMASimulation implements IDMASimulation {
        protected _config: DMAConfigModel;
        protected _invalidate: () => void;
        protected _sites: IDMASites;
        protected _area: Data.DataModelBase;
        protected _income: Data.DataModelBase;
        protected _neighbors: Data.DataModelBase;
        constructor(config: DMAConfigModel, invalidate: () => void);
        initFrom(dma: IDMA): void;
        set sites(value: IDMASites);
        get sites(): IDMASites;
        get area(): Data.DataModelBase;
        get income(): Data.DataModelBase;
        get neighbors(): Data.DataModelBase;
    }
    export class DMAConfigModel extends Tools.EventSink {
        protected _configs: DMAConfigsDescriptor;
        protected _config: DMAConfigDescriptor;
        protected _id: string;
        protected _area: boolean;
        protected _income: boolean;
        protected _neighbors: boolean;
        protected _impact: boolean;
        protected _restricted: boolean;
        protected _sites: ReadonlyArray<any>;
        protected _threshold: number;
        protected _sequence: number;
        protected _storeCode: string;
        protected _storeTable: Dashboards.ISitesTable;
        protected _areaCode: string;
        protected _influence: string;
        protected _time: string;
        protected _partition: string[];
        protected _source: DMASimulation;
        protected _target: DMASimulation;
        protected _impactTable: Data.DataModelBase;
        constructor(configs: DMAConfigsDescriptor);
        private _invalidate;
        set id(value: string);
        set area(value: boolean);
        get area(): boolean;
        set income(value: boolean);
        get income(): boolean;
        set neighbors(value: boolean);
        get neighbors(): boolean;
        set impact(value: boolean);
        get impact(): boolean;
        set restricted(value: boolean);
        get restricted(): boolean;
        set sites(value: ReadonlyArray<any>);
        get sites(): ReadonlyArray<any>;
        set threshold(value: number);
        get storeTable(): Dashboards.ISitesTable;
        get storeCode(): string;
        get areaCode(): string;
        get influence(): string;
        get time(): string;
        get partition(): ReadonlyArray<string>;
        get source(): IDMASimulation;
        get target(): IDMASimulation;
        get impactTable(): Data.DataModelBase;
        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void;
        protected _run(): void;
        simulate(): Promise<void>;
    }
    export {};
}
/**
 * Created by jean.rennes on 22/06/2018.
 */
declare namespace AFC.Data {
    export interface IIndexedTable {
        readonly definition: IDBTableDefinition;
        readonly columnIndex: {
            [key: string]: number;
        };
        readonly geometryIndice: number;
        qualifiers?: {
            [key: number]: number;
        };
    }
    export interface IStoreTableResourceContent extends ITableResourceContent, IIndexedTable {
        readonly descriptor: AFC.Data.HistoricizedTableDescriptor;
    }
    interface ISourceParametersData extends Tools.IObservable {
        readonly columnIndex: {
            [key: string]: number;
        };
        indexOf(key: ReadonlyArray<any>): number;
        getRow(index: number): ReadonlyArray<any>;
        compareKey: (row: ReadonlyArray<any>, value: any) => number;
        create(key: ReadonlyArray<any>, values: {
            [key: string]: any;
        }): any;
        modify(key: ReadonlyArray<any>, values: {
            [key: string]: any;
        }): any;
        delete_(key: ReadonlyArray<any>): any;
    }
    export interface ISourceParameters extends IDataContainerChecker<IStore> {
        readonly data: ISourceParametersData;
    }
    export function findQualifier(content: {
        readonly definition: IDBTableDefinition;
        qualifiers?: {
            [key: number]: number;
        };
    }, qualifier: Qualifier, mute?: boolean): number;
    export abstract class StoreBase implements IReadonlyStore {
        readonly content: IIndexedTable;
        abstract readonly geometry: GeoJSON.Point;
        readonly identifier: string;
        readonly mainAddress: string;
        readonly address: string;
        readonly zipCode: string;
        readonly city: string;
        readonly country: string;
        readonly totalSurface: number;
        readonly surface: number;
        readonly symbol: string;
        readonly brand: string;
        readonly businessCode: string;
        readonly revenue: number;
        readonly changes: string;
        constructor(content: IIndexedTable);
        protected _getGeometry(): number;
        protected _getColumn(column: string): number;
        protected _getQualifier(qualifier: Qualifier, mute?: boolean): number;
        protected abstract _getData(indice: number): any;
        static extend(constructor: {
            new (...items: any[]): IReadonlyStore;
        }, getProperty: (qualifier: Qualifier) => PropertyDescriptor): void;
        get tableDefinition(): IDBTableDefinition;
        get key(): ReadonlyArray<any>;
        getData(column: string, stringify?: boolean): any;
        hasQualifier(qualifier: Qualifier): boolean;
        getQualifiedColumn(qualifier: Qualifier): IDBColumnDefinition;
        getColumn(name: string): IDBColumnDefinition;
    }
    export class ReadonlyStore extends StoreBase {
        protected _values: ReadonlyArray<any>;
        constructor(content: IIndexedTable, values: ReadonlyArray<any>);
        protected _getData(indice: number): any;
        static propertyDefinition(qualifier: Qualifier): PropertyDescriptor;
        get geometry(): GeoJSON.Point;
    }
    const Store_base: abstract new (...args: any[]) => StoreBase & Tools.IEventSink;
    export class Store extends Store_base implements IStore {
        protected readonly _parameters: ISourceParameters;
        protected _values: ReadonlyArray<any>;
        protected _override: RecordOverrides;
        protected _closed: boolean;
        protected _created: boolean;
        protected _valid: boolean;
        protected _messages: ReadonlyArray<ICheckMessage>;
        protected _events: {
            [key: string]: any;
        };
        readonly content: IStoreTableResourceContent;
        identifier: string;
        mainAddress: string;
        address: string;
        zipCode: string;
        city: string;
        country: string;
        totalSurface: number;
        surface: number;
        symbol: string;
        brand: string;
        businessCode: string;
        revenue: number;
        changes: string;
        constructor(content: IStoreTableResourceContent, parameters: ISourceParameters, values: ReadonlyArray<any>);
        protected _reset(values: ReadonlyArray<any>): void;
        protected _toPositions(columns: ReadonlyArray<string>): ReadonlyArray<number>;
        protected _getData(indice: number): any;
        protected _set(indice: number, value: any): boolean;
        protected _check(parameters: ISourceParameters, callback: (valid: boolean, messages: ReadonlyArray<ICheckMessage>, events: {
            [key: string]: any;
        }) => any): void;
        static propertyDefinition(qualifier: Qualifier): PropertyDescriptor;
        static commit(store: Store, key: ReadonlyArray<any>, parameters: ISourceParameters, callback: (valid: boolean, messages?: ReadonlyArray<ICheckMessage>) => any): void;
        get tableDescriptor(): TableDescriptor;
        get exist(): boolean;
        get geometry(): GeoJSON.Point;
        set geometry(value: GeoJSON.Point);
        getOldData(column: string): any;
        setData(column: string, value: any): boolean;
        checkColumn(column: string, callback: (column: IDBColumnDefinition, dirty: boolean, value: any, valid: boolean, message: Readonly<ICheckMessage>, indice: number) => any): void;
        check(callback: (valid: boolean, messages: ReadonlyArray<ICheckMessage>, events: {
            [key: string]: any;
        }) => any): void;
        commit(callback?: (valid: boolean, messages?: ReadonlyArray<ICheckMessage>) => any): void;
        close(): void;
        getState(): IReadonlyStore;
        invalidate(columns?: ReadonlyArray<string>): void;
        isDirty(columns?: ReadonlyArray<string>): boolean;
    }
    type IDataItemStore = IDataItemContainer<IDataItemStoreData<IStore>>;
    interface IDMAContext extends TradeArea.IDMAContext {
        readonly storeSource: StoreSource;
    }
    export interface IStoreSourceProject {
        readonly id: string;
        readonly events?: IModificationEvents;
        readonly info?: IDBHistoryBranchInfo;
    }
    export abstract class StoreSource extends ResourceLoader<IStoreTableResourceContent> implements IDataModel, IStoreSource, ISourceParametersData {
        protected _historizedModel: HistorizedModel;
        protected _cache: TradeArea.IDMAContext;
        protected _scenario: Scenario;
        protected _dataModel: IDataModelView;
        protected _parameters: ISourceParameters;
        protected _ready: boolean;
        check: (storeSource: IStoreSource, store: Store, column: IDBColumnDefinition, dirty: boolean, value: string, callback: (valid: boolean, message?: Readonly<ICheckMessage>) => void) => void;
        static DMAContext: {
            new (storeSource: StoreSource): IDMAContext;
        };
        constructor(resource: ITableResource, remote?: IHistorizedModelRemote);
        protected _check(store: Store, column: IDBColumnDefinition, dirty: boolean, value: string, callback: (valid: boolean, message?: Readonly<ICheckMessage>) => any): void;
        protected _onDirty(event: IDataEvent): void;
        protected abstract _load(content: ITableResourceContent): Promise<IDataTable>;
        protected _release(): void;
        getMetadata(): Promise<IStoreTableResourceContent>;
        get parameters(): ISourceParameters;
        get fullName(): string;
        get isHistoricized(): boolean;
        get branchInfo(): IDBHistoryBranchInfo;
        get geometry(): IDBColumnDefinition;
        release(): void;
        get session(): string;
        get columns(): ReadonlyArray<IDBColumn>;
        get primaryKey(): ReadonlyArray<string>;
        get values(): ReadonlyArray<ReadonlyArray<any>>;
        get columnIndex(): {
            [key: string]: number;
        };
        getKeyFromRow(row: ReadonlyArray<any>): ReadonlyArray<any>;
        compareKey(row: ReadonlyArray<any>, key: ReadonlyArray<any>): number;
        compareRow(row0: ReadonlyArray<any>, row1: ReadonlyArray<any>): number;
        create(key: ReadonlyArray<any>, values: {
            [key: string]: any;
        }): void;
        modify(key: ReadonlyArray<any>, values: {
            [key: string]: any;
        }): void;
        delete_(key: ReadonlyArray<any>): void;
        indexOf(row: ReadonlyArray<any>): number;
        find(key: ReadonlyArray<any>): number;
        getRow(index: number): ReadonlyArray<any>;
        dropEvents(key: ReadonlyArray<any>): void;
        generateContext(): TradeArea.IDMAContext;
        get scenario(): Scenario;
        protected _setBranch(project: IStoreSourceProject, commit?: boolean): Promise<ITableResourceContent>;
        protected _onDataTable(content: IStoreTableResourceContent, dataTable: IDataTable, project?: IStoreSourceProject): Promise<ITableResourceContent>;
        get branch(): string;
        init(project?: IStoreSourceProject): Promise<boolean>;
        ready(): Promise<boolean>;
        createStore(code?: any): Store;
        getStore(code: any): Store;
        getStoreFromRow(row?: ReadonlyArray<any>): Store | undefined;
        hasQualifier(qualifier: Qualifier): boolean;
        getQualifiedColumn(qualifier: Qualifier): IDBColumnDefinition;
        get length(): number;
        item(index: number): IDataItemStore;
        generateEvents(): IModificationEvents;
        createBranch(options?: Parameters<HistoricizedTableDescriptor['insertBranch']>[0], events?: IModificationEvents): Promise<IDBHistoryBranchBase>;
        clone(): StoreSource;
        copy(project?: IStoreSourceProject): StoreSource;
    }
    type GetProps<TBase> = TBase extends new (props: infer P) => any ? P : never;
    type GetInstance<TBase> = TBase extends new (...args: any[]) => infer I ? I : never;
    type MergeCtor<A, B> = new (props: GetProps<A> & GetProps<B>) => GetInstance<A> & GetInstance<B>;
    export function readOnlyStoreSourceMixin<A extends {}, TBase extends new (args: A) => IRowCollection>(Base: TBase): MergeCtor<{
        new (args: {
            content: IStoreTableResourceContent;
        } & GetProps<TBase>): {
            [x: string]: any;
            readonly geometry: IDBColumnDefinition;
            readonly fullName: string;
            hasQualifier(qualifier: Qualifier): boolean;
            getQualifiedColumn(qualifier: Qualifier): IDBColumnDefinition;
            getStoreFromRow(row?: ReadonlyArray<any>): ReadonlyStore | undefined;
            item(index: number): IDataItemContainer<IDataItemStoreData>;
            readonly content: IStoreTableResourceContent;
        };
        [x: string]: any;
    }, TBase>;
    export function storeSourceMixin<A extends {}, TBase extends new (args: A) => IDataEditor & IRowCollection & Data.IColumnIndexProvider & Data.IKeyProvider & Tools.IObservable>(Base: TBase): MergeCtor<{
        new (args: {
            content: IStoreTableResourceContent;
        } & GetProps<TBase>): {
            [x: string]: any;
            readonly geometry: IDBColumnDefinition;
            readonly fullName: string;
            hasQualifier(qualifier: Qualifier): boolean;
            getQualifiedColumn(qualifier: Qualifier): IDBColumnDefinition;
            createStore(code?: any): Store;
            getStoreFromRow(row?: ReadonlyArray<any>): Store | undefined;
            item(index: number): IDataItemStore;
            readonly parameters: ISourceParameters;
            readonly content: IStoreTableResourceContent;
            check: (storeSource: IStoreSource, store: Store, column: IDBColumnDefinition, dirty: boolean, value: string, callback: (valid: boolean, message?: Readonly<ICheckMessage>) => void) => void;
        };
        [x: string]: any;
    }, TBase>;
    export {};
}
declare namespace AFC.Tools {
    const enum MutexState {
        acquired = 0,
        e_cancelled = 1
    }
    class Mutex {
        acquire(): Promise<MutexState>;
        release(): void;
        cancel(): void;
        isLocked(): boolean;
    }
}
/**
 * Created by jean.rennes on 15/05/2019.
 */
declare namespace AFC.Application {
    class DashboardParc extends Data.StoreSource {
        get dirty(): boolean;
        protected _load(content: Data.IStoreTableResourceContent): Promise<AFC.Data.DataModel>;
        protected _onDirty(event: AFC.Data.IDataEvent<Data.IHistorizedDataEventItem>): void;
        protected _setBranch(project: AFC.Data.IStoreSourceProject, commit?: boolean): Promise<AFC.Data.ITableResourceContent>;
        ready(dashboardData?: boolean): Promise<boolean>;
        init(project?: Data.IStoreSourceProject): Promise<boolean>;
        clone(): DashboardParc;
        release(): void;
        move(point: GeoJSON.Point): void;
        setParameters(dashboard: Dashboards.IDashboard, point: GeoJSON.Point, view: string): void;
        modify(key: ReadonlyArray<any>, values: {
            [key: string]: any;
        }): void;
    }
    class AdminParc extends Data.StoreSource {
        setCode(selector: string, code: string | number): void;
        protected _load(content: Data.IStoreTableResourceContent): Promise<AFC.Data.IDataTable>;
    }
}
/**
 * Created by jean.rennes on 29/07/2020.
 */
declare namespace AFC.Globals {
    export class TileLayerProvider<K extends DrawableLayerType> extends Rest.RequestBuilder implements ITileLayerProvider<K> {
        readonly descriptor: Globals.MapLayerDescriptor;
        constructor(mapLayerDescriptor: Globals.MapLayerDescriptor, base?: Rest.IContextModifier);
        requestTiles(layer: ITileLayer<K>, tiles: ReadonlyArray<string>, callback: (tiles: ReadonlyArray<string>, rows: any[][]) => any): void;
    }
    const EventSink_base_1: abstract new (...args: any[]) => Data.RowComparator & Tools.IEventSink;
    class EventSink extends EventSink_base_1 {
        private _timeout;
        dispatchChange: () => any;
        readonly getCodeForContext: (row: ReadonlyArray<any>) => any;
        readonly getKeyFromContext: (code: any) => ReadonlyArray<any>;
        constructor(primaryKey: ReadonlyArray<string>, columnIndex: {
            readonly [key: string]: any;
        });
        protected _register(): void;
        once(type: Tools.EventType, callback: (event: Tools.IEvent) => any, callbackref: any, context: any): void;
        on(type: Tools.EventType, callback: (event: Tools.IEvent) => any, context?: any): void;
    }
    interface ILayerListener {
        attach(mapLayerTiledModel: IMapLayerTiledModel): void;
        detach(): void;
    }
    export class TileVectorModel<K extends DrawableLayerType, P extends ITileLayerProvider<K> = ITileLayerProvider<K>> extends EventSink implements ITileVectorModel<K, P>, ILayerListener {
        private static _Bookmark;
        private _mapLayerTiledModel;
        private _hidden;
        private _filter;
        readonly provider: P;
        readonly name: string;
        readonly geometryIndice: number;
        readonly columns: ReadonlyArray<Data.IDBColumnDefinition>;
        readonly primaryKey: ReadonlyArray<string>;
        readonly columnIndex: {
            readonly [key: string]: number;
        };
        entities: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>[];
        constructor({ provider, name, geometryIndice, columns, primaryKey }: {
            provider: P;
            name: string;
            geometryIndice: number;
            columns: ReadonlyArray<Data.IDBColumnDefinition>;
            primaryKey: ReadonlyArray<string>;
        });
        protected _lowerBound(container: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>[], row: ReadonlyArray<any>): number;
        protected _match(container: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>[], i: number, row: ReadonlyArray<any>): GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>;
        protected _insert(container: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>[], indice: number, entity: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>): void;
        protected _remove(container: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>[], indice: number): void;
        protected _getRowContainer(row: ReadonlyArray<any>): GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>[];
        protected _onDirty(event: Globals.IMapLayerEvent): void;
        attach(mapLayerTiledModel: IMapLayerTiledModel): void;
        detach(): void;
        fireLayerEvent(items?: Data.IDataEventItem[], reset?: boolean): ReturnType<EventSink['fireEvent']>;
        lowerBound(geometry: GeometryForLayerType[K], row: ReadonlyArray<any>): ReturnType<ITileVectorModel<K>['lowerBound']>;
        remove(feature: GeoJSON.Feature<GeometryForLayerType[K], ITileFeatureProperties<K>>): boolean;
        empty(): void;
        get length(): number;
        getRow(index: number): ReadonlyArray<any>;
        indexOf(row: ReadonlyArray<any>): number;
        find(key: ReadonlyArray<any>): number;
        set filter(value: (row: ReadonlyArray<any>, dataModel: IMapLayerModelData) => boolean);
        get filter(): (row: ReadonlyArray<any>, dataModel: IMapLayerModelData) => boolean;
    }
    export function tileVectorModel<K extends DrawableLayerType, P extends ITileLayerProvider>(provider: P, columns: ReadonlyArray<Data.IDBColumnDefinition>, primaryKey: ReadonlyArray<string>, name: string, geometryIndice: number): TileVectorModel<K, P> | undefined;
    type EventType = Data.DataEventType.create | Data.DataEventType.modify | Data.DataEventType.delete_;
    export interface IEventInfo extends AFC.Data.IDataItemStoreData {
        readonly eventType: EventType;
        getInitialData(column: string): ReadonlyArray<any> | undefined;
    }
    export type ITileLayerProviderImpl<K extends DrawableLayerType = DrawableLayerType> = ITileLayerProvider<K> & Rest.RequestBuilder;
    export type IMapLayerTiledModelImpl<K extends DrawableLayerType = DrawableLayerType> = IMapLayerTiledModel<K, TileVectorModel<K, ITileLayerProviderImpl<K>>>;
    export function mapLayerTiledModel<K extends DrawableLayerType = DrawableLayerType>(mapLayerDescriptor: Globals.MapLayerDescriptor, template: IMapVectorLayerMetaData<K>, thematics: ILayerLegendData, data?: TileVectorModel<K, ITileLayerProviderImpl<K>>): IMapLayerTiledModelImpl<K>;
    export function readOnlyStoreVectorModel<P extends ITileLayerProvider<LayerType.symbol>>(content: Data.ITableResourceContent<AFC.Data.HistoricizedTableDescriptor>, provider: P, definition: Readonly<Data.IDBTableDefinition>, name: string, geometryIndice: number): ITileVectorModel<LayerType.symbol, P> & Data.IReadonlyStoreSource & {
        getStoreFromRow(row?: ReadonlyArray<any>): AFC.Data.ReadonlyStore | undefined;
    };
    export function storeVectorModel(content: Data.IStoreTableResourceContent, model: TileVectorModel<LayerType.symbol>, /* target table */ target?: string, session?: string): ITileVectorModel<LayerType.symbol, ITileLayerProvider<LayerType.symbol> & Data.IRowCollection & Data.IKeyProvider & Data.IColumnIndexProvider & Tools.IObservable & Data.IDataSource<IEventInfo>> & Data.IDataEditor & Data.IStoreSource & {
        getStoreFromRow(row?: ReadonlyArray<any>): AFC.Data.Store | undefined;
    };
    export function compoundMapLayerTiledModel<K extends DrawableLayerType = DrawableLayerType>(mapLayerDescriptor: Globals.MapLayerDescriptor, reference: Readonly<Data.IDBTableDefinition>, thematics: ILayerLegendData, dataModel: Data.IDataModel, template: IMapVectorLayerMetaData<K>, name: string, zooms: {
        readonly minZ: number;
        readonly maxZ: number;
    }): IMapLayerTiledModelImpl<K>;
    export {};
}
/**
 * Created by jean.rennes on 02/08/2016.
 */
declare namespace AFC.Tools.ParcEdition {
    interface IDBHistoryBranchBase extends AFC.Data.IDBHistoryBranchBase {
        properties: {
            code: string | number | Array<string | number>;
        };
    }
    interface IDBHistoryBranchRow extends IDBHistoryBranchBase {
        values: {
            [key: string]: any;
        }[];
    }
    interface IProjectBase extends AFC.Data.IDataItemStoreData {
        readonly id: string;
        readonly author: string;
        readonly creationDate: Date;
        readonly name: string;
        readonly description: string | null;
        readonly rating: number | null;
        readonly status: AFC.Data.HistoryBranchStatus | null;
        readonly store: AFC.Data.IReadonlyStore;
    }
    export interface IProjectInfo extends IProjectBase {
        load(): Promise<IProject>;
    }
    export interface IProject extends IProjectBase, AFC.Data.IStoreSourceProject, AFC.Tools.IObservable {
        readonly info: AFC.Data.IDBHistoryBranchInfo;
        description: string | null;
        rating: number | null;
        status: AFC.Data.HistoryBranchStatus | null;
        events: AFC.Data.IModificationEvents;
    }
    function _getProjetTableParameters(storeColumns: ReadonlyArray<AFC.Data.IDBColumnDefinition>): {
        key: number[];
        offset: number;
        columns: AFC.Data.IDBColumnDefinition[];
        primaryKey: readonly string[];
        geometry: number;
    };
    interface IProjectInfoProvider {
        readonly descriptor: AFC.Data.HistoricizedTableDescriptor;
        readonly history: AFC.Data.IHistory;
        readonly content: AFC.Data.IStoreTableResourceContent;
        readonly key: ReadonlyArray<number>;
    }
    type IDataItemProject = AFC.Data.IDataItemContainer<IProjectInfo>;
    export interface IProjectSource extends AFC.Data.IReadonlyStoreSource {
        item(index: number): IDataItemProject;
    }
    export class ProjectsList extends AFC.Data.DataModel implements AFC.Data.IDataModel, IProjectInfoProvider, IProjectSource {
        protected readonly _offset: number;
        readonly descriptor: AFC.Data.HistoricizedTableDescriptor;
        readonly history: AFC.Data.IHistory;
        readonly content: AFC.Data.IStoreTableResourceContent;
        readonly parameters: AFC.Data.IDataContainerChecker<AFC.Data.IReadonlyStore>;
        readonly key: ReadonlyArray<number>;
        check: (storeSource: AFC.Data.IReadonlyStoreSource, store: AFC.Data.IReadonlyStore, column: AFC.Data.IDBColumnDefinition, dirty: boolean, value: string, callback: (valid: boolean, message: Readonly<AFC.Data.ICheckMessage>) => any) => void;
        protected _check(store: AFC.Data.IReadonlyStore, column: AFC.Data.IDBColumnDefinition, dirty: boolean, value: string, callback: (valid: boolean, message?: Readonly<AFC.Data.ICheckMessage>) => any): void;
        constructor(refContent: AFC.Data.IStoreTableResourceContent, storeColumns: ReadonlyArray<AFC.Data.IDBColumnDefinition>, branches: IDBHistoryBranchRow[]);
        get length(): number;
        getRow(indice: number): ReadonlyArray<any>;
        get geometry(): AFC.Data.IDBColumnDefinition;
        hasQualifier(qualifier: AFC.Data.Qualifier): boolean;
        getQualifiedColumn(qualifier: AFC.Data.Qualifier): AFC.Data.IDBColumnDefinition;
        get fullName(): string;
        item(index: number): IDataItemProject;
        getProjectFromRow(row?: ReadonlyArray<any>): IProjectInfo & {
            readonly key: ReadonlyArray<any>;
        } | undefined;
    }
    export function listProjects(dataSource: AFC.Data.StoreSource, filters?: AFC.Data.IDBHistoryBranchesFilters, additionalColumns?: ReadonlyArray<string>): Promise<ProjectsList>;
    export function createProject(dataSource: AFC.Application.DashboardParc, store: AFC.Data.Store): Promise<IProject>;
    export function loadProject(dataSource: AFC.Data.ResourceLoader<AFC.Data.IStoreTableResourceContent>, id: string, store: AFC.Data.Store): Promise<IProject>;
    export function cloneProject(dataSource: AFC.Data.StoreSource, project: IProject): Promise<IProject>;
    export class QueryParc extends AFC.Data.StoreSource {
        protected _command: AFC.Data.IQueryCommand;
        static readonly tableToken: string;
        static readonly brandToken: string;
        protected _load(content: AFC.Data.ITableResourceContent): Promise<AFC.Data.IDataTable>;
        loadData(command: AFC.Data.IQueryCommand, project?: AFC.Data.IStoreSourceProject): Promise<boolean>;
    }
    class ProjectTileProvider implements Globals.ITileLayerProvider {
        private readonly _offset;
        private readonly _filter;
        private readonly _options;
        readonly content: AFC.Data.IStoreTableResourceContent;
        readonly key: ReadonlyArray<number>;
        constructor(content: AFC.Data.ITableResourceContent, parameters: ReturnType<typeof _getProjetTableParameters>, columns: ReadonlyArray<AFC.Data.IDBColumnDefinition>);
        requestTiles(layer: Globals.ITileLayer, tiles: ReadonlyArray<string>, callback: (tiles: ReadonlyArray<string>, rows: ReadonlyArray<any>[]) => any): void;
    }
    const ProjectTileVectorModel_base: new (props: {
        content: AFC.Data.IStoreTableResourceContent;
    } & {
        provider: ProjectTileProvider;
        name: string;
        geometryIndice: number;
        columns: readonly AFC.Data.IDBColumnDefinition[];
        primaryKey: readonly string[];
    }) => {
        [x: string]: any;
        readonly geometry: AFC.Data.IDBColumnDefinition;
        readonly fullName: string;
        hasQualifier(qualifier: AFC.Data.Qualifier): boolean;
        getQualifiedColumn(qualifier: AFC.Data.Qualifier): AFC.Data.IDBColumnDefinition;
        getStoreFromRow(row?: readonly any[]): AFC.Data.ReadonlyStore;
        item(index: number): AFC.Data.IDataItemContainer<AFC.Data.IDataItemStoreData<AFC.Data.IReadonlyStore>>;
        readonly content: AFC.Data.IStoreTableResourceContent;
    } & Globals.TileVectorModel<Globals.LayerType.symbol, ProjectTileProvider>;
    export class ProjectTileVectorModel extends ProjectTileVectorModel_base implements IProjectInfoProvider, IProjectSource {
        readonly descriptor: AFC.Data.HistoricizedTableDescriptor;
        readonly history: AFC.Data.IHistory;
        readonly key: ReadonlyArray<number>;
        constructor(content: AFC.Data.IStoreTableResourceContent, additionalColumns?: ReadonlyArray<string>);
        item(index: number): IDataItemProject;
        getProjectFromRow(row?: ReadonlyArray<any>): IProjectInfo & {
            readonly key: ReadonlyArray<any>;
        } | undefined;
    }
    export {};
}
/**
 * Created by jean.rennes on 18/09/2020.
 */
declare namespace AFC.Application {
    export const enum ParcType {
        dashboard = 1,
        administrative = 2,
        query = 3
    }
    interface IParcFactory {
        [ParcType.dashboard]: DashboardParc;
        [ParcType.administrative]: AdminParc;
        [ParcType.query]: AFC.Tools.ParcEdition.QueryParc;
    }
    export interface IStoreSourceRemote {
        confirmUpdate?: (result: Data.IUpdateCommandResult) => Promise<boolean>;
        onUpdate: (results: ReadonlyArray<Data.IUpdateCommandResult>, force: boolean, replacements: ReadonlyArray<Rest.ContextSubstitute>) => void;
    }
    export class DashboardActivity extends RestActivity implements Data.ISessionProvider {
        protected readonly _sink: Tools.EventSink<any, Tools.IEventData>;
        refreshStamps(): Promise<void>;
        getSession(): string;
        getHistorizedTableResources(): Promise<AFC.Data.ITableResource[] & {
            [key: string]: AFC.Data.ITableResource;
        }>;
        loadHistory(): Promise<any>;
        getStoreSource<K extends ParcType>(dbName: string, name: string, parcType: K, remote?: IStoreSourceRemote): Promise<IParcFactory[K]>;
        invalidateStaticLayers(): Promise<any>;
        protected _pushContextModifiers(dashboard: Dashboards.IDashboard, storeSource: Data.StoreSource, context: any): Promise<void>;
        getDashboards(descriptors: ReadonlyArray<Dashboards.IDashboardDescriptor>, storeSource: Data.StoreSource, store: Data.IReadonlyStore, project?: AFC.Tools.ParcEdition.IProject, context?: any): Promise<ReadonlyArray<Dashboards.IDashboard>>;
        getDataStorage(): Storage;
    }
    export {};
}
/**
 * Created by jean.rennes on 17/05/2019.
 */
declare namespace AFC.Application {
    class DataGrabber extends Tools.EventSink {
        private _cache;
        readonly method: string;
        readonly async: boolean;
        readonly dataType: string;
        constructor(method?: 'GET' | 'POST', async?: boolean, dataType?: string);
        protected _onAlways(key: string, jqXHR: JQueryXHR, textStatus: string): void;
        getData(url: string, body: any): Promise<any>;
    }
}
/**
 * Created by jean.rennes on 21/02/2020.
 */
declare namespace AFC.Application {
    class DialogFragment extends Fragment {
        onCreate(savedInstanceState?: Bundle): void;
        getLayoutInflater(savedInstanceState: Bundle): ILayoutInflater;
        onCreateDialog(savedInstanceState: Bundle): Controls.Dialog;
        onSaveInstanceState(outState: Bundle): void;
        onActivityCreated(savedInstanceState: Bundle): void;
        onDestroyView(): void;
        show(fragmentManager: FragmentManager, tag?: string): void;
        dismiss(): void;
        onViewStateRestored(savedInstanceState?: Bundle): void;
        onDismiss(dialog: Controls.Dialog): void;
    }
}
/**
 * Created by jean.rennes on 18/09/2020.
 */
declare namespace AFC.Application {
    class Inflater {
        inflate(resource: string, root: gui.IView): gui.IView;
    }
}
/**
 * Created by jean.rennes on 18/09/2020.
 */
declare namespace AFC.Application {
    class Storage {
        readonly key: string;
        constructor(key: string);
        setItem(key: string, value: any): void;
        getItem(key: string): any;
    }
}
/**
 * Created by jean.rennes on 14/05/2019.
 */
declare namespace AFC.Application {
    export interface IBrandSelectorItem {
        readonly value: number;
        readonly label: string;
        readonly image: string;
        color: string;
    }
    export interface IBrandSelectorConfiguration {
        readonly filterEnabled: boolean;
        readonly template: string;
        compare(brand0: string, brand1: string): number;
        map(symbolFactory: Globals.SymbolFactory, brand: string, businessCode: string, indice: number): IBrandSelectorItem;
        filter(regExps: ReadonlyArray<RegExp> | null, brand: string): boolean;
        onClick(brand: string, image: string): void;
    }
    export class BrandSelectorConfiguration implements IBrandSelectorConfiguration {
        filterEnabled: boolean;
        template: string;
        protected _ref: {
            readonly [key: string]: number;
        };
        protected _order: {
            readonly [key: string]: number;
        };
        protected _getOrder(): {
            readonly [key: string]: number;
        };
        static mruMaxElement: number;
        constructor(order?: {
            readonly [key: string]: number;
        });
        compare(brand0: string, brand1: string): number;
        map(symbolFactory: Globals.SymbolFactory, brand: string, businessCode: string, indice: number): IBrandSelectorItem;
        filter(regExps: ReadonlyArray<RegExp> | null, brand: string): boolean;
        onClick(brand: string, image: string): void;
    }
    interface IBrandSelectorValue {
        brand: string;
        symbol: string;
    }
    export class AfcBrand extends HTMLElement {
        static observedAttributes: string[];
        get value(): string;
        set value(value: string);
        connectedCallback(): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
    }
    export class AfcSymbol extends gui.AfcGuiElement {
        static observedAttributes: string[];
        get symbols(): Globals.SymbolFactory;
        set symbols(value: Globals.SymbolFactory);
        get value(): string;
        set value(value: string);
        connectedCallback(): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
    }
    export class AfcBusinessCodeSelector extends gui.AfcGuiElement {
        options: ReadonlyArray<string>;
        static observedAttributes: string[];
        constructor();
        get value(): string;
        set value(value: string);
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
    }
    export class AfcBrandSelector extends gui.AfcGuiElement {
        disabled: boolean;
        maxItem: number;
        static observedAttributes: string[];
        constructor();
        getConfiguration(): IBrandSelectorConfiguration;
        setConfiguration(value: IBrandSelectorConfiguration): void;
        get symbols(): Globals.SymbolFactory;
        set symbols(value: Globals.SymbolFactory);
        get selected(): IBrandSelectorValue;
        set selected(value: IBrandSelectorValue);
        connectedCallback(): void;
        disconnectedCallback(): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
        setVisibility(show: boolean): void;
    }
    export class AfcStoreForm extends gui.AfcGuiElement {
        static observedAttributes: string[];
        protected _onRestoreViewState(activity: Application.RestActivity, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
        private _getColumnForInput;
        getColumnForInput(input: HTMLElement): AFC.Data.IDBColumn;
        setStoreValue(column: AFC.Data.IDBColumn, value: string, fireEvent?: boolean): boolean;
        constructor();
        get store(): AFC.Data.IStore;
        set store(value: AFC.Data.IStore);
        get template(): string;
        set template(value: string);
        get ondatachange(): (event: CustomEvent<ReadonlyArray<AFC.Data.IDBColumn>>) => void;
        set ondatachange(value: (event: CustomEvent<ReadonlyArray<AFC.Data.IDBColumn>>) => void);
        connectedCallback(): void;
        disconnectedCallback(): void;
        submit(): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
    }
    export {};
}
declare namespace AFC.gui {
    class AfcAutoEditLabelControl extends AfcGuiElement {
        private _value;
        private _editionMode;
        static observedAttributes: string[];
        constructor();
        get value(): string;
        set value(value: string);
        get editionMode(): boolean;
        set editionMode(value: boolean);
    }
}
declare namespace AFC.gui {
    type IFilterSelection = (boolean | number)[][];
    interface IFilterValue {
        selection: IFilterSelection;
        filterText: string;
    }
    export class AfcFilterControl extends AfcGuiElement {
        static observedAttributes: string[];
        constructor();
        protected _getContextParamName(param: string): string;
        protected _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void;
        protected _onRestoreViewState(context: Application.Context, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
        get columns(): ReadonlyArray<string>;
        set columns(value: ReadonlyArray<string>);
        get rows(): readonly string[];
        set rows(value: readonly string[]);
        get value(): IFilterValue;
        set value(value: IFilterValue);
        get type(): string;
        set type(value: string);
        protected _hasCustomFilter(): boolean;
        setSelection(value: IFilterSelection): void;
        setFilterText(value: string): void;
        protected _refresh(): void;
        protected _refreshHighlighted(): void;
        protected _draw(): void;
        resetSelection(selectAll?: boolean): void;
        selectColumn(col: number): void;
        selectRow(row: number): void;
        selectCell(col: number, row: number): void;
        protected _getXYFromEvent(e: MouseEvent): {
            x: number;
            y: number;
        };
        protected _resetHighlighted(): void;
        protected _onMouseEnter(e: MouseEvent): void;
        protected _onMouseOut(e: MouseEvent): void;
        protected _onClickCloseFilterText(): void;
        updateCloseFilterButton(): void;
        protected _onTextFilterChange(e: Event): void;
        onFilterChanged(): void;
        protected _onTextFilterChangeNoDelay(): void;
        protected _onClick(e: MouseEvent): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
    }
    export {};
}
/**
 * Created by jean.rennes on 18/01/2017.
 */
declare namespace AFC.gui {
    class AfcGuiDiv extends AfcGuiElement {
        protected _muted: boolean;
        static observedAttributes: string[];
        protected _setMute(mute: boolean): void;
        protected _resize(screenRect: Partial<IScreenRect>): void;
    }
    class AfcGuiRoot extends AfcGuiDiv {
        static observedAttributes: string[];
        resize(screenRect: Partial<IScreenRect>): void;
    }
}
/**
 * Created by jean.rennes on 28/01/2020.
 */
declare namespace AFC.gui {
    class AfcGuiFragmentHolder extends gui.AfcGuiElement {
        static observedAttributes: string[];
        set content(className: string);
        setContent(value?: Application.Fragment, tag?: string): void;
        protected _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void;
        protected _onRestoreViewState(context: Application.Context, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
        disconnectedCallback(): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
    }
}
/**
 * Created by jean.rennes on 14/05/2019.
 */
declare namespace AFC.gui {
    class AfcRatingControl extends AfcGuiElement {
        static observedAttributes: string[];
        constructor();
        protected _onRestoreViewState(activity: Application.RestActivity, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
        protected _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void;
        get value(): number;
        set value(value: number);
        get maxValue(): number;
        set maxValue(value: number);
        get allowHalf(): boolean;
        set allowHalf(value: boolean);
        get disabled(): boolean;
        set disabled(value: boolean);
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
    }
}
/**
 * Created by jean.rennes on 03/02/2020.
 */
declare namespace AFC.gui {
    class AfcGuiTab extends HTMLElement {
        get selected(): boolean;
        set selected(value: boolean);
    }
    class AfcGuiTabBar extends AfcGuiElement {
        static observedAttributes: string[];
        constructor();
        protected _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void;
        protected _onRestoreViewState(context: Application.Context, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
        get value(): string;
        set value(value: string);
    }
}
/**
 * Created by jean.rennes on 25/07/2018.
 */
declare namespace AFC.gui {
    class AfcGuiTemplate extends AfcGuiDiv {
        static observedAttributes: string[];
        protected _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void;
        protected _onRestoreViewState(context: Application.Context, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
        set content(value: string | HTMLTemplateElement | undefined | null);
        get content(): string | HTMLTemplateElement | undefined | null;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
    }
}
/**
 * Created by jean.rennes on 20/05/2020.
 */
declare namespace AFC.gui {
    interface IViewPagerOptions {
        pageTransformer: Controls.ViewPager.IPageTransformer;
        duration: DOMHighResTimeStamp;
        timingFunction: (x: number) => number;
    }
    class AfcGuiViewPager extends AfcGuiElement {
        protected _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void;
        protected _onRestoreViewState(context: Application.Context, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
        protected _resize(screenRect: Partial<IScreenRect>): void;
        setAdapter(adapter: Controls.FragmentStateAdapter): void;
        setOptions(options?: Partial<IViewPagerOptions>): void;
        setCurrentItem(item: number): Promise<Application.Fragment>;
        getCurrentItem(): number;
        refresh(): void;
        connectedCallback(): void;
        disconnectedCallback(): void;
    }
}
declare namespace AFC.gui {
    function parseOptions<T = any>(value: string, defaultOptions: T): Partial<T>;
    class AfcGuiWaitBar extends AfcGuiElement {
        readonly adapter: AFC.Globals.WaitAdapter;
        constructor();
        protected _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void;
        protected _onRestoreViewState(context: Application.Context, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
        setOptions(options: Partial<Controls.ISpinnerAnimationOptions>): void;
        disconnectedCallback(): void;
    }
    class AfcGuiProgressBar extends AfcGuiElement {
        readonly adapter: AFC.Globals.WaitAdapter;
        constructor();
        connectedCallback(): void;
        disconnectedCallback(): void;
    }
}
/**
 * Created by jean.rennes on 19/09/2017.
 */
declare namespace AFC.gui {
    export function _compare(this: AfcGuiRepeater, value0: Data.IDataItemContainer, value1: Data.IDataItemContainer): number;
    const _onClear: unique symbol;
    export class AfcGuiRepeater<S extends AFC.Data.IDataSource & Partial<Tools.IObservable> = AFC.Data.IDataSource & Partial<Tools.IObservable>> extends AfcBindableElement<S, Data.RepeaterAdapter<S>> {
        protected _control: Controls.Repeater;
        static observedAttributes: string[];
        orderBy: string;
        orderByDirection: string;
        compare: (value0: Data.IDataItemContainer, value1: Data.IDataItemContainer) => number;
        constructor();
        protected _onRestoreViewState(context: Application.Context, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
        protected [_onClear](): void;
        protected _onGenerate(): void;
        set maxItem(value: number);
        get maxItem(): number;
        get adapter(): Data.RepeaterAdapter;
        set template(value: (value: {
            [key: string]: any;
        }) => string);
        get template(): (value: {
            [key: string]: any;
        }) => string;
        set dataBinder(value: (name: string, key: string, value: Data.IDataItemContainer) => any);
        get dataBinder(): (name: string, key: string, value: Data.IDataItemContainer) => any;
        set filter(value: (value: Data.IDataItemContainer) => boolean);
        get filter(): (value: Data.IDataItemContainer) => boolean;
        connectedCallback(): void;
        disconnectedCallback(): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
        refresh(): void;
    }
    export {};
}
/**
 * Created by jean.rennes on 19/09/2017.
 */
declare namespace AFC.gui {
    class ConfigGroupControlRepeater extends Controls.Repeater {
        protected _childrenElem: Array<HTMLElement>;
        storeChildElem(elem: HTMLElement): void;
        getChildrenElem(): Array<HTMLElement>;
        insertItem(container: Node, elem: HTMLElement): void;
    }
    /**
     * Config group repeater
     *
     * defaultcursel = "VALUE" select dom item with data-value = defaultcursel (use it for item out of model !!!)
     * defaultcursel = null: default item (in mdoel) selection
     *
     * Usage example:
     *          <afc-gui-config-group
     *                  handlers="app.screen.getConfigListHandlers"
     *                  defaultcursel="0"
     *                  mru-id="mruConfigList"
     *                  mru-active="true"
     *                  mru-handlers="app.screen.getDataStorageHandlers">
     *              ...
     *              <template>...</template>
     *              ...
     *              <div data-index="4" onclick="myFn();">
     *                  Custom button to be added outside reapeater logic
     *              </div>
     *          </afc-gui-config-group>
     */
    export class AfcGuiConfigGroup extends AfcGuiRepeater {
        protected _control: ConfigGroupControlRepeater;
        protected _adapter: Dashboards.ConfigGroupAdapter;
        protected _manualContainerElem?: HTMLElement;
        static observedAttributes: string[];
        constructor();
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
        connectedCallback(): void;
        protected _onGenerate(): void;
        onListClick(event: MouseEvent): any;
        onListBtnClick(event: MouseEvent): any;
        toggleCollapse(forceCollapse?: boolean): any;
        toggleManualEdition(event: MouseEvent, itemElem: HTMLElement, forceShow?: boolean): void;
    }
    export {};
}
/**
 * Created by jean.rennes on 28/05/2019.
 */
declare namespace AFC.gui {
    abstract class BindableElement<Model extends Tools.INotifier, Adapter extends Tools.AdapterBase<Model>> extends AfcGuiElement {
        protected _adapter: Adapter;
        static observedAttributes: string[];
        protected _setMute(bMute: boolean): void;
        protected _onDirty(event: Tools.IEvent): void;
        protected _bind(): Model;
        protected _unbind(): void;
        set model(value: Model);
        get model(): Model;
        get adapter(): Adapter;
        connectedCallback(): void;
        disconnectedCallback(): void;
    }
    abstract class ForElement<Model extends Tools.INotifier, Adapter extends Tools.AdapterBase<Model>> extends BindableElement<Model, Adapter> {
        static observedAttributes: string[];
        constructor(setProvider: (element: ForElement<Model, Adapter>, forVal: string) => HTMLElement);
        set for(value: string);
        get for(): string;
        connectedCallback(): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
    }
}
/**
 * Created by jean.rennes on 04/10/2016.
 */
declare namespace AFC.gui {
    export function parentLookup<T extends HTMLElement>(element: HTMLElement, tagName: string): T;
    export abstract class DashboardView<Model extends Dashboards.IViewModel, Adapter extends Tools.AdapterBase<Model>> extends ForElement<Model, Adapter> {
        readonly label: LabelProvider<Model>;
        static observedAttributes: string[];
        constructor(setProvider: (element: ForElement<Model, Adapter>, forVal: string) => HTMLElement, ctor: Tools.Constructor<Model>);
        set source(value: string);
        get source(): string;
        protected _bind(): Model;
        protected _unbind(): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
    }
    export interface IChartProviderHolder extends HTMLElement {
        chart: Dashboards.IChartModel;
    }
    export class AfcGuiChart extends DashboardView<Dashboards.IChartModel | Dashboards.IReportModel, Dashboards.ChartAdapter> {
        static observedAttributes: string[];
        constructor();
        get options(): Partial<Dashboards.IChartOptions>;
        set options(value: Partial<Dashboards.IChartOptions>);
        protected _resize(screenRect: Partial<IScreenRect>): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
    }
    export interface IGridProviderHolder extends HTMLElement {
        grid: Dashboards.IGridModel;
    }
    interface IGridViewRemote {
        readonly selection: number;
        moveFromCurrentLine(offset: number): number;
        selectLine(key: number): void;
    }
    export interface ICellClickEventDetail {
        readonly column: number;
        readonly line: number;
        readonly originalLine: number;
        readonly model: Data.IDataModel;
        readonly key: ReadonlyArray<any>;
    }
    export class AfcGuiGrid extends DashboardView<Dashboards.IGridModel, Dashboards.GridAdapter> implements IGridViewRemote {
        static observedAttributes: string[];
        constructor();
        protected _onDirty(event: Tools.IEvent): void;
        protected _resize(screenRect: Partial<IScreenRect>): void;
        set template(value: (value: Controls.IGridCell) => string);
        get template(): (value: Controls.IGridCell) => string;
        set dataBinder(value: (name: string, key: string, value: {
            [key: string]: any;
        }) => string);
        get dataBinder(): (name: string, key: string, value: {
            [key: string]: any;
        }) => string;
        set originalSize(value: boolean);
        get originalSize(): boolean;
        get selection(): number;
        moveFromCurrentLine(offset: number): number;
        selectLine(nativeLine?: number): void;
        connectedCallback(): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
    }
    export class AfcGuiSelector extends BindableElement<Dashboards.DashboardModel, Dashboards.SelectorAdapter> implements IChartProviderHolder, IGridProviderHolder {
        static observedAttributes: string[];
        constructor();
        set mode(value: Dashboards.SelectorMode);
        get mode(): Dashboards.SelectorMode;
        get map(): Dashboards.IMapModel;
        get grid(): Dashboards.IGridModel;
        get chart(): Dashboards.IChartModel;
        get filter(): (dashboard: Dashboards.IDashboard, view: Dashboards.IView) => boolean;
        set filter(value: (dashboard: Dashboards.IDashboard, view: Dashboards.IView) => boolean);
        connectedCallback(): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
        selectPrevious(): Promise<AFC.Dashboards.ISelectorEventData>;
        selectNext(): Promise<AFC.Dashboards.ISelectorEventData>;
        selectItem(value?: string): Promise<AFC.Dashboards.ISelectorEventData>;
        getDashboardFilter(mode: Dashboards.SelectorMode): (dashboard: Dashboards.IDashboard) => Controls.ISelectorGroup[];
    }
    export class AfcGuiDashboard extends AfcGuiDiv {
        readonly model: Dashboards.DashboardModel;
        constructor();
        protected _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void;
        protected _onRestoreViewState(activity: Application.RestActivity, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
        static observedAttributes: string[];
        get dashboard(): string;
        set dashboard(value: string);
        get instance(): Dashboards.IDashboard;
        set instance(value: Dashboards.IDashboard);
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
        disconnectedCallback(): void;
    }
    export class AfcGuiSplitter extends AfcGuiElement {
        static observedAttributes: string[];
        constructor();
        protected _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void;
        protected _onRestoreViewState(context: Application.Context, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
        _onDataChange(e: CustomEvent): void;
    }
    export interface IRedistrictableElement extends HTMLElement {
        attachRedistrict: (redistrict: AfcGuiRedistrict) => any;
        detachRedistrict: (redistrict: AfcGuiRedistrict) => any;
    }
    const enum RedistrictColumnType {
        integer = 1,
        real = 2,
        string = 3,
        sum = 4
    }
    interface ICustomColumnValueMap {
        [RedistrictColumnType.integer]: ($scope: {
            readonly [key: string]: any;
        }, $scopes: ReadonlyArray<{
            readonly [key: string]: any;
        }>) => number;
        [RedistrictColumnType.real]: ($scope: {
            readonly [key: string]: any;
        }, $scopes: ReadonlyArray<{
            readonly [key: string]: any;
        }>) => number;
        [RedistrictColumnType.string]: ($scope: {
            readonly [key: string]: any;
        }, $scopes: ReadonlyArray<{
            readonly [key: string]: any;
        }>) => string;
        [RedistrictColumnType.sum]: ($scope: {
            readonly [key: string]: any;
        }, $scopes: ReadonlyArray<{
            readonly [key: string]: any;
        }>, $row: {
            [key: string]: any;
        }) => number;
    }
    interface IRedistrictColumn<T extends RedistrictColumnType = RedistrictColumnType> {
        readonly type: T;
        readonly definition: Data.IDBColumn;
        readonly value: ICustomColumnValueMap[T];
    }
    export const enum ZoneType {
        subset = 1,
        outOfZone = 2,
        total = 3
    }
    export interface IDistrictParameters {
        zone: Dashboards.IZone;
        descriptor: Dashboards.IRadiusAreaDescriptor | Dashboards.IIsodistanceAreaDescriptor | Dashboards.IIsochroneAreaDescriptor | Dashboards.IPredefinedAreaDescriptor | Dashboards.IBulkMailAreaDescriptor;
        layerModel: Globals.MapLayerStaticModel<Globals.LayerType.polygon> | Globals.IMapLayerTiledModelImpl<Globals.LayerType.polygon>;
        dataModel: Data.IDataModel;
        colorProperty: Globals.ILayerProperty<number>;
    }
    export class AfcGuiColumn<T extends RedistrictColumnType = RedistrictColumnType> extends HTMLElement implements IRedistrictColumn<T> {
        static observedAttributes: string[];
        constructor();
        set name(value: string);
        get name(): string;
        set type(value: T);
        get type(): T;
        set value(value: ICustomColumnValueMap[T]);
        get value(): ICustomColumnValueMap[T];
        get definition(): Data.IDBColumn;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
        connectedCallback(): void;
        disconnectedCallback(): void;
    }
    export class AfcGuiRedistrict extends AfcGuiElement {
        readonly model: Data.IDataModelBase & Tools.IObservable & {
            readonly dataModel: Data.IRowCollection & Tools.IObservable & Data.IDBTableDefinition;
        };
        static observedAttributes: string[];
        constructor();
        protected static _onDataChange(e: Event): void;
        set for(value: string);
        get for(): string;
        get selected(): string;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
        connectedCallback(): void;
        disconnectedCallback(): void;
        setRedistrictable(element?: IRedistrictableElement): void;
        protected _dataBind(repeater: AfcGuiRepeater, name: string, key: string, value: Data.IDataItemContainer): string;
        redistrictDataBinder(name: string, key: string, value: Data.IDataItemContainer): string | void;
        setParameters(parameters: IDistrictParameters): void;
        refresh(): void;
    }
    export {};
}
/**
 * Created by jean.rennes on 18/01/2017.
 */
declare namespace AFC.gui {
    interface IMapProviderHolder extends HTMLElement {
        map: Dashboards.IMapModel;
    }
    interface IDistrictLayerProvider extends gui.IBaseLayerProvider {
        getDistrictParameters(): Promise<IDistrictParameters>;
        getQualifiedColumn(data: Data.IDBTableDefinition, dataQualifier: Dashboards.DataQualifier): number;
        affectRow(data: Globals.IMapLayerModelData, row: ReadonlyArray<any>, id: string): Promise<void>;
        getOwnership(data: Globals.IMapLayerModelData, row: ReadonlyArray<any>): Promise<void>;
        deleteUnit(data: Globals.IMapLayerModelData, row: ReadonlyArray<any>): Promise<void>;
        isRedistricted(): boolean;
    }
    class AfcGuiMap extends DashboardView<Dashboards.IMapModel, Dashboards.MapAdapter> implements ILayerProviderElement, IRedistrictableElement {
        constructor();
        getCount(): number;
        getLayerProvider(indice: number): IBaseLayerProvider;
        getBbox(): Promise<Tools.Geometry.Rectangle>;
        getInfo(): Promise<Readonly<ILayerProviderInfo>>;
        canDistrict(): boolean;
        enableDistricting(enable: boolean, indicators?: ReadonlyArray<string>): void;
        isRedistricted(): boolean;
        resetDistrict(): void;
        get handlers(): gui.IMapEventHandlers;
        getDistrictProvider(): IDistrictLayerProvider;
        refresh(): void;
        attachRedistrict(redistrict: AfcGuiRedistrict): void;
        detachRedistrict(redistrict: AfcGuiRedistrict): void;
        getRedistrict(): AfcGuiRedistrict;
        disconnectedCallback(): void;
    }
}
/**
 * Created by jean.rennes on 19/09/2017.
 */
declare namespace AFC.gui {
    class AfcGuiComboBox extends AfcBindableElement<AFC.Data.IDataSource & Tools.IObservable, Data.ComboBoxAdapter> {
        protected _control: Controls.ComboBox;
        static observedAttributes: string[];
        constructor();
        protected _onGenerate(): void;
        connectedCallback(): void;
        disconnectedCallback(): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
        set disabled(newVal: boolean);
        get disabled(): boolean;
        set value(newVal: string);
        get value(): string;
        refresh(): void;
    }
}
/**
 * Created by jean.rennes on 08/12/2020.
 */
declare namespace AFC.Application {
    interface IDataRecord extends Partial<Tools.IObservable<Tools.IObservable, Data.IDataRecordEventData>> {
        readonly setData?: (column: string, value: any) => boolean;
        readonly getQualifiedColumn?: (qualifier: Data.Qualifier) => Data.IDBColumn;
        getData(column: string): any;
        getColumn(column: string): Data.IDBColumn;
    }
    export class AfcForm extends gui.AfcGuiElement {
        static observedAttributes: string[];
        private _getColumnForInput;
        getColumnForInput(input: HTMLElement): Data.IDBColumn;
        setValue(column: Data.IDBColumn, value: string, fireEvent?: boolean): boolean;
        constructor();
        get dataRecord(): IDataRecord;
        set dataRecord(value: IDataRecord);
        get template(): string;
        set template(value: string);
        get ondatachange(): (event: CustomEvent<ReadonlyArray<Data.IDBColumn>>) => void;
        set ondatachange(value: (event: CustomEvent<ReadonlyArray<Data.IDBColumn>>) => void);
        connectedCallback(): void;
        disconnectedCallback(): void;
        submit(): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
    }
    export {};
}
/**
 * Created by jean.rennes on 03/04/2017.
 */
declare namespace AFC.gui {
    class AfcGuiPanel extends HTMLElement {
        static observedAttributes: string[];
        set name(value: string);
        get name(): string;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
        connectedCallback(): void;
        disconnectedCallback(): void;
    }
    class AfcGuiPanelHolder extends BindableElement<Data.IDataContainerProvider, Data.PanelAdapter> {
        static observedAttributes: string[];
        constructor();
        set source(value: string);
        get source(): string;
        protected _bind(): Data.IDataContainerProvider;
        protected _unbind(): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
    }
}
/**
 * Created by jean.rennes on 28/05/2019.
 */
declare namespace AFC.gui {
    class LabelProvider<Model extends Globals.ILabelProvider> extends Tools.EventSink implements Globals.ILabelProvider {
        protected _model: Model;
        protected _onAttach(): void;
        protected _onDirty(): void;
        constructor();
        get label(): string;
        set model(value: Model);
        get model(): Model;
    }
    interface ILabelProviderHolder extends HTMLElement {
        label: Globals.ILabelProvider;
    }
    class AfcGuiLabel extends ForElement<Globals.ILabelProvider, Globals.LabelAdapter> {
        static observedAttributes: string[];
        constructor();
    }
}
/**
 * Created by jean.rennes on 28/05/2019.
 */
declare namespace AFC.gui {
    class AfcGuiPhotoControl extends AFC.Controls.Control {
        private _ro;
        private _format;
        constructor(element: string | HTMLElement);
        setROMode(ro: boolean): void;
        empty(): void;
        refresh(storePictures: AFC.PhotoManager.IPicturesSource): void;
    }
    export class AfcGuiPhoto extends AfcGuiElement {
        protected _pictureSource: AFC.PhotoManager.IPicturesSource;
        protected _control: AfcGuiPhotoControl;
        static observedAttributes: string[];
        constructor();
        set picturesSource(pictureSource: AFC.PhotoManager.IPicturesSource);
        protected _onGenerate(): void;
        connectedCallback(): void;
        refresh(): void;
        deletePictureCheck(picture: AfcGuiPhoto): Promise<boolean>;
        setROMode(ro: boolean): void;
    }
    export {};
}
declare namespace AFC.gui {
    class AfcGuiTemplateElem extends AfcBindableElement<any, Globals.TemplateElemAdapter> {
        static observedAttributes: string[];
        constructor(adapter?: Globals.TemplateElemAdapter);
        protected _onRestoreViewState(context: Application.Context, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
        set dataBinder(value: (name: string, key: string, value: Data.IDataItemContainer) => any);
        get dataBinder(): (name: string, key: string, value: Data.IDataItemContainer) => any;
        set adapter(adapter: Globals.TemplateElemAdapter);
        get adapter(): Globals.TemplateElemAdapter;
        /**
         * Store initial content <afc-gui-template-elem> as template
         */
        connectedCallback(): void;
        disconnectedCallback(): void;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
        refresh(): void;
    }
}
/**
 * Created by jean.rennes on 03/10/2018.
 */
declare namespace AFC.gui {
    interface ILegendsProviderHolder extends HTMLElement {
        legends: Globals.ILegendsProvider;
    }
    class AfcGuiLegend extends ForElement<Globals.ILegendsProvider, Globals.LegendsAdapter> {
        static observedAttributes: string[];
        protected _onDirty(): void;
        constructor();
        set enableFiltering(value: boolean);
        get enableFiltering(): boolean;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
        isEmpty(): boolean;
    }
}
/**
 * Created by jean.rennes on 11/10/2017.
 */
declare module L {
    interface GoogleOptions {
        mapOptions: {
            styles: any;
            backgroundColor: string;
        };
    }
    class Google extends Layer {
        constructor(type_?: string, options?: GoogleOptions);
    }
    interface ButtonOptions {
        text: string;
        iconUrl: string;
        onClick: L.LeafletEventHandlerFn;
        toggle: boolean;
        hideText?: boolean;
        maxWidth?: string;
    }
    module Control {
        class Button extends L.Control {
            constructor(options?: Partial<ButtonOptions>);
            options: L.ControlOptions;
        }
    }
}
/**
 * Created by jean.rennes on 19/02/2019.
 */
declare namespace AFC.gui {
    class AfcGuiLibraryMap extends AfcGuiElement implements ILayerProviderElement {
        static observedAttributes: string[];
        protected _setHide(bHide: boolean): void;
        protected _onRestoreViewState(activity: Application.RestActivity, fragmentManager: AFC.Application.FragmentManager, savedInstanceState?: Application.Bundle): void;
        protected _onSaveInstanceState(context: Application.Context, savedInstanceState: Application.Bundle): void;
        set name(value: string);
        get name(): string;
        getCount(): number;
        getLayerProvider(indice: number): TileLayerProvider;
        getInfo(): Promise<Readonly<ILayerProviderInfo>>;
        attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
        refresh(): void;
    }
}
declare namespace AFC.Tools {
    interface ICommandFunc {
        (params: any): void;
    }
    interface IItemCommandHistory {
        cmdRollback: ICommandFunc;
        cmdCommit: ICommandFunc;
    }
    interface IExecCommandFunc {
        (command: ICommandFunc): void;
    }
    /**
     * Helper for command history, stack list of actions, enable to undo or redo stacked commands.
     */
    export class CommandHistoryHelper {
        private _currentCommitDone;
        private _currentRollbackDone;
        private _cursor;
        private _stackCommands;
        private _execCommand;
        constructor(execCommand: IExecCommandFunc);
        undo: () => void;
        redo: () => void;
        /**
         * Get command at given index
         * @param index The command index, if null, index = cursor
         * @returns
         */
        getCommand(index?: number): IItemCommandHistory;
        /**
         * Allow update of last command, in case of action wasnt finished yet, and one command is a succession of multiple actions (eg. mousedown while painting)
         * @param command The updated command
         * @param index The command index, if null, index = cursor
         */
        updateLastCommand(command: IItemCommandHistory, index?: number): void;
        /**
         * Add a command item to history stack at cursor index, then reset all next actions (clean redos after undo > new action).
         * @param commandItem The command to be added to the stack, must contain rollback and commit callbacks.
         */
        addCommand(commandItem: IItemCommandHistory): void;
        /**
         * Can redo if stack is not empty and current box' commit callback not already done
         * @returns true if can redo action (not already comitted), false otherwise
         */
        canRedo(): boolean;
        /**
         * Can redo if stack is not empty and current box' commit callback not already done
         * @returns true if can undo action (not already rollbacked), false otherwise
         */
        canUndo(): boolean;
        /**
         * Undo command if exists, call previous item's cmdRollback function. If only one item, call self rollback.
         */
        undoCommand(): void;
        /**
         * Redo command if exists, call next item's cmdCommit function. If only one item, call self commit.
         */
        redoCommand(): void;
        /**
         * Execute callback function.
         * @param command The callback function that will apply state according to triggered action (redo or undo).
         */
        execCommand(command: ICommandFunc): void;
    }
    export {};
}
/**
 * Created by jean.rennes on 22/03/2021.
 */
declare namespace AFC.Dashboards {
    export interface IGridClass {
        readonly color: string;
        readonly padding: string;
        readonly backgroundColor: string;
        readonly fontSize: string;
        readonly textAlign: string;
        readonly verticalAlign: string;
        readonly fontWeight: string;
        readonly fontFamily: string;
        readonly borderStyle: string;
        readonly borderWidth: string;
        readonly borderColor: string;
        readonly textDecoration: string;
        readonly fontStyle: string;
        readonly whiteSpace: string;
    }
    export interface IGridRowHeader {
        readonly name: string;
        readonly text?: string;
        readonly className: string;
        readonly renderer: Globals.GridRenderer;
        readonly height: number;
        readonly image: string;
    }
    export interface IGridColumnHeader {
        readonly name: string;
        readonly text?: string;
        readonly className: string;
        readonly renderer: Globals.GridRenderer;
        readonly width: number;
        readonly image: string;
        readonly supportOrdering: boolean;
        readonly type: Data.DataKind;
    }
    export interface IGridCell {
        readonly value: any;
        readonly text: string;
        readonly className: string;
        readonly renderer: Globals.GridRenderer;
        readonly image: string;
    }
    export interface IGridData {
        classes: {
            [key: string]: IGridClass;
        };
        rowHeaders: {
            width: number;
            visibility: boolean;
            items: IGridRowHeader[];
        };
        columnHeaders: {
            ordering?: {
                index: number;
                descending: boolean;
            }[];
            height: number;
            visibility: boolean;
            items: IGridColumnHeader[];
        };
        images: {
            [key: string]: string;
        };
        items: IGridCell[][];
    }
    export class GridApp implements Globals.IGridApp {
        private readonly _index;
        readonly gridData: IGridData;
        readonly hasRowHeader: boolean;
        readonly hasColumnHeader: boolean;
        readonly sortedColumns: Globals.ISortedColumn[];
        constructor(gridData: IGridData, allowOrdering?: boolean, sortedColumns?: Globals.ISortedColumn[]);
        get allowOrdering(): boolean;
        getRowCount(): number;
        getRowHeader(line: number): Globals.IGridAppCell;
        getRowHeaderWidth(): number;
        getRowHeight(line: number): number;
        getColumnInfo(column: number): Globals.IGridAppColumnInfo;
        getColumnCount(): number;
        getColumnHeader(column: number): Globals.IGridAppCell;
        getColumnHeaderHeight(): number;
        getColumnWidth(column: number): number;
        getCell(column: number, line: number): Globals.IGridAppCell;
        getValue(column: string, line: number): number | string;
        getSymbol(key: string): string;
    }
    class GridAppCell implements Globals.IGridAppCell {
        readonly value: any;
        readonly symbol: string;
        readonly image: string;
        readonly color: string;
        readonly backgroundColor: string;
        readonly renderer: Globals.GridRenderer;
        readonly padding: string;
        readonly fontSize: string;
        readonly textAlign: string;
        readonly verticalAlign: string;
        readonly fontWeight: string;
        readonly fontFamily: string;
        readonly borderStyle: string;
        readonly borderWidth: string;
        readonly borderColor: string;
        readonly textDecoration: string;
        readonly fontStyle: string;
        readonly whiteSpace: string;
        readonly thematic: Globals.IThematic<number>;
        readonly text: string;
        className: string;
        constructor(item: Globals.ITemplateSheetColumnHeader | Globals.ITemplateSheetRowHeader | Globals.ITemplateSheetCell, template: Partial<Globals.ITemplateSheetClass>, value: any, text: string, backgroundColor: string);
    }
    export abstract class MetaGridApp implements Globals.IGridApp {
        readonly template: Globals.ITemplateSheet;
        readonly hasRowHeader: boolean;
        readonly hasColumnHeader: boolean;
        readonly allowOrdering: boolean;
        readonly sortedColumns: Globals.ISortedColumn[];
        constructor(template: Globals.ITemplateSheet, allowOrdering: boolean, sortedColumns?: Globals.ISortedColumn[]);
        protected _getCellEx(item: Globals.ITemplateSheetColumnHeader | Globals.ITemplateSheetRowHeader | Globals.ITemplateSheetCell, value: any, text: string, backgroundColor?: string, format?: Tools.StringTools.FormatString): GridAppCell;
        abstract getRowCount(): number;
        abstract getRowHeader(line: number): Globals.IGridAppCell;
        abstract getRowHeaderWidth(): number;
        abstract getRowHeight(line: number): number;
        abstract getColumnInfo(column: number): Globals.IGridAppColumnInfo;
        getColumnCount(): number;
        abstract getColumnHeader(column: number): Globals.IGridAppCell;
        getColumnHeaderHeight(): number;
        getColumnWidth(column: number): number;
        abstract getCell(column: number, line: number): Globals.IGridAppCell;
        abstract getValue(column: string, line: number): number | string;
        getSymbol(key: string): string;
    }
    export class DetailedGridApp extends MetaGridApp {
        private readonly _thematic;
        private readonly _formats;
        readonly template: Globals.ITemplateDetailedSheet;
        readonly dataModel: Data.IDataModelBase;
        readonly sortedColumns: Globals.ISortedColumn[];
        readonly index: ReadonlyArray<number>;
        constructor(template: Globals.ITemplateDetailedSheet, data: Partial<Globals.IDetailData>, sortedColumns: Globals.ISortedColumn[]);
        getRowCount(): number;
        getRowHeader(line: number): Globals.IGridAppCell;
        getRowHeaderWidth(): number;
        getRowHeight(line: number): number;
        getColumnInfo(column: number): Globals.IGridAppColumnInfo;
        getColumnHeader(column: number): Globals.IGridAppCell;
        getCell(column: number, line: number): Globals.IGridAppCell;
        getValue(column: string, line: number): number | string;
    }
    export {};
}
/**
 * Created by jean.rennes on 22/04/2016.
 */
declare namespace AFC.Traffic {
    export const enum EventType {
        statistics = 65537,
        packages = 65538
    }
    export const enum TrafficStatus {
        none = 0,
        pending = 1,
        ready = 2
    }
    interface ITrafficData {
        name: string;
        description: string;
        value: number;
    }
    interface ITrafficUnitArea {
        code: string;
        pct: number;
        count: number;
    }
    interface ITrafficLocation {
        lon: number;
        lat: number;
    }
    interface ITrafficSection {
        id: string;
        endpoint1: ITrafficLocation;
        endpoint2: ITrafficLocation;
        version: string;
    }
    interface ITrafficStatisticsResponse {
        section: ITrafficSection;
        status: string;
        provider: string;
        package: string;
        newVersionAvailable?: boolean;
        error?: string;
        geographicLevel?: string;
        geographicSource?: string;
        dataSource?: string;
        data: Array<ITrafficData>;
        livingArea: Array<ITrafficUnitArea>;
        workingArea: Array<ITrafficUnitArea>;
    }
    export interface ITrafficStatistics {
        id: string;
        status: TrafficStatus;
        newerAvailable: boolean;
        needBuy: boolean;
        readonly workingArea?: Data.IDataTable & Data.IDataCreation;
        readonly livingArea?: Data.IDataTable & Data.IDataCreation;
        readonly infoTable?: Data.IDataTable & Data.IDataCreation;
    }
    interface ITrafficPackage {
        id: string;
        name: string;
        description: string;
        fullCost: number;
        cost: number;
    }
    interface ITrafficPackagesResponse {
        packages: Array<ITrafficPackage>;
        newVersionCost?: number;
        credits?: number;
    }
    export interface ITrafficPackages {
        readonly packages: Array<ITrafficPackage>;
        newVersionCost?: number;
        credits?: number;
    }
    class TrafficPackages implements ITrafficPackages {
        protected readonly _packages: Array<ITrafficPackage>;
        protected _invalidate: () => void;
        protected _newVersionCost: number;
        protected _credits: number;
        constructor(invalidate: () => void, response: ITrafficPackagesResponse);
        get packages(): Array<ITrafficPackage>;
        get newVersionCost(): number;
        get credits(): number;
    }
    class TrafficStatistics implements ITrafficStatistics {
        protected _invalidate: () => void;
        protected _workingArea: Data.DataModelBase;
        protected _livingArea: Data.DataModelBase;
        protected _infoTable: Data.DataModelBase;
        protected _status: TrafficStatus;
        protected _newerAvailable: boolean;
        protected _needBuy: boolean;
        protected _model: TrafficModel;
        protected _id: string;
        protected _package: string;
        protected _provider: string;
        protected _onError: boolean;
        protected _errorMsg: string;
        protected _newVersionAvailable: boolean;
        constructor(model: TrafficModel, invalidate: () => void, response: ITrafficStatisticsResponse, infoTableResource: AFC.Data.ITableResourceContent);
        protected _getLivingAreaTable(units: Array<ITrafficUnitArea>): Data.DataModelBase;
        protected _getWorkingAreaTable(units: Array<ITrafficUnitArea>): Data.DataModelBase;
        protected _getInfoTable(info: Array<ITrafficData>, infoTableResource: AFC.Data.ITableResourceContent): Data.DataModelBase;
        initFrom(): void;
        get isOnError(): boolean;
        get errorMsg(): string;
        get id(): string;
        get provider(): string;
        get package(): string;
        get newVersionAvailable(): boolean;
        get workingArea(): Data.DataModelBase;
        get livingArea(): Data.DataModelBase;
        get infoTable(): Data.DataModelBase;
        get status(): TrafficStatus;
        get newerAvailable(): boolean;
        get needBuy(): boolean;
    }
    export class TrafficModel extends Tools.EventSink {
        protected _x: number;
        protected _y: number;
        protected _serverKind: string;
        protected _geographicSource: string;
        protected _currentCodeValue: string | number;
        protected _useCredit: boolean;
        protected _packageToBuy: string;
        protected _sequence: number;
        protected _sequencePackages: number;
        protected _statistics: TrafficStatistics;
        protected _packages: TrafficPackages;
        protected _infoTableName: string;
        readonly restModel: Rest.RestModel;
        constructor(restModel: Rest.RestModel);
        private _invalidate;
        set geographicSource(value: string);
        get geographicSource(): string;
        set serverKind(value: string);
        get serverKind(): string;
        set x(value: number);
        set y(value: number);
        get x(): number;
        get y(): number;
        get isOnError(): boolean;
        get errorMsg(): string;
        set currentCodeValue(value: string | number);
        get currentCodeValue(): string | number;
        setUseCredit(value: boolean, pack: string): void;
        set infoTableTemplate(table: string);
        protected _onAlwaysPackages(sequence: number, jqXHR: JQueryXHR, textStatus: string): void;
        protected _onAlways(sequence: number, jqXHR: JQueryXHR, textStatus: string): void;
        request(): Promise<ITrafficStatistics>;
        requestPackages(): Promise<TrafficPackages>;
    }
    export {};
}
/**
 * Created by jean.rennes on 26/04/2016.
 */
declare namespace AFC.Tools.Dashboards {
    import Dashboards = AFC.Dashboards;
    export interface IDMAReplacementOptions {
        readonly confirm?: () => Promise<boolean>;
        readonly zone?: Dashboards.IZone<Dashboards.ZoneType.predefined>;
        readonly income?: Dashboards.IZone<Dashboards.ZoneType.predefined>;
        readonly impact?: string;
        readonly neighbors?: string;
        readonly descriptor?: TradeArea.DMAConfigDescriptor;
    }
    export interface ITrafficReplacementOptions {
        readonly confirm?: (callback: (update: boolean) => void) => any;
        readonly workingZone?: Dashboards.IZone<Dashboards.ZoneType.predefined>;
        readonly livingZone?: Dashboards.IZone<Dashboards.ZoneType.predefined>;
        readonly geographicSource?: string;
        readonly customServer?: string;
        readonly x: number;
        readonly y: number;
        readonly currentCodeValue: string | number;
    }
    type ResourceSubstitute = Rest.ResourceSubstitute;
    const ResourceSubstitute: typeof Rest.ResourceSubstitute;
    interface IStoreSourceListenerEventData extends IEventData {
        readonly data: ReadonlyArray<AFC.Data.IDataEvent>;
        readonly dashboard: ReadonlyArray<AFC.Data.IDataEvent>;
    }
    export type IStoreSourceListenerEvent = IEvent<AFC.Data.StoreSource, IStoreSourceListenerEventData>;
    abstract class StoreSourceListener implements Rest.IContextModifier {
        readonly dashboard: Dashboards.IDashboard;
        readonly storeSource: AFC.Data.StoreSource;
        constructor(dashboard: Dashboards.IDashboard, storeSource: AFC.Data.StoreSource);
        protected _create(): void;
        protected abstract _update(event: AFC.Data.IDataEvent): void;
        abstract updateBody(body: AFC.Dashboards.IDashboardContextData): void;
        load(): Promise<any>;
        release(): void;
    }
    export class StoreSourceLoader extends StoreSourceListener implements Rest.IContextModifier {
        readonly creator: ResourceSubstitute;
        constructor(dashboard: Dashboards.IDashboard, storeSource: AFC.Data.StoreSource);
        protected _create(): void;
        protected _update(event: AFC.Data.IDataEvent): void;
        updateBody(body: AFC.Dashboards.IDashboardContextData): void;
        release(): void;
    }
    interface IDMALoaderZone extends ResourceSubstitute {
        readonly zone: Dashboards.IZone<Dashboards.ZoneType.predefined>;
        load(reset?: boolean): Promise<void>;
    }
    const DMALoader_base: abstract new (...args: any[]) => StoreSourceListener & IEventSink;
    export class DMALoader extends DMALoader_base implements Rest.IContextModifier {
        private static _Zone;
        readonly dmaModel: TradeArea.DMAConfigModel;
        readonly confirm: () => Promise<boolean>;
        readonly zone: IDMALoaderZone;
        readonly income: ResourceSubstitute;
        readonly impact: ResourceSubstitute;
        readonly neighbors: ResourceSubstitute;
        private _status;
        private _pending;
        private _columns;
        private _reaffectStorage;
        constructor(dashboard: Dashboards.IDashboard, storeSource: AFC.Data.StoreSource, dmaModel: TradeArea.DMAConfigModel, options: IDMAReplacementOptions);
        private _off;
        private _onReset;
        protected _update(event: AFC.Data.IDataEvent): Promise<void>;
        updateBody(body: Dashboards.IDashboardContextData, options?: Dashboards.IDashboardContextModifierOptions): any;
        load(options?: Dashboards.IDashboardContextModifierOptions): Promise<void>;
        protected _simulate(): Promise<TradeArea.IDMASimulation>;
        release(): void;
    }
    const TrafficLoader_base: abstract new (...args: any[]) => StoreSourceLoader & IEventSink;
    export class TrafficLoader extends TrafficLoader_base implements Rest.IContextModifier {
        protected _confirm: (callback: (update: boolean) => void) => any;
        protected _workingArea: ResourceSubstitute;
        protected _livingArea: ResourceSubstitute;
        protected _trafficStatistics: ResourceSubstitute;
        protected _status: Traffic.TrafficStatus;
        protected _trafficModel: Traffic.TrafficModel;
        protected _dashboard: Dashboards.IDashboard;
        protected _cluster: string;
        constructor(dashboard: Dashboards.IDashboard, storeSource: AFC.Data.StoreSource, restModel: Rest.RestModel, options?: ITrafficReplacementOptions);
        protected _setDashboardCluster(dashboard: Dashboards.IDashboard, clusterId: string, value: string): void;
        protected _getDashboardCluster(dashboard: Dashboards.IDashboard, clusterId: string): string;
        updateBody(body: Dashboards.IDashboardContextData): any;
        forceBuy(pack: string): void;
        load(): Promise<void>;
        protected _update(event: AFC.Data.IDataEvent): void;
        release(): void;
    }
    export function setClusterSite(cluster: Dashboards.IZoneCluster, store: AFC.Data.IReadonlyStore): number | string;
    interface IPosition {
        readonly columns: number;
        readonly offset: number;
        readonly lines: readonly number[];
    }
    class GridAppAggregate extends Dashboards.MetaGridApp {
        readonly positions: IPosition[];
        readonly allowOrdering: boolean;
        readonly data: Readonly<Globals.IDataSheet>[];
        constructor(template: Globals.ITemplateSheet, positions: IPosition[], data: Readonly<Globals.IDataSheet>[]);
        getRowCount(): number;
        getRowHeader(line: number): Globals.IGridAppCell;
        getRowHeaderWidth(): number;
        getRowHeight(line: number): number;
        getColumnInfo(column: number): Globals.IGridAppColumnInfo;
        getColumnHeader(column: number): Globals.IGridAppCell;
        getColumnHeaderHeight(): number;
        getColumnWidth(column: number): number;
        getCell(column: number, line: number): Globals.IGridAppCell;
        getValue(column: string, line: number): number | string;
    }
    export class DashboardsAggregate extends EventSink implements AFC.Dashboards.IGridModel {
        protected _dashboards: ReadonlyArray<Dashboards.IDashboard>;
        protected _id: string;
        protected _gridApp: GridAppAggregate;
        protected _sheets: ReadonlyArray<AFC.Dashboards.ISheet<AFC.Dashboards.ViewType.spreadSheet | AFC.Dashboards.ViewType.aggregatedSheet>>;
        protected _data: Readonly<Globals.IDataSheet>[];
        getType(): Promise<AFC.Dashboards.ViewType>;
        readonly properties: ReadonlyArray<AFC.Dashboards.IDashboardProperty>;
        readonly dashboard: AFC.Dashboards.IDashboard;
        dashboardModel: AFC.Dashboards.DashboardModel;
        getForeignDataModel(): AFC.Data.IDataModel;
        getLegendImage(width: number, height: number, horizontal: boolean, quality?: number): Promise<string | void>;
        protected _onAttach(): void;
        constructor();
        protected _releaseView(view: Dashboards.IView): void;
        protected _loadViewData(sheet: AFC.Dashboards.ISheet<AFC.Dashboards.ViewType.spreadSheet | AFC.Dashboards.ViewType.aggregatedSheet>, indice: number): void;
        protected _onDirty(e: Tools.IEvent): void;
        _clear(): void;
        setId(value: string): void;
        get id(): string;
        get label(): string;
        set dashboards(value: ReadonlyArray<AFC.Dashboards.IDashboard>);
        get dashboards(): ReadonlyArray<AFC.Dashboards.IDashboard>;
        getGridApp(): Promise<Globals.IGridApp>;
    }
    export {};
}
declare namespace AFC.Tools.Geocoding {
    const enum Provider {
        auto = 0,
        nominatim = 1,
        dataGouv = 2
    }
    interface ISearchOptions {
        countryCode?: string;
        bbox?: number[];
        maxResults?: number;
        provider?: Provider;
    }
    interface IReverseOptions {
        countryCode?: string;
        provider?: Provider;
    }
    interface IGeocodeResult {
        address?: string;
        zipCode?: string;
        city?: string;
        country?: string;
        countryCode?: string;
        score?: number;
        location?: GeoJSON.Point;
        native_?: any;
    }
    class Geocoder {
        protected _onReverseComplete(handle: (data: any) => IGeocodeResult, callback: (geocodeResult: IGeocodeResult, success: boolean) => any, jqXHR: JQueryXHR, textStatus: string): void;
        protected _onSearchComplete(handle: (data: any) => IGeocodeResult[], callback: (geocodeResults: IGeocodeResult[], success: boolean) => any, jqXHR: JQueryXHR, textStatus: string): void;
        search(query: string, callback: (geocodeResults: IGeocodeResult[], success: boolean) => any, options?: ISearchOptions): void;
        reverse(lat: number, lon: number, callback: (geocodeResult: IGeocodeResult, success: boolean) => any, options?: IReverseOptions): void;
    }
}
/**
 * Created by jean.rennes on 14/03/2016.
 */
declare namespace AFC.Tools.ParcEdition {
    export interface IMapLayerEditorInfo {
        gui: gui.AfcGuiLayer;
        layer: L.Layer;
        store: AFC.Data.IStore;
        source: Globals.IEventLayerInfo;
    }
    export interface IMapLayerEditorOptions {
        createCode?: (handlers: LayerEditionHandlers) => any;
        onMoveEnd?: (handlers: LayerEditionHandlers, destination: GeoJSON.Point, info: IMapLayerEditorInfo) => boolean;
        click(handlers: LayerEditionHandlers, latlng: L.LatLng, info: IMapLayerEditorInfo, event: L.LeafletMouseEvent): any;
    }
    class MoveControl extends L.Control {
        protected _text: d3.Selection<SVGTextElement, undefined, SVGElement, undefined>;
        protected _start: L.LatLngTuple;
        protected _cancel: () => void;
        readonly info: IMapLayerEditorInfo;
        constructor(info: IMapLayerEditorInfo, cancel: () => void);
        protected _onMove(e: L.LeafletMouseEvent): void;
        onAdd(map: L.Map): HTMLElement;
        onRemove(map: L.Map): void;
    }
    export type ILayerEditionSource = AFC.Data.IDataEditor & AFC.Data.IStoreSource & {
        getStoreFromRow(row?: ReadonlyArray<any>): AFC.Data.Store | undefined;
    };
    export class LayerEditionHandlers implements gui.IMapEventHandlers {
        protected _move: MoveControl;
        readonly options: IMapLayerEditorOptions;
        readonly parc: ILayerEditionSource;
        readonly holder: gui.AfcGuiMapHolder;
        readonly guiLayers: ReadonlyArray<gui.AfcGuiLayer>;
        readonly symbolFactory: Globals.SymbolFactory;
        disabled: boolean;
        constructor(storeSource: ILayerEditionSource, holder: gui.AfcGuiMapHolder, guiLayers: ReadonlyArray<gui.AfcGuiLayer>, symbolFactory: Globals.SymbolFactory, options: IMapLayerEditorOptions);
        create(latlng: L.LatLng): AFC.Data.IStore;
        startMove(info: IMapLayerEditorInfo): void;
        endMove(): void;
        click(latlng: L.LatLng, source: gui.IEventLayerInfo<Globals.LayerType.symbol>, event: L.LeafletMouseEvent): boolean;
    }
    export {};
}
/**
 * Created by jean.rennes on 05/10/2017.
 */
declare namespace AFC {
    namespace Tools {
        namespace Storage {
            function setItem(key: string, value?: any): void;
            function getItem(key: string): any;
            function getKeys(): string[];
        }
    }
}
/**
 * Created by jean.rennes on 22/05/2019.
 */
declare namespace AFC.Tools.ParcEdition {
    export interface IStoreCartItemData {
        readonly id: string;
        readonly store: AFC.Data.IReadonlyStore;
    }
    class StoreCartItemData implements IStoreCartItemData {
        readonly id: string;
        readonly store: AFC.Data.IReadonlyStore;
        constructor(branch: string, store: AFC.Data.IReadonlyStore);
    }
    export class StoreCart extends Tools.EventSink implements AFC.Data.IDataSource<IStoreCartItemData>, AFC.Globals.ILabelProvider {
        protected _data: StoreCartItemData[];
        get length(): number;
        get label(): string;
        item(index: number): AFC.Data.IDataItemContainer<IStoreCartItemData>;
        indexOf(id: string, store: AFC.Data.IReadonlyStore): number;
        add(id: string, store: AFC.Data.IReadonlyStore): boolean;
        remove(id: string, store: AFC.Data.IReadonlyStore): void;
        clear(): void;
    }
    export {};
}
/**
 * Created by jean.rennes on 26/04/2016.
 */
declare namespace AFC.Tools {
    class Synchronizer {
        result: any;
        push: (arg: (...args: any[]) => void, reference?: any) => {
            (...args: any[]): void;
        };
        start: () => void;
        constructor(callback: (result: any) => void, context?: any);
    }
}
declare namespace AFC {
    namespace BulkMail {
        interface IBMAnalysisDataValue {
            from(): Date;
            value(): number;
        }
        class BMAnalysisDataValue implements IBMAnalysisDataValue {
            private _from;
            private _value;
            constructor(from: Date, value: number);
            from(): Date;
            value(): number;
        }
        class BMAnalysisDataValues {
            private _custom;
            private _group;
            private _values;
            constructor(group: IBMAnalysisGroupItem, custom: (dataId: string, values: BMAnalysisDataValues) => IBMAnalysisDataValue[]);
            get values(): {
                from: Date;
                values: {
                    [key: string]: number;
                };
            }[];
            get(dataId: string): IBMAnalysisDataValue[];
            dateRange(): Date[];
            pushValue(from: Date, values: {
                [key: string]: number;
            }): void;
            get group(): IBMAnalysisGroupItem;
        }
        class BMAnalysisData {
            private _id;
            private _name;
            private _description;
            private _canAggregate;
            private _suffix;
            private _precision;
            private _isCustom;
            private _format;
            constructor(id: string, name?: string, description?: string, suffix?: string, canAggregate?: boolean, precision?: number, format?: (x: number) => string, isCustom?: boolean);
            get id(): string;
            get name(): string;
            get description(): string;
            get isCustom(): boolean;
            canAggregate(): boolean;
            toString(x: number): string;
        }
        interface IBMAnalysisGroupItemStyle {
            get color(): string;
        }
        interface IBMAnalysisGroupItem {
            get key(): {
                id: string;
                value: string;
            };
            get id(): string;
            get name(): string;
            get description(): string;
            get isStore(): boolean;
            get style(): IBMAnalysisGroupItemStyle;
            get count(): number;
        }
        interface IBMAnalysisGroupDescription {
            get id(): string;
            get name(): string;
            get style(): IBMAnalysisGroupItemStyle;
        }
        class BMAnalysisGroupsSettings {
            private _storesTable;
            private _nameColum;
            private _codeColum;
            private _groupColumns;
            private _allowAllStores;
            private _isValid;
            private _allStores;
            private _groups;
            private _allStoresLabel;
            constructor();
            load(): Promise<boolean>;
            get description(): IBMAnalysisGroupDescription[];
            set storesTable(storesTable: AFC.Data.IDataTable);
            set nameColum(col: string);
            set codeColum(col: string);
            private set groupColumns(value);
            findFromKey(key: {
                id: string;
                value: string;
            }): IBMAnalysisGroupItem;
            find(searchString: string, groupsOnly?: boolean): IBMAnalysisGroupItem[];
            private _getAllStoresGroup;
            private _init;
        }
        class BMAnalysis extends Tools.EventSink {
            private _data;
            private _customData;
            private _customValues;
            private _groupsSettings;
            private _dataValuesCache;
            private _pendingRequests;
            static get uri(): string;
            constructor(groupsSettings: BMAnalysisGroupsSettings);
            findGroupsFromKey(key: {
                id: string;
                value: string;
            }): IBMAnalysisGroupItem;
            findGroups(searchString: string, groupsOnly?: boolean): IBMAnalysisGroupItem[];
            get groupsDescription(): IBMAnalysisGroupDescription[];
            get data(): Promise<BMAnalysisData[]>;
            requestDataValues(group: IBMAnalysisGroupItem): Promise<BMAnalysisDataValues>;
            set customData(data: BMAnalysisData[]);
            set customValues(fn: (dataId: string, values: BMAnalysisDataValues) => IBMAnalysisDataValue[]);
            XLSExport(groups: {
                group0: IBMAnalysisGroupItem;
                group1: IBMAnalysisGroupItem;
            }, dateRanges: {
                date0: {
                    from: Date;
                    to: Date;
                };
                date1: {
                    from: Date;
                    to: Date;
                };
                date2: {
                    from: Date;
                    to: Date;
                };
            }): void;
        }
    }
}
declare namespace AFC {
    namespace BulkMail {
        class BMEntity extends Tools.EventSink {
            protected _code: string;
            get code(): string;
            constructor(item?: {
                [key: string]: any;
            });
        }
    }
}
declare namespace AFC {
    namespace BulkMail {
        const enum BMStoreStatus {
            active = "active",
            inactive = "inactive",
            undefined = "undefined"
        }
        type TStoreDataValues = {
            [key: string]: any;
        };
        /**
         * Instance of store for a campaign
         */
        class BMStore extends BMEntity {
            /**
             * Store identifier in DB, given by api
             */
            protected _code: string;
            /**
             * Store status, if active, store is participating to the campaign
             */
            protected _status: BMStoreStatus;
            protected _statusInitial: BMStoreStatus;
            protected _campaign: BMCampaign;
            /**
             *
             */
            protected _valuesTargeted: TStoreDataValues;
            protected _valuesTargetedMax: TStoreDataValues;
            protected _valuesUpcoming: TStoreDataValues;
            protected _valuesUpcomingMax: TStoreDataValues;
            /**
             * Intial values of eather upcoming in case of upcoming exists, or targeted if not.
             * This save initial values to populate initial qty in table, otherwise, valuesTargeted or Upcoming may be updated
             * after computing operation
             */
            protected _valuesInitial: Readonly<TStoreDataValues>;
            /**
             * Store temp qty given by user
             */
            qtyTemp: number;
            /**
             * Store temp qty computed
             */
            qtyTempComputed: number;
            constructor(campaign: BMCampaign, item?: IStoreDataInStoreList);
            get code(): string;
            get status(): BMStoreStatus;
            set status(status: BMStoreStatus);
            get statusInitial(): BMStoreStatus;
            get valuesInitial(): Readonly<TStoreDataValues>;
            get valuesTargeted(): TStoreDataValues;
            set valuesTargeted(values: TStoreDataValues);
            get valuesTargetedMax(): TStoreDataValues;
            set valuesTargetedMax(values: TStoreDataValues);
            get valuesUpcoming(): TStoreDataValues;
            set valuesUpcoming(values: TStoreDataValues);
            get valuesUpcomingMax(): TStoreDataValues;
            set valuesUpcomingMax(values: TStoreDataValues);
            /**
             * Test if store is active (in campaign)
             *
             * @returns
             */
            isActive(): boolean;
            /**
             * Toggle store status to active or inactive (no DB saving)
             *
             * @param active
             * @returns
             */
            toggleActive(active?: boolean): BMStoreStatus;
            getQtyTargeted(options?: string[]): number;
            getQtyUpcoming(options?: string[]): number;
            getQtyDiff(): number;
            /**
             * Return computed quantity according to given options (= segments), if no option, return sum of all
             * active segments in campaign
             *
             * @param options An array of segments code
             * @param optGetInitial If force true, retrieve intial values targeted or upcoming (valeus that hasnt changed following multiple computes by user), default is false
             * @returns sum of qty according to segments given or default active segments in campaign
             */
            getQty(options?: string[], optGetInitial?: boolean): number;
            /**
             * Get max qty available
             * // TODO: refacto with previous getQty() fn
             *
             * @param options
             * @returns
             */
            getQtyMax(options?: string[]): number;
            private _getQty;
            /**
             * Return qty temp = input by user in store edition table
             *
             * @returns
             */
            getQtyTemp(): number;
            getBudget(): number;
            getBudgetMax(): number;
            getVolume(): number;
            getVolumeMax(): number;
            getZoneAggregates(): {
                [key: string]: number;
            };
        }
    }
}
declare namespace AFC.BulkMail {
    export interface IStoreZoneUnitsDataValues {
        [key: string]: number | IStoreZoneUnitsDataValues;
    }
    export interface IStoreZoneUnitsData {
        targeted: boolean;
        code: string;
        values: IStoreZoneUnitsDataValues;
    }
    interface IStoreZoneData {
        storeCode: string | number;
        units: IStoreZoneUnitsData[];
    }
    export interface IStoreZoneInfo {
        featuresVersion: string;
        whole?: {
            table: {
                database: string;
                name: string;
            };
            outlineTable?: {
                database: string;
                name: string;
            };
        };
        targeted: {
            table: {
                database: string;
                name: string;
            };
            outlineTable?: {
                database: string;
                name: string;
            };
        };
    }
    export const enum SegmentStatus {
        enabled = "enabled",
        disabled = "disabled"
    }
    export class BMZone {
        constructor(campaign: BMCampaign, zoneCode: string, featuresVersion: string, session: string);
        createAjaxRequest<T = any>(action?: any): Rest.IAjaxRequest<T>;
        protected _getStoreZone(stores: ReadonlyArray<string | number>): Promise<void>;
        protected _compute(stores: ReadonlyArray<{
            storeCode: string | number;
            quantity: number;
        }>, criteria: ReadonlyArray<{
            data: string;
            isASC: boolean;
        }>, segments: ReadonlyArray<{
            code: string;
            status: SegmentStatus;
        }> | null, target: Readonly<{
            segments: Array<{
                code: string;
            }>;
            options: Array<string>;
        }> | null, reset: boolean, update: boolean, hideUnits: boolean): Promise<IStoreZoneData[]>;
        computeStoreZone(stores: ReadonlyArray<{
            storeCode: string | number;
            quantity: number;
        }>, criteria: ReadonlyArray<{
            data: string;
            isASC: boolean;
        }>, segments: ReadonlyArray<{
            code: string;
            status: SegmentStatus;
        }> | null, target: Readonly<{
            segments: Array<{
                code: string;
            }>;
            options: Array<string>;
        }> | null, reset: boolean, hideUnits?: boolean): Promise<ReadonlyArray<Readonly<IStoreZoneUnitsData>>[]>;
        updateStoreZone(stores: ReadonlyArray<{
            storeCode: string | number;
            quantity: number;
        }>, criteria: ReadonlyArray<{
            data: string;
            isASC: boolean;
        }>, reset: boolean, hideUnits?: boolean): Promise<ReadonlyArray<Readonly<IStoreZoneUnitsData>>[]>;
        /**
         * Cancel session > call api, will trigger DB cleaning
         *
         * @returns
         */
        cancelComputeStoreZone(): Promise<Boolean>;
        replaceStoreZone(areas: ReadonlyArray<{
            storeCode: string | number;
            featureCodes: ReadonlyArray<string>;
        }>): Promise<ReadonlyArray<Readonly<IStoreZoneUnitsData>>[]>;
        getUnits(storeCodes: ReadonlyArray<string | number>): Promise<ReadonlyArray<Readonly<IStoreZoneUnitsData>>[]>;
        getInfo(): Promise<Readonly<IStoreZoneInfo>>;
        private _unitsData;
        private _info;
        readonly campaign: BMCampaign;
        readonly code: string;
        readonly featuresVersion: string;
        readonly session: string;
        get unitsData(): {
            [key: string]: IStoreZoneUnitsData[];
        };
    }
    export {};
}
declare namespace AFC {
    namespace BulkMail {
        const enum BMCampaignChannel {
            sms = "sms",
            eddm = "eddm",
            social = "social"
        }
        class BMCampaignExtraInfo {
            private _messages;
            private _providerMetaData;
            constructor(item?: ICampaignRestData);
            get messages(): BMCampaignMessage[];
            get providerMetaData(): any;
        }
        class BMCampaignMessage {
            private _code;
            private _name;
            private _preview;
            private _description;
            private _color;
            constructor(item?: ICampaignRestMessage);
            get code(): string;
            get name(): string;
            get description(): string;
            get preview(): string;
            get color(): string;
            toHTMLText(): string;
        }
        abstract class BMCampaign extends BMEntity {
            protected _disableDirtyEvent: boolean;
            /**
             * Campaign identifier in DB, auto generated at creation
             */
            protected _code: string;
            /**
             * (FK) Targeted zone identifier for this campaign
             */
            private _zoneCodeTargeted;
            /**
            * (FK) Upcoming zone identifier for this campaign
            */
            private _zoneCodeUpcoming;
            /**
             * Current feature version the campaign is based on
             */
            private _codeVersionTargeted;
            /**
             * Upcoming feature version
             */
            private _codeVersionUpcoming;
            /**
             * Campaign name defined by user, eg. "OP32 - Le blanc 2022"
             */
            private _name;
            /**
             * Start date for the campaign, must be lower than end date, ignore date's time part
             */
            protected _beginDate: Date;
            /**
             * End date of the campaign, must be higher than end date, ignore date's time part
             */
            protected _endDate: Date;
            /**
             * Tableau d'objets fournissant les quantits et le statut de chaque type d'habitat (segments HRVA)
             */
            protected _segmentList: Map<string, string>;
            /**
             * Campaign status (eg. edition mode, computing in progress, deleted, ...) @see BMCampaignStatus for values
             */
            private _status;
            /**
             * Nombre de BAL cibles par segment et cumul des donnes client sur les zones cibles en cours de production
             * Proprits des objets : valeurs des segments
             */
            private _targetedAggregates;
            /**
             * Nombre de BAL cibles par segment et cumul des donnes client sur les zones cibles en cours de production
             * Proprits des objets : valeurs des segments
             */
            private _upcomingAggregates;
            /**
             * Nombre de magasins par statut
             * eg. [{status: "active", count: 291}, {status: "inactive", count: 15}]
             *
             * !!!! /!\= de storeList
             */
            protected _storesCounter: Array<{
                status: BMStoreStatus;
                count: number;
            }>;
            /**
             * Store list
             * eg. [{code: 'E001', status: 'inactive'}, ...]
             */
            private _storeList;
            /**
             * Store entity list
             */
            private _storeEntityList;
            /**
             * Date for sorting when on create new campaign...........................................
             */
            private _timestampCreatedAt;
            /**
             * Keep date of last call api for stats on targeted zone
             */
            private _timestampStatsTargeted;
            private _timestampStats;
            /**
             * Keep date of last call api for stats on upcoming zone
             */
            private _timestampStatsUpcoming;
            channel: BMCampaignChannel;
            constructor(item?: ICampaignRestData, isNew?: boolean);
            get code(): string;
            get timestampCreatedAt(): number;
            get codeVersionTargeted(): string;
            set codeVersionTargeted(code: string);
            get codeVersionUpcoming(): string;
            set codeVersionUpcoming(code: string);
            get zoneCodeTargeted(): string;
            set zoneCodeTargeted(zoneCode: string);
            get zoneCodeUpcoming(): string;
            set zoneCodeUpcoming(zoneCode: string);
            get beginDate(): string | Date;
            get beginDateAsString(): string;
            get beginDateAsStringInput(): string;
            set beginDate(date: string | Date);
            get endDate(): string | Date;
            get endDateAsString(): string;
            get endDateAsStringInput(): string;
            set endDate(date: string | Date);
            get name(): string;
            set name(name: string);
            get segments(): Map<string, string>;
            set segments(segments: Map<string, string> | {
                [key: string]: any;
            });
            get status(): BMCampaignStatus;
            set status(status: BMCampaignStatus);
            get storesCounter(): {
                status: BMStoreStatus;
                count: number;
            }[];
            set storesCounter(storesCounter: {
                status: BMStoreStatus;
                count: number;
            }[]);
            set stores(stores: IStoreDataInStoreList[]);
            get stores(): BMStore[];
            get targetedAggregates(): Map<string, number> | {
                [key: string]: number;
            };
            set targetedAggregates(aggr: Map<string, number> | {
                [key: string]: number;
            });
            get upcomingAggregates(): Map<string, number> | {
                [key: string]: number;
            };
            set upcomingAggregates(aggr: Map<string, number> | {
                [key: string]: number;
            });
            cancelSession(session: string): Promise<any>;
            validateSession(session: string): Promise<any>;
            manageStoresSession(session: string, doCancel: boolean): Promise<boolean>;
            /**
             * Return nb store active
             * !!! If campaign list dashboard => value comes from store counter (returned counter by api)
             * if details screen of a campaign, value comes from reducer on store list loaded by api
             */
            get nbStoresActive(): any;
            get nbStoresActiveInitial(): number;
            getNbStoresActive(customFilter?: ((store: IStoreDataInStoreList) => boolean)): number;
            /**
             * Return total of stores for the campaign (active and inactive), stores without zone are ignored,
             * if store list exists, get length of collection
             * otherwise, return store counter value provided by api (eg. in campaign screen)
             */
            get nbStoresTotal(): number;
            getNbStoresTotal(customFilter?: ((store: IStoreDataInStoreList) => boolean)): number;
            /**
             * Return sum of targeted segment, according to values from targeted version
             */
            get qty(): number;
            /**
             * Return sum of targeted segment, according to values from upcoming version
             */
            get qtyUpcoming(): number;
            /**
             * Return sum of targeted according to given segments if any
             *
             * @param segmentCodeList The code segment list
             * @returns The sum of targeted aggregates according to segments
             */
            getQty(segmentCodeList?: string[]): number;
            /**
             * Return sum of each participating store's live qty (qty computed by user)
             */
            getStoresQty(): number;
            /**
             * Return uri campaign API (eg. "/bm/campaigns/_CODE_CAMPAIGN_")
             *
             * @param campaign
             * @returns the uri for current campaign
             */
            static getUriCampaign(campaign: BMCampaign | string): string;
            /**
             * Download campaign's xlsx file, call api and save file as blob
             * eg. "http://localhost/asterop/rest/CiblageISA/bm/campaigns/e70aba3e6a8b49b787d9d054dd4f7f7d?f=xlsx&token=XXX...XXX"
             */
            downloadFile(): void;
            /**
             * Check validity of campaign's inputs (eg. name, dates) and return an array of errors if any
             *
             * @returns string[]
             */
            hasError(): string[];
            protected hasErrorEx(): string[];
            hasErrorSegments(): boolean;
            hasErrorTitle(): boolean;
            hasErrorDates(): boolean;
            canPublish(): boolean;
            canUnpublish(): boolean;
            isValid(): boolean;
            isChannelSMS(): boolean;
            isChannelEddm(): boolean;
            isChannelSocial(): boolean;
            /**
             * Check if dates valid and check if begin date is before end date
             *
             * @returns boolean
             */
            isValidDates(): boolean;
            disableDirtyEvent(disable: boolean): void;
            fillCampaignWithRestData(item: ICampaignRestData): void;
            /**
             * Tag campaign as deleted in DB
             * @returns
             */
            delete(): Promise<boolean>;
            getParamItemSave(): {
                [key: string]: any;
            };
            /**
             * (alias) Save new campaign in DB
             *
             * @param item
             * @returns
             */
            save(item: {
                [key: string]: any;
            }, basedOnCodeCampaign: string): Promise<any>;
            /**
             * Update campaign in DB if not new. If new, only update attributes.
             * Call api:
             *      /bm/campaigns/{codeCampaign}
             *      action={
                        "type":"update",
                        "name":"Le blanc 2018",
                        "dateStart":"2018-08-31",
                        "dateEnd":"2018-08-11",
                        "segments":[{"code":"NB_BALS_A", "status":"enabled"}, {"code":"NB_BALS_R", "status":"enabled"}]
                    }
             *
             * @param item eg.
             *      {
             *      dateEnd: "1999-08-11"
                    dateStart: "1999-08-31"
                    name: "Random 1"
                    segments:
                        {NB_BALS_A: "enabled"
                        NB_BALS_H: "disabled"
                        NB_BALS_R: "enabled"
                        NB_BALS_V: "enabled"}
                    }
             * @returns
             */
            update(item?: ICampaignUpdateData, forceSave?: boolean, isSimulation?: boolean, silent?: boolean): Promise<any>;
            /**
             *
             * @param item
             * @returns
             */
            simulate(item?: ICampaignUpdateData): Promise<ICampaignRestData>;
            /**
             * Commit temp zone for current campaign
             *
             * Si un code de zone et un code de session sont passs, alors mise  jour de la table de zones
             * (les zones associes au code de session deviennent les zones courantes de la campagne)
             *
             * @param codeSession
             * @returns
             */
            updateCommitZone(codeSession: string): Promise<any>;
            /**
             * Activate or deactivate a list of stores for the current campaign
             * !!! Don't wait for api return to trigger Event update on cachedData
             * !!! => but campaign segments and aggregates is updated w/ api call return
             *
             * @param stores An array of stores to be activated or deactivaed
             * @returns Promise true if call API ok
             */
            updateStores(stores: IStoreDataInStoreList[]): Promise<any>;
            protected _updateFromPublish(item: ICampaignRestData): void;
            /**
             * Publish campaign to provider (set status to "published")
             *
             * @param setIsPublish If true, set campaign to publish, if not, unpublish campaign (= set status pending). True by default.
             * @returns
             */
            publish(setIsPublish?: boolean, immediate?: boolean, publishDate?: Date, publishDate2?: Date): Promise<boolean>;
            /**
             *
             * @param campaignCopyCode
             * @returns
             */
            postUpcomingApplyZone(campaignCopyCode: string): Promise<boolean>;
            /**
             * Validate upcoming zone for the current campaign
             *
             * @returns
             */
            validateUpcoming(): Promise<boolean>;
            /**
             * Set zones and targetted aggregates from a given code campaign to the current campaign
             * (used in campaign creation)
             *
             * @param basedOnCodeCampaign The campaign code to be copied
             */
            copyZonesFromCampaign(basedOnCodeCampaign: string): void;
            copyZonesFromCampaignUpcoming(basedOnCodeCampaign?: string, undoCopy?: boolean): void;
            /**
             * Return segment list as array
             *
             * @returns
             */
            getSegments(): {
                code: string;
                status: AFC.BulkMail.SegmentStatus;
            }[];
            /**
             * Return store entity corresponding to given store code
             *
             * @param storeCode The store code
             * @returns The BMStore entity found or undefined
             */
            getStore(storeCode: string): BMStore;
            /**
             * Get all stores for a campaign: for each stores, indicates if it is active or not for the current campaign.
             *      url: /asterop/rest/bulkmail/bm/campaigns/{codeCampaign}/stores
             *      api response: [{code: "E001", status: "inactive"}, {code: "E002", status: "active"},]
             *
             * Fills
             * - this._storeList // TODO: --remove this line when  BMStore entity OK
             * - this._storeEntityList
             *
             * @returns Promise result returning the list of active/inactive stores for the current campaign
             */
            getStoreList(forceUpdate?: boolean): Promise<IStoreDataInStoreList[]>;
            setStoreName(channel: BMCampaignChannel, storeCode: string, storeName: string): Promise<IStoreDataInStoreList>;
            /**
             * Call api to get kpis (per segmentations, aggregates, ...) for each store
             *          url: asterop/rest/{projet}/bm/zones/{code zone} + action type = "stats"
             *          api response:
             *          {"stores": [
             *              {"code":"E002","values":{"NB_BALS_H":2708,"NB_BALS_R":5107,"NB_BALS_V":25055,"NB_BALS_A":1869,"CA":0,"DATA1":0,"DATA2":0}},
             *              ...
             *          ]}
             *
             * @params codeSession - The session id generated by client on screen creation
             * @param storeCodes - A list of store codes to be refreshed
             * @params saveToCampaignStores - Force update for all campaign' stores obj, in both cases true or false, values are passed to promise result
             * @params saveToupdateQtyTmpComputed - If true, set value to temp computed qty of each store
             *
             * @returns
             */
            computeZoneData(codeSession: string, storeCodes?: string[], saveToCampaignStores?: boolean): Promise<void>;
            protected _generateApiStats(codeSession: string): Rest.IAjaxRequest;
            /**
             * Get campaign provider
             *
             * @returns
             */
            getProvider(): BMProvider;
            loadExtraInfo(): Promise<BMCampaignExtraInfo>;
            /**
             * Compute aggregates for campaign/zones with kpis comming from @see BMCampaign::computeZoneData()
             * and stores definition (active/inactive)
             * // TODO: refacto totalStores, activeStores, selectedStores
             *
             * @param selectedStoreList Array of store codes wich will be used to computed aggreagation for store selection by user (if any given)
             * @param codeSession
             * @param filteredStoredList Array of store codes wich will be used to computed aggreagation on filtered stores only
             * @returns Promise with computed results
             */
            getZoneAggregates(selectedStoreList: string[], codeSession: string, filteredStoredList?: string[]): Promise<{
                totalStores: {
                    [key: string]: number;
                };
                activeStores: {
                    [key: string]: number;
                };
                selectedStores: {
                    [key: string]: number;
                };
            }>;
            /**
             * Returns codes segments that are enabled for the current campaign
             *
             * @returns array[]
             */
            getActiveSegments(): string[];
            /**
             * Returns zone model for handling zone sectors,
             * BEWARE ! in case of upcoming, return upcoming zone !!!!!!
             *
             * @returns BMZone
             */
            getStoreZone(session: string, forceGetTargeted: false): BMZone;
            /**
             * Return nb stores that have been modified by user
             * @returns
             */
            getKpiNbDiffStores(customFilter?: (store: BMStore) => boolean): number;
            getKpiNbActiveStores(): number;
            /**
             * Clean store list (eg. use when leaving campaign details screen)
             */
            flushStores(): void;
            /**
             * Resset timestamp for stats to allow calling once again stats API (otherwise stats data are stores in each stores)
             */
            invalidateStats(): void;
            /**
             * Check if campaign still has an upcoming version
             *
             * @returns If true, campaign has an upcoming version
             */
            hasUpcoming(): boolean;
            /**
             * Compares campaign begin date and next version delivery date
             *
             * @returns True if campaign starts after upcoming version is delivered to production
             */
            isPostUpcoming(withoutUpcomingZone?: boolean): boolean;
            isPublished(): boolean;
            isNew(): boolean;
            storeToggleActive(storeOrCode: string | BMStore, active?: boolean): BMStoreStatus;
        }
        const enum BMCampaignStatus {
            new = "new",
            pending = "pending",
            published = "published",
            deleted = "deleted",
            template = "template",
            validated = "validated",
            checked = "checked"
        }
        const enum BMCampaignRouteStatus {
            sleeping = "sleeping",
            verification = "verification",
            scheduled = "scheduled",
            started = "started",
            completed = "completed",
            completedFinal = "completedFinal",
            canceled = "canceled",
            stopped = "stopped"
        }
        const enum BMSegmentStatus {
            enabled = "enabled",
            disabled = "disabled"
        }
        interface IStoreDataInStoreList {
            code: string;
            status: BMStoreStatus;
            channels?: {
                [key: string]: any;
            };
            values?: {
                [key: string]: any;
            };
        }
        /**
         * Rest result declaration of api service : /bm/campaigns for a campaign item
         * or data coming from new campaign creation from UI
         *
         * eg.
         *          {
                        "code": "5bb364ad746c4387970ae6988254ec1a",
                        "name": "Opration Vacances d't 2022",
                        "dateStart": "2022-08-06T00:00:00.000Z",
                        "dateEnd": "2022-10-06T00:00:00.000Z",
                        "targeted": {
                            "zoneCode": "e9587b83d39a4f0787f21c91df7bde49",
                            "featuresVersion": "wsorawtuorjdz3h8sh4dynipunh4rid8",
                            "aggreagtes": {
                                "CA": 0,
                                "DATA1": 0,
                                "DATA2": 0
                            }
                        },
                        "status": "pending",
                        "segments": {
                            "NB_BALS_R": "enabled",
                            "NB_BALS_A": "enabled"
                        },
                        "stores": [
                            {
                                "status": "active",
                                "count": 1
                            },
                            {
                                "status": "inactive",
                                "count": 305
                            }
                        ]
                    }
         */
        interface ICampaignRestData {
            code?: string;
            name?: string;
            channel?: BMCampaignChannel;
            dateStart?: string | Date;
            dateEnd?: string | Date;
            targeted?: {
                zoneCode: string;
                featuresVersion: string;
                aggregates?: {
                    [key: string]: any;
                } | Map<string, number>;
            };
            upcoming?: {
                zoneCode: string;
                featuresVersion: string;
                aggregates?: {
                    [key: string]: any;
                } | Map<string, number>;
            };
            status?: BMCampaignStatus;
            segments?: {
                [key: string]: any;
            };
            stores?: {
                status: BMStoreStatus;
                count: number;
            }[];
            messages?: [ICampaignRestMessage];
            providerMetaData?: any;
        }
        interface ICampaignRestMessage {
            code: string;
            name: string;
            description: string;
            color: string;
            preview: string;
        }
        interface ICampaignUpdateData extends Omit<ICampaignRestData, 'stores'> {
            stores?: IStoreDataInStoreList[];
            basedOnCodeCampaign?: BMCampaign;
            target?: {
                options?: Array<string>;
                segments?: Array<{
                    id: string;
                }>;
            };
        }
    }
}
declare namespace AFC {
    namespace BulkMail {
        class BMCampaignEDDM extends BMCampaign {
        }
    }
}
declare namespace AFC {
    namespace BulkMail {
        class BMCampaignFactory {
            static createCampaign(item?: ICampaignRestData | ICampaignSMSRestData, isNew?: boolean): BMCampaignSMS | BMCampaignEDDM | BMCampaignSocial;
        }
    }
}
declare namespace AFC {
    namespace BulkMail {
        const EventType_MessageDirty = 45679645;
        interface ICampaignSMSRestData extends ICampaignRestData {
            cost?: {
                budget: number;
                volume: number;
            };
            target?: {
                segments: Array<{
                    code: string;
                }>;
                options: Array<string>;
            };
            routeStatus: BMCampaignRouteStatus;
            routeStatusDetail?: string;
            sender: string;
            message?: {
                text: string;
                shortenURL: boolean;
            };
        }
        interface IPreviewSMSRestData {
            preview: string;
            smsCount: number;
            remainingChars: number;
            warnings?: Array<string>;
            errors?: Array<string>;
        }
        class BMCampaignSMS extends BMCampaign {
            private _sender;
            private _message;
            private _shortenURL;
            private _personaOptions;
            protected _segmentList: Map<string, string>;
            volume: number;
            budget: number;
            private _routeStatus;
            private _routeStatusDetail;
            constructor(item?: ICampaignSMSRestData, isNew?: boolean);
            get routeStatusDetail(): string;
            get routeStatus(): BMCampaignRouteStatus;
            set routeStatus(routeStatus: BMCampaignRouteStatus);
            get segments(): Map<string, string>;
            set segments(segments: Map<string, string> | Array<{
                code: string;
            }>);
            get personaId(): string;
            get persona(): string;
            get qty(): number;
            get shortenURL(): boolean;
            set shortenURL(shorten: boolean);
            get message(): string;
            set message(message: string);
            get sender(): string;
            set sender(sender: string);
            get personaOptions(): Array<string>;
            set personaOptions(options: Array<string>);
            getTarget(): Readonly<{
                segments: Array<{
                    code: string;
                }>;
                options: Array<string>;
            }>;
            protected _updateFromPublish(item: ICampaignRestData): void;
            isCompleted(): boolean;
            canPublish(): boolean;
            canUnpublish(): boolean;
            isValidDates(): boolean;
            get beginDateTimeAsString(): string;
            hasUpcoming(): boolean;
            hasOption(opt: string): boolean;
            fillCampaignWithRestData(item: ICampaignSMSRestData): void;
            getParamItemSave(): {
                [key: string]: any;
            };
            update(item?: ICampaignUpdateData, forceSave?: boolean, isSimulation?: boolean, silent?: boolean): Promise<any>;
            protected hasErrorEx(): string[];
            hasErrorSegments(): boolean;
            callSendSmsTest(phoneNumbers: Array<string>): Promise<any>;
            callPreviewMessage(refCode?: string): Promise<IPreviewSMSRestData | null>;
            validate(): Promise<boolean>;
            getNewVolumeBudget(campaignReference?: BMCampaignSMS): Promise<{
                volume: number;
                budget: number;
            }>;
        }
    }
}
declare namespace AFC {
    namespace BulkMail {
        interface ICampaignSocialRestData extends ICampaignRestData {
            cost?: {
                budget: number;
            };
            routeStatus: BMCampaignRouteStatus;
            routeStatusDetail?: string;
        }
        class BMCampaignSocial extends BMCampaign {
            private _routeStatus;
            private _routeStatusDetail;
            budget: number;
            constructor(item?: ICampaignSocialRestData, isNew?: boolean);
            get routeStatusDetail(): string;
            get routeStatus(): BMCampaignRouteStatus;
            set routeStatus(routeStatus: BMCampaignRouteStatus);
            hasErrorSegments(): boolean;
            copyZonesFromCampaign(basedOnCodeCampaign: string): void;
            protected _updateFromPublish(item: ICampaignRestData): void;
            setStoresInfo(values: Array<any>, session: string): Promise<boolean>;
            canPublish(): boolean;
            validate(): Promise<boolean>;
        }
    }
}
declare namespace AFC {
    namespace BulkMail {
        /**
         * Class for cache singleton
         */
        class BMEntityCacheData {
            static readonly path = "/bm";
            static readonly pathCampaign: string;
            static readonly pathProviders: string;
            static readonly pathZones: string;
            restModel: Rest.RestModel;
            eventHandler: Tools.EventSink;
            private static instance;
            private _campaignList;
            private _providerList;
            private _storeList;
            private _zoneList;
            /**
             * Current XHR sequence number
             */
            private _sequence;
            private constructor();
            static getInstance(restModel?: Rest.RestModel): BMEntityCacheData;
            get campaignList(): BMDataModel;
            get providerList(): BMDataModel;
            get sequence(): number;
            set sequence(value: number);
            get storeList(): BMDataModel;
            get zoneList(): BMDataModel;
            /**
             * Return stored campaign corresponding to given code
             *
             * @param code
             */
            campaign(code: string): BMCampaign;
            /**
             * Return stored provider corresponding to given code provider or given codeVersion
             *
             * @param code
             * @param codeVersion
             */
            provider(code?: string, codeVersion?: string): BMProvider;
            static flushCampaignList(): void;
            /**
             * Clear all cached data
             */
            static flushAll(): void;
            /**
             * Fireevent on complete XHR request
             *
             * @param sequence
             * @param jqXHR
             * @param textStatus
             */
            private _onComplete;
            /**
             * Update campaigns from DB if not already done, otherwise, get campaignList
             *
             * @param forceUpdate Set true to force call to api and refresh campaignList
             * @returns Promise<campaignList>
             */
            getCampaigns(forceUpdate?: boolean): Promise<BMDataModel>;
            /**
             * Create new BMCampaign and add this newly created campaign to campaign list.
             * New campaign has empty dates: force user to indicate value.
             */
            createCampaign(provider: BulkMail.BMProvider): void;
            /**
             * Call given campaign update function @see BMCampaign.update()
             *
             * @param code Campaign code to be updated
             * @returns promise
             */
            updateCampaign(code: string, item?: ICampaignUpdateData, silent?: boolean): Promise<boolean>;
            /**
             * Call given campaign deletion function @see BMCampaign.delete() and remove campaign from cache
             *
             * @param code Campaign code to be removed
             * @returns promise
             */
            deleteCampaign(code: string): Promise<boolean>;
            /**
             * Copy zone from campaign to another (used in campaign creation)
             *
             * @param codeCampaignFrom
             * @param codeCampaignTo
             */
            copyZones(codeCampaignFrom: string, codeCampaignTo: string): void;
            getProvidersChannels(): Promise<Array<BMCampaignChannel>>;
            /**
             * Update providers from DB if not already done, otherwise, get providerList
             *
             * @param forceUpdate Set true to force call to api and refresh providerList
             * @returns Promise<providerList>
             */
            getProviders(forceUpdate?: boolean): Promise<BMDataModel>;
        }
        interface IDataItemContainerCustomProps extends Data.IDataItemContainer {
            readonly entity: BMEntity;
            props: any;
        }
        class BMDataModel extends Tools.EventSink implements Data.IDataSource {
            private _items;
            constructor();
            get length(): number;
            get items(): BMEntity[];
            entity(index: number): BMEntity;
            item(index: number): IDataItemContainerCustomProps;
            addItem(obj: BMEntity): void;
            removeItem(code: string): void;
            flushItemProps(index: number): void;
            flushProps(): void;
            forEach(callbackfn: (value: BMEntity, index: number, array: BMEntity[]) => any): void;
            filter(callbackfn: (value: BMEntity, index: number, array: BMEntity[]) => any): BMEntity[];
        }
    }
}
declare namespace AFC {
    namespace BulkMail {
        const enum BMVersionStatus {
            production = "production",
            upcoming = "upcoming",
            deprecated = "deprecated",
            template = "template"
        }
        interface IProviderCustomData {
            code: string;
            name: string;
            direction?: "ASC" | "DESC";
            enabled?: boolean;
        }
        interface IVersionData {
            code: string;
            dateAdded: string;
            dateProduction: string;
            name: string;
            provider: string;
            dashboardGeoLevel: string;
            status: BMVersionStatus;
            dataTables: {
                id: string;
                database: string;
                name: string;
            }[];
        }
        class BMProvider extends BMEntity {
            /**
             * Provider identifier in DB, auto generated at creation
             */
            protected _code: string;
            /**
             * Provider name
             */
            private _name;
            /**
             * Tableau d'objets dcrivant les segments
             */
            private _segmentList;
            /**
             * Tableau des donnes custom pouvant servir pour le tri des secteurs lors du calcul d'une zone
             * eg. [{code: "CA", name: "CA"}, {code: "CRIT_1", name: "Critre numro 1"},]
             */
            private _ordering;
            /**
             * Tableau des donnes custom pouvant tre agrges sur les zones (pour faire par exemple des graphiques, )
             * eg. [{code: "CA", name: "CA"}, {code: "DATA1", name: "Agrgat 1"}, {code: "DATA2", name: "Agrgat 2"}]
             */
            private _aggregates;
            /**
             * Tableau des versions des secteurs gographiques
             */
            private _featureVersions;
            channel: BMCampaignChannel;
            balance: {
                balance: number;
                scheduled: number;
            };
            description: string;
            senders: Array<string>;
            placeholders: Array<{
                id: string;
                name: string;
            }>;
            constructor(item?: {
                [key: string]: any;
            });
            get code(): string;
            get name(): string;
            get segments(): {
                [key: string]: any;
            }[];
            get ordering(): IProviderCustomData[];
            get aggregates(): IProviderCustomData[];
            get featureVersions(): IVersionData[];
            /**
             * Get an array of aggregates codes, used to compute total aggregates values (in campaign details screen > charts)
             *
             * @returns An array of aggregates code eg. [ "CA", "DATA1", "DATA2" ]
             */
            getAggregatesCodeList(): string[];
            /**
             * Get the aggregate name corresponding to given code aggergate
             *
             * @param code The aggregate code
             * @returns The corresponding aggregate name
             */
            getAggregateName(code: string): string;
            /**
             * Get the segment name corresponding to given code segment
             *
             * @param code The segment code
             * @returns The corresponding segment name
             */
            getSegmentName(code: string): any;
            /**
             * Return provider's paramaters (= Provider.ordering) as data model
             *
             * @returns The provider's ordering aggregates as a DataModel
             */
            getConfigParameters(): BMParametersDataModel;
            /**
             * Returns feature version current in production
             *
             * @returns The current feature version in production
             */
            getCurrentVersion(): {
                [key: string]: any;
            };
            /**
             * Returns upcoming feature version
             *
             * @returns The next feature version
             */
            getNextVersion(): IVersionData;
            /**
             * Returns feature version corresponding to given code version
             *
             * @returns
             */
            getVersion(codeVersion: string): IVersionData;
        }
        class BMParametersDataModel extends Data.DataSource {
            private _items;
            get length(): number;
            constructor(items: IProviderCustomData[]);
            item(index: number): Data.IDataItemContainer<IProviderCustomData>;
        }
    }
}
/**
 * Created by jean.rennes on 23/09/2015.
 */
declare namespace AFC.Dashboards {
    interface IViewModelEventData extends Tools.IEventData {
        sequence: Symbol;
        data: IDashboardEventData;
        dashboard: IDashboard;
    }
    abstract class ViewModel<V extends IView> extends Tools.EventSink implements IViewModel {
        protected _dashboardModel: DashboardModel;
        protected _view: V;
        protected _id: string;
        constructor();
        protected abstract _filter(view: IView): boolean;
        protected _onDirty(event?: Tools.IEvent<DashboardModel, IDashboardEventData>): void;
        setId(value?: string): boolean;
        set dashboardModel(value: DashboardModel);
        get dashboardModel(): DashboardModel;
        get id(): string;
        get name(): string;
        get label(): string;
        getView<V2 = V>(): Promise<V2>;
        getType(): Promise<ViewType>;
        get properties(): ReadonlyArray<IDashboardProperty>;
        get dashboard(): IDashboard;
        protected _onAttach(event: Tools.IEvent<this, IViewModelEventData>): void;
        release(): void;
        getLegendImage(width: number, height: number, horizontal?: boolean, quality?: number): Promise<string | void>;
    }
    export class MapModel extends ViewModel<IMapView> implements IMapModel {
        protected _foreignData: {
            readonly dataModel: Data.IRowCollection & Data.IKeyProvider;
            readonly thematics: Globals.ILayerLegendData;
        }[];
        protected _filter(view: IView): boolean;
        setId(value: string): boolean;
        setLayerForeignData(indice: number, foreignData?: {
            readonly dataModel: Data.IRowCollection & Data.IKeyProvider;
            readonly thematics: Globals.ILayerLegendData;
        }): void;
        getLayerCount(): Promise<number>;
        getMapTemplate(): Promise<string>;
        getDescriptors(): Promise<ReadonlyArray<IMapLayerDescriptor>>;
        getLayer(indice: number): Promise<Globals.IMapLayerStaticModel>;
        getBbox(): Promise<Tools.Geometry.Rectangle>;
    }
    class GridDataSource implements Data.IDataContainer {
        protected readonly _gridData: IGridData;
        constructor(gridData: IGridData);
        getData(key: string, stringify?: boolean): any;
    }
    export class GridModel<V extends IAggregatedSheet | IDetailedSheet | ISpreadSheet = IAggregatedSheet | IDetailedSheet | ISpreadSheet> extends ViewModel<V> implements IGridModel, Data.IDataContainerProvider {
        protected _foreignData: {
            readonly dataModel: Data.IDataModel;
            readonly thematic: Globals.IThematicData;
        };
        setId(value: string): boolean;
        protected _onForeignDirty(event: Data.IDataEvent): void;
        protected _releaseForeignData(): void;
        release(): void;
        protected _filter(view: IView): boolean;
        setForeignData(foreignData?: {
            readonly dataModel: Data.IDataModel;
            readonly thematic: Globals.IThematicData;
        }): boolean;
        getForeignDataModel(): Data.IDataModel;
        getGridApp(): Promise<Globals.IGridApp>;
        getDataContainer(): Promise<GridDataSource>;
    }
    export function checkChartData(view: IChart | ISpreadSheet): boolean;
    export class ChartModel<V extends IChart | ISpreadSheet | IReport = IChart | ISpreadSheet | IReport> extends ViewModel<V> implements IChartModel, IReportModel {
        protected _filter(view: IView): boolean;
        get drawable(): boolean;
        getImage(width: number, height: number, page?: number): Promise<string | void>;
        getChartData(): Promise<Globals.IChartModel | void>;
        getReportMetadata(): Promise<Globals.IReportMetadata | void>;
        getReportData(): Promise<IReportContentData | void>;
    }
    export class DashboardModel extends Tools.EventSink {
        protected _dashboard: IDashboard;
        constructor(dashboard?: IDashboard);
        private _onAttach;
        private _onDirty;
        get dashboard(): IDashboard;
        set dashboard(dashboard: IDashboard);
        get id(): string;
        get name(): string;
        get levels(): ReadonlyArray<IGeographicalLevel>;
        get properties(): ReadonlyArray<IDashboardProperty>;
        release(): void;
    }
    export {};
}
/**
 * Created by jean.rennes on 24/02/2021.
 */
declare namespace AFC.Dashboards {
    export type ZoneReaffectableType = ZoneType.radius | ZoneType.isodistance | ZoneType.isochrone | ZoneType.predefined | ZoneType.bulkMail;
    export type IDescriptorsForReaffect<T extends ZoneReaffectableType = ZoneReaffectableType> = ZoneDescriptorForZoneType[T];
    export interface IReaffectStorage extends Tools.IObservable<IReaffectStorage> {
        readonly id: symbol;
        readonly table: string;
        readonly mode: ZoneReaffectStorage;
        readonly commit: boolean;
        load(): Promise<void>;
        updateContext(zone: IZone, data: IDashboardContextDataBase): string | void;
        isRedistricted(site: number | string): boolean;
        reset(site: number | string): Promise<void>;
        affect(site: number | string, unit: string, subset: string): Promise<void>;
        applyChanges(site: number | string, unit: string, values: {
            [key: string]: any;
        }): Promise<void>;
        delete(site: number | string, unit: string): Promise<void>;
        getOwnership(site: number | string, unit: string): Promise<void>;
        release(): void;
    }
    export interface IReaffectStorages {
        load(): Promise<ReadonlyArray<IReaffectStorage>>;
        createStorage(descriptor: IDescriptorsForReaffect, districtingMode: ZoneReaffectStorage, zones?: ReadonlyArray<IZone>): IReaffectStorage;
        get(descriptor: IDescriptorsForReaffect): IReaffectStorage;
        invalidate(reaffectStorage: IReaffectStorage): void;
    }
    export const enum OperationType {
        reset = 1,
        update = 2,
        getOwnership = 3,
        delete = 4
    }
    interface IDistrictRequestEvent {
        value?: {
            [key: string]: any[];
        };
        reset?: boolean;
        branch?: string;
        site: number | string;
    }
    export interface IResetOperation {
        type: OperationType.reset;
        events: IDistrictRequestEvent[];
        getOperation(): {
            type: string;
            events: IDistrictRequestEvent[];
        };
    }
    export interface IUpdateOperation {
        readonly pure: boolean;
        type: OperationType.update;
        events: {
            site: any;
            branch?: string;
            units: {
                [key: string]: string | {
                    [key: string]: any;
                };
            };
        }[];
        getOperation(): {
            type: string;
            events: IDistrictRequestEvent[] | {
                site: any;
                branch?: string;
                units: {
                    unit: string;
                    values: {
                        [key: string]: any;
                    };
                }[];
            }[];
        };
    }
    export interface IOwnershipOperation {
        type: OperationType.getOwnership;
        events: {
            site: any;
            branch?: string;
            units: string[];
        }[];
        getOperation(): {
            type: string;
            events: {
                site: any;
                branch?: string;
                units: string[];
            }[];
        };
    }
    export interface IDeleteOperation {
        type: OperationType.delete;
        events: {
            site: any;
            branch?: string;
            units: string[];
        }[];
        getOperation(): {
            type: string;
            events: {
                site: any;
                branch?: string;
                units: string[];
            }[];
        };
    }
    export type IDistrictOperation = IUpdateOperation | IResetOperation | IOwnershipOperation | IDeleteOperation;
    export type IDistrictEvent = Tools.IEvent<IReaffectStorage, IDistrictOperation[]>;
    export function reaffectStorages(dashboard: IDashboard): IReaffectStorages;
    export {};
}
/**
 * Created by jean.rennes on 12/10/2015.
 */
declare namespace AFC.Dashboards {
    interface IZoneDistrict {
        readonly isRedistricted: boolean;
        getReaffectStorage(): Promise<IReaffectStorage>;
        affect(unit: string, subset: string): Promise<void>;
        applyChanges(unit: string, values: {
            [key: string]: any;
        }): Promise<void>;
        delete(unit: string): Promise<void>;
        getOwnership(unit: string): Promise<void>;
        reset(): Promise<void>;
    }
    interface ISites {
        readonly columns: ReadonlyArray<Data.IDBColumn>;
        current: string | number;
    }
    const enum DistrictType {
        base = 0,
        redistricting = 1,
        full = 2
    }
    interface IZone<T extends keyof ZoneDescriptorForZoneType = keyof ZoneDescriptorForZoneType> extends Tools.IObservable {
        readonly dashboard: IDashboard;
        readonly reference: ZoneDescriptorForZoneType[T];
        readonly cluster: IZoneCluster;
        readonly id: string;
        readonly name: string;
        readonly type: ZoneType;
        readonly perSiteConfiguration: string;
        readonly sites: ISites;
        readonly district: IZoneDistrict;
        createRequest<T2 = any>(path?: string, districtType?: DistrictType, options?: Rest.IRestRequestOptions): [number, Promise<Rest.IAjaxRequest<T2>>];
        updateContext(data: IDashboardContextDataBase, reaffectStorage: IReaffectStorage, sitesTable: ISitesTable): void;
        getReaffectStorage(): Promise<IReaffectStorage>;
        configure(configuration?: IZoneConfiguration): void;
        getDescriptor(): Promise<ZoneDescriptorForZoneType[T]>;
        getData(dataSourceKind: DataSourceKind, indicators?: ReadonlyArray<string>): Promise<Data.IDataModelBase>;
        clone(dashboard: IDashboard, cluster: IZoneCluster): IZone<T>;
        invalidate(siteChange?: boolean): void;
    }
    function zone<T extends keyof ZoneDescriptorForZoneType = any>(dashboard: IDashboard, reference: ZoneDescriptorForZoneType[T], cluster: IZoneCluster): IZone<T>;
}
/**
 * Created by jean.rennes on 16/04/2019.
 */
declare namespace AFC.Dashboards {
    export const enum ZoneType {
        unknown = 0,
        radius = 1,
        isodistance = 2,
        isochrone = 3,
        predefined = 4,
        administrative = 5,
        selection = 6,
        dynamicMarket = 7,
        surrounding = 8,
        bulkMail = 9,
        subset = 10,
        subsetUnion = 11,
        outOfZone = 12
    }
    interface IZonePartitionData {
        readonly id: string;
        readonly name: string;
        readonly subsets: ReadonlyArray<IZoneSubsetData>;
        readonly districtingTable: string;
        readonly districtingMode: string;
    }
    interface IRadiusAreaData extends IZoneData {
        sitesTable: ISitesTable;
        bounds: readonly number[];
        outOfZoneExtraBound: number;
        unit: string;
        useCentroid: boolean;
        forceSurroundingToZero: boolean;
        perSiteConfiguration: string;
        readonly partition: IZonePartitionData;
    }
    interface ITravelTimeAreaData extends IZoneData {
        sitesTable: ISitesTable;
        bounds: ReadonlyArray<number>;
        outOfZoneExtraBound: number;
        modeOfTransport: string;
        anchorThreshold: number;
        mode: string;
        tollFreeOnly: boolean;
        reverseMode: boolean;
        forceSurroundingToZero: boolean;
        perSiteConfiguration: string;
        readonly partition: IZonePartitionData;
    }
    interface IIsodistanceAreaData extends ITravelTimeAreaData {
        unit: string;
    }
    interface IIsochroneAreaData extends ITravelTimeAreaData {
        unit: string;
    }
    interface IPredefinedAreaData extends IZoneData {
        sitesTable: ISitesTable;
        areaTable: string;
        siteCodeColumn: string;
        geographicalCodeColumn: string;
        partitionColumn: string;
        partition: IZonePartitionData;
    }
    interface ISurroundingAreaData extends IZoneData {
        sitesTable: ISitesTable;
    }
    interface IBulkMailAreaData extends IZoneData {
        sitesTable: ISitesTable;
        readonly partition: IZonePartitionData;
        readonly scores: ReadonlyArray<IBulkMailAreaScore>;
        readonly target: IBulkMailAreaTarget;
    }
    interface ZoneDataForZoneType {
        [key: number]: IZoneData;
        [ZoneType.radius]: IRadiusAreaData;
        [ZoneType.isodistance]: IIsodistanceAreaData;
        [ZoneType.isochrone]: IIsochroneAreaData;
        [ZoneType.predefined]: IPredefinedAreaData;
        [ZoneType.administrative]: IZoneData;
        [ZoneType.surrounding]: ISurroundingAreaData;
        [ZoneType.bulkMail]: IBulkMailAreaData;
    }
    export interface ZoneDescriptorForZoneType {
        [key: number]: IZoneDescriptor;
        [ZoneType.radius]: IRadiusAreaDescriptor;
        [ZoneType.isodistance]: IIsodistanceAreaDescriptor;
        [ZoneType.isochrone]: IIsochroneAreaDescriptor;
        [ZoneType.predefined]: IPredefinedAreaDescriptor;
        [ZoneType.administrative]: IAdministrativeAreaDescriptor;
        [ZoneType.surrounding]: ISurroundingAreaDescriptor;
        [ZoneType.bulkMail]: IBulkMailAreaDescriptor;
    }
    export function zoneDescriptor<T extends keyof ZoneDataForZoneType = any>(dashboard: IDashboardDescriptor, data: ZoneDataForZoneType[T]): ZoneDescriptorForZoneType[T];
    export function buildContext(base: IZoneDescriptor, configuration: IZoneConfiguration): IContextZone;
    export class ZonePartitionDescriptor {
        readonly id: string;
        readonly name: string;
        readonly districtingTable: string;
        readonly subsets: readonly ISubsetDescriptor[];
        constructor(data: IZonePartitionData);
    }
    export {};
}
declare namespace AFC.Data {
    function DataConfigGroupMixin<T extends Tools.Constructor<{}>>(Base: T): (abstract new (...args: any[]) => {
        _list: Array<any>;
        readonly columns: readonly IDBColumn[];
        readonly values: readonly (readonly any[])[];
        readonly length: number;
        item(index: number): AFC.Data.IDataItemContainer;
    }) & T;
    const DataConfigGroup: Tools.Constructor<Tools.EventSink & IDataSource>;
    type DataConfigGroup = typeof DataConfigGroup;
}
/**
 * Created by jean.rennes on 17/02/2021.
 */
declare namespace AFC.Data {
    class DataModelView<T extends IFilteredDataModel = IFilteredDataModel> extends Tools.EventSink implements IFilteredDataModel {
        readonly columns: ReadonlyArray<IDBColumn>;
        readonly primaryKey: ReadonlyArray<string>;
        readonly columnIndex: {
            readonly [key: string]: number;
        };
        readonly dataModel: T;
        constructor(dataModel: T, mapping: {
            [key: string]: string;
        });
        protected _onDirty(event: IDataEvent): void;
        protected _mapValues(values: {
            [key: string]: any;
        }): {
            [key: string]: any;
        };
        getRow(index: number): ReadonlyArray<ReadonlyArray<any>>;
        get values(): ReadonlyArray<ReadonlyArray<any>>;
        get length(): number;
        item(index: number): IDataItemContainer;
        getKeyFromRow(row: any[]): ReadonlyArray<any>;
        compareKey(row: ReadonlyArray<any>, key: ReadonlyArray<any>): number;
        compareRow(row0: ReadonlyArray<any>, row1: ReadonlyArray<any>): number;
        create(key: any[], values: {
            [key: string]: any;
        }): boolean;
        modify(key: any[], values: {
            [key: string]: any;
        }): boolean;
        delete_(key: any[]): void;
        indexOf(row: ReadonlyArray<any>): number;
        find(key: ReadonlyArray<any>): number;
    }
}
/**
 * Created by jean.rennes on 10/12/2020.
 */
declare namespace AFC.Data {
    interface IDataContainerChecker<T extends IDataContainer = IDataContainer> {
        check(dataContainer: T, column: IDBColumnDefinition, dirty: boolean, value: string, callback: (valid: boolean, message?: Readonly<ICheckMessage>) => any): void;
    }
    class CheckMessage implements Readonly<ICheckMessage> {
        readonly column: IDBColumnDefinition;
        readonly message: string;
        readonly type: CheckMessageType;
        constructor(column: IDBColumnDefinition | null, value: any, messageType?: CheckMessageType);
    }
    class RecordOverrides<T extends IDataContainer = IDataContainer> {
        readonly columns: ReadonlyArray<IDBColumnDefinition>;
        values: ReadonlyArray<any>;
        protected _override: any[];
        protected _states: boolean[];
        protected _messages: Readonly<ICheckMessage>[];
        protected _sink: Tools.EventSink;
        protected _sinks: Tools.EventSink[];
        constructor(columns: ReadonlyArray<IDBColumnDefinition>, values: ReadonlyArray<any>);
        get(indice: number): any;
        set(indice: number, value: any): IDataRecordEventData;
        isDirty(indice: number): boolean;
        check(container: T, checker: IDataContainerChecker<T>, column: IDBColumnDefinition, indice: number): Promise<[/*column:*/ IDBColumnDefinition, /*dirty:*/ boolean, /*value:*/ any, /*valid:*/ boolean, /*message:*/ Readonly<ICheckMessage>, /*indice:*/ number]>;
        reset(values: ReadonlyArray<any>): void;
        invalidate(columns: ReadonlyArray<number>): void;
    }
    class DataRecord extends Tools.EventSink implements IDataContainer {
        protected _override: RecordOverrides;
        protected _valid: boolean;
        protected _committable: boolean;
        protected _messages: ReadonlyArray<ICheckMessage>;
        protected _events: {
            [key: string]: any;
        };
        readonly dataModel: IDataModel;
        readonly setData: (name: string, value: any) => boolean;
        static checkColumn<T extends DataRecord = DataRecord>(dataRecord: T, checker: IDataContainerChecker<T>, column: string, callback: (column: IDBColumnDefinition, dirty: boolean, value: any, valid: boolean, message: Readonly<ICheckMessage>, indice: number) => any): void;
        static check<T extends DataRecord = DataRecord>(dataRecord: T, checker: IDataContainerChecker<T>, callback: (valid: boolean, committable: boolean, messages: ReadonlyArray<ICheckMessage>, events: {
            [key: string]: any;
        }) => any): void;
        static commit<T extends DataRecord = DataRecord>(dataModel: IDataModel, dataContainer: T, checker: IDataContainerChecker<T>, callback: (valid: boolean, committed: boolean, messages?: ReadonlyArray<ICheckMessage>, events?: {
            [key: string]: any;
        }) => void): void;
        constructor(dataModel: IDataModel, row: ReadonlyArray<any>);
        getColumn(name: string): IDBColumn;
        getData(name: string, stringify?: boolean): any;
    }
}
/**
 * Created by jean.rennes on 04/04/2016.
 */
declare namespace AFC.Data {
    interface IQueryCommand {
        commandText: string;
        maximumRows?: number;
        parameters?: {
            [key: string]: number | boolean | string | GeoJSON.GeometryObject;
        };
    }
    class Queries extends Rest.RequestBuilder<Rest.IRequestBody<Rest.IDataUpdateContext>> {
        readonly restModel: Rest.RestModel;
        constructor(restModel: Rest.RestModel, base?: Rest.IContextModifier);
        createAjaxRequest(commands: IQueryCommand[], format?: Rest.RestFormat): Promise<Rest.IAjaxRequest>;
        /** @deprecated : use getDataTable instead */
        requestData(commands: IQueryCommand[], callback: (queries: IDataTable[]) => any, context?: any, format?: Rest.RestFormat): void;
        getDataTable(commands: IQueryCommand[], format?: Rest.RestFormat): Promise<IDataTable[]>;
    }
}
/**
 * Created by jean.rennes on 04/04/2016.
 */
declare namespace AFC.Data {
    interface IUpdateCommand {
        table: string;
        events: IModificationEvents;
        session?: string;
    }
    interface IUpdateCommandResult {
        result: number;
        events: IModificationEvents;
        invalidate: AFC.Rest.IDataUpdate[];
        status: {
            errors: {
                code: number;
                text: string;
            }[];
            warnings: {
                code: number;
                text: string;
            }[];
            messages: {
                code: number;
                text: string;
            }[];
        };
    }
    class Updates extends Rest.DataCreator {
        protected _restModel: Rest.RestModel;
        constructor(restModel: Rest.RestModel);
        run(commands: IUpdateCommand[], callback: (queries: IUpdateCommandResult[]) => any, force?: boolean): number;
    }
}
/**
 * Created by jean.rennes on 19/07/2017.
 */
declare namespace AFC.Globals {
    export const enum ChartType {
        none = 0,
        pie = 1,
        pie3d = 2,
        points = 3,
        bar = 4,
        stackedBar = 5,
        doughnut = 6,
        doughnut3d = 7,
        boxPlot = 8,
        bubble = 9,
        container = 10,
        radar = 11,
        barHorizontal = 12,
        stackedBarHorizontal = 13
    }
    export function chartType(value: string): ChartType;
    export type ColorStyleType = 'transparent' | 'solid' | 'twoColorsGradient';
    export type GradientStyle = 'horizontal' | 'vertical' | 'upperDiag' | 'lowerDiag' | 'upperCorner' | 'lowerCorner' | 'center';
    export type GradientSubStyle = 'center' | 'edges' | 'end' | 'start';
    export type Alignment = "left" | "center" | "right";
    export type VAlignment = 'top' | 'middle' | 'bottom';
    export interface IChartStyle {
    }
    export interface IColorStyle {
        type: ColorStyleType;
        color: number;
    }
    export interface ISolidColorStyle extends IColorStyle {
    }
    export interface ITwoColorsGradientStyle extends IColorStyle {
        style: GradientStyle;
        subStyle: GradientSubStyle;
        color2: number;
    }
    export interface IChartStyleFont extends IChartStyle, IStyleFont {
    }
    export interface IChartStyleLabelItem extends IChartStyle {
        font: IChartStyleFont;
        color: number;
        backgroundColor: number;
        borderColor: number;
        visible: boolean;
        align: Alignment;
    }
    export interface IChartStyleLabelPercentItem extends IChartStyleLabelItem {
        showPercent: boolean;
    }
    export interface IChartStyleLabel extends IChartStyleLabelPercentItem {
        noOverlap: boolean;
        showLines: boolean;
        verticalAlign: boolean;
        showPartColor: boolean;
    }
    export interface IChartStylePartSerie extends IChartStyle {
        name: string;
        fillColor: number;
        borderColor: number;
        label: IChartStyleLabelPercentItem;
    }
    export interface IChartStyleTitle extends IChartStyle {
        font: IChartStyleFont;
        color: number;
        backgroundColor: number;
        borderColor: number;
        visible: boolean;
    }
    export interface IChartTitle extends IChartStyleTitle {
        text: string;
        placement: VAlignment;
        align: Alignment;
    }
    export interface IChartStyleAggregation extends IChartStyle {
        name: string;
        aggregationPercentage: number;
        active: boolean;
    }
    export interface IChartStylePie extends IChartStyle {
        radial: number;
        angle: number;
        explode: number;
        showExplode: boolean;
        aggregation: IChartStyleAggregation;
    }
    export interface IChartStyleDoughnut extends IChartStylePie {
        hole: number;
    }
    export interface IChartProperties {
        type: ChartType;
        title: IChartTitle;
        font: IChartStyleFont;
        color: number;
        backgroundColor: number;
        borderColor: number;
    }
    export interface IChartPieProperties extends IChartProperties {
        label: IChartStyleLabel;
        pie: IChartStylePie;
        parts: IChartStylePartSerie[];
        subtitle: IChartStyleTitle;
    }
    export interface IChartDoughnutProperties extends IChartProperties {
        label: IChartStyleLabel;
        pie: IChartStyleDoughnut;
        parts: IChartStylePartSerie[];
        subtitle: IChartStyleTitle;
    }
    export interface IChartBarProperties extends IChartProperties {
        series: IChartStyleBarSerie[];
        xAxis: IChartStyleAxis;
        yAxis: IChartStyleAxisCont[];
        tracingZone: IChartStyleTracingZone;
        label: IChartStyleLabelItem;
        spaceX: number;
    }
    export interface IChartStyleBarSerieNegativeBarItem extends IChartStyle {
        borderColor: number;
        color: IColorStyle;
    }
    export interface IChartStyleBarSerieBarItem extends IChartStyle {
        visible: boolean;
        borderColor: number;
        color: IColorStyle;
        negative?: IChartStyleBarSerieNegativeBarItem;
    }
    export interface IChartStyleBarSerieNegativeSymbolItem extends IChartStyle {
        color: number;
        font: IChartStyleFont;
        charCode: string;
    }
    export interface IChartStyleBarSerieSymbolItem extends IChartStyle {
        visible: boolean;
        color: number;
        font: IChartStyleFont;
        charCode: string;
        negative?: IChartStyleBarSerieNegativeSymbolItem;
    }
    export interface IChartStyleBarSerieLineItem extends IChartStyle {
        visible: boolean;
        color: number;
        width: number;
    }
    export interface IChartStyleBarSerie extends IChartStyle {
        axis: number;
        name: string;
        bar: IChartStyleBarSerieBarItem;
        label: IChartStyleLabelItem;
        line: IChartStyleBarSerieLineItem;
        symbol: IChartStyleBarSerieSymbolItem;
    }
    export interface IChartStyleAxis extends IChartStyle {
        color: number;
        name: string;
        showTickers: boolean;
        showLine: boolean;
        showValues: boolean;
        showTitle: boolean;
        font: IChartStyleFont;
        textAngle: number;
        textColor: number;
    }
    export interface IChartStyleAxisCont extends IChartStyleAxis {
        axisIntersectPoint: {
            automatic: boolean;
            value: number;
        };
        min: {
            automatic: boolean;
            value: number;
        };
        max: {
            automatic: boolean;
            value: number;
        };
    }
    export interface IGraphRadarFillingSerieProperties extends IChartStyle {
        visible: boolean;
        color: IColorStyle;
        transparency: number;
    }
    export interface IGraphRadarLineSerieProperties extends IChartStyle {
        visible: boolean;
        color: number;
        width: number;
    }
    export interface IGraphRadarSymbolSerieProperties extends IChartStyle {
        visible: boolean;
        color: number;
        font: IChartStyleFont;
        charCode: string;
    }
    export interface IGraphRadarSerie extends IChartStyle {
        name: string;
        filling: IGraphRadarFillingSerieProperties;
        line: IGraphRadarLineSerieProperties;
        symbol: IGraphRadarSymbolSerieProperties;
    }
    export interface IGraphRadarAxes extends IChartStyle {
        min: {
            automatic: boolean;
            value: number;
        };
        max: {
            automatic: boolean;
            value: number;
        };
        color: number;
        showLine: boolean;
        showValues: boolean;
        font: IChartStyleFont;
        textColor: number;
        labels: string[];
    }
    export interface IChartRadarProperties extends IChartProperties {
        tracingZone: IChartStyleTracingZone;
        series: IGraphRadarSerie[];
        axes: IGraphRadarAxes;
    }
    export interface IChartStyleTracingZone extends IChartStyle {
        color: IColorStyle;
    }
    export interface IChartDatum {
        value: any;
    }
    export interface IChartModelSubtitles {
        columnHeaders?: ReadonlyArray<string>;
        rowHeaders?: ReadonlyArray<string>;
    }
    interface ChartPropertiesChartType {
        [ChartType.pie]: IChartPieProperties;
        [ChartType.bar]: IChartBarProperties;
        [ChartType.doughnut]: IChartDoughnutProperties;
        [ChartType.radar]: IChartRadarProperties;
        [ChartType.barHorizontal]: IChartBarProperties;
    }
    export interface IChartMetadata<T extends ChartType = ChartType> {
        chartDataTransposed: boolean;
        subtitles: Readonly<Globals.IChartModelSubtitles>;
        chartProperties: T extends keyof ChartPropertiesChartType ? ChartPropertiesChartType[T] : IChartProperties;
    }
    export interface IChartModel<T extends ChartType = ChartType> extends IChartMetadata<T> {
        data: IChartDatum[][];
    }
    export {};
}
/**
 * Created by jean.rennes on 20/01/2021.
 */
declare namespace AFC.PhotoManager {
    interface ITagValue {
        id: string;
        alias?: string;
        ordinal?: number;
    }
    interface IPictureTagValue {
        name: string;
        alias?: string;
        ordinal?: number;
        value: ITagValue;
    }
    interface ITagValueRequest {
        name: string;
        value: any;
    }
    interface IPictureFormat {
        id: string;
        width: number;
        height: number;
    }
    interface IAlbum {
        id: string;
        name: string;
        description: string;
    }
    interface IPicture {
        id: string;
        name: string;
        title: string;
        album: string;
        creationDate: Date;
        width: number;
        height: number;
        location?: GeoJSON.Point;
        formats?: IPictureFormat[];
        tags: IPictureTagValue[];
    }
    export interface IPicturesSource {
        deletePicture(picture: Picture): Promise<boolean>;
        setPictureTagsValues(picture: Picture, tags: ITagValueRequest[]): Promise<Picture>;
        addPicture(file: File, tags: ITagValueRequest[], pictureToReplace?: Picture): Promise<Picture>;
        getPictures(tags: ITagValueRequest[]): Promise<Picture[]>;
        getFirstPicture(tags: ITagValueRequest[]): Promise<Picture>;
        getPicture(pictureId: string): Promise<Picture>;
    }
    const _sequence: unique symbol;
    export class Picture extends Tools.EventSink {
        readonly restModel: Rest.RestModel;
        protected _imagesServer: AFC.ServerInfo.ImagesServerInfoProvider;
        protected _picture: IPicture;
        protected _data: {
            [name: string]: string;
        };
        protected [_sequence]: number;
        constructor(restModel: Rest.RestModel, imagesServer: AFC.ServerInfo.ImagesServerInfoProvider, picture: IPicture);
        get tags(): ITagValueRequest[];
        set tags(tags: ITagValueRequest[]);
        get id(): string;
        get name(): string;
        get title(): string;
        get creationDate(): Date;
        get album(): string;
        getTagValue(name: string): string;
        getData(pictureFormat?: string): Promise<string>;
    }
    export class Album extends Tools.EventSink implements IAlbum {
        readonly restModel: Rest.RestModel;
        protected _imagesServer: AFC.ServerInfo.ImagesServerInfoProvider;
        protected _album: IAlbum;
        constructor(restModel: Rest.RestModel, imagesServer: AFC.ServerInfo.ImagesServerInfoProvider, album: IAlbum);
        get id(): string;
        get name(): string;
        get description(): string;
        deletePicture(picture: Picture): Promise<boolean>;
        setPictureTagsValues(picture: Picture, tags: ITagValueRequest[]): Promise<Picture>;
        uploadPicture(file: File, tags: ITagValueRequest[], pictureToReplace?: Picture): Promise<Picture>;
        queryPictures(tags: ITagValueRequest[]): Promise<Picture[]>;
    }
    export class PhotoManager extends Tools.EventSink {
        readonly restModel: Rest.RestModel;
        protected _imagesServer: AFC.ServerInfo.ImagesServerInfoProvider;
        protected _albums: Album[];
        protected [_sequence]: number;
        constructor(restModel: Rest.RestModel);
        get albums(): Promise<ReadonlyArray<Album>>;
        getAlbum(albumName: string): Promise<Album>;
        queryPictures(albumName: string, tags: ITagValueRequest[]): Promise<Picture[]>;
    }
    export class StorePictures extends Tools.EventSink implements IPicturesSource {
        readonly restModel: Rest.RestModel;
        protected _sequence: number;
        protected _photoManager: PhotoManager;
        protected _pictures: Picture[];
        protected _album: string;
        protected _storeCodeTagValue: string;
        protected _imagesServer: AFC.ServerInfo.ImagesServerInfoProvider;
        constructor(restModel: Rest.RestModel);
        set album(albumName: string);
        get album(): string;
        get albumObject(): Promise<Album>;
        set store(store: AFC.Data.IStore);
        set storeCode(storeCode: any);
        getPictures(tags: ITagValueRequest[]): Promise<Picture[]>;
        getPicture(pictureId: string): Promise<Picture>;
        getFirstPicture(tags: ITagValueRequest[]): Promise<Picture>;
        addPicture(file: File, tags: ITagValueRequest[], pictureToDelete?: Picture): Promise<Picture>;
        deletePicture(picture: Picture): Promise<boolean>;
        setPictureTagsValues(picture: Picture, tags: ITagValueRequest[]): Promise<Picture>;
        _filterPictures(tags: ITagValueRequest[]): Picture[];
        reset(): void;
    }
    export {};
}
/**
 * Created by jean.rennes on 26/03/2018.
 */
declare namespace AFC.Globals {
    const enum ReportObjectType {
        text = 1,
        dashboardView = 2,
        grid = 3,
        bitmap = 4,
        line = 5,
        shape = 6
    }
    function reportObjectType(value: string): ReportObjectType;
    interface IReportObject {
        readonly name: string;
        readonly type: ReportObjectType;
        readonly shadow: {
            readonly color: number;
            readonly XMove: number;
            readonly YMove: number;
            readonly XPosition: number;
            readonly YPosition: number;
            readonly visible: boolean;
        };
        readonly borderColor: number;
        readonly borderWidth: number;
        readonly backgroundColor: number;
        readonly top: number;
        readonly left: number;
        readonly width: number;
        readonly height: number;
        readonly properties: {
            readonly [key: string]: number;
        };
    }
    interface IStyleFont {
        fontFamily: string;
        fontSize: number;
        fontWeight: string;
        fontStyle: string;
        textDecoration: string;
    }
    interface ITextReportObject extends IReportObject {
        readonly type: ReportObjectType.text;
        readonly color: number;
        readonly font: IStyleFont;
        readonly text: string;
        readonly verticalAlign: Globals.VAlignment;
        readonly textAlign: Globals.Alignment;
        readonly multiline: boolean;
    }
    interface IGridReportObject extends IReportObject {
        readonly type: ReportObjectType.grid;
        readonly content: Dashboards.IGridData;
    }
    interface IBitmapReportObject extends IReportObject {
        readonly id: string;
        readonly representationMode?: "none" | "cover" | "contain";
        readonly type: ReportObjectType.bitmap;
    }
    const enum LineStyle {
        normal = 0,
        dots = 1
    }
    interface ILineReportObject extends IReportObject {
        readonly type: ReportObjectType.line;
        readonly color: number;
        readonly weight: number;
        readonly style: LineStyle;
        readonly startPoint: IPointReportObject;
        readonly endPoint: IPointReportObject;
    }
    const enum PointStyle {
        none = 0,
        arrow = 1,
        openArrow = 2,
        bullet = 3,
        diamond = 4
    }
    interface IPointReportObject {
        readonly weight: number;
        readonly style: PointStyle;
    }
    const enum Shape {
        none = 0,
        ellipse = 1,
        star = 2,
        roundedRectangle = 3,
        ring = 4,
        regularPolygone = 5,
        diamond = 6,
        noParking = 7,
        cross = 8,
        label = 9,
        parenthesis = 10,
        rectTriangle = 11,
        trapezium = 12,
        parallelogram = 13,
        ribbon = 14,
        balloon = 15,
        simpleArrow = 16,
        rectangleArrow = 17,
        curvedArrow = 18,
        polyArrow = 19,
        pipeArrow = 20,
        specialSimpleArrow = 21
    }
    interface IShapeReportObject extends IReportObject {
        readonly type: ReportObjectType.shape;
        readonly shape: Shape;
        readonly fillColor: number;
        readonly color: number;
        readonly weight: number;
    }
    interface IReportMetadata {
        readonly pages: {
            readonly width: number;
            readonly height: number;
            readonly backgroundColor: number;
            readonly objects: IReportObject[];
            readonly notes: string;
        }[];
        readonly images: {
            [key: string]: string;
        };
        readonly width: number;
        readonly height: number;
        readonly headerHeight: number;
        readonly footerHeight: number;
        readonly firstPage: number;
        readonly headerLocked: boolean;
        readonly footerLocked: boolean;
        readonly format: number;
    }
    interface IReportData extends Dashboards.IReportContentData {
        readonly views: {
            readonly [key: number]: Promise<Readonly<Controls.IReportViewBlock>>;
        };
    }
    interface IReportModel {
        readonly metadata: IReportMetadata;
        readonly data: IReportData;
    }
}
/**
 * Created by jean.rennes on 17/03/2016.
 */
declare namespace AFC.Globals {
    export interface IBBSScriptResult {
        result: number;
        outValue?: any;
    }
    interface IBBSScriptContextData extends Dashboards.IMultiDashboardContextData {
        uri: string;
        plugin?: string;
        function?: string;
        parameters?: ReadonlyArray<any> | {
            [key: string]: any;
        };
    }
    export class BBSScript extends Tools.EventSink {
        private _tid;
        private _uid;
        private _result;
        private _sequenceRun;
        private _dashboards;
        private _builder;
        readonly uri: string;
        readonly callFunction: string;
        readonly parameters: ReadonlyArray<any> | {
            [key: string]: any;
        };
        readonly plugin: string;
        readonly restModel: Rest.RestModel;
        constructor(retModel: Rest.RestModel, uri: string, callfunction: string, parameters: ReadonlyArray<any> | {
            [key: string]: any;
        }, plugin?: string);
        createDataParameter(creation: Data.IDataCreation): any;
        createDashboardParameter(dashboard: Dashboards.IDashboard, reports?: Array<string>): any;
        getRequest(options?: Rest.IRestRequestOptions): Promise<Rest.IAjaxRequest<IBBSScriptContextData>>;
        run(): Promise<IBBSScriptResult>;
        getRunningState(): Promise<AFC.Globals.ProgressStatus>;
    }
    export {};
}
/**
 * Created by jean.rennes on 20/01/2021.
 */
declare namespace AFC.ServerInfo {
    interface IServerInfo {
        url: string;
    }
    export interface IServerInfoProvider {
        getServerInfo(): Promise<IServerInfo>;
    }
    const _sequence: unique symbol;
    export class ImagesServerInfoProvider extends Tools.EventSink implements IServerInfoProvider {
        readonly restModel: Rest.RestModel;
        protected _serverInfo: IServerInfo;
        protected [_sequence]: number;
        constructor(restModel: Rest.RestModel);
        getServerInfo(): Promise<IServerInfo>;
    }
    export {};
}
/**
 * Created by jean.rennes on 20/01/2021.
 */
declare namespace AFC.Globals {
    export const enum UploadType {
        dataDump = 0
    }
    export interface IUploadCommand {
        type: string;
        mimeType: string;
        name: string;
        size: number;
        lastModified: Date;
        content: string;
    }
    interface IUploadResultItem {
        text: string;
        detail?: any;
    }
    export interface IUploadResult {
        result: number;
        outValue: {
            resourceId: string;
            errors: IUploadResultItem[];
            messages: IUploadResultItem[];
            warnings: IUploadResultItem[];
        };
    }
    interface IDataDumpCommandOptions {
        database: string;
        target: string;
        mode?: string;
        description?: string;
    }
    interface ICommandType2Options {
        [UploadType.dataDump]: IDataDumpCommandOptions;
    }
    export class Uploader {
        readonly restModel: Rest.RestModel;
        constructor(restModel: Rest.RestModel);
        upload<T extends UploadType = UploadType>(type: T, file: File, options: Readonly<ICommandType2Options[T]>): Promise<any>;
    }
    export {};
}
/**
 * Created by jean.rennes on 27/07/2017.
 */
declare namespace AFC {
    namespace TradeArea {
        const enum LengthUnit {
            meter = 1,
            kilometer = 2,
            yard = 3,
            mile = 4
        }
        function lengthUnit(value: LengthUnit): string;
        function lengthUnit(value: string): LengthUnit;
        const enum TimeUnit {
            minute = 1,
            decimal = 2,
            second = 3
        }
        function timeUnit(value: TimeUnit): string;
        function timeUnit(value: string): TimeUnit;
        const enum TravelMode {
            boundary = 1,
            residentialArea = 2,
            centroid = 3
        }
        function travelMode(value: TravelMode): string;
        function travelMode(value: string): TravelMode;
        const enum ModeOfTransport {
            carTravel = 1,
            pedestrian = 2,
            hybrid = 3
        }
        function modeOfTransport(value: ModeOfTransport): string;
        function modeOfTransport(value: string): ModeOfTransport;
        type NetworkDescriptor = {
            modeOfTransport: ModeOfTransport;
            name: string;
            countryCode: string;
            version: string;
            copyright: string;
            adminUnitsYear: string;
            adminUnits: {
                id: number;
                name: string;
            }[];
            description: string;
        };
        class Networks extends Tools.EventSink {
            protected _restModel: Rest.RestModel;
            constructor(restModel: Rest.RestModel);
            getNetworks(): Promise<ReadonlyArray<NetworkDescriptor>>;
        }
    }
}
/**
 * Created by jean.rennes on 21/02/2020.
 */
declare namespace AFC.Controls {
    interface IOnDismissListener {
        onDismiss(dialog: Dialog): void;
    }
    class Dialog {
        constructor(activity: Application.Activity);
        protected _onCreate(savedInstanceState?: Application.Bundle): void;
        protected _onStart(): void;
        protected _onStop(): void;
        getOwnerActivity(): Application.Activity;
        getWindow(): Window;
        show(): void;
        hide(): void;
        create(): void;
        dismiss(): void;
        onSaveInstanceState(): Application.Bundle;
        onRestoreInstanceState(savedInstanceState: Application.Bundle): void;
        setContentView(view: gui.IView): void;
        setTitle(title: string): void;
        setOwnerActivity(activity: Application.Activity): void;
        setOnDismissListener(listener: IOnDismissListener): void;
        setCanceledOnTouchOutside(cancel: boolean): void;
    }
}
/**
 * Created by jean.rennes on 21/02/2020.
 */
declare namespace AFC.Controls {
    class AlertDialog extends Dialog {
        static BUTTON_POSITIVE: number;
        static BUTTON_NEUTRAL: number;
        static BUTTON_NEGATIVE: number;
        protected _setupTitle(panel: Element): void;
        protected _setupContent(panel: gui.AfcGuiDiv): void;
        protected _setupButtons(panel: Element): void;
        protected _onCreate(savedInstanceState?: Application.Bundle): void;
        setTitle(title: string): void;
        setView(view: string | gui.IView): void;
        setMessage(message: string): void;
        setButton(whichButton: number, text: string, listener: (dialog: AlertDialog, which: number) => any): void;
    }
}
/**
 * Created by jean.rennes on 21/10/2015.
 */
declare namespace AFC.Controls {
    class Autocomplete {
        private _container;
        private _autocomplete;
        constructor(element: any);
        private static _createSource;
        setProvider(provider: (value: string, callback: (data?: any[]) => void) => void): void;
        refresh(): void;
        on(str: string, callback: JQueryUI.AutocompleteEvent): void;
        destroy(): void;
    }
}
/**
 * Created by jean.rennes on 13/07/2017.
 */
declare namespace AFC.Controls {
    type D3Selection = d3.Selection<d3.BaseType, {}, null, undefined>;
    export class Charts extends Image {
        protected _chart: Globals.IChartModel;
        protected _size(svg: D3Selection): void;
        clear(): void;
        setData(chart: Globals.IChartModel): void;
        invalidateSize(): void;
    }
    export {};
}
/**
 * Created by jean.rennes on 20/05/2020.
 */
declare namespace AFC.Controls {
    class Draggable {
        moveThreshold: number;
        moveThrottle: number;
        swipeThreshold: number;
        swipeTimeThreshold: number;
        clickTimeThreshold: number;
        static moveThreshold: number;
        static moveThrottle: number;
        static swipeThreshold: number;
        static swipeTimeThreshold: number;
        static clickTimeThreshold: number;
        static destroy(draggable: Draggable): void;
        constructor(element: HTMLElement);
    }
}
declare namespace AFC.Controls {
    export interface IGeoJSON<K extends Globals.LayerType, P extends Globals.IGeoJsonProperties> extends L.LayerGroup<P> {
        addData(data: GeoJSON.GeoJsonObject | ReadonlyArray<GeoJSON.GeoJsonObject>): this;
        getLayers(): Globals.LayerForLayerType<K, P>[];
        removeLayer(layer: number | Globals.LayerForLayerType<K, P>): this;
        clearLayers(): this;
        highlight(keys?: ReadonlyArray<any>[]): void;
        findItem(key: ReadonlyArray<any>): Globals.LayerForLayerType<K, P>;
        options: L.GeoJSONOptions<P, Globals.GeometryForLayerType[K]>;
    }
    export interface GeoJSONOptions<P extends Globals.IGeoJsonProperties = Globals.IGeoJsonProperties> extends L.GeoJSONOptions<P> {
        minZoom?: number;
        maxZoom?: number;
    }
    export interface GeoJSON<K extends Globals.LayerType, P extends Globals.IGeoJsonProperties> extends IGeoJSON<K, P>, L.GeoJSON<P, Globals.GeometryForLayerType[K]> {
        readonly getGeometryFromResult: never;
        addData(data: GeoJSON.GeoJsonObject | ReadonlyArray<GeoJSON.GeoJsonObject>): this;
        addLayer(layer: Globals.LayerForLayerType<K, P>): this;
        getLayer(id: number): Globals.LayerForLayerType<K, P>;
        getLayers(): Globals.LayerForLayerType<K, P>[];
        removeLayer(layer: number | Globals.LayerForLayerType<K, P>): this;
    }
    class GeoJSONImpl<K extends Globals.LayerType, P extends Globals.IGeoJsonProperties> extends L.GeoJSON<P> implements GeoJSON<K, P> {
        protected _resetView(): void;
        protected _layers: {
            [key: string]: L.Layer;
        };
        protected _onEachFeature(feature: GeoJSON.Feature<Globals.GeometryForLayerType[K], P>, layer: L.Layer): void;
        readonly getGeometryFromResult: never;
        options: GeoJSONOptions<P>;
        isVisible(): boolean;
        addData(data: GeoJSON.GeoJsonObject | ReadonlyArray<GeoJSON.GeoJsonObject>): this;
        addLayer(layer: Globals.LayerForLayerType<K, P>): this;
        getLayer(id: number): Globals.LayerForLayerType<K, P>;
        getLayers(): Globals.LayerForLayerType<K, P>[];
        getEvents(): {
            [name: string]: L.LeafletEventHandlerFn;
        };
        removeLayer(layer: number | Globals.LayerForLayerType<K, P>): this;
        clearLayers(): this;
        setStyle(style: L.PathOptions | L.StyleFunction<P>): this;
        highlight(keys?: ReadonlyArray<any>[]): void;
        findItem(key: ReadonlyArray<any>): Globals.LayerForLayerType<K, P>;
    }
    export const GeoJSON: {
        new <K extends Globals.LayerType = Globals.LayerType, P extends Globals.IGeoJsonProperties = Globals.IGeoJsonProperties>(keyProvider: Data.IKeyProvider & Data.IColumnIndexProvider, geojson?: GeoJSON.GeoJsonObject, options?: L.GeoJSONOptions<P>): GeoJSONImpl<K, P>;
    };
    export interface MarkerClusterGroup<P extends Globals.IGeoJsonProperties = Globals.IGeoJsonProperties> extends L.FeatureGroup<P>, IGeoJSON<Globals.LayerType.symbol, P> {
        readonly getGeometryFromResult: never;
        readonly geoJSONOptions: L.GeoJSONOptions<P>;
        addData(data: GeoJSON.GeoJsonObject | ReadonlyArray<GeoJSON.GeoJsonObject>): this;
        addLayer(layer: Globals.Point<P>): this;
        addLayers(layers: Globals.Point<P>[], skipLayerAddEvent?: boolean): this;
        getLayer(id: number): Globals.Point<P>;
        getLayers(): Globals.Point<P>[];
        removeLayer(layer: number | Globals.Point<P>): this;
        zoomToShowLayer(layer: Globals.Point<P>, callback?: () => void): void;
        getVisibleParent(marker: L.Marker | L.CircleMarker): L.Marker;
        setStyle(style: L.PathOptions | L.StyleFunction<P>): this;
        options: L.GeoJSONOptions<P, GeoJSON.Point>;
    }
    export interface MarkerClusterGroupOptions extends L.MarkerClusterGroupOptions {
        minZoom?: number;
        maxZoom?: number;
    }
    class MarkerClusterGroupImpl<P extends Globals.IGeoJsonProperties> extends L.MarkerClusterGroup implements MarkerClusterGroup<P> {
        readonly getGeometryFromResult: never;
        readonly geoJSONOptions: L.GeoJSONOptions<P>;
        protected _resetView(): void;
        protected _featureGroup: L.FeatureGroup & {
            _map: L.Map;
        };
        protected _nonPointGroup: L.FeatureGroup & {
            _map: L.Map;
        };
        isVisible(): boolean;
        initialize(clusterOptions?: MarkerClusterGroupOptions, options?: L.GeoJSONOptions<P>): void;
        addData(data: GeoJSON.GeoJsonObject | ReadonlyArray<GeoJSON.GeoJsonObject>): this;
        getLayer(id: number): Globals.Point<P>;
        getLayers(): Globals.Point<P>[];
        setStyle(style: L.PathOptions | L.StyleFunction<P>): this;
        findItem(key: ReadonlyArray<any>): Globals.Point<P>;
        highlight(keys?: ReadonlyArray<any>[]): void;
    }
    export const MarkerClusterGroup: {
        new <P extends Globals.IGeoJsonProperties = Globals.IGeoJsonProperties>(keyProvider: Data.IKeyProvider & Data.IColumnIndexProvider, clusterOptions?: MarkerClusterGroupOptions, options?: L.GeoJSONOptions<P>): MarkerClusterGroupImpl<P>;
    };
    export function markerClusterGroup<P extends Globals.IGeoJsonProperties = Globals.IGeoJsonProperties>(keyProvider: Data.IKeyProvider & Data.IColumnIndexProvider, options: L.GeoJSONOptions<P>, clusterOptions?: MarkerClusterGroupOptions): MarkerClusterGroupImpl<P>;
    export {};
}
/**
 * Created by jean.rennes on 20/02/2017.
 */
declare namespace AFC.Controls {
    interface IFilterableLegendInfo extends Globals.ILegendInfo {
        readonly id: string;
        readonly filterable: Data.IFilterable;
        readonly property: Required<Globals.ILayerProperty>;
        states: number;
    }
    class Legends extends Control {
        update(data: ReadonlyArray<IFilterableLegendInfo | Globals.ILegendInfo>, enableFiltering?: boolean): void;
    }
}
declare namespace AFC.Controls {
    class ProgressBar extends Control {
        private _runningTasks;
        private _allTasksBar;
        private _progressBarDiv;
        private _textNode;
        private _fullDetailsMode;
        constructor(element: string | HTMLElement);
        isFullDetailsMode(): boolean;
        setFullDetailsMode(full: boolean): void;
        refresh(tasks: ReadonlyArray<Globals.IProgressInfoBarTask>): void;
        private _refresh;
        private _initHTMLControls;
    }
}
/**
 * Created by jean.rennes on 26/03/2018.
 */
declare namespace AFC.Controls {
    const enum ReportViewBlockType {
        none = 0,
        image = 1,
        charts = 2,
        gridView = 3,
        legends = 4
    }
    interface IReportViewBlock {
        type: ReportViewBlockType;
    }
    interface IReportViewBlockImage extends IReportViewBlock {
        type: ReportViewBlockType.image;
        data: string;
    }
    interface IReportViewBlockCharts extends IReportViewBlock {
        type: ReportViewBlockType.charts;
        data: Globals.IChartModel;
    }
    interface IReportViewBlockGridView extends IReportViewBlock {
        type: ReportViewBlockType.gridView;
        data: Globals.IGridApp;
    }
    interface IReportViewBlockLegends extends IReportViewBlock {
        type: ReportViewBlockType.legends;
        data: Globals.ILegendInfo[];
    }
    class ReportPage extends Charts {
        protected _lengths: [number, number, number, number];
        protected _report: Globals.IReportModel;
        protected _index: number;
        clear(): void;
        setPage(report: Globals.IReportModel, index: number): void;
        invalidateSize(): void;
    }
}
/**
 * Created by jean.rennes on 27/10/2016.
 */
declare namespace AFC.Controls {
    export interface IBlockListItem extends IListItem {
        properties: ReadonlyArray<Dashboards.IDashboardProperty>;
    }
    export interface ISelectorGroup extends IListItem {
        items: ReadonlyArray<IBlockListItem>;
    }
    export interface ISelection {
        group: Controls.ISelectorGroup;
        item: number;
    }
    class BlockList extends ListBox {
        block: number;
        displayNames: boolean;
        protected _build(container: JQuery, items: IBlockListItem[]): JQuery;
    }
    export class Selector extends Control {
        protected _radioGroup: RadioGroup;
        protected _blockList: BlockList;
        protected _groups: ReadonlyArray<ISelectorGroup>;
        protected _selected: number[];
        constructor(list: string | HTMLElement, radio: string | HTMLElement);
        get HTMLElement2(): HTMLElement;
        set block(value: number);
        get block(): number;
        get selected(): ISelection;
        setGroups(groups?: ReadonlyArray<ISelectorGroup>, selected?: number[]): void;
        select(groupId?: string, itemId?: string): void;
        protected _onRadioChange(typeArg: string, eventInitDict?: EventInit): void;
        protected _onListChange(typeArg: string, eventInitDict?: EventInit): void;
    }
    export {};
}
declare namespace AFC.Controls {
    class TemplateElem extends Control {
        protected _template: string;
        protected _templates: {
            [key: string]: string;
        };
        private _formatNumbers;
        set template(contentHtml: string);
        get template(): string;
        setTemplate(value: string, name?: string): void;
        getTemplate(name: string): string;
        dataBinder: (name: string, key: string, value: Data.IDataItemContainer) => any;
        setFormatNumbers(formatNumbers: boolean): void;
        /**
         * Interpret template and replace{{MY_VAR_NAME|MY_FORMATTER}}
         * @param value
         */
        generateContent(value: {
            [key: string]: any;
        }): void;
        /**
         * Empty htmlcontent of node
         */
        empty(): void;
    }
}
/**
 * Created by jean.rennes on 06/12/2019.
 */
declare namespace AFC.Controls {
    export namespace ViewPager {
        interface IPageTransformer {
            transformPage(view: gui.AfcGuiDiv, position: number): void;
        }
    }
    interface _IContext {
        frameGroup: HTMLElement;
        frameGroupStyle: CSSStyleDeclaration;
        width: number;
        height: number;
    }
    interface _ITarget {
        position: -1 | 1;
        right?: number;
        left?: number;
    }
    export abstract class FragmentStateAdapter {
        constructor(fragmentManager: Application.FragmentManager);
        abstract getFragment(item: number): Application.Fragment;
        abstract getItemCount(): number;
    }
    export class ViewPager extends Control {
        protected _frameGroup: HTMLElement;
        protected _animation: InstanceType<typeof ViewPager._Animation>;
        protected _adapter: FragmentStateAdapter;
        protected _transformer: ViewPager.IPageTransformer;
        protected _frame: InstanceType<typeof ViewPager._Frame>;
        duration: DOMHighResTimeStamp;
        ease: (n: number) => number;
        onPageScrollStateChanged: (state: number) => any;
        protected static _ease(n: number): number;
        static SCROLL_STATE_IDLE: number;
        static SCROLL_STATE_DRAGGING: number;
        static SCROLL_STATE_SETTLING: number;
        protected static _Frame: {
            new (frameGroup: HTMLElement, container: gui.IView, inner: gui.AfcGuiDiv, item: number, offset: number, referenceNode: HTMLElement): {
                readonly container: HTMLElement;
                readonly inner: gui.AfcGuiDiv;
                readonly item: number;
                offset: number;
                fragment: Application.Fragment;
                drawNoCheck(pager: ViewPager): void;
                draw(pager: ViewPager, context: _IContext, position: number): void;
                detach(pager: ViewPager): void;
            };
        };
        protected static _Animation: {
            new (pager: ViewPager, context: _IContext, frames: [InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>], position: -1 | 1, resolve: (fragment: Application.Fragment) => void): {
                stop: () => void;
            };
        };
        constructor(element: string | HTMLElement);
        protected _onPageScrollStateChanged(state: number): void;
        protected _getContext(): _IContext;
        protected _stop(): void;
        protected _createFrame(frameGroup: HTMLElement, width: number, height: number, item: number, offset: number, referenceNode?: HTMLElement): InstanceType<typeof ViewPager._Frame>;
        protected _reset(item?: number): void;
        protected _expandFrameGroup(context: _IContext, frame: InstanceType<typeof ViewPager._Frame>, left: number, right: number, position: -1 | 1): [InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>];
        protected _transform(context: _IContext, frames: [InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>], position: number): void;
        protected _shrinkFrameGroup(context: _IContext, frames: [InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>, InstanceType<typeof ViewPager._Frame>]): Application.Fragment;
        protected _getTarget(start: number, end: number, max: number): _ITarget;
        setCurrentItem(item: number): Promise<Application.Fragment>;
        getCurrentItem(): number;
        setAdapter(adapter: FragmentStateAdapter): void;
        setPageTransformer(transformer?: ViewPager.IPageTransformer): void;
        invalidateSize(): void;
    }
    export {};
}
declare interface Spinner {
    readonly opts: AFC.Controls.ISpinnerAnimationOptions;
    spin(target: any): Spinner;
    stop(): void;
    incremental: number;
}
declare var Spinner: new (options?: AFC.Controls.ISpinnerAnimationOptions) => Spinner;
declare namespace AFC.Controls {
    interface ISpinnerAnimationOptions {
        /**
         * The number of lines to draw
         */
        lines?: number;
        /**
         * The length of each line
         */
        length?: number;
        /**
         * The line thickness
         */
        width?: number;
        /**
         * The radius of the inner circle
         */
        radius?: number;
        /**
         * Scales overall size of the spinner
         */
        scale?: number;
        /**
         * Corner roundness (0..1)
         */
        corners?: number;
        /**
         * A CSS color string, or array of strings to set the line color
         */
        color?: string | string[];
        /**
         * A CSS color string, or array of strings to set the color that lines will fade to.
         * Defaults to transparent.
         */
        fadeColor?: string | string[];
        /**
         * The animation name used for the spinner lines. Defaults to 'spinner-line-fade-default'.
         */
        animation?: string;
        /**
         * The rotation offset
         */
        rotate?: number;
        /**
         * 1: clockwise, -1: counterclockwise
         */
        direction?: number;
        /**
         * Rounds per second
         */
        speed?: number;
        /**
         * The z-index (defaults to 2000000000)
         */
        zIndex?: number;
        /**
         * The CSS class to assign to the spinner
         */
        className?: string;
        /**
         * Top position relative to parent (defaults to 50%)
         */
        top?: string;
        /**
         * Left position relative to parent (defaults to 50%)
         */
        left?: string;
        /**
         * Whether to render the default shadow (boolean).
         * A string can be used to set a custom box-shadow value.
         */
        shadow?: boolean | string;
        /**
         * Element positioning
         */
        position?: string;
    }
    class WaitBar extends Control {
        protected _options: Partial<ISpinnerAnimationOptions>;
        protected _spinner: Spinner;
        static readonly defaultOptions: ISpinnerAnimationOptions;
        constructor(element?: string | HTMLElement);
        set options(options: Partial<ISpinnerAnimationOptions>);
        get options(): Partial<ISpinnerAnimationOptions>;
        show(): void;
        hide(): void;
    }
}
declare namespace AFC.Controls {
    class Window {
        private _context;
        private _container;
        private _element;
        private _handler;
        constructor(context: Application.Context);
        getContainer(): Window;
        setContainer(container: Window): void;
        setContentView(view: gui.IView): void;
        getElement(): gui.AfcGuiRoot;
        destroy(): void;
    }
}
